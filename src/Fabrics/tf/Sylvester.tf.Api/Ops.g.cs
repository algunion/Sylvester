using System;

namespace TensorFlow {
	public partial class TF_Graph {
		/// <summary>
		/// </summary>
		/// <param name="true_classes">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UniformCandidateSampler'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="num_true">
		/// </param>
		/// <param name="num_sampled">
		/// </param>
		/// <param name="unique">
		/// </param>
		/// <param name="range_max">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sampled_candidates:
		///   true_expected_count:
		///   sampled_expected_count:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output sampled_candidates, TF_Output true_expected_count, TF_Output sampled_expected_count) UniformCandidateSampler (TF_Output true_classes, long num_true, long num_sampled, bool unique, long range_max, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UniformCandidateSampler", MakeName ("UniformCandidateSampler", operName));
			c_api.TF_AddInput(desc, true_classes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_true", num_true);
			c_api.TF_SetAttrInt (desc, "num_sampled", num_sampled);
			c_api.TF_SetAttrBool (desc, "unique", Convert.ToByte(unique));
			c_api.TF_SetAttrInt (desc, "range_max", range_max);
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var sampled_candidates = new TF_Output (op, _idx++);
			var true_expected_count = new TF_Output (op, _idx++);
			var sampled_expected_count = new TF_Output (op, _idx++);
			return (sampled_candidates, true_expected_count, sampled_expected_count);
		}

		/// <summary>
		///   Debug NaN Value Counter Op
		/// </summary>
		/// <param name="input">
		///   Input tensor, non-Reference type.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DebugNanCount'.
		/// </param>
		/// <param name="device_name">
		///   Optional argument
		/// </param>
		/// <param name="tensor_name">
		///   Optional argument
		///   Name of the input tensor.
		/// </param>
		/// <param name="debug_urls">
		///   Optional argument
		///   List of URLs to debug targets, e.g.,
		///   file:///foo/tfdbg_dump, grpc:://localhost:11011.
		/// </param>
		/// <param name="gated_grpc">
		///   Optional argument
		///   Whether this op will be gated. If any of the debug_urls of this
		///   debug node is of the grpc:// scheme, when the value of this attribute is set
		///   to True, the data will not actually be sent via the grpc stream unless this
		///   debug op has been enabled at the debug_url. If all of the debug_urls of this
		///   debug node are of the grpc:// scheme and the debug op is enabled at none of
		///   them, the output will be an empty Tensor.
		/// </param>
		/// <returns>
		///   An integer output tensor that is the number of NaNs in the input.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Counts number of NaNs in the input tensor, for debugging.
		/// </remarks>
		public TF_Output DebugNanCount (TF_Output input, string device_name = null, string tensor_name = null, string[] debug_urls = null, bool? gated_grpc = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DebugNanCount", MakeName ("DebugNanCount", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (device_name != null)
				c_api.TF_SetAttrString (desc, "device_name", device_name);
			
			if (tensor_name != null)
				c_api.TF_SetAttrString (desc, "tensor_name", tensor_name);
			
			if (debug_urls != null)
				c_api.TF_SetAttrStringList (desc, "debug_urls", debug_urls);
			
			if (gated_grpc.HasValue)
				c_api.TF_SetAttrBool (desc, "gated_grpc", Convert.ToByte(gated_grpc.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="fft_length">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RFFT3D'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RFFT3D (TF_Output input, TF_Output fft_length, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RFFT3D", MakeName ("RFFT3D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, fft_length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Copy Op.
		/// </summary>
		/// <param name="input">
		///   Input tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Copy'.
		/// </param>
		/// <param name="tensor_name">
		///   Optional argument
		///   The name of the input tensor.
		/// </param>
		/// <param name="debug_ops_spec">
		///   Optional argument
		///   A list of debug op spec (op, url, gated_grpc) for attached debug
		///   ops. Each element of the list has the format
		///   &amp;lt;debug_op&amp;gt;;&amp;lt;grpc_url&amp;gt;;&amp;lt;gated_grpc&amp;gt;, wherein gated_grpc is boolean represented
		///   as 0/1. E.g., "DebugIdentity;grpc://foo:3333;1",
		///   "DebugIdentity;file:///tmp/tfdbg_1;0".
		/// </param>
		/// <returns>
		///   Output tensor, deep-copied from input.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Performs CPU-to-CPU or GPU-to-GPU deep-copying of tensor, depending on the
		///   device on which the tensor is allocated.
		///   N.B.: If the all downstream attached debug ops are disabled given the current
		///   gRPC gating status, the output will simply forward the input tensor without
		///   deep-copying. See the documentation of Debug* ops for more details.
		///   
		///   Unlike the CopyHost Op, this op does not have HostMemory constraint on its
		///   input or output.
		/// </remarks>
		public TF_Output Copy (TF_Output input, string tensor_name = null, string[] debug_ops_spec = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Copy", MakeName ("Copy", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (tensor_name != null)
				c_api.TF_SetAttrString (desc, "tensor_name", tensor_name);
			
			if (debug_ops_spec != null)
				c_api.TF_SetAttrStringList (desc, "debug_ops_spec", debug_ops_spec);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TPUReplicateMetadata'.
		/// </param>
		/// <param name="num_cores_per_replica">
		///   Optional argument
		/// </param>
		/// <param name="topology">
		///   Optional argument
		/// </param>
		/// <param name="use_tpu">
		///   Optional argument
		/// </param>
		/// <param name="device_assignment">
		///   Optional argument
		/// </param>
		/// <param name="computation_shape">
		///   Optional argument
		/// </param>
		/// <param name="host_compute_core">
		///   Optional argument
		/// </param>
		/// <param name="padding_map">
		///   Optional argument
		/// </param>
		/// <param name="step_marker_location">
		///   Optional argument
		/// </param>
		/// <param name="allow_soft_placement">
		///   Optional argument
		/// </param>
		/// <param name="num_replicas">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation TPUReplicateMetadata (long num_replicas, long? num_cores_per_replica = null, string topology = null, bool? use_tpu = null, long[] device_assignment = null, long[] computation_shape = null, string[] host_compute_core = null, string[] padding_map = null, string step_marker_location = null, bool? allow_soft_placement = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TPUReplicateMetadata", MakeName ("TPUReplicateMetadata", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_replicas", num_replicas);
			if (num_cores_per_replica.HasValue)
				c_api.TF_SetAttrInt (desc, "num_cores_per_replica", num_cores_per_replica.Value);
			
			if (topology != null)
				c_api.TF_SetAttrString (desc, "topology", topology);
			
			if (use_tpu.HasValue)
				c_api.TF_SetAttrBool (desc, "use_tpu", Convert.ToByte(use_tpu.Value));
			
			if (device_assignment != null)
				c_api.TF_SetAttrIntList (desc, "device_assignment", ref device_assignment[0], device_assignment.Length);
			
			if (computation_shape != null)
				c_api.TF_SetAttrIntList (desc, "computation_shape", ref computation_shape[0], computation_shape.Length);
			
			if (host_compute_core != null)
				c_api.TF_SetAttrStringList (desc, "host_compute_core", host_compute_core);
			
			if (padding_map != null)
				c_api.TF_SetAttrStringList (desc, "padding_map", padding_map);
			
			if (step_marker_location != null)
				c_api.TF_SetAttrString (desc, "step_marker_location", step_marker_location);
			
			if (allow_soft_placement.HasValue)
				c_api.TF_SetAttrBool (desc, "allow_soft_placement", Convert.ToByte(allow_soft_placement.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DeepCopy'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DeepCopy (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DeepCopy", MakeName ("DeepCopy", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedMaxPool'.
		/// </param>
		/// <param name="ksize">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedMaxPool (TF_Output input, TF_Output min_input, TF_Output max_input, long[] ksize, long[] strides, string padding, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedMaxPool", MakeName ("QuantizedMaxPool", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RefNextIteration'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RefNextIteration (TF_Output data, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RefNextIteration", MakeName ("RefNextIteration", operName));
			c_api.TF_AddInput(desc, data);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DatasetToGraph'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DatasetToGraph (TF_Output input_dataset, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DatasetToGraph", MakeName ("DatasetToGraph", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var graph = new TF_Output (op, _idx++);
			return graph;
		}

		/// <summary>
		///   Copy Host Op.
		/// </summary>
		/// <param name="input">
		///   Input tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CopyHost'.
		/// </param>
		/// <param name="tensor_name">
		///   Optional argument
		///   The name of the input tensor.
		/// </param>
		/// <param name="debug_ops_spec">
		///   Optional argument
		///   A list of debug op spec (op, url, gated_grpc) for attached debug
		///   ops. Each element of the list has the format
		///   &amp;lt;debug_op&amp;gt;;&amp;lt;grpc_url&amp;gt;;&amp;lt;gated_grpc&amp;gt;, wherein gated_grpc is boolean represented
		///   as 0/1. E.g., "DebugIdentity;grpc://foo:3333;1",
		///   "DebugIdentity;file:///tmp/tfdbg_1;0".
		/// </param>
		/// <returns>
		///   Output tensor, deep-copied from input.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Performs CPU-to-CPU deep-copying of tensor.
		///   N.B.: If the all downstream attached debug ops are disabled given the current
		///   gRPC gating status, the output will simply forward the input tensor without
		///   deep-copying. See the documentation of Debug* ops for more details.
		///   
		///   Unlike the Copy Op, this op has HostMemory constraint on its input or output.
		/// </remarks>
		public TF_Output CopyHost (TF_Output input, string tensor_name = null, string[] debug_ops_spec = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CopyHost", MakeName ("CopyHost", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (tensor_name != null)
				c_api.TF_SetAttrString (desc, "tensor_name", tensor_name);
			
			if (debug_ops_spec != null)
				c_api.TF_SetAttrStringList (desc, "debug_ops_spec", debug_ops_spec);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StackPop'.
		/// </param>
		/// <param name="elem_type">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StackPop (TF_Output handle, TF_DataType elem_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StackPop", MakeName ("StackPop", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "elem_type", elem_type);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var elem = new TF_Output (op, _idx++);
			return elem;
		}

		/// <summary>
		/// </summary>
		/// <param name="values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ParallelConcat'.
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ParallelConcat (TF_Output[] values, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ParallelConcat", MakeName ("ParallelConcat", operName));
			c_api.TF_AddInputList(desc, values[0], values.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="scale">
		/// </param>
		/// <param name="offset">
		/// </param>
		/// <param name="mean">
		/// </param>
		/// <param name="variance">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedBatchNormV2'.
		/// </param>
		/// <param name="epsilon">
		///   Optional argument
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="is_training">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   y:
		///   batch_mean:
		///   batch_variance:
		///   reserve_space_1:
		///   reserve_space_2:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output y, TF_Output batch_mean, TF_Output batch_variance, TF_Output reserve_space_1, TF_Output reserve_space_2) FusedBatchNormV2 (TF_Output x, TF_Output scale, TF_Output offset, TF_Output mean, TF_Output variance, float? epsilon = null, string data_format = null, bool? is_training = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FusedBatchNormV2", MakeName ("FusedBatchNormV2", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, scale);
			c_api.TF_AddInput(desc, offset);
			c_api.TF_AddInput(desc, mean);
			c_api.TF_AddInput(desc, variance);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (epsilon.HasValue)
				c_api.TF_SetAttrFloat (desc, "epsilon", epsilon.Value);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (is_training.HasValue)
				c_api.TF_SetAttrBool (desc, "is_training", Convert.ToByte(is_training.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			var batch_mean = new TF_Output (op, _idx++);
			var batch_variance = new TF_Output (op, _idx++);
			var reserve_space_1 = new TF_Output (op, _idx++);
			var reserve_space_2 = new TF_Output (op, _idx++);
			return (y, batch_mean, batch_variance, reserve_space_1, reserve_space_2);
		}

		/// <summary>
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="axis">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GatherV2'.
		/// </param>
		/// <param name="batch_dims">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output GatherV2 (TF_Output parameters, TF_Output indices, TF_Output axis, long? batch_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GatherV2", MakeName ("GatherV2", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, axis);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (batch_dims.HasValue)
				c_api.TF_SetAttrInt (desc, "batch_dims", batch_dims.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="axis">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CumulativeLogsumexp'.
		/// </param>
		/// <param name="exclusive">
		///   Optional argument
		/// </param>
		/// <param name="reverse">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CumulativeLogsumexp (TF_Output x, TF_Output axis, bool? exclusive = null, bool? reverse = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CumulativeLogsumexp", MakeName ("CumulativeLogsumexp", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, axis);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (exclusive.HasValue)
				c_api.TF_SetAttrBool (desc, "exclusive", Convert.ToByte(exclusive.Value));
			
			if (reverse.HasValue)
				c_api.TF_SetAttrBool (desc, "reverse", Convert.ToByte(reverse.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="mg">
		/// </param>
		/// <param name="ms">
		/// </param>
		/// <param name="mom">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="rho">
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyCenteredRMSProp'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ApplyCenteredRMSProp (TF_Output var, TF_Output mg, TF_Output ms, TF_Output mom, TF_Output lr, TF_Output rho, TF_Output momentum, TF_Output epsilon, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyCenteredRMSProp", MakeName ("ApplyCenteredRMSProp", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, mg);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, momentum);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="num_threads">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PrivateThreadPoolDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output PrivateThreadPoolDataset (TF_Output input_dataset, TF_Output num_threads, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PrivateThreadPoolDataset", MakeName ("PrivateThreadPoolDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, num_threads);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Debug Identity Op.
		/// </summary>
		/// <param name="input">
		///   Input tensor, non-Reference type.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DebugIdentity'.
		/// </param>
		/// <param name="device_name">
		///   Optional argument
		/// </param>
		/// <param name="tensor_name">
		///   Optional argument
		///   Name of the input tensor.
		/// </param>
		/// <param name="debug_urls">
		///   Optional argument
		///   List of URLs to debug targets, e.g.,
		///   file:///foo/tfdbg_dump, grpc:://localhost:11011
		/// </param>
		/// <param name="gated_grpc">
		///   Optional argument
		///   Whether this op will be gated. If any of the debug_urls of this
		///   debug node is of the grpc:// scheme, when the value of this attribute is set
		///   to True, the data will not actually be sent via the grpc stream unless this
		///   debug op has been enabled at the debug_url. If all of the debug_urls of this
		///   debug node are of the grpc:// scheme and the debug op is enabled at none of
		///   them, the output will be an empty Tensor.
		/// </param>
		/// <returns>
		///   Output tensor that equals the input tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Provides an identity mapping of the non-Ref type input tensor for debugging.
		/// </remarks>
		public TF_Output DebugIdentity (TF_Output input, string device_name = null, string tensor_name = null, string[] debug_urls = null, bool? gated_grpc = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DebugIdentity", MakeName ("DebugIdentity", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (device_name != null)
				c_api.TF_SetAttrString (desc, "device_name", device_name);
			
			if (tensor_name != null)
				c_api.TF_SetAttrString (desc, "tensor_name", tensor_name);
			
			if (debug_urls != null)
				c_api.TF_SetAttrStringList (desc, "debug_urls", debug_urls);
			
			if (gated_grpc.HasValue)
				c_api.TF_SetAttrBool (desc, "gated_grpc", Convert.ToByte(gated_grpc.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Snapshot'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Snapshot (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Snapshot", MakeName ("Snapshot", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Sin'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Sin (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Sin", MakeName ("Sin", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Enter'.
		/// </param>
		/// <param name="is_constant">
		///   Optional argument
		/// </param>
		/// <param name="parallel_iterations">
		///   Optional argument
		/// </param>
		/// <param name="frame_name">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Enter (TF_Output data, string frame_name, bool? is_constant = null, long? parallel_iterations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Enter", MakeName ("Enter", operName));
			c_api.TF_AddInput(desc, data);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "frame_name", frame_name);
			if (is_constant.HasValue)
				c_api.TF_SetAttrBool (desc, "is_constant", Convert.ToByte(is_constant.Value));
			
			if (parallel_iterations.HasValue)
				c_api.TF_SetAttrInt (desc, "parallel_iterations", parallel_iterations.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="element_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListFromTensor'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorListFromTensor (TF_Output tensor, TF_Output element_shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListFromTensor", MakeName ("TensorListFromTensor", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, element_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			return output_handle;
		}

		/// <summary>
		///   Debug Numeric Summary Op.
		/// </summary>
		/// <param name="input">
		///   Input tensor, non-Reference type, float or double.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DebugNumericSummary'.
		/// </param>
		/// <param name="device_name">
		///   Optional argument
		/// </param>
		/// <param name="tensor_name">
		///   Optional argument
		///   Name of the input tensor.
		/// </param>
		/// <param name="debug_urls">
		///   Optional argument
		///   List of URLs to debug targets, e.g.,
		///   file:///foo/tfdbg_dump, grpc:://localhost:11011
		/// </param>
		/// <param name="lower_bound">
		///   Optional argument
		///   (float) The lower bound &amp;lt;= which values will be included in the
		///   generalized -inf count. Default: -inf.
		/// </param>
		/// <param name="upper_bound">
		///   Optional argument
		///   (float) The upper bound &amp;gt;= which values will be included in the
		///   generalized +inf count. Default: +inf.
		/// </param>
		/// <param name="mute_if_healthy">
		///   Optional argument
		///   (bool) Do not send data to the debug URLs unless at least one
		///   of elements [2], [3] and [7] (i.e., the nan count and the generalized -inf and
		///   inf counts) is non-zero.
		/// </param>
		/// <param name="gated_grpc">
		///   Optional argument
		///   Whether this op will be gated. If any of the debug_urls of this
		///   debug node is of the grpc:// scheme, when the value of this attribute is set
		///   to True, the data will not actually be sent via the grpc stream unless this
		///   debug op has been enabled at the debug_url. If all of the debug_urls of this
		///   debug node are of the grpc:// scheme and the debug op is enabled at none of
		///   them, the output will be an empty Tensor.
		/// </param>
		/// <returns>
		///   A double tensor of shape [14 + nDimensions], where nDimensions is the
		///   the number of dimensions of the tensor's shape. The elements of output are:
		///   [0]: is initialized (1.0) or not (0.0).
		///   [1]: total number of elements
		///   [2]: NaN element count
		///   [3]: generalized -inf count: elements &amp;lt;= lower_bound. lower_bound is -inf by
		///   default.
		///   [4]: negative element count (excluding -inf), if lower_bound is the default
		///   -inf. Otherwise, this is the count of elements &amp;gt; lower_bound and &amp;lt; 0.
		///   [5]: zero element count
		///   [6]: positive element count (excluding +inf), if upper_bound is the default
		///   -inf. Otherwise, this is the count of elements &amp;lt; upper_bound and &amp;gt; 0.
		///   [7]: generalized +inf count, elements &amp;gt;= upper_bound. upper_bound is +inf by
		///   default.
		///   Output elements [1:8] are all zero, if the tensor is uninitialized.
		///   [8]: minimum of all non-inf and non-NaN elements.
		///   If uninitialized or no such element exists: +inf.
		///   [9]: maximum of all non-inf and non-NaN elements.
		///   If uninitialized or no such element exists: -inf.
		///   [10]: mean of all non-inf and non-NaN elements.
		///   If uninitialized or no such element exists: NaN.
		///   [11]: variance of all non-inf and non-NaN elements.
		///   If uninitialized or no such element exists: NaN.
		///   [12]: Data type of the tensor encoded as an enum integer. See the DataType
		///   proto for more details.
		///   [13]: Number of dimensions of the tensor (ndims).
		///   [14+]: Sizes of the dimensions.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Provide a basic summary of numeric value types, range and distribution.
		/// </remarks>
		public TF_Output DebugNumericSummary (TF_Output input, string device_name = null, string tensor_name = null, string[] debug_urls = null, float? lower_bound = null, float? upper_bound = null, bool? mute_if_healthy = null, bool? gated_grpc = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DebugNumericSummary", MakeName ("DebugNumericSummary", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (device_name != null)
				c_api.TF_SetAttrString (desc, "device_name", device_name);
			
			if (tensor_name != null)
				c_api.TF_SetAttrString (desc, "tensor_name", tensor_name);
			
			if (debug_urls != null)
				c_api.TF_SetAttrStringList (desc, "debug_urls", debug_urls);
			
			if (lower_bound.HasValue)
				c_api.TF_SetAttrFloat (desc, "lower_bound", lower_bound.Value);
			
			if (upper_bound.HasValue)
				c_api.TF_SetAttrFloat (desc, "upper_bound", upper_bound.Value);
			
			if (mute_if_healthy.HasValue)
				c_api.TF_SetAttrBool (desc, "mute_if_healthy", Convert.ToByte(mute_if_healthy.Value));
			
			if (gated_grpc.HasValue)
				c_api.TF_SetAttrBool (desc, "gated_grpc", Convert.ToByte(gated_grpc.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="perm">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Transpose'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Transpose (TF_Output x, TF_Output perm, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Transpose", MakeName ("Transpose", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, perm);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Barrier'.
		/// </param>
		/// <param name="shapes">
		///   Optional argument
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="component_types">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Barrier (TF_DataType[] component_types, long[][] shapes = null, long? capacity = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Barrier", MakeName ("Barrier", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (shapes != null)
				c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="i">
		/// </param>
		/// <param name="v">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InplaceUpdate'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output InplaceUpdate (TF_Output x, TF_Output i, TF_Output v, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InplaceUpdate", MakeName ("InplaceUpdate", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, i);
			c_api.TF_AddInput(desc, v);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="true_classes">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LogUniformCandidateSampler'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="num_true">
		/// </param>
		/// <param name="num_sampled">
		/// </param>
		/// <param name="unique">
		/// </param>
		/// <param name="range_max">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sampled_candidates:
		///   true_expected_count:
		///   sampled_expected_count:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output sampled_candidates, TF_Output true_expected_count, TF_Output sampled_expected_count) LogUniformCandidateSampler (TF_Output true_classes, long num_true, long num_sampled, bool unique, long range_max, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LogUniformCandidateSampler", MakeName ("LogUniformCandidateSampler", operName));
			c_api.TF_AddInput(desc, true_classes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_true", num_true);
			c_api.TF_SetAttrInt (desc, "num_sampled", num_sampled);
			c_api.TF_SetAttrBool (desc, "unique", Convert.ToByte(unique));
			c_api.TF_SetAttrInt (desc, "range_max", range_max);
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var sampled_candidates = new TF_Output (op, _idx++);
			var true_expected_count = new TF_Output (op, _idx++);
			var sampled_expected_count = new TF_Output (op, _idx++);
			return (sampled_candidates, true_expected_count, sampled_expected_count);
		}

		/// <summary>
		/// </summary>
		/// <param name="reader_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderNumRecordsProducedV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ReaderNumRecordsProducedV2 (TF_Output reader_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderNumRecordsProducedV2", MakeName ("ReaderNumRecordsProducedV2", operName));
			c_api.TF_AddInput(desc, reader_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var records_produced = new TF_Output (op, _idx++);
			return records_produced;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Lgamma'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Lgamma (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Lgamma", MakeName ("Lgamma", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Pack'.
		/// </param>
		/// <param name="axis">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Pack (TF_Output[] values, long? axis = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Pack", MakeName ("Pack", operName));
			c_api.TF_AddInputList(desc, values[0], values.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (axis.HasValue)
				c_api.TF_SetAttrInt (desc, "axis", axis.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="rate">
		/// </param>
		/// <param name="seed">
		/// </param>
		/// <param name="seed2">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SamplingDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SamplingDataset (TF_Output input_dataset, TF_Output rate, TF_Output seed, TF_Output seed2, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SamplingDataset", MakeName ("SamplingDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, rate);
			c_api.TF_AddInput(desc, seed);
			c_api.TF_AddInput(desc, seed2);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="i">
		/// </param>
		/// <param name="v">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InplaceAdd'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output InplaceAdd (TF_Output x, TF_Output i, TF_Output v, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InplaceAdd", MakeName ("InplaceAdd", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, i);
			c_api.TF_AddInput(desc, v);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="filenames">
		/// </param>
		/// <param name="header_bytes">
		/// </param>
		/// <param name="record_bytes">
		/// </param>
		/// <param name="footer_bytes">
		/// </param>
		/// <param name="buffer_size">
		/// </param>
		/// <param name="compression_type">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FixedLengthRecordDatasetV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FixedLengthRecordDatasetV2 (TF_Output filenames, TF_Output header_bytes, TF_Output record_bytes, TF_Output footer_bytes, TF_Output buffer_size, TF_Output compression_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FixedLengthRecordDatasetV2", MakeName ("FixedLengthRecordDatasetV2", operName));
			c_api.TF_AddInput(desc, filenames);
			c_api.TF_AddInput(desc, header_bytes);
			c_api.TF_AddInput(desc, record_bytes);
			c_api.TF_AddInput(desc, footer_bytes);
			c_api.TF_AddInput(desc, buffer_size);
			c_api.TF_AddInput(desc, compression_type);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RefIdentity'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RefIdentity (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RefIdentity", MakeName ("RefIdentity", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="ms">
		/// </param>
		/// <param name="mom">
		/// </param>
		/// <param name="mg">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingCenteredRMSPropParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LoadTPUEmbeddingCenteredRMSPropParameters (TF_Output parameters, TF_Output ms, TF_Output mom, TF_Output mg, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingCenteredRMSPropParameters", MakeName ("LoadTPUEmbeddingCenteredRMSPropParameters", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			c_api.TF_AddInput(desc, mg);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GatherNd'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output GatherNd (TF_Output parameters, TF_Output indices, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GatherNd", MakeName ("GatherNd", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="lengths">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArraySplitV3'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArraySplitV3 (TF_Output handle, TF_Output value, TF_Output lengths, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArraySplitV3", MakeName ("TensorArraySplitV3", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, lengths);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var flow_out = new TF_Output (op, _idx++);
			return flow_out;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_h">
		/// </param>
		/// <param name="input_c">
		/// </param>
		/// <param name="parameters">
		/// </param>
		/// <param name="output">
		/// </param>
		/// <param name="output_h">
		/// </param>
		/// <param name="output_c">
		/// </param>
		/// <param name="output_backprop">
		/// </param>
		/// <param name="output_h_backprop">
		/// </param>
		/// <param name="output_c_backprop">
		/// </param>
		/// <param name="reserve_space">
		/// </param>
		/// <param name="host_reserved">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNBackpropV2'.
		/// </param>
		/// <param name="rnn_mode">
		///   Optional argument
		/// </param>
		/// <param name="input_mode">
		///   Optional argument
		/// </param>
		/// <param name="direction">
		///   Optional argument
		/// </param>
		/// <param name="dropout">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   input_backprop:
		///   input_h_backprop:
		///   input_c_backprop:
		///   params_backprop:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output input_backprop, TF_Output input_h_backprop, TF_Output input_c_backprop, TF_Output params_backprop) CudnnRNNBackpropV2 (TF_Output input, TF_Output input_h, TF_Output input_c, TF_Output parameters, TF_Output output, TF_Output output_h, TF_Output output_c, TF_Output output_backprop, TF_Output output_h_backprop, TF_Output output_c_backprop, TF_Output reserve_space, TF_Output host_reserved, string rnn_mode = null, string input_mode = null, string direction = null, float? dropout = null, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CudnnRNNBackpropV2", MakeName ("CudnnRNNBackpropV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_h);
			c_api.TF_AddInput(desc, input_c);
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, output);
			c_api.TF_AddInput(desc, output_h);
			c_api.TF_AddInput(desc, output_c);
			c_api.TF_AddInput(desc, output_backprop);
			c_api.TF_AddInput(desc, output_h_backprop);
			c_api.TF_AddInput(desc, output_c_backprop);
			c_api.TF_AddInput(desc, reserve_space);
			c_api.TF_AddInput(desc, host_reserved);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (rnn_mode != null)
				c_api.TF_SetAttrString (desc, "rnn_mode", rnn_mode);
			
			if (input_mode != null)
				c_api.TF_SetAttrString (desc, "input_mode", input_mode);
			
			if (direction != null)
				c_api.TF_SetAttrString (desc, "direction", direction);
			
			if (dropout.HasValue)
				c_api.TF_SetAttrFloat (desc, "dropout", dropout.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var input_backprop = new TF_Output (op, _idx++);
			var input_h_backprop = new TF_Output (op, _idx++);
			var input_c_backprop = new TF_Output (op, _idx++);
			var params_backprop = new TF_Output (op, _idx++);
			return (input_backprop, input_h_backprop, input_c_backprop, params_backprop);
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="i">
		/// </param>
		/// <param name="v">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InplaceSub'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output InplaceSub (TF_Output x, TF_Output i, TF_Output v, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InplaceSub", MakeName ("InplaceSub", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, i);
			c_api.TF_AddInput(desc, v);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="images">
		/// </param>
		/// <param name="scale">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AdjustSaturation'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AdjustSaturation (TF_Output images, TF_Output scale, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AdjustSaturation", MakeName ("AdjustSaturation", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, scale);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="axis">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UniqueWithCountsV2'.
		/// </param>
		/// <param name="out_idx">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   y:
		///   idx:
		///   count:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output y, TF_Output idx, TF_Output count) UniqueWithCountsV2 (TF_Output x, TF_Output axis, TF_DataType? out_idx = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UniqueWithCountsV2", MakeName ("UniqueWithCountsV2", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, axis);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_idx.HasValue)
				c_api.TF_SetAttrType (desc, "out_idx", out_idx.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			var idx = new TF_Output (op, _idx++);
			var count = new TF_Output (op, _idx++);
			return (y, idx, count);
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="count">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TakeDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TakeDataset (TF_Output input_dataset, TF_Output count, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TakeDataset", MakeName ("TakeDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, count);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UniqueWithCounts'.
		/// </param>
		/// <param name="out_idx">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   y:
		///   idx:
		///   count:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output y, TF_Output idx, TF_Output count) UniqueWithCounts (TF_Output x, TF_DataType? out_idx = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UniqueWithCounts", MakeName ("UniqueWithCounts", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_idx.HasValue)
				c_api.TF_SetAttrType (desc, "out_idx", out_idx.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			var idx = new TF_Output (op, _idx++);
			var count = new TF_Output (op, _idx++);
			return (y, idx, count);
		}

		/// <summary>
		/// </summary>
		/// <param name="hypothesis_indices">
		/// </param>
		/// <param name="hypothesis_values">
		/// </param>
		/// <param name="hypothesis_shape">
		/// </param>
		/// <param name="truth_indices">
		/// </param>
		/// <param name="truth_values">
		/// </param>
		/// <param name="truth_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EditDistance'.
		/// </param>
		/// <param name="normalize">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output EditDistance (TF_Output hypothesis_indices, TF_Output hypothesis_values, TF_Output hypothesis_shape, TF_Output truth_indices, TF_Output truth_values, TF_Output truth_shape, bool? normalize = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EditDistance", MakeName ("EditDistance", operName));
			c_api.TF_AddInput(desc, hypothesis_indices);
			c_api.TF_AddInput(desc, hypothesis_values);
			c_api.TF_AddInput(desc, hypothesis_shape);
			c_api.TF_AddInput(desc, truth_indices);
			c_api.TF_AddInput(desc, truth_values);
			c_api.TF_AddInput(desc, truth_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (normalize.HasValue)
				c_api.TF_SetAttrBool (desc, "normalize", Convert.ToByte(normalize.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AddN'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AddN (TF_Output[] inputs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AddN", MakeName ("AddN", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var sum = new TF_Output (op, _idx++);
			return sum;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Rint'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Rint (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Rint", MakeName ("Rint", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="diagonal">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Diag'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Diag (TF_Output diagonal, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Diag", MakeName ("Diag", operName));
			c_api.TF_AddInput(desc, diagonal);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatrixInverse'.
		/// </param>
		/// <param name="adjoint">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchMatrixInverse (TF_Output input, bool? adjoint = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatrixInverse", MakeName ("BatchMatrixInverse", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (adjoint.HasValue)
				c_api.TF_SetAttrBool (desc, "adjoint", Convert.ToByte(adjoint.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="begin">
		/// </param>
		/// <param name="end">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StridedSlice'.
		/// </param>
		/// <param name="begin_mask">
		///   Optional argument
		/// </param>
		/// <param name="end_mask">
		///   Optional argument
		/// </param>
		/// <param name="ellipsis_mask">
		///   Optional argument
		/// </param>
		/// <param name="new_axis_mask">
		///   Optional argument
		/// </param>
		/// <param name="shrink_axis_mask">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StridedSlice (TF_Output input, TF_Output begin, TF_Output end, TF_Output strides, long? begin_mask = null, long? end_mask = null, long? ellipsis_mask = null, long? new_axis_mask = null, long? shrink_axis_mask = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StridedSlice", MakeName ("StridedSlice", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, begin);
			c_api.TF_AddInput(desc, end);
			c_api.TF_AddInput(desc, strides);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (begin_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "begin_mask", begin_mask.Value);
			
			if (end_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "end_mask", end_mask.Value);
			
			if (ellipsis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "ellipsis_mask", ellipsis_mask.Value);
			
			if (new_axis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "new_axis_mask", new_axis_mask.Value);
			
			if (shrink_axis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "shrink_axis_mask", shrink_axis_mask.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Empty'.
		/// </param>
		/// <param name="init">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Empty (TF_Output shape, TF_DataType dtype, bool? init = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Empty", MakeName ("Empty", operName));
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (init.HasValue)
				c_api.TF_SetAttrBool (desc, "init", Convert.ToByte(init.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="reader_handle">
		/// </param>
		/// <param name="queue_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderReadV2'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   key:
		///   value:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output key, TF_Output value) ReaderReadV2 (TF_Output reader_handle, TF_Output queue_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderReadV2", MakeName ("ReaderReadV2", operName));
			c_api.TF_AddInput(desc, reader_handle);
			c_api.TF_AddInput(desc, queue_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var key = new TF_Output (op, _idx++);
			var value = new TF_Output (op, _idx++);
			return (key, value);
		}

		/// <summary>
		/// </summary>
		/// <param name="orig_input_shape">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AvgPool3DGrad'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="ksize">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AvgPool3DGrad (TF_Output orig_input_shape, TF_Output grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AvgPool3DGrad", MakeName ("AvgPool3DGrad", operName));
			c_api.TF_AddInput(desc, orig_input_shape);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters:
		///   ms:
		///   mom:
		///   gradient_accumulators:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output parameters, TF_Output ms, TF_Output mom, TF_Output gradient_accumulators) RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug", MakeName ("RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var ms = new TF_Output (op, _idx++);
			var mom = new TF_Output (op, _idx++);
			var gradient_accumulators = new TF_Output (op, _idx++);
			return (parameters, ms, mom, gradient_accumulators);
		}

		/// <summary>
		/// </summary>
		/// <param name="indices">
		/// </param>
		/// <param name="dims">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnravelIndex'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output UnravelIndex (TF_Output indices, TF_Output dims, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnravelIndex", MakeName ("UnravelIndex", operName));
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, dims);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="iterator">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalStatsAggregatorSummary'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalStatsAggregatorSummary (TF_Output iterator, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalStatsAggregatorSummary", MakeName ("ExperimentalStatsAggregatorSummary", operName));
			c_api.TF_AddInput(desc, iterator);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var summary = new TF_Output (op, _idx++);
			return summary;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BytesProducedStatsDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BytesProducedStatsDataset (TF_Output input_dataset, TF_Output tag, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BytesProducedStatsDataset", MakeName ("BytesProducedStatsDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, tag);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="concat_dim">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Concat'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Concat (TF_Output concat_dim, TF_Output[] values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Concat", MakeName ("Concat", operName));
			c_api.TF_AddInput(desc, concat_dim);
			c_api.TF_AddInputList(desc, values[0], values.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalIteratorGetDevice'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalIteratorGetDevice (TF_Output resource, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalIteratorGetDevice", MakeName ("ExperimentalIteratorGetDevice", operName));
			c_api.TF_AddInput(desc, resource);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var device = new TF_Output (op, _idx++);
			return device;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BroadcastTo'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BroadcastTo (TF_Output input, TF_Output shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BroadcastTo", MakeName ("BroadcastTo", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TFRecordReader'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="compression_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TFRecordReader (string container = null, string shared_name = null, string compression_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TFRecordReader", MakeName ("TFRecordReader", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (compression_type != null)
				c_api.TF_SetAttrString (desc, "compression_type", compression_type);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="values">
		/// </param>
		/// <param name="axis">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ConcatV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ConcatV2 (TF_Output[] values, TF_Output axis, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ConcatV2", MakeName ("ConcatV2", operName));
			c_api.TF_AddInputList(desc, values[0], values.Length);
			c_api.TF_AddInput(desc, axis);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PrelinearizeTuple'.
		/// </param>
		/// <param name="layouts">
		///   Optional argument
		/// </param>
		/// <param name="shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output PrelinearizeTuple (TF_Output[] inputs, long[][] shapes, long[] layouts = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PrelinearizeTuple", MakeName ("PrelinearizeTuple", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			if (layouts != null)
				c_api.TF_SetAttrIntList (desc, "layouts", ref layouts[0], layouts.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="grads">
		/// </param>
		/// <param name="size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeNearestNeighborGrad'.
		/// </param>
		/// <param name="align_corners">
		///   Optional argument
		/// </param>
		/// <param name="half_pixel_centers">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ResizeNearestNeighborGrad (TF_Output grads, TF_Output size, bool? align_corners = null, bool? half_pixel_centers = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResizeNearestNeighborGrad", MakeName ("ResizeNearestNeighborGrad", operName));
			c_api.TF_AddInput(desc, grads);
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (align_corners.HasValue)
				c_api.TF_SetAttrBool (desc, "align_corners", Convert.ToByte(align_corners.Value));
			
			if (half_pixel_centers.HasValue)
				c_api.TF_SetAttrBool (desc, "half_pixel_centers", Convert.ToByte(half_pixel_centers.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="element_shape">
		/// </param>
		/// <param name="max_num_elements">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EmptyTensorList'.
		/// </param>
		/// <param name="element_dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output EmptyTensorList (TF_Output element_shape, TF_Output max_num_elements, TF_DataType element_dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EmptyTensorList", MakeName ("EmptyTensorList", operName));
			c_api.TF_AddInput(desc, element_shape);
			c_api.TF_AddInput(desc, max_num_elements);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "element_dtype", element_dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="lengths">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArraySplit'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArraySplit (TF_Output handle, TF_Output value, TF_Output lengths, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArraySplit", MakeName ("TensorArraySplit", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, lengths);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var flow_out = new TF_Output (op, _idx++);
			return flow_out;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchSelfAdjointEigV2'.
		/// </param>
		/// <param name="compute_v">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   e:
		///   v:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output e, TF_Output v) BatchSelfAdjointEigV2 (TF_Output input, bool? compute_v = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchSelfAdjointEigV2", MakeName ("BatchSelfAdjointEigV2", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (compute_v.HasValue)
				c_api.TF_SetAttrBool (desc, "compute_v", Convert.ToByte(compute_v.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var e = new TF_Output (op, _idx++);
			var v = new TF_Output (op, _idx++);
			return (e, v);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPool'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="ksize">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPool (TF_Output input, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPool", MakeName ("MaxPool", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixDeterminant'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MatrixDeterminant (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixDeterminant", MakeName ("MatrixDeterminant", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Const'.
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Const (TF_Tensor value, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Const", MakeName ("Const", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTensor (desc, "value", value, status);
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DebugGradientIdentity'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DebugGradientIdentity (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DebugGradientIdentity", MakeName ("DebugGradientIdentity", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="dim">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExpandDims'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExpandDims (TF_Output input, TF_Output dim, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExpandDims", MakeName ("ExpandDims", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, dim);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="quantile_stream_resource_handle">
		/// </param>
		/// <param name="summaries">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesQuantileStreamResourceAddSummaries'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation BoostedTreesQuantileStreamResourceAddSummaries (TF_Output quantile_stream_resource_handle, TF_Output[] summaries, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesQuantileStreamResourceAddSummaries", MakeName ("BoostedTreesQuantileStreamResourceAddSummaries", operName));
			c_api.TF_AddInput(desc, quantile_stream_resource_handle);
			c_api.TF_AddInputList(desc, summaries[0], summaries.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="a">
		/// </param>
		/// <param name="b">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_a">
		/// </param>
		/// <param name="max_a">
		/// </param>
		/// <param name="min_b">
		/// </param>
		/// <param name="max_b">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedMatMulWithBiasAndRelu'.
		/// </param>
		/// <param name="Toutput">
		///   Optional argument
		/// </param>
		/// <param name="transpose_a">
		///   Optional argument
		/// </param>
		/// <param name="transpose_b">
		///   Optional argument
		/// </param>
		/// <param name="input_quant_mode">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_out:
		///   max_out:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_out, TF_Output max_out) QuantizedMatMulWithBiasAndRelu (TF_Output a, TF_Output b, TF_Output bias, TF_Output min_a, TF_Output max_a, TF_Output min_b, TF_Output max_b, TF_DataType? Toutput = null, bool? transpose_a = null, bool? transpose_b = null, string input_quant_mode = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedMatMulWithBiasAndRelu", MakeName ("QuantizedMatMulWithBiasAndRelu", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, b);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_a);
			c_api.TF_AddInput(desc, max_a);
			c_api.TF_AddInput(desc, min_b);
			c_api.TF_AddInput(desc, max_b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Toutput.HasValue)
				c_api.TF_SetAttrType (desc, "Toutput", Toutput.Value);
			
			if (transpose_a.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_a", Convert.ToByte(transpose_a.Value));
			
			if (transpose_b.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_b", Convert.ToByte(transpose_b.Value));
			
			if (input_quant_mode != null)
				c_api.TF_SetAttrString (desc, "input_quant_mode", input_quant_mode);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_out = new TF_Output (op, _idx++);
			var max_out = new TF_Output (op, _idx++);
			return (output, min_out, max_out);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'HostConst'.
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output HostConst (TF_Tensor value, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "HostConst", MakeName ("HostConst", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTensor (desc, "value", value, status);
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="num_workers">
		/// </param>
		/// <param name="index">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AutoShardDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AutoShardDataset (TF_Output input_dataset, TF_Output num_workers, TF_Output index, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AutoShardDataset", MakeName ("AutoShardDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, num_workers);
			c_api.TF_AddInput(desc, index);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceGather'.
		/// </param>
		/// <param name="batch_dims">
		///   Optional argument
		/// </param>
		/// <param name="validate_indices">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ResourceGather (TF_Output resource, TF_Output indices, TF_DataType dtype, long? batch_dims = null, bool? validate_indices = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceGather", MakeName ("ResourceGather", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (batch_dims.HasValue)
				c_api.TF_SetAttrInt (desc, "batch_dims", batch_dims.Value);
			
			if (validate_indices.HasValue)
				c_api.TF_SetAttrBool (desc, "validate_indices", Convert.ToByte(validate_indices.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ImmutableConst'.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <param name="memory_region_name">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ImmutableConst (TF_DataType dtype, long[] shape, string memory_region_name, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ImmutableConst", MakeName ("ImmutableConst", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			c_api.TF_SetAttrString (desc, "memory_region_name", memory_region_name);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var tensor = new TF_Output (op, _idx++);
			return tensor;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GuaranteeConst'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output GuaranteeConst (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GuaranteeConst", MakeName ("GuaranteeConst", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MapIncompleteSize'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MapIncompleteSize (TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MapIncompleteSize", MakeName ("MapIncompleteSize", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		/// </summary>
		/// <param name="images">
		/// </param>
		/// <param name="size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeNearestNeighbor'.
		/// </param>
		/// <param name="align_corners">
		///   Optional argument
		/// </param>
		/// <param name="half_pixel_centers">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ResizeNearestNeighbor (TF_Output images, TF_Output size, bool? align_corners = null, bool? half_pixel_centers = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResizeNearestNeighbor", MakeName ("ResizeNearestNeighbor", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (align_corners.HasValue)
				c_api.TF_SetAttrBool (desc, "align_corners", Convert.ToByte(align_corners.Value));
			
			if (half_pixel_centers.HasValue)
				c_api.TF_SetAttrBool (desc, "half_pixel_centers", Convert.ToByte(half_pixel_centers.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var resized_images = new TF_Output (op, _idx++);
			return resized_images;
		}

		/// <summary>
		/// </summary>
		/// <param name="diagonal">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixDiag'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MatrixDiag (TF_Output diagonal, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixDiag", MakeName ("MatrixDiag", operName));
			c_api.TF_AddInput(desc, diagonal);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_indices">
		/// </param>
		/// <param name="input_values">
		/// </param>
		/// <param name="input_shape">
		/// </param>
		/// <param name="reduction_axes">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReduceMaxSparse'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices:
		///   output_values:
		///   output_shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output_indices, TF_Output output_values, TF_Output output_shape) SparseReduceMaxSparse (TF_Output input_indices, TF_Output input_values, TF_Output input_shape, TF_Output reduction_axes, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseReduceMaxSparse", MakeName ("SparseReduceMaxSparse", operName));
			c_api.TF_AddInput(desc, input_indices);
			c_api.TF_AddInput(desc, input_values);
			c_api.TF_AddInput(desc, input_shape);
			c_api.TF_AddInput(desc, reduction_axes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_indices = new TF_Output (op, _idx++);
			var output_values = new TF_Output (op, _idx++);
			var output_shape = new TF_Output (op, _idx++);
			return (output_indices, output_values, output_shape);
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="stats_aggregator">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="counter_prefix">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalSetStatsAggregatorDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalSetStatsAggregatorDataset (TF_Output input_dataset, TF_Output stats_aggregator, TF_Output tag, TF_Output counter_prefix, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalSetStatsAggregatorDataset", MakeName ("ExperimentalSetStatsAggregatorDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, stats_aggregator);
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, counter_prefix);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalThreadPoolHandle'.
		/// </param>
		/// <param name="max_intra_op_parallelism">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="num_threads">
		/// </param>
		/// <param name="display_name">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalThreadPoolHandle (long num_threads, string display_name, long? max_intra_op_parallelism = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalThreadPoolHandle", MakeName ("ExperimentalThreadPoolHandle", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_threads", num_threads);
			c_api.TF_SetAttrString (desc, "display_name", display_name);
			if (max_intra_op_parallelism.HasValue)
				c_api.TF_SetAttrInt (desc, "max_intra_op_parallelism", max_intra_op_parallelism.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ZerosLike'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ZerosLike (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ZerosLike", MakeName ("ZerosLike", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OnesLike'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output OnesLike (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OnesLike", MakeName ("OnesLike", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="accumulators">
		/// </param>
		/// <param name="gradient_accumulators">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug (TF_Output parameters, TF_Output accumulators, TF_Output gradient_accumulators, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug", MakeName ("LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, accumulators);
			c_api.TF_AddInput(desc, gradient_accumulators);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RightShift'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RightShift (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RightShift", MakeName ("RightShift", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Rank'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Rank (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Rank", MakeName ("Rank", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DiagPart'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DiagPart (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DiagPart", MakeName ("DiagPart", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var diagonal = new TF_Output (op, _idx++);
			return diagonal;
		}

		/// <summary>
		/// </summary>
		/// <param name="diagonal">
		/// </param>
		/// <param name="k">
		/// </param>
		/// <param name="num_rows">
		/// </param>
		/// <param name="num_cols">
		/// </param>
		/// <param name="padding_value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixDiagV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MatrixDiagV2 (TF_Output diagonal, TF_Output k, TF_Output num_rows, TF_Output num_cols, TF_Output padding_value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixDiagV2", MakeName ("MatrixDiagV2", operName));
			c_api.TF_AddInput(desc, diagonal);
			c_api.TF_AddInput(desc, k);
			c_api.TF_AddInput(desc, num_rows);
			c_api.TF_AddInput(desc, num_cols);
			c_api.TF_AddInput(desc, padding_value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="elem">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StackPush'.
		/// </param>
		/// <param name="swap_memory">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StackPush (TF_Output handle, TF_Output elem, bool? swap_memory = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StackPush", MakeName ("StackPush", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, elem);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (swap_memory.HasValue)
				c_api.TF_SetAttrBool (desc, "swap_memory", Convert.ToByte(swap_memory.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="indices">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="shapes">
		/// </param>
		/// <param name="dense_inputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseCross'.
		/// </param>
		/// <param name="hashed_output">
		/// </param>
		/// <param name="num_buckets">
		/// </param>
		/// <param name="hash_key">
		/// </param>
		/// <param name="out_type">
		/// </param>
		/// <param name="internal_type">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices:
		///   output_values:
		///   output_shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output_indices, TF_Output output_values, TF_Output output_shape) SparseCross (TF_Output[] indices, TF_Output[] values, TF_Output[] shapes, TF_Output[] dense_inputs, bool hashed_output, long num_buckets, long hash_key, TF_DataType out_type, TF_DataType internal_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseCross", MakeName ("SparseCross", operName));
			c_api.TF_AddInputList(desc, indices[0], indices.Length);
			c_api.TF_AddInputList(desc, values[0], values.Length);
			c_api.TF_AddInputList(desc, shapes[0], shapes.Length);
			c_api.TF_AddInputList(desc, dense_inputs[0], dense_inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrBool (desc, "hashed_output", Convert.ToByte(hashed_output));
			c_api.TF_SetAttrInt (desc, "num_buckets", num_buckets);
			c_api.TF_SetAttrInt (desc, "hash_key", hash_key);
			c_api.TF_SetAttrType (desc, "out_type", out_type);
			c_api.TF_SetAttrType (desc, "internal_type", internal_type);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_indices = new TF_Output (op, _idx++);
			var output_values = new TF_Output (op, _idx++);
			var output_shape = new TF_Output (op, _idx++);
			return (output_indices, output_values, output_shape);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="diagonal">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixSetDiag'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MatrixSetDiag (TF_Output input, TF_Output diagonal, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixSetDiag", MakeName ("MatrixSetDiag", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, diagonal);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ConfigureDistributedTPU'.
		/// </param>
		/// <param name="embedding_config">
		///   Optional argument
		/// </param>
		/// <param name="tpu_embedding_config">
		///   Optional argument
		/// </param>
		/// <param name="is_global_init">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ConfigureDistributedTPU (string embedding_config = null, string tpu_embedding_config = null, bool? is_global_init = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ConfigureDistributedTPU", MakeName ("ConfigureDistributedTPU", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (embedding_config != null)
				c_api.TF_SetAttrString (desc, "embedding_config", embedding_config);
			
			if (tpu_embedding_config != null)
				c_api.TF_SetAttrString (desc, "tpu_embedding_config", tpu_embedding_config);
			
			if (is_global_init.HasValue)
				c_api.TF_SetAttrBool (desc, "is_global_init", Convert.ToByte(is_global_init.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var topology = new TF_Output (op, _idx++);
			return topology;
		}

		/// <summary>
		/// </summary>
		/// <param name="gradients">
		/// </param>
		/// <param name="outputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EluGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output EluGrad (TF_Output gradients, TF_Output outputs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EluGrad", MakeName ("EluGrad", operName));
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, outputs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var backprops = new TF_Output (op, _idx++);
			return backprops;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="elem">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StackPushV2'.
		/// </param>
		/// <param name="swap_memory">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StackPushV2 (TF_Output handle, TF_Output elem, bool? swap_memory = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StackPushV2", MakeName ("StackPushV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, elem);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (swap_memory.HasValue)
				c_api.TF_SetAttrBool (desc, "swap_memory", Convert.ToByte(swap_memory.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="diagonal">
		/// </param>
		/// <param name="k">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixSetDiagV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MatrixSetDiagV2 (TF_Output input, TF_Output diagonal, TF_Output k, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixSetDiagV2", MakeName ("MatrixSetDiagV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, diagonal);
			c_api.TF_AddInput(desc, k);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="ms">
		/// </param>
		/// <param name="mom">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="rho">
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyRMSProp'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceSparseApplyRMSProp (TF_Output var, TF_Output ms, TF_Output mom, TF_Output lr, TF_Output rho, TF_Output momentum, TF_Output epsilon, TF_Output grad, TF_Output indices, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyRMSProp", MakeName ("ResourceSparseApplyRMSProp", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, momentum);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="num_required">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceAccumulatorTakeGradient'.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ResourceAccumulatorTakeGradient (TF_Output handle, TF_Output num_required, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceAccumulatorTakeGradient", MakeName ("ResourceAccumulatorTakeGradient", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, num_required);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var average = new TF_Output (op, _idx++);
			return average;
		}

		/// <summary>
		/// </summary>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="segment_ids">
		/// </param>
		/// <param name="output_dim0">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentSqrtNGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseSegmentSqrtNGrad (TF_Output grad, TF_Output indices, TF_Output segment_ids, TF_Output output_dim0, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSegmentSqrtNGrad", MakeName ("SparseSegmentSqrtNGrad", operName));
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, segment_ids);
			c_api.TF_AddInput(desc, output_dim0);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="k">
		/// </param>
		/// <param name="padding_value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixDiagPartV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MatrixDiagPartV2 (TF_Output input, TF_Output k, TF_Output padding_value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixDiagPartV2", MakeName ("MatrixDiagPartV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, k);
			c_api.TF_AddInput(desc, padding_value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var diagonal = new TF_Output (op, _idx++);
			return diagonal;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_datasets">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ChooseFastestDataset'.
		/// </param>
		/// <param name="num_experiments">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ChooseFastestDataset (TF_Output[] input_datasets, long num_experiments, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ChooseFastestDataset", MakeName ("ChooseFastestDataset", operName));
			c_api.TF_AddInputList(desc, input_datasets[0], input_datasets.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_experiments", num_experiments);
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixDiagPart'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MatrixDiagPart (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixDiagPart", MakeName ("MatrixDiagPart", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var diagonal = new TF_Output (op, _idx++);
			return diagonal;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_h">
		/// </param>
		/// <param name="input_c">
		/// </param>
		/// <param name="parameters">
		/// </param>
		/// <param name="sequence_lengths">
		/// </param>
		/// <param name="output">
		/// </param>
		/// <param name="output_h">
		/// </param>
		/// <param name="output_c">
		/// </param>
		/// <param name="output_backprop">
		/// </param>
		/// <param name="output_h_backprop">
		/// </param>
		/// <param name="output_c_backprop">
		/// </param>
		/// <param name="reserve_space">
		/// </param>
		/// <param name="host_reserved">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNBackpropV3'.
		/// </param>
		/// <param name="rnn_mode">
		///   Optional argument
		/// </param>
		/// <param name="input_mode">
		///   Optional argument
		/// </param>
		/// <param name="direction">
		///   Optional argument
		/// </param>
		/// <param name="dropout">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="num_proj">
		///   Optional argument
		/// </param>
		/// <param name="time_major">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   input_backprop:
		///   input_h_backprop:
		///   input_c_backprop:
		///   params_backprop:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output input_backprop, TF_Output input_h_backprop, TF_Output input_c_backprop, TF_Output params_backprop) CudnnRNNBackpropV3 (TF_Output input, TF_Output input_h, TF_Output input_c, TF_Output parameters, TF_Output sequence_lengths, TF_Output output, TF_Output output_h, TF_Output output_c, TF_Output output_backprop, TF_Output output_h_backprop, TF_Output output_c_backprop, TF_Output reserve_space, TF_Output host_reserved, string rnn_mode = null, string input_mode = null, string direction = null, float? dropout = null, long? seed = null, long? seed2 = null, long? num_proj = null, bool? time_major = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CudnnRNNBackpropV3", MakeName ("CudnnRNNBackpropV3", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_h);
			c_api.TF_AddInput(desc, input_c);
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, sequence_lengths);
			c_api.TF_AddInput(desc, output);
			c_api.TF_AddInput(desc, output_h);
			c_api.TF_AddInput(desc, output_c);
			c_api.TF_AddInput(desc, output_backprop);
			c_api.TF_AddInput(desc, output_h_backprop);
			c_api.TF_AddInput(desc, output_c_backprop);
			c_api.TF_AddInput(desc, reserve_space);
			c_api.TF_AddInput(desc, host_reserved);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (rnn_mode != null)
				c_api.TF_SetAttrString (desc, "rnn_mode", rnn_mode);
			
			if (input_mode != null)
				c_api.TF_SetAttrString (desc, "input_mode", input_mode);
			
			if (direction != null)
				c_api.TF_SetAttrString (desc, "direction", direction);
			
			if (dropout.HasValue)
				c_api.TF_SetAttrFloat (desc, "dropout", dropout.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (num_proj.HasValue)
				c_api.TF_SetAttrInt (desc, "num_proj", num_proj.Value);
			
			if (time_major.HasValue)
				c_api.TF_SetAttrBool (desc, "time_major", Convert.ToByte(time_major.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var input_backprop = new TF_Output (op, _idx++);
			var input_h_backprop = new TF_Output (op, _idx++);
			var input_c_backprop = new TF_Output (op, _idx++);
			var params_backprop = new TF_Output (op, _idx++);
			return (input_backprop, input_h_backprop, input_c_backprop, params_backprop);
		}

		/// <summary>
		/// </summary>
		/// <param name="key">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapStage'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation OrderedMapStage (TF_Output key, TF_Output indices, TF_Output[] values, TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OrderedMapStage", MakeName ("OrderedMapStage", operName));
			c_api.TF_AddInput(desc, key);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInputList(desc, values[0], values.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="axis">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UniqueV2'.
		/// </param>
		/// <param name="out_idx">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   y:
		///   idx:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output y, TF_Output idx) UniqueV2 (TF_Output x, TF_Output axis, TF_DataType? out_idx = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UniqueV2", MakeName ("UniqueV2", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, axis);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_idx.HasValue)
				c_api.TF_SetAttrType (desc, "out_idx", out_idx.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			var idx = new TF_Output (op, _idx++);
			return (y, idx);
		}

		/// <summary>
		/// </summary>
		/// <param name="images">
		/// </param>
		/// <param name="size">
		/// </param>
		/// <param name="min">
		/// </param>
		/// <param name="max">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedResizeBilinear'.
		/// </param>
		/// <param name="align_corners">
		///   Optional argument
		/// </param>
		/// <param name="half_pixel_centers">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   resized_images:
		///   out_min:
		///   out_max:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output resized_images, TF_Output out_min, TF_Output out_max) QuantizedResizeBilinear (TF_Output images, TF_Output size, TF_Output min, TF_Output max, bool? align_corners = null, bool? half_pixel_centers = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedResizeBilinear", MakeName ("QuantizedResizeBilinear", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, size);
			c_api.TF_AddInput(desc, min);
			c_api.TF_AddInput(desc, max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (align_corners.HasValue)
				c_api.TF_SetAttrBool (desc, "align_corners", Convert.ToByte(align_corners.Value));
			
			if (half_pixel_centers.HasValue)
				c_api.TF_SetAttrBool (desc, "half_pixel_centers", Convert.ToByte(half_pixel_centers.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var resized_images = new TF_Output (op, _idx++);
			var out_min = new TF_Output (op, _idx++);
			var out_max = new TF_Output (op, _idx++);
			return (resized_images, out_min, out_max);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="num_lower">
		/// </param>
		/// <param name="num_upper">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixBandPart'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MatrixBandPart (TF_Output input, TF_Output num_lower, TF_Output num_upper, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixBandPart", MakeName ("MatrixBandPart", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, num_lower);
			c_api.TF_AddInput(desc, num_upper);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var band = new TF_Output (op, _idx++);
			return band;
		}

		/// <summary>
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Reshape'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Reshape (TF_Output tensor, TF_Output shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Reshape", MakeName ("Reshape", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="backprop_val_grad">
		/// </param>
		/// <param name="input_indices">
		/// </param>
		/// <param name="input_start">
		/// </param>
		/// <param name="output_indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSliceGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseSliceGrad (TF_Output backprop_val_grad, TF_Output input_indices, TF_Output input_start, TF_Output output_indices, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSliceGrad", MakeName ("SparseSliceGrad", operName));
			c_api.TF_AddInput(desc, backprop_val_grad);
			c_api.TF_AddInput(desc, input_indices);
			c_api.TF_AddInput(desc, input_start);
			c_api.TF_AddInput(desc, output_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var val_grad = new TF_Output (op, _idx++);
			return val_grad;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="alpha">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="delta">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyProximalGradientDescent'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ApplyProximalGradientDescent (TF_Output var, TF_Output alpha, TF_Output l1, TF_Output l2, TF_Output delta, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyProximalGradientDescent", MakeName ("ApplyProximalGradientDescent", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, alpha);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, delta);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PreventGradient'.
		/// </param>
		/// <param name="message">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output PreventGradient (TF_Output input, string message = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PreventGradient", MakeName ("PreventGradient", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (message != null)
				c_api.TF_SetAttrString (desc, "message", message);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="serialized">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ParseTensor'.
		/// </param>
		/// <param name="out_type">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ParseTensor (TF_Output serialized, TF_DataType out_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ParseTensor", MakeName ("ParseTensor", operName));
			c_api.TF_AddInput(desc, serialized);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "out_type", out_type);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StopGradient'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StopGradient (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StopGradient", MakeName ("StopGradient", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Softplus'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Softplus (TF_Output features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Softplus", MakeName ("Softplus", operName));
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var activations = new TF_Output (op, _idx++);
			return activations;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="thread_pool">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ThreadPoolDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ThreadPoolDataset (TF_Output input_dataset, TF_Output thread_pool, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ThreadPoolDataset", MakeName ("ThreadPoolDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, thread_pool);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="dims">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Reverse'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Reverse (TF_Output tensor, TF_Output dims, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Reverse", MakeName ("Reverse", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, dims);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="axis">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReverseV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ReverseV2 (TF_Output tensor, TF_Output axis, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReverseV2", MakeName ("ReverseV2", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, axis);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="step">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteScalarSummary'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation WriteScalarSummary (TF_Output writer, TF_Output step, TF_Output tag, TF_Output value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WriteScalarSummary", MakeName ("WriteScalarSummary", operName));
			c_api.TF_AddInput(desc, writer);
			c_api.TF_AddInput(desc, step);
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Div'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Div (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Div", MakeName ("Div", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="sp_indices">
		/// </param>
		/// <param name="sp_values">
		/// </param>
		/// <param name="sp_shape">
		/// </param>
		/// <param name="dense">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseDenseCwiseAdd'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseDenseCwiseAdd (TF_Output sp_indices, TF_Output sp_values, TF_Output sp_shape, TF_Output dense, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseDenseCwiseAdd", MakeName ("SparseDenseCwiseAdd", operName));
			c_api.TF_AddInput(desc, sp_indices);
			c_api.TF_AddInput(desc, sp_values);
			c_api.TF_AddInput(desc, sp_shape);
			c_api.TF_AddInput(desc, dense);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="dims">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Fill'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Fill (TF_Output dims, TF_Output value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Fill", MakeName ("Fill", operName));
			c_api.TF_AddInput(desc, dims);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv3D'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Conv3D (TF_Output input, TF_Output filter, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Conv3D", MakeName ("Conv3D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="index">
		/// </param>
		/// <param name="item">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListSetItem'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorListSetItem (TF_Output input_handle, TF_Output index, TF_Output item, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListSetItem", MakeName ("TensorListSetItem", operName));
			c_api.TF_AddInput(desc, input_handle);
			c_api.TF_AddInput(desc, index);
			c_api.TF_AddInput(desc, item);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			return output_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="path">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SnapshotDataset'.
		/// </param>
		/// <param name="compression">
		///   Optional argument
		/// </param>
		/// <param name="reader_path_prefix">
		///   Optional argument
		/// </param>
		/// <param name="writer_path_prefix">
		///   Optional argument
		/// </param>
		/// <param name="shard_size_bytes">
		///   Optional argument
		/// </param>
		/// <param name="pending_snapshot_expiry_seconds">
		///   Optional argument
		/// </param>
		/// <param name="num_reader_threads">
		///   Optional argument
		/// </param>
		/// <param name="reader_buffer_size">
		///   Optional argument
		/// </param>
		/// <param name="num_writer_threads">
		///   Optional argument
		/// </param>
		/// <param name="writer_buffer_size">
		///   Optional argument
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SnapshotDataset (TF_Output input_dataset, TF_Output path, TF_DataType[] output_types, long[][] output_shapes, string compression = null, string reader_path_prefix = null, string writer_path_prefix = null, long? shard_size_bytes = null, long? pending_snapshot_expiry_seconds = null, long? num_reader_threads = null, long? reader_buffer_size = null, long? num_writer_threads = null, long? writer_buffer_size = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SnapshotDataset", MakeName ("SnapshotDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, path);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (compression != null)
				c_api.TF_SetAttrString (desc, "compression", compression);
			
			if (reader_path_prefix != null)
				c_api.TF_SetAttrString (desc, "reader_path_prefix", reader_path_prefix);
			
			if (writer_path_prefix != null)
				c_api.TF_SetAttrString (desc, "writer_path_prefix", writer_path_prefix);
			
			if (shard_size_bytes.HasValue)
				c_api.TF_SetAttrInt (desc, "shard_size_bytes", shard_size_bytes.Value);
			
			if (pending_snapshot_expiry_seconds.HasValue)
				c_api.TF_SetAttrInt (desc, "pending_snapshot_expiry_seconds", pending_snapshot_expiry_seconds.Value);
			
			if (num_reader_threads.HasValue)
				c_api.TF_SetAttrInt (desc, "num_reader_threads", num_reader_threads.Value);
			
			if (reader_buffer_size.HasValue)
				c_api.TF_SetAttrInt (desc, "reader_buffer_size", reader_buffer_size.Value);
			
			if (num_writer_threads.HasValue)
				c_api.TF_SetAttrInt (desc, "num_writer_threads", num_writer_threads.Value);
			
			if (writer_buffer_size.HasValue)
				c_api.TF_SetAttrInt (desc, "writer_buffer_size", writer_buffer_size.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Identity'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Identity (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Identity", MakeName ("Identity", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="multi_device_iterator">
		/// </param>
		/// <param name="iterators">
		/// </param>
		/// <param name="deleter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DeleteMultiDeviceIterator'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation DeleteMultiDeviceIterator (TF_Output multi_device_iterator, TF_Output[] iterators, TF_Output deleter, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DeleteMultiDeviceIterator", MakeName ("DeleteMultiDeviceIterator", operName));
			c_api.TF_AddInput(desc, multi_device_iterator);
			c_api.TF_AddInputList(desc, iterators[0], iterators.Length);
			c_api.TF_AddInput(desc, deleter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="points">
		/// </param>
		/// <param name="num_to_sample">
		/// </param>
		/// <param name="seed">
		/// </param>
		/// <param name="num_retries_per_sample">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'KmeansPlusPlusInitialization'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output KmeansPlusPlusInitialization (TF_Output points, TF_Output num_to_sample, TF_Output seed, TF_Output num_retries_per_sample, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "KmeansPlusPlusInitialization", MakeName ("KmeansPlusPlusInitialization", operName));
			c_api.TF_AddInput(desc, points);
			c_api.TF_AddInput(desc, num_to_sample);
			c_api.TF_AddInput(desc, seed);
			c_api.TF_AddInput(desc, num_retries_per_sample);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var samples = new TF_Output (op, _idx++);
			return samples;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Tan'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Tan (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Tan", MakeName ("Tan", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Inv'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Inv (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Inv", MakeName ("Inv", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="out_backprop">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv3DBackpropFilter'.
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Conv3DBackpropFilter (TF_Output input, TF_Output filter, TF_Output out_backprop, long[] strides, string padding, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Conv3DBackpropFilter", MakeName ("Conv3DBackpropFilter", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="perm">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ConjugateTranspose'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ConjugateTranspose (TF_Output x, TF_Output perm, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ConjugateTranspose", MakeName ("ConjugateTranspose", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, perm);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatrixDiagPart'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchMatrixDiagPart (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatrixDiagPart", MakeName ("BatchMatrixDiagPart", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var diagonal = new TF_Output (op, _idx++);
			return diagonal;
		}

		/// <summary>
		/// </summary>
		/// <param name="seq_len_max">
		/// </param>
		/// <param name="x">
		/// </param>
		/// <param name="cs_prev">
		/// </param>
		/// <param name="h_prev">
		/// </param>
		/// <param name="w">
		/// </param>
		/// <param name="wci">
		/// </param>
		/// <param name="wcf">
		/// </param>
		/// <param name="wco">
		/// </param>
		/// <param name="b">
		/// </param>
		/// <param name="i">
		/// </param>
		/// <param name="cs">
		/// </param>
		/// <param name="f">
		/// </param>
		/// <param name="o">
		/// </param>
		/// <param name="ci">
		/// </param>
		/// <param name="co">
		/// </param>
		/// <param name="h">
		/// </param>
		/// <param name="cs_grad">
		/// </param>
		/// <param name="h_grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BlockLSTMGrad'.
		/// </param>
		/// <param name="use_peephole">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   x_grad:
		///   cs_prev_grad:
		///   h_prev_grad:
		///   w_grad:
		///   wci_grad:
		///   wcf_grad:
		///   wco_grad:
		///   b_grad:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output x_grad, TF_Output cs_prev_grad, TF_Output h_prev_grad, TF_Output w_grad, TF_Output wci_grad, TF_Output wcf_grad, TF_Output wco_grad, TF_Output b_grad) BlockLSTMGrad (TF_Output seq_len_max, TF_Output x, TF_Output cs_prev, TF_Output h_prev, TF_Output w, TF_Output wci, TF_Output wcf, TF_Output wco, TF_Output b, TF_Output i, TF_Output cs, TF_Output f, TF_Output o, TF_Output ci, TF_Output co, TF_Output h, TF_Output cs_grad, TF_Output h_grad, bool use_peephole, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BlockLSTMGrad", MakeName ("BlockLSTMGrad", operName));
			c_api.TF_AddInput(desc, seq_len_max);
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, cs_prev);
			c_api.TF_AddInput(desc, h_prev);
			c_api.TF_AddInput(desc, w);
			c_api.TF_AddInput(desc, wci);
			c_api.TF_AddInput(desc, wcf);
			c_api.TF_AddInput(desc, wco);
			c_api.TF_AddInput(desc, b);
			c_api.TF_AddInput(desc, i);
			c_api.TF_AddInput(desc, cs);
			c_api.TF_AddInput(desc, f);
			c_api.TF_AddInput(desc, o);
			c_api.TF_AddInput(desc, ci);
			c_api.TF_AddInput(desc, co);
			c_api.TF_AddInput(desc, h);
			c_api.TF_AddInput(desc, cs_grad);
			c_api.TF_AddInput(desc, h_grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrBool (desc, "use_peephole", Convert.ToByte(use_peephole));
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var x_grad = new TF_Output (op, _idx++);
			var cs_prev_grad = new TF_Output (op, _idx++);
			var h_prev_grad = new TF_Output (op, _idx++);
			var w_grad = new TF_Output (op, _idx++);
			var wci_grad = new TF_Output (op, _idx++);
			var wcf_grad = new TF_Output (op, _idx++);
			var wco_grad = new TF_Output (op, _idx++);
			var b_grad = new TF_Output (op, _idx++);
			return (x_grad, cs_prev_grad, h_prev_grad, w_grad, wci_grad, wcf_grad, wco_grad, b_grad);
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="scale">
		/// </param>
		/// <param name="offset">
		/// </param>
		/// <param name="mean">
		/// </param>
		/// <param name="variance">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedBatchNorm'.
		/// </param>
		/// <param name="epsilon">
		///   Optional argument
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="is_training">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   y:
		///   batch_mean:
		///   batch_variance:
		///   reserve_space_1:
		///   reserve_space_2:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output y, TF_Output batch_mean, TF_Output batch_variance, TF_Output reserve_space_1, TF_Output reserve_space_2) FusedBatchNorm (TF_Output x, TF_Output scale, TF_Output offset, TF_Output mean, TF_Output variance, float? epsilon = null, string data_format = null, bool? is_training = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FusedBatchNorm", MakeName ("FusedBatchNorm", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, scale);
			c_api.TF_AddInput(desc, offset);
			c_api.TF_AddInput(desc, mean);
			c_api.TF_AddInput(desc, variance);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (epsilon.HasValue)
				c_api.TF_SetAttrFloat (desc, "epsilon", epsilon.Value);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (is_training.HasValue)
				c_api.TF_SetAttrBool (desc, "is_training", Convert.ToByte(is_training.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			var batch_mean = new TF_Output (op, _idx++);
			var batch_variance = new TF_Output (op, _idx++);
			var reserve_space_1 = new TF_Output (op, _idx++);
			var reserve_space_2 = new TF_Output (op, _idx++);
			return (y, batch_mean, batch_variance, reserve_space_1, reserve_space_2);
		}

		/// <summary>
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Gather'.
		/// </param>
		/// <param name="validate_indices">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Gather (TF_Output parameters, TF_Output indices, bool? validate_indices = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Gather", MakeName ("Gather", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (validate_indices.HasValue)
				c_api.TF_SetAttrBool (desc, "validate_indices", Convert.ToByte(validate_indices.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DebugGradientRefIdentity'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DebugGradientRefIdentity (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DebugGradientRefIdentity", MakeName ("DebugGradientRefIdentity", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PlaceholderWithDefault'.
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output PlaceholderWithDefault (TF_Output input, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PlaceholderWithDefault", MakeName ("PlaceholderWithDefault", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApproximateEqual'.
		/// </param>
		/// <param name="tolerance">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ApproximateEqual (TF_Output x, TF_Output y, float? tolerance = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApproximateEqual", MakeName ("ApproximateEqual", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (tolerance.HasValue)
				c_api.TF_SetAttrFloat (desc, "tolerance", tolerance.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="true_classes">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AllCandidateSampler'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="num_true">
		/// </param>
		/// <param name="num_sampled">
		/// </param>
		/// <param name="unique">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sampled_candidates:
		///   true_expected_count:
		///   sampled_expected_count:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output sampled_candidates, TF_Output true_expected_count, TF_Output sampled_expected_count) AllCandidateSampler (TF_Output true_classes, long num_true, long num_sampled, bool unique, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AllCandidateSampler", MakeName ("AllCandidateSampler", operName));
			c_api.TF_AddInput(desc, true_classes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_true", num_true);
			c_api.TF_SetAttrInt (desc, "num_sampled", num_sampled);
			c_api.TF_SetAttrBool (desc, "unique", Convert.ToByte(unique));
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var sampled_candidates = new TF_Output (op, _idx++);
			var true_expected_count = new TF_Output (op, _idx++);
			var sampled_expected_count = new TF_Output (op, _idx++);
			return (sampled_candidates, true_expected_count, sampled_expected_count);
		}

		/// <summary>
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorScatterUpdate'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorScatterUpdate (TF_Output tensor, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorScatterUpdate", MakeName ("TensorScatterUpdate", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="tags">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScalarSummary'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ScalarSummary (TF_Output tags, TF_Output values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScalarSummary", MakeName ("ScalarSummary", operName));
			c_api.TF_AddInput(desc, tags);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var summary = new TF_Output (op, _idx++);
			return summary;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Sigmoid'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Sigmoid (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Sigmoid", MakeName ("Sigmoid", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FloorMod'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FloorMod (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FloorMod", MakeName ("FloorMod", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CheckNumerics'.
		/// </param>
		/// <param name="message">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CheckNumerics (TF_Output tensor, string message, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CheckNumerics", MakeName ("CheckNumerics", operName));
			c_api.TF_AddInput(desc, tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "message", message);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatsAggregatorHandleV2'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StatsAggregatorHandleV2 (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatsAggregatorHandleV2", MakeName ("StatsAggregatorHandleV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="algorithm">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatefulUniform'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StatefulUniform (TF_Output resource, TF_Output algorithm, TF_Output shape, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatefulUniform", MakeName ("StatefulUniform", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, algorithm);
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="begin">
		/// </param>
		/// <param name="end">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceStridedSliceAssign'.
		/// </param>
		/// <param name="begin_mask">
		///   Optional argument
		/// </param>
		/// <param name="end_mask">
		///   Optional argument
		/// </param>
		/// <param name="ellipsis_mask">
		///   Optional argument
		/// </param>
		/// <param name="new_axis_mask">
		///   Optional argument
		/// </param>
		/// <param name="shrink_axis_mask">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceStridedSliceAssign (TF_Output reference, TF_Output begin, TF_Output end, TF_Output strides, TF_Output value, long? begin_mask = null, long? end_mask = null, long? ellipsis_mask = null, long? new_axis_mask = null, long? shrink_axis_mask = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceStridedSliceAssign", MakeName ("ResourceStridedSliceAssign", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, begin);
			c_api.TF_AddInput(desc, end);
			c_api.TF_AddInput(desc, strides);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (begin_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "begin_mask", begin_mask.Value);
			
			if (end_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "end_mask", end_mask.Value);
			
			if (ellipsis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "ellipsis_mask", ellipsis_mask.Value);
			
			if (new_axis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "new_axis_mask", new_axis_mask.Value);
			
			if (shrink_axis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "shrink_axis_mask", shrink_axis_mask.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixLogarithm'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MatrixLogarithm (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixLogarithm", MakeName ("MatrixLogarithm", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AnonymousMultiDeviceIterator'.
		/// </param>
		/// <param name="devices">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   handle:
		///   deleter:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output handle, TF_Output deleter) AnonymousMultiDeviceIterator (string[] devices, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AnonymousMultiDeviceIterator", MakeName ("AnonymousMultiDeviceIterator", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrStringList (desc, "devices", devices);
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			var deleter = new TF_Output (op, _idx++);
			return (handle, deleter);
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InvertPermutation'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output InvertPermutation (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InvertPermutation", MakeName ("InvertPermutation", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="indices">
		/// </param>
		/// <param name="data">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ParallelDynamicStitch'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ParallelDynamicStitch (TF_Output[] indices, TF_Output[] data, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ParallelDynamicStitch", MakeName ("ParallelDynamicStitch", operName));
			c_api.TF_AddInputList(desc, indices[0], indices.Length);
			c_api.TF_AddInputList(desc, data[0], data.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var merged = new TF_Output (op, _idx++);
			return merged;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'VariableShape'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output VariableShape (TF_Output input, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "VariableShape", MakeName ("VariableShape", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Shape'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Shape (TF_Output input, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Shape", MakeName ("Shape", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Unique'.
		/// </param>
		/// <param name="out_idx">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   y:
		///   idx:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output y, TF_Output idx) Unique (TF_Output x, TF_DataType? out_idx = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Unique", MakeName ("Unique", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_idx.HasValue)
				c_api.TF_SetAttrType (desc, "out_idx", out_idx.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			var idx = new TF_Output (op, _idx++);
			return (y, idx);
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueIsClosedV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output QueueIsClosedV2 (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueIsClosedV2", MakeName ("QueueIsClosedV2", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var is_closed = new TF_Output (op, _idx++);
			return is_closed;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterUpdate'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ScatterUpdate (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterUpdate", MakeName ("ScatterUpdate", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EnsureShape'.
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output EnsureShape (TF_Output input, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EnsureShape", MakeName ("EnsureShape", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="sample_indices">
		/// </param>
		/// <param name="embedding_indices">
		/// </param>
		/// <param name="aggregation_weights">
		/// </param>
		/// <param name="mode_override">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EnqueueTPUEmbeddingSparseTensorBatch'.
		/// </param>
		/// <param name="device_ordinal">
		///   Optional argument
		/// </param>
		/// <param name="combiners">
		///   Optional argument
		/// </param>
		/// <param name="max_sequence_lengths">
		///   Optional argument
		/// </param>
		/// <param name="table_ids">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation EnqueueTPUEmbeddingSparseTensorBatch (TF_Output[] sample_indices, TF_Output[] embedding_indices, TF_Output[] aggregation_weights, TF_Output mode_override, long[] table_ids, long? device_ordinal = null, string[] combiners = null, long[] max_sequence_lengths = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EnqueueTPUEmbeddingSparseTensorBatch", MakeName ("EnqueueTPUEmbeddingSparseTensorBatch", operName));
			c_api.TF_AddInputList(desc, sample_indices[0], sample_indices.Length);
			c_api.TF_AddInputList(desc, embedding_indices[0], embedding_indices.Length);
			c_api.TF_AddInputList(desc, aggregation_weights[0], aggregation_weights.Length);
			c_api.TF_AddInput(desc, mode_override);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "table_ids", ref table_ids[0], table_ids.Length);
			if (device_ordinal.HasValue)
				c_api.TF_SetAttrInt (desc, "device_ordinal", device_ordinal.Value);
			
			if (combiners != null)
				c_api.TF_SetAttrStringList (desc, "combiners", combiners);
			
			if (max_sequence_lengths != null)
				c_api.TF_SetAttrIntList (desc, "max_sequence_lengths", ref max_sequence_lengths[0], max_sequence_lengths.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="seq_lengths">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReverseSequence'.
		/// </param>
		/// <param name="batch_dim">
		///   Optional argument
		/// </param>
		/// <param name="seq_dim">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ReverseSequence (TF_Output input, TF_Output seq_lengths, long seq_dim, long? batch_dim = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReverseSequence", MakeName ("ReverseSequence", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, seq_lengths);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "seq_dim", seq_dim);
			if (batch_dim.HasValue)
				c_api.TF_SetAttrInt (desc, "batch_dim", batch_dim.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterAdd'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceScatterAdd (TF_Output resource, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceScatterAdd", MakeName ("ResourceScatterAdd", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Ceil'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Ceil (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Ceil", MakeName ("Ceil", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="group_assignment">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CrossReplicaSum'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CrossReplicaSum (TF_Output input, TF_Output group_assignment, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CrossReplicaSum", MakeName ("CrossReplicaSum", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, group_assignment);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Size'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Size (TF_Output input, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Size", MakeName ("Size", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="boxes">
		/// </param>
		/// <param name="scores">
		/// </param>
		/// <param name="max_output_size">
		/// </param>
		/// <param name="iou_threshold">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NonMaxSuppressionV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output NonMaxSuppressionV2 (TF_Output boxes, TF_Output scores, TF_Output max_output_size, TF_Output iou_threshold, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NonMaxSuppressionV2", MakeName ("NonMaxSuppressionV2", operName));
			c_api.TF_AddInput(desc, boxes);
			c_api.TF_AddInput(desc, scores);
			c_api.TF_AddInput(desc, max_output_size);
			c_api.TF_AddInput(desc, iou_threshold);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var selected_indices = new TF_Output (op, _idx++);
			return selected_indices;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="begin">
		/// </param>
		/// <param name="size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Slice'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Slice (TF_Output input, TF_Output begin, TF_Output size, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Slice", MakeName ("Slice", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, begin);
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="quantile_stream_resource_handle">
		/// </param>
		/// <param name="bucket_boundaries">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesQuantileStreamResourceDeserialize'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation BoostedTreesQuantileStreamResourceDeserialize (TF_Output quantile_stream_resource_handle, TF_Output[] bucket_boundaries, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesQuantileStreamResourceDeserialize", MakeName ("BoostedTreesQuantileStreamResourceDeserialize", operName));
			c_api.TF_AddInput(desc, quantile_stream_resource_handle);
			c_api.TF_AddInputList(desc, bucket_boundaries[0], bucket_boundaries.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AvgPool3D'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="ksize">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AvgPool3D (TF_Output input, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AvgPool3D", MakeName ("AvgPool3D", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="shape">
		/// </param>
		/// <param name="begin">
		/// </param>
		/// <param name="end">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="dy">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StridedSliceGrad'.
		/// </param>
		/// <param name="begin_mask">
		///   Optional argument
		/// </param>
		/// <param name="end_mask">
		///   Optional argument
		/// </param>
		/// <param name="ellipsis_mask">
		///   Optional argument
		/// </param>
		/// <param name="new_axis_mask">
		///   Optional argument
		/// </param>
		/// <param name="shrink_axis_mask">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StridedSliceGrad (TF_Output shape, TF_Output begin, TF_Output end, TF_Output strides, TF_Output dy, long? begin_mask = null, long? end_mask = null, long? ellipsis_mask = null, long? new_axis_mask = null, long? shrink_axis_mask = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StridedSliceGrad", MakeName ("StridedSliceGrad", operName));
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, begin);
			c_api.TF_AddInput(desc, end);
			c_api.TF_AddInput(desc, strides);
			c_api.TF_AddInput(desc, dy);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (begin_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "begin_mask", begin_mask.Value);
			
			if (end_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "end_mask", end_mask.Value);
			
			if (ellipsis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "ellipsis_mask", ellipsis_mask.Value);
			
			if (new_axis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "new_axis_mask", new_axis_mask.Value);
			
			if (shrink_axis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "shrink_axis_mask", shrink_axis_mask.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="begin">
		/// </param>
		/// <param name="end">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StridedSliceAssign'.
		/// </param>
		/// <param name="begin_mask">
		///   Optional argument
		/// </param>
		/// <param name="end_mask">
		///   Optional argument
		/// </param>
		/// <param name="ellipsis_mask">
		///   Optional argument
		/// </param>
		/// <param name="new_axis_mask">
		///   Optional argument
		/// </param>
		/// <param name="shrink_axis_mask">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StridedSliceAssign (TF_Output reference, TF_Output begin, TF_Output end, TF_Output strides, TF_Output value, long? begin_mask = null, long? end_mask = null, long? ellipsis_mask = null, long? new_axis_mask = null, long? shrink_axis_mask = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StridedSliceAssign", MakeName ("StridedSliceAssign", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, begin);
			c_api.TF_AddInput(desc, end);
			c_api.TF_AddInput(desc, strides);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (begin_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "begin_mask", begin_mask.Value);
			
			if (end_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "end_mask", end_mask.Value);
			
			if (ellipsis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "ellipsis_mask", ellipsis_mask.Value);
			
			if (new_axis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "new_axis_mask", new_axis_mask.Value);
			
			if (shrink_axis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "shrink_axis_mask", shrink_axis_mask.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="reduction_indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Min'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Min (TF_Output input, TF_Output reduction_indices, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Min", MakeName ("Min", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, reduction_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnwrapDatasetVariant'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output UnwrapDatasetVariant (TF_Output input_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnwrapDatasetVariant", MakeName ("UnwrapDatasetVariant", operName));
			c_api.TF_AddInput(desc, input_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			return output_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayClose'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation TensorArrayClose (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayClose", MakeName ("TensorArrayClose", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="begin">
		/// </param>
		/// <param name="end">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorStridedSliceUpdate'.
		/// </param>
		/// <param name="begin_mask">
		///   Optional argument
		/// </param>
		/// <param name="end_mask">
		///   Optional argument
		/// </param>
		/// <param name="ellipsis_mask">
		///   Optional argument
		/// </param>
		/// <param name="new_axis_mask">
		///   Optional argument
		/// </param>
		/// <param name="shrink_axis_mask">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorStridedSliceUpdate (TF_Output input, TF_Output begin, TF_Output end, TF_Output strides, TF_Output value, long? begin_mask = null, long? end_mask = null, long? ellipsis_mask = null, long? new_axis_mask = null, long? shrink_axis_mask = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorStridedSliceUpdate", MakeName ("TensorStridedSliceUpdate", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, begin);
			c_api.TF_AddInput(desc, end);
			c_api.TF_AddInput(desc, strides);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (begin_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "begin_mask", begin_mask.Value);
			
			if (end_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "end_mask", end_mask.Value);
			
			if (ellipsis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "ellipsis_mask", ellipsis_mask.Value);
			
			if (new_axis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "new_axis_mask", new_axis_mask.Value);
			
			if (shrink_axis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "shrink_axis_mask", shrink_axis_mask.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="reader_handle">
		/// </param>
		/// <param name="queue_handle">
		/// </param>
		/// <param name="num_records">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderReadUpToV2'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   keys:
		///   values:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output keys, TF_Output values) ReaderReadUpToV2 (TF_Output reader_handle, TF_Output queue_handle, TF_Output num_records, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderReadUpToV2", MakeName ("ReaderReadUpToV2", operName));
			c_api.TF_AddInput(desc, reader_handle);
			c_api.TF_AddInput(desc, queue_handle);
			c_api.TF_AddInput(desc, num_records);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var keys = new TF_Output (op, _idx++);
			var values = new TF_Output (op, _idx++);
			return (keys, values);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MultiDeviceIterator'.
		/// </param>
		/// <param name="devices">
		/// </param>
		/// <param name="shared_name">
		/// </param>
		/// <param name="container">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MultiDeviceIterator (string[] devices, string shared_name, string container, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MultiDeviceIterator", MakeName ("MultiDeviceIterator", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrStringList (desc, "devices", devices);
			c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			c_api.TF_SetAttrString (desc, "container", container);
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="json_examples">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeJSONExample'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DecodeJSONExample (TF_Output json_examples, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodeJSONExample", MakeName ("DecodeJSONExample", operName));
			c_api.TF_AddInput(desc, json_examples);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var binary_examples = new TF_Output (op, _idx++);
			return binary_examples;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="multiples">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Tile'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Tile (TF_Output input, TF_Output multiples, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Tile", MakeName ("Tile", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, multiples);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="multiples">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TileGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TileGrad (TF_Output input, TF_Output multiples, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TileGrad", MakeName ("TileGrad", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, multiples);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Where'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Where (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Where", MakeName ("Where", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var index = new TF_Output (op, _idx++);
			return index;
		}

		/// <summary>
		/// </summary>
		/// <param name="s0">
		/// </param>
		/// <param name="s1">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BroadcastArgs'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BroadcastArgs (TF_Output s0, TF_Output s1, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BroadcastArgs", MakeName ("BroadcastArgs", operName));
			c_api.TF_AddInput(desc, s0);
			c_api.TF_AddInput(desc, s1);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var r0 = new TF_Output (op, _idx++);
			return r0;
		}

		/// <summary>
		/// </summary>
		/// <param name="s0">
		/// </param>
		/// <param name="s1">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BroadcastGradientArgs'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   r0:
		///   r1:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output r0, TF_Output r1) BroadcastGradientArgs (TF_Output s0, TF_Output s1, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BroadcastGradientArgs", MakeName ("BroadcastGradientArgs", operName));
			c_api.TF_AddInput(desc, s0);
			c_api.TF_AddInput(desc, s1);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var r0 = new TF_Output (op, _idx++);
			var r1 = new TF_Output (op, _idx++);
			return (r0, r1);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="paddings">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Pad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Pad (TF_Output input, TF_Output paddings, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Pad", MakeName ("Pad", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, paddings);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="paddings">
		/// </param>
		/// <param name="constant_values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PadV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output PadV2 (TF_Output input, TF_Output paddings, TF_Output constant_values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PadV2", MakeName ("PadV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, paddings);
			c_api.TF_AddInput(desc, constant_values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="paddings">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MirrorPad'.
		/// </param>
		/// <param name="mode">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MirrorPad (TF_Output input, TF_Output paddings, string mode, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MirrorPad", MakeName ("MirrorPad", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, paddings);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "mode", mode);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="paddings">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MirrorPadGrad'.
		/// </param>
		/// <param name="mode">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MirrorPadGrad (TF_Output input, TF_Output paddings, string mode, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MirrorPadGrad", MakeName ("MirrorPadGrad", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, paddings);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "mode", mode);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource_handle">
		/// </param>
		/// <param name="serialized">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DeserializeIterator'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation DeserializeIterator (TF_Output resource_handle, TF_Output serialized, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DeserializeIterator", MakeName ("DeserializeIterator", operName));
			c_api.TF_AddInput(desc, resource_handle);
			c_api.TF_AddInput(desc, serialized);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Placeholder'.
		/// </param>
		/// <param name="shape">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Placeholder (TF_DataType dtype, long[] shape = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Placeholder", MakeName ("Placeholder", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (shape != null)
				c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PlaceholderV2'.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output PlaceholderV2 (TF_DataType dtype, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PlaceholderV2", MakeName ("PlaceholderV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Squeeze'.
		/// </param>
		/// <param name="squeeze_dims">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Squeeze (TF_Output input, long[] squeeze_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Squeeze", MakeName ("Squeeze", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (squeeze_dims != null)
				c_api.TF_SetAttrIntList (desc, "squeeze_dims", ref squeeze_dims[0], squeeze_dims.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringStrip'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StringStrip (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringStrip", MakeName ("StringStrip", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="shift">
		/// </param>
		/// <param name="axis">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Roll'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Roll (TF_Output input, TF_Output shift, TF_Output axis, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Roll", MakeName ("Roll", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, shift);
			c_api.TF_AddInput(desc, axis);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ListDiff'.
		/// </param>
		/// <param name="out_idx">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   idx:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output idx) ListDiff (TF_Output x, TF_Output y, TF_DataType? out_idx = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ListDiff", MakeName ("ListDiff", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_idx.HasValue)
				c_api.TF_SetAttrType (desc, "out_idx", out_idx.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var idx = new TF_Output (op, _idx++);
			return (output, idx);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FIFOQueue'.
		/// </param>
		/// <param name="shapes">
		///   Optional argument
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="component_types">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FIFOQueue (TF_DataType[] component_types, long[][] shapes = null, long? capacity = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FIFOQueue", MakeName ("FIFOQueue", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (shapes != null)
				c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="new_global_step">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AccumulatorSetGlobalStep'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation AccumulatorSetGlobalStep (TF_Output handle, TF_Output new_global_step, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AccumulatorSetGlobalStep", MakeName ("AccumulatorSetGlobalStep", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, new_global_step);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="checkpoint_prefixes">
		/// </param>
		/// <param name="destination_prefix">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MergeV2Checkpoints'.
		/// </param>
		/// <param name="delete_old_dirs">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation MergeV2Checkpoints (TF_Output checkpoint_prefixes, TF_Output destination_prefix, bool? delete_old_dirs = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MergeV2Checkpoints", MakeName ("MergeV2Checkpoints", operName));
			c_api.TF_AddInput(desc, checkpoint_prefixes);
			c_api.TF_AddInput(desc, destination_prefix);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (delete_old_dirs.HasValue)
				c_api.TF_SetAttrBool (desc, "delete_old_dirs", Convert.ToByte(delete_old_dirs.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="tag">
		/// </param>
		/// <param name="tensor">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ImageSummary'.
		/// </param>
		/// <param name="max_images">
		///   Optional argument
		/// </param>
		/// <param name="bad_color">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ImageSummary (TF_Output tag, TF_Output tensor, long? max_images = null, TF_Tensor bad_color = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ImageSummary", MakeName ("ImageSummary", operName));
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (max_images.HasValue)
				c_api.TF_SetAttrInt (desc, "max_images", max_images.Value);
			
			if (bad_color != null)
				c_api.TF_SetAttrTensor (desc, "bad_color", bad_color, status);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var summary = new TF_Output (op, _idx++);
			return summary;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="block_shape">
		/// </param>
		/// <param name="paddings">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SpaceToBatchND'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SpaceToBatchND (TF_Output input, TF_Output block_shape, TF_Output paddings, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SpaceToBatchND", MakeName ("SpaceToBatchND", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, block_shape);
			c_api.TF_AddInput(desc, paddings);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="paddings">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SpaceToBatch'.
		/// </param>
		/// <param name="block_size">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SpaceToBatch (TF_Output input, TF_Output paddings, long block_size, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SpaceToBatch", MakeName ("SpaceToBatch", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, paddings);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "block_size", block_size);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PriorityQueueV2'.
		/// </param>
		/// <param name="component_types">
		///   Optional argument
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output PriorityQueueV2 (long[][] shapes, TF_DataType[] component_types = null, long? capacity = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PriorityQueueV2", MakeName ("PriorityQueueV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			if (component_types != null)
				c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="block_shape">
		/// </param>
		/// <param name="crops">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchToSpaceND'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchToSpaceND (TF_Output input, TF_Output block_shape, TF_Output crops, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchToSpaceND", MakeName ("BatchToSpaceND", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, block_shape);
			c_api.TF_AddInput(desc, crops);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DivNoNan'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DivNoNan (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DivNoNan", MakeName ("DivNoNan", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="m">
		/// </param>
		/// <param name="v">
		/// </param>
		/// <param name="beta1_power">
		/// </param>
		/// <param name="beta2_power">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="beta1">
		/// </param>
		/// <param name="beta2">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdam'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <param name="use_nesterov">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceApplyAdam (TF_Output var, TF_Output m, TF_Output v, TF_Output beta1_power, TF_Output beta2_power, TF_Output lr, TF_Output beta1, TF_Output beta2, TF_Output epsilon, TF_Output grad, bool? use_locking = null, bool? use_nesterov = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyAdam", MakeName ("ResourceApplyAdam", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, v);
			c_api.TF_AddInput(desc, beta1_power);
			c_api.TF_AddInput(desc, beta2_power);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, beta1);
			c_api.TF_AddInput(desc, beta2);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (use_nesterov.HasValue)
				c_api.TF_SetAttrBool (desc, "use_nesterov", Convert.ToByte(use_nesterov.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="index">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayWriteV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayWriteV2 (TF_Output handle, TF_Output index, TF_Output value, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayWriteV2", MakeName ("TensorArrayWriteV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, index);
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var flow_out = new TF_Output (op, _idx++);
			return flow_out;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="crops">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchToSpace'.
		/// </param>
		/// <param name="block_size">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchToSpace (TF_Output input, TF_Output crops, long block_size, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchToSpace", MakeName ("BatchToSpace", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, crops);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "block_size", block_size);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="images">
		/// </param>
		/// <param name="size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeBilinear'.
		/// </param>
		/// <param name="align_corners">
		///   Optional argument
		/// </param>
		/// <param name="half_pixel_centers">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ResizeBilinear (TF_Output images, TF_Output size, bool? align_corners = null, bool? half_pixel_centers = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResizeBilinear", MakeName ("ResizeBilinear", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (align_corners.HasValue)
				c_api.TF_SetAttrBool (desc, "align_corners", Convert.ToByte(align_corners.Value));
			
			if (half_pixel_centers.HasValue)
				c_api.TF_SetAttrBool (desc, "half_pixel_centers", Convert.ToByte(half_pixel_centers.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var resized_images = new TF_Output (op, _idx++);
			return resized_images;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SpaceToDepth'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="block_size">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SpaceToDepth (TF_Output input, long block_size, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SpaceToDepth", MakeName ("SpaceToDepth", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "block_size", block_size);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DepthToSpace'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="block_size">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DepthToSpace (TF_Output input, long block_size, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DepthToSpace", MakeName ("DepthToSpace", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "block_size", block_size);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="momenta">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingMomentumParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LoadTPUEmbeddingMomentumParameters (TF_Output parameters, TF_Output momenta, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingMomentumParameters", MakeName ("LoadTPUEmbeddingMomentumParameters", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, momenta);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="images">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExtractImagePatches'.
		/// </param>
		/// <param name="ksizes">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="rates">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExtractImagePatches (TF_Output images, long[] ksizes, long[] strides, long[] rates, string padding, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExtractImagePatches", MakeName ("ExtractImagePatches", operName));
			c_api.TF_AddInput(desc, images);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksizes", ref ksizes[0], ksizes.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrIntList (desc, "rates", ref rates[0], rates.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var patches = new TF_Output (op, _idx++);
			return patches;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_indices">
		/// </param>
		/// <param name="input_values">
		/// </param>
		/// <param name="input_shape">
		/// </param>
		/// <param name="reduction_axes">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReduceMax'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseReduceMax (TF_Output input_indices, TF_Output input_values, TF_Output input_shape, TF_Output reduction_axes, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseReduceMax", MakeName ("SparseReduceMax", operName));
			c_api.TF_AddInput(desc, input_indices);
			c_api.TF_AddInput(desc, input_values);
			c_api.TF_AddInput(desc, input_shape);
			c_api.TF_AddInput(desc, reduction_axes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExtractVolumePatches'.
		/// </param>
		/// <param name="ksizes">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExtractVolumePatches (TF_Output input, long[] ksizes, long[] strides, string padding, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExtractVolumePatches", MakeName ("ExtractVolumePatches", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksizes", ref ksizes[0], ksizes.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var patches = new TF_Output (op, _idx++);
			return patches;
		}

		/// <summary>
		/// </summary>
		/// <param name="shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomUniform'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RandomUniform (TF_Output shape, TF_DataType dtype, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomUniform", MakeName ("RandomUniform", operName));
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FractionalMaxPool'.
		/// </param>
		/// <param name="pseudo_random">
		///   Optional argument
		/// </param>
		/// <param name="overlapping">
		///   Optional argument
		/// </param>
		/// <param name="deterministic">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="pooling_ratio">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   row_pooling_sequence:
		///   col_pooling_sequence:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output row_pooling_sequence, TF_Output col_pooling_sequence) FractionalMaxPool (TF_Output value, float[] pooling_ratio, bool? pseudo_random = null, bool? overlapping = null, bool? deterministic = null, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FractionalMaxPool", MakeName ("FractionalMaxPool", operName));
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFloatList (desc, "pooling_ratio", ref pooling_ratio[0], pooling_ratio.Length);
			if (pseudo_random.HasValue)
				c_api.TF_SetAttrBool (desc, "pseudo_random", Convert.ToByte(pseudo_random.Value));
			
			if (overlapping.HasValue)
				c_api.TF_SetAttrBool (desc, "overlapping", Convert.ToByte(overlapping.Value));
			
			if (deterministic.HasValue)
				c_api.TF_SetAttrBool (desc, "deterministic", Convert.ToByte(deterministic.Value));
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var row_pooling_sequence = new TF_Output (op, _idx++);
			var col_pooling_sequence = new TF_Output (op, _idx++);
			return (output, row_pooling_sequence, col_pooling_sequence);
		}

		/// <summary>
		/// </summary>
		/// <param name="indices">
		/// </param>
		/// <param name="depth">
		/// </param>
		/// <param name="on_value">
		/// </param>
		/// <param name="off_value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OneHot'.
		/// </param>
		/// <param name="axis">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output OneHot (TF_Output indices, TF_Output depth, TF_Output on_value, TF_Output off_value, long? axis = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OneHot", MakeName ("OneHot", operName));
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, depth);
			c_api.TF_AddInput(desc, on_value);
			c_api.TF_AddInput(desc, off_value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (axis.HasValue)
				c_api.TF_SetAttrInt (desc, "axis", axis.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="gradients">
		/// </param>
		/// <param name="features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReluGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ReluGrad (TF_Output gradients, TF_Output features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReluGrad", MakeName ("ReluGrad", operName));
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var backprops = new TF_Output (op, _idx++);
			return backprops;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CollectiveReduce'.
		/// </param>
		/// <param name="wait_for">
		///   Optional argument
		/// </param>
		/// <param name="group_size">
		/// </param>
		/// <param name="group_key">
		/// </param>
		/// <param name="instance_key">
		/// </param>
		/// <param name="merge_op">
		/// </param>
		/// <param name="final_op">
		/// </param>
		/// <param name="subdiv_offsets">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CollectiveReduce (TF_Output input, long group_size, long group_key, long instance_key, string merge_op, string final_op, long[] subdiv_offsets, long[] wait_for = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CollectiveReduce", MakeName ("CollectiveReduce", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "group_size", group_size);
			c_api.TF_SetAttrInt (desc, "group_key", group_key);
			c_api.TF_SetAttrInt (desc, "instance_key", instance_key);
			c_api.TF_SetAttrString (desc, "merge_op", merge_op);
			c_api.TF_SetAttrString (desc, "final_op", final_op);
			c_api.TF_SetAttrIntList (desc, "subdiv_offsets", ref subdiv_offsets[0], subdiv_offsets.Length);
			if (wait_for != null)
				c_api.TF_SetAttrIntList (desc, "wait_for", ref wait_for[0], wait_for.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var data = new TF_Output (op, _idx++);
			return data;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizeAndDequantize'.
		/// </param>
		/// <param name="signed_input">
		///   Optional argument
		/// </param>
		/// <param name="num_bits">
		///   Optional argument
		/// </param>
		/// <param name="range_given">
		///   Optional argument
		/// </param>
		/// <param name="input_min">
		///   Optional argument
		/// </param>
		/// <param name="input_max">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output QuantizeAndDequantize (TF_Output input, bool? signed_input = null, long? num_bits = null, bool? range_given = null, float? input_min = null, float? input_max = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizeAndDequantize", MakeName ("QuantizeAndDequantize", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (signed_input.HasValue)
				c_api.TF_SetAttrBool (desc, "signed_input", Convert.ToByte(signed_input.Value));
			
			if (num_bits.HasValue)
				c_api.TF_SetAttrInt (desc, "num_bits", num_bits.Value);
			
			if (range_given.HasValue)
				c_api.TF_SetAttrBool (desc, "range_given", Convert.ToByte(range_given.Value));
			
			if (input_min.HasValue)
				c_api.TF_SetAttrFloat (desc, "input_min", input_min.Value);
			
			if (input_max.HasValue)
				c_api.TF_SetAttrFloat (desc, "input_max", input_max.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_min">
		/// </param>
		/// <param name="input_max">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizeAndDequantizeV2'.
		/// </param>
		/// <param name="signed_input">
		///   Optional argument
		/// </param>
		/// <param name="num_bits">
		///   Optional argument
		/// </param>
		/// <param name="range_given">
		///   Optional argument
		/// </param>
		/// <param name="round_mode">
		///   Optional argument
		/// </param>
		/// <param name="narrow_range">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output QuantizeAndDequantizeV2 (TF_Output input, TF_Output input_min, TF_Output input_max, bool? signed_input = null, long? num_bits = null, bool? range_given = null, string round_mode = null, bool? narrow_range = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizeAndDequantizeV2", MakeName ("QuantizeAndDequantizeV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_min);
			c_api.TF_AddInput(desc, input_max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (signed_input.HasValue)
				c_api.TF_SetAttrBool (desc, "signed_input", Convert.ToByte(signed_input.Value));
			
			if (num_bits.HasValue)
				c_api.TF_SetAttrInt (desc, "num_bits", num_bits.Value);
			
			if (range_given.HasValue)
				c_api.TF_SetAttrBool (desc, "range_given", Convert.ToByte(range_given.Value));
			
			if (round_mode != null)
				c_api.TF_SetAttrString (desc, "round_mode", round_mode);
			
			if (narrow_range.HasValue)
				c_api.TF_SetAttrBool (desc, "narrow_range", Convert.ToByte(narrow_range.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="node_ids">
		/// </param>
		/// <param name="gradients">
		/// </param>
		/// <param name="hessians">
		/// </param>
		/// <param name="feature">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesAggregateStats'.
		/// </param>
		/// <param name="max_splits">
		/// </param>
		/// <param name="num_buckets">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BoostedTreesAggregateStats (TF_Output node_ids, TF_Output gradients, TF_Output hessians, TF_Output feature, long max_splits, long num_buckets, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesAggregateStats", MakeName ("BoostedTreesAggregateStats", operName));
			c_api.TF_AddInput(desc, node_ids);
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, hessians);
			c_api.TF_AddInput(desc, feature);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "max_splits", max_splits);
			c_api.TF_SetAttrInt (desc, "num_buckets", num_buckets);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var stats_summary = new TF_Output (op, _idx++);
			return stats_summary;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_min">
		/// </param>
		/// <param name="input_max">
		/// </param>
		/// <param name="num_bits">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizeAndDequantizeV3'.
		/// </param>
		/// <param name="signed_input">
		///   Optional argument
		/// </param>
		/// <param name="range_given">
		///   Optional argument
		/// </param>
		/// <param name="narrow_range">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output QuantizeAndDequantizeV3 (TF_Output input, TF_Output input_min, TF_Output input_max, TF_Output num_bits, bool? signed_input = null, bool? range_given = null, bool? narrow_range = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizeAndDequantizeV3", MakeName ("QuantizeAndDequantizeV3", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_min);
			c_api.TF_AddInput(desc, input_max);
			c_api.TF_AddInput(desc, num_bits);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (signed_input.HasValue)
				c_api.TF_SetAttrBool (desc, "signed_input", Convert.ToByte(signed_input.Value));
			
			if (range_given.HasValue)
				c_api.TF_SetAttrBool (desc, "range_given", Convert.ToByte(range_given.Value));
			
			if (narrow_range.HasValue)
				c_api.TF_SetAttrBool (desc, "narrow_range", Convert.ToByte(narrow_range.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnicodeDecodeWithOffsets'.
		/// </param>
		/// <param name="errors">
		///   Optional argument
		/// </param>
		/// <param name="replacement_char">
		///   Optional argument
		/// </param>
		/// <param name="replace_control_characters">
		///   Optional argument
		/// </param>
		/// <param name="Tsplits">
		///   Optional argument
		/// </param>
		/// <param name="input_encoding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   row_splits:
		///   char_values:
		///   char_to_byte_starts:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output row_splits, TF_Output char_values, TF_Output char_to_byte_starts) UnicodeDecodeWithOffsets (TF_Output input, string input_encoding, string errors = null, long? replacement_char = null, bool? replace_control_characters = null, TF_DataType? Tsplits = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnicodeDecodeWithOffsets", MakeName ("UnicodeDecodeWithOffsets", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "input_encoding", input_encoding);
			if (errors != null)
				c_api.TF_SetAttrString (desc, "errors", errors);
			
			if (replacement_char.HasValue)
				c_api.TF_SetAttrInt (desc, "replacement_char", replacement_char.Value);
			
			if (replace_control_characters.HasValue)
				c_api.TF_SetAttrBool (desc, "replace_control_characters", Convert.ToByte(replace_control_characters.Value));
			
			if (Tsplits.HasValue)
				c_api.TF_SetAttrType (desc, "Tsplits", Tsplits.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var row_splits = new TF_Output (op, _idx++);
			var char_values = new TF_Output (op, _idx++);
			var char_to_byte_starts = new TF_Output (op, _idx++);
			return (row_splits, char_values, char_to_byte_starts);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="min_range">
		/// </param>
		/// <param name="max_range">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizeV2'.
		/// </param>
		/// <param name="mode">
		///   Optional argument
		/// </param>
		/// <param name="round_mode">
		///   Optional argument
		/// </param>
		/// <param name="T">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   output_min:
		///   output_max:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output output_min, TF_Output output_max) QuantizeV2 (TF_Output input, TF_Output min_range, TF_Output max_range, TF_DataType T, string mode = null, string round_mode = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizeV2", MakeName ("QuantizeV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, min_range);
			c_api.TF_AddInput(desc, max_range);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "T", T);
			if (mode != null)
				c_api.TF_SetAttrString (desc, "mode", mode);
			
			if (round_mode != null)
				c_api.TF_SetAttrString (desc, "round_mode", round_mode);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var output_min = new TF_Output (op, _idx++);
			var output_max = new TF_Output (op, _idx++);
			return (output, output_min, output_max);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NcclAllReduce'.
		/// </param>
		/// <param name="reduction">
		/// </param>
		/// <param name="num_devices">
		/// </param>
		/// <param name="shared_name">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output NcclAllReduce (TF_Output input, string reduction, long num_devices, string shared_name, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NcclAllReduce", MakeName ("NcclAllReduce", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "reduction", reduction);
			c_api.TF_SetAttrInt (desc, "num_devices", num_devices);
			c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var data = new TF_Output (op, _idx++);
			return data;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGrad'.
		/// </param>
		/// <param name="source">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayGrad (TF_Output handle, TF_Output flow_in, string source, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayGrad", MakeName ("TensorArrayGrad", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "source", source);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var grad_handle = new TF_Output (op, _idx++);
			return grad_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BitwiseOr'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BitwiseOr (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BitwiseOr", MakeName ("BitwiseOr", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="min_range">
		/// </param>
		/// <param name="max_range">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Dequantize'.
		/// </param>
		/// <param name="mode">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Dequantize (TF_Output input, TF_Output min_range, TF_Output max_range, string mode = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Dequantize", MakeName ("Dequantize", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, min_range);
			c_api.TF_AddInput(desc, max_range);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (mode != null)
				c_api.TF_SetAttrString (desc, "mode", mode);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="images">
		/// </param>
		/// <param name="quality">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodeJpegVariableQuality'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output EncodeJpegVariableQuality (TF_Output images, TF_Output quality, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EncodeJpegVariableQuality", MakeName ("EncodeJpegVariableQuality", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, quality);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var contents = new TF_Output (op, _idx++);
			return contents;
		}

		/// <summary>
		/// </summary>
		/// <param name="concat_dim">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="input_mins">
		/// </param>
		/// <param name="input_maxes">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConcat'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   output_min:
		///   output_max:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output output_min, TF_Output output_max) QuantizedConcat (TF_Output concat_dim, TF_Output[] values, TF_Output[] input_mins, TF_Output[] input_maxes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConcat", MakeName ("QuantizedConcat", operName));
			c_api.TF_AddInput(desc, concat_dim);
			c_api.TF_AddInputList(desc, values[0], values.Length);
			c_api.TF_AddInputList(desc, input_mins[0], input_mins.Length);
			c_api.TF_AddInputList(desc, input_maxes[0], input_maxes.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var output_min = new TF_Output (op, _idx++);
			var output_max = new TF_Output (op, _idx++);
			return (output, output_min, output_max);
		}

		/// <summary>
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <param name="input_min">
		/// </param>
		/// <param name="input_max">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedReshape'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   output_min:
		///   output_max:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output output_min, TF_Output output_max) QuantizedReshape (TF_Output tensor, TF_Output shape, TF_Output input_min, TF_Output input_max, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedReshape", MakeName ("QuantizedReshape", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, input_min);
			c_api.TF_AddInput(desc, input_max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var output_min = new TF_Output (op, _idx++);
			var output_max = new TF_Output (op, _idx++);
			return (output, output_min, output_max);
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="x_min">
		/// </param>
		/// <param name="x_max">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedInstanceNorm'.
		/// </param>
		/// <param name="output_range_given">
		///   Optional argument
		/// </param>
		/// <param name="given_y_min">
		///   Optional argument
		/// </param>
		/// <param name="given_y_max">
		///   Optional argument
		/// </param>
		/// <param name="variance_epsilon">
		///   Optional argument
		/// </param>
		/// <param name="min_separation">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   y:
		///   y_min:
		///   y_max:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output y, TF_Output y_min, TF_Output y_max) QuantizedInstanceNorm (TF_Output x, TF_Output x_min, TF_Output x_max, bool? output_range_given = null, float? given_y_min = null, float? given_y_max = null, float? variance_epsilon = null, float? min_separation = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedInstanceNorm", MakeName ("QuantizedInstanceNorm", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, x_min);
			c_api.TF_AddInput(desc, x_max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (output_range_given.HasValue)
				c_api.TF_SetAttrBool (desc, "output_range_given", Convert.ToByte(output_range_given.Value));
			
			if (given_y_min.HasValue)
				c_api.TF_SetAttrFloat (desc, "given_y_min", given_y_min.Value);
			
			if (given_y_max.HasValue)
				c_api.TF_SetAttrFloat (desc, "given_y_max", given_y_max.Value);
			
			if (variance_epsilon.HasValue)
				c_api.TF_SetAttrFloat (desc, "variance_epsilon", variance_epsilon.Value);
			
			if (min_separation.HasValue)
				c_api.TF_SetAttrFloat (desc, "min_separation", min_separation.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			var y_min = new TF_Output (op, _idx++);
			var y_max = new TF_Output (op, _idx++);
			return (y, y_min, y_max);
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="segment_ids">
		/// </param>
		/// <param name="num_segments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentMeanWithNumSegments'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseSegmentMeanWithNumSegments (TF_Output data, TF_Output indices, TF_Output segment_ids, TF_Output num_segments, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSegmentMeanWithNumSegments", MakeName ("SparseSegmentMeanWithNumSegments", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, segment_ids);
			c_api.TF_AddInput(desc, num_segments);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArraySizeV3'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArraySizeV3 (TF_Output handle, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArraySizeV3", MakeName ("TensorArraySizeV3", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		/// </summary>
		/// <param name="sorted_inputs">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UpperBound'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output UpperBound (TF_Output sorted_inputs, TF_Output values, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UpperBound", MakeName ("UpperBound", operName));
			c_api.TF_AddInput(desc, sorted_inputs);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_a">
		/// </param>
		/// <param name="input_b">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListConcatLists'.
		/// </param>
		/// <param name="element_dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorListConcatLists (TF_Output input_a, TF_Output input_b, TF_DataType element_dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListConcatLists", MakeName ("TensorListConcatLists", operName));
			c_api.TF_AddInput(desc, input_a);
			c_api.TF_AddInput(desc, input_b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "element_dtype", element_dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="seed">
		/// </param>
		/// <param name="seed2">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AnonymousRandomSeedGenerator'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   handle:
		///   deleter:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output handle, TF_Output deleter) AnonymousRandomSeedGenerator (TF_Output seed, TF_Output seed2, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AnonymousRandomSeedGenerator", MakeName ("AnonymousRandomSeedGenerator", operName));
			c_api.TF_AddInput(desc, seed);
			c_api.TF_AddInput(desc, seed2);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			var deleter = new TF_Output (op, _idx++);
			return (handle, deleter);
		}

		/// <summary>
		/// </summary>
		/// <param name="sorted_inputs">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LowerBound'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LowerBound (TF_Output sorted_inputs, TF_Output values, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LowerBound", MakeName ("LowerBound", operName));
			c_api.TF_AddInput(desc, sorted_inputs);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterNd'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ScatterNd (TF_Output indices, TF_Output updates, TF_Output shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterNd", MakeName ("ScatterNd", operName));
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="gradients">
		/// </param>
		/// <param name="features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Relu6Grad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Relu6Grad (TF_Output gradients, TF_Output features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Relu6Grad", MakeName ("Relu6Grad", operName));
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var backprops = new TF_Output (op, _idx++);
			return backprops;
		}

		/// <summary>
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorScatterAdd'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorScatterAdd (TF_Output tensor, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorScatterAdd", MakeName ("TensorScatterAdd", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="condition">
		/// </param>
		/// <param name="t">
		/// </param>
		/// <param name="e">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SelectV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SelectV2 (TF_Output condition, TF_Output t, TF_Output e, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SelectV2", MakeName ("SelectV2", operName));
			c_api.TF_AddInput(desc, condition);
			c_api.TF_AddInput(desc, t);
			c_api.TF_AddInput(desc, e);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="grads">
		/// </param>
		/// <param name="original_image">
		/// </param>
		/// <param name="scale">
		/// </param>
		/// <param name="translation">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScaleAndTranslateGrad'.
		/// </param>
		/// <param name="kernel_type">
		///   Optional argument
		/// </param>
		/// <param name="antialias">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ScaleAndTranslateGrad (TF_Output grads, TF_Output original_image, TF_Output scale, TF_Output translation, string kernel_type = null, bool? antialias = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScaleAndTranslateGrad", MakeName ("ScaleAndTranslateGrad", operName));
			c_api.TF_AddInput(desc, grads);
			c_api.TF_AddInput(desc, original_image);
			c_api.TF_AddInput(desc, scale);
			c_api.TF_AddInput(desc, translation);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (kernel_type != null)
				c_api.TF_SetAttrString (desc, "kernel_type", kernel_type);
			
			if (antialias.HasValue)
				c_api.TF_SetAttrBool (desc, "antialias", Convert.ToByte(antialias.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GetSessionTensor'.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output GetSessionTensor (TF_Output handle, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GetSessionTensor", MakeName ("GetSessionTensor", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			return value;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InfeedEnqueuePrelinearizedBuffer'.
		/// </param>
		/// <param name="device_ordinal">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation InfeedEnqueuePrelinearizedBuffer (TF_Output input, long? device_ordinal = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InfeedEnqueuePrelinearizedBuffer", MakeName ("InfeedEnqueuePrelinearizedBuffer", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (device_ordinal.HasValue)
				c_api.TF_SetAttrInt (desc, "device_ordinal", device_ordinal.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorScatterSub'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorScatterSub (TF_Output tensor, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorScatterSub", MakeName ("TensorScatterSub", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixInverse'.
		/// </param>
		/// <param name="adjoint">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MatrixInverse (TF_Output input, bool? adjoint = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixInverse", MakeName ("MatrixInverse", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (adjoint.HasValue)
				c_api.TF_SetAttrBool (desc, "adjoint", Convert.ToByte(adjoint.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="serialized_sparse">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DeserializeSparse'.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sparse_indices:
		///   sparse_values:
		///   sparse_shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output sparse_indices, TF_Output sparse_values, TF_Output sparse_shape) DeserializeSparse (TF_Output serialized_sparse, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DeserializeSparse", MakeName ("DeserializeSparse", operName));
			c_api.TF_AddInput(desc, serialized_sparse);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var sparse_indices = new TF_Output (op, _idx++);
			var sparse_values = new TF_Output (op, _idx++);
			var sparse_shape = new TF_Output (op, _idx++);
			return (sparse_indices, sparse_values, sparse_shape);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterNdNonAliasingAdd'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ScatterNdNonAliasingAdd (TF_Output input, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterNdNonAliasingAdd", MakeName ("ScatterNdNonAliasingAdd", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="image_size">
		/// </param>
		/// <param name="bounding_boxes">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SampleDistortedBoundingBox'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="min_object_covered">
		///   Optional argument
		/// </param>
		/// <param name="aspect_ratio_range">
		///   Optional argument
		/// </param>
		/// <param name="area_range">
		///   Optional argument
		/// </param>
		/// <param name="max_attempts">
		///   Optional argument
		/// </param>
		/// <param name="use_image_if_no_bounding_boxes">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   begin:
		///   size:
		///   bboxes:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output begin, TF_Output size, TF_Output bboxes) SampleDistortedBoundingBox (TF_Output image_size, TF_Output bounding_boxes, long? seed = null, long? seed2 = null, float? min_object_covered = null, float[] aspect_ratio_range = null, float[] area_range = null, long? max_attempts = null, bool? use_image_if_no_bounding_boxes = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SampleDistortedBoundingBox", MakeName ("SampleDistortedBoundingBox", operName));
			c_api.TF_AddInput(desc, image_size);
			c_api.TF_AddInput(desc, bounding_boxes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (min_object_covered.HasValue)
				c_api.TF_SetAttrFloat (desc, "min_object_covered", min_object_covered.Value);
			
			if (aspect_ratio_range != null)
				c_api.TF_SetAttrFloatList (desc, "aspect_ratio_range", ref aspect_ratio_range[0], aspect_ratio_range.Length);
			
			if (area_range != null)
				c_api.TF_SetAttrFloatList (desc, "area_range", ref area_range[0], area_range.Length);
			
			if (max_attempts.HasValue)
				c_api.TF_SetAttrInt (desc, "max_attempts", max_attempts.Value);
			
			if (use_image_if_no_bounding_boxes.HasValue)
				c_api.TF_SetAttrBool (desc, "use_image_if_no_bounding_boxes", Convert.ToByte(use_image_if_no_bounding_boxes.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var begin = new TF_Output (op, _idx++);
			var size = new TF_Output (op, _idx++);
			var bboxes = new TF_Output (op, _idx++);
			return (begin, size, bboxes);
		}

		/// <summary>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxArgs'.
		/// </param>
		/// <param name="min">
		///   Optional argument
		/// </param>
		/// <param name="max">
		///   Optional argument
		/// </param>
		/// <param name="num_bits">
		///   Optional argument
		/// </param>
		/// <param name="narrow_range">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FakeQuantWithMinMaxArgs (TF_Output inputs, float? min = null, float? max = null, long? num_bits = null, bool? narrow_range = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FakeQuantWithMinMaxArgs", MakeName ("FakeQuantWithMinMaxArgs", operName));
			c_api.TF_AddInput(desc, inputs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (min.HasValue)
				c_api.TF_SetAttrFloat (desc, "min", min.Value);
			
			if (max.HasValue)
				c_api.TF_SetAttrFloat (desc, "max", max.Value);
			
			if (num_bits.HasValue)
				c_api.TF_SetAttrInt (desc, "num_bits", num_bits.Value);
			
			if (narrow_range.HasValue)
				c_api.TF_SetAttrBool (desc, "narrow_range", Convert.ToByte(narrow_range.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var outputs = new TF_Output (op, _idx++);
			return outputs;
		}

		/// <summary>
		/// </summary>
		/// <param name="num_layers">
		/// </param>
		/// <param name="num_units">
		/// </param>
		/// <param name="input_size">
		/// </param>
		/// <param name="weights">
		/// </param>
		/// <param name="biases">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNCanonicalToParamsV2'.
		/// </param>
		/// <param name="rnn_mode">
		///   Optional argument
		/// </param>
		/// <param name="input_mode">
		///   Optional argument
		/// </param>
		/// <param name="direction">
		///   Optional argument
		/// </param>
		/// <param name="dropout">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="num_proj">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CudnnRNNCanonicalToParamsV2 (TF_Output num_layers, TF_Output num_units, TF_Output input_size, TF_Output[] weights, TF_Output[] biases, string rnn_mode = null, string input_mode = null, string direction = null, float? dropout = null, long? seed = null, long? seed2 = null, long? num_proj = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CudnnRNNCanonicalToParamsV2", MakeName ("CudnnRNNCanonicalToParamsV2", operName));
			c_api.TF_AddInput(desc, num_layers);
			c_api.TF_AddInput(desc, num_units);
			c_api.TF_AddInput(desc, input_size);
			c_api.TF_AddInputList(desc, weights[0], weights.Length);
			c_api.TF_AddInputList(desc, biases[0], biases.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (rnn_mode != null)
				c_api.TF_SetAttrString (desc, "rnn_mode", rnn_mode);
			
			if (input_mode != null)
				c_api.TF_SetAttrString (desc, "input_mode", input_mode);
			
			if (direction != null)
				c_api.TF_SetAttrString (desc, "direction", direction);
			
			if (dropout.HasValue)
				c_api.TF_SetAttrFloat (desc, "dropout", dropout.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (num_proj.HasValue)
				c_api.TF_SetAttrInt (desc, "num_proj", num_proj.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			return parameters;
		}

		/// <summary>
		/// </summary>
		/// <param name="t">
		/// </param>
		/// <param name="t_min">
		/// </param>
		/// <param name="t_max">
		/// </param>
		/// <param name="m">
		/// </param>
		/// <param name="m_min">
		/// </param>
		/// <param name="m_max">
		/// </param>
		/// <param name="v">
		/// </param>
		/// <param name="v_min">
		/// </param>
		/// <param name="v_max">
		/// </param>
		/// <param name="beta">
		/// </param>
		/// <param name="beta_min">
		/// </param>
		/// <param name="beta_max">
		/// </param>
		/// <param name="gamma">
		/// </param>
		/// <param name="gamma_min">
		/// </param>
		/// <param name="gamma_max">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedBatchNormWithGlobalNormalization'.
		/// </param>
		/// <param name="out_type">
		/// </param>
		/// <param name="variance_epsilon">
		/// </param>
		/// <param name="scale_after_normalization">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   result:
		///   result_min:
		///   result_max:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output result, TF_Output result_min, TF_Output result_max) QuantizedBatchNormWithGlobalNormalization (TF_Output t, TF_Output t_min, TF_Output t_max, TF_Output m, TF_Output m_min, TF_Output m_max, TF_Output v, TF_Output v_min, TF_Output v_max, TF_Output beta, TF_Output beta_min, TF_Output beta_max, TF_Output gamma, TF_Output gamma_min, TF_Output gamma_max, TF_DataType out_type, float variance_epsilon, bool scale_after_normalization, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedBatchNormWithGlobalNormalization", MakeName ("QuantizedBatchNormWithGlobalNormalization", operName));
			c_api.TF_AddInput(desc, t);
			c_api.TF_AddInput(desc, t_min);
			c_api.TF_AddInput(desc, t_max);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, m_min);
			c_api.TF_AddInput(desc, m_max);
			c_api.TF_AddInput(desc, v);
			c_api.TF_AddInput(desc, v_min);
			c_api.TF_AddInput(desc, v_max);
			c_api.TF_AddInput(desc, beta);
			c_api.TF_AddInput(desc, beta_min);
			c_api.TF_AddInput(desc, beta_max);
			c_api.TF_AddInput(desc, gamma);
			c_api.TF_AddInput(desc, gamma_min);
			c_api.TF_AddInput(desc, gamma_max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "out_type", out_type);
			c_api.TF_SetAttrFloat (desc, "variance_epsilon", variance_epsilon);
			c_api.TF_SetAttrBool (desc, "scale_after_normalization", Convert.ToByte(scale_after_normalization));
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var result = new TF_Output (op, _idx++);
			var result_min = new TF_Output (op, _idx++);
			var result_max = new TF_Output (op, _idx++);
			return (result, result_min, result_max);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_h">
		/// </param>
		/// <param name="input_c">
		/// </param>
		/// <param name="parameters">
		/// </param>
		/// <param name="sequence_lengths">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNV3'.
		/// </param>
		/// <param name="rnn_mode">
		///   Optional argument
		/// </param>
		/// <param name="input_mode">
		///   Optional argument
		/// </param>
		/// <param name="direction">
		///   Optional argument
		/// </param>
		/// <param name="dropout">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="num_proj">
		///   Optional argument
		/// </param>
		/// <param name="is_training">
		///   Optional argument
		/// </param>
		/// <param name="time_major">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   output_h:
		///   output_c:
		///   reserve_space:
		///   host_reserved:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output output_h, TF_Output output_c, TF_Output reserve_space, TF_Output host_reserved) CudnnRNNV3 (TF_Output input, TF_Output input_h, TF_Output input_c, TF_Output parameters, TF_Output sequence_lengths, string rnn_mode = null, string input_mode = null, string direction = null, float? dropout = null, long? seed = null, long? seed2 = null, long? num_proj = null, bool? is_training = null, bool? time_major = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CudnnRNNV3", MakeName ("CudnnRNNV3", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_h);
			c_api.TF_AddInput(desc, input_c);
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, sequence_lengths);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (rnn_mode != null)
				c_api.TF_SetAttrString (desc, "rnn_mode", rnn_mode);
			
			if (input_mode != null)
				c_api.TF_SetAttrString (desc, "input_mode", input_mode);
			
			if (direction != null)
				c_api.TF_SetAttrString (desc, "direction", direction);
			
			if (dropout.HasValue)
				c_api.TF_SetAttrFloat (desc, "dropout", dropout.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (num_proj.HasValue)
				c_api.TF_SetAttrInt (desc, "num_proj", num_proj.Value);
			
			if (is_training.HasValue)
				c_api.TF_SetAttrBool (desc, "is_training", Convert.ToByte(is_training.Value));
			
			if (time_major.HasValue)
				c_api.TF_SetAttrBool (desc, "time_major", Convert.ToByte(time_major.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var output_h = new TF_Output (op, _idx++);
			var output_c = new TF_Output (op, _idx++);
			var reserve_space = new TF_Output (op, _idx++);
			var host_reserved = new TF_Output (op, _idx++);
			return (output, output_h, output_c, reserve_space, host_reserved);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="reduction_indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'All'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output All (TF_Output input, TF_Output reduction_indices, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "All", MakeName ("All", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, reduction_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="gradients">
		/// </param>
		/// <param name="inputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxArgsGradient'.
		/// </param>
		/// <param name="min">
		///   Optional argument
		/// </param>
		/// <param name="max">
		///   Optional argument
		/// </param>
		/// <param name="num_bits">
		///   Optional argument
		/// </param>
		/// <param name="narrow_range">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FakeQuantWithMinMaxArgsGradient (TF_Output gradients, TF_Output inputs, float? min = null, float? max = null, long? num_bits = null, bool? narrow_range = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FakeQuantWithMinMaxArgsGradient", MakeName ("FakeQuantWithMinMaxArgsGradient", operName));
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, inputs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (min.HasValue)
				c_api.TF_SetAttrFloat (desc, "min", min.Value);
			
			if (max.HasValue)
				c_api.TF_SetAttrFloat (desc, "max", max.Value);
			
			if (num_bits.HasValue)
				c_api.TF_SetAttrInt (desc, "num_bits", num_bits.Value);
			
			if (narrow_range.HasValue)
				c_api.TF_SetAttrBool (desc, "narrow_range", Convert.ToByte(narrow_range.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var backprops = new TF_Output (op, _idx++);
			return backprops;
		}

		/// <summary>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="min">
		/// </param>
		/// <param name="max">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxVars'.
		/// </param>
		/// <param name="num_bits">
		///   Optional argument
		/// </param>
		/// <param name="narrow_range">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FakeQuantWithMinMaxVars (TF_Output inputs, TF_Output min, TF_Output max, long? num_bits = null, bool? narrow_range = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FakeQuantWithMinMaxVars", MakeName ("FakeQuantWithMinMaxVars", operName));
			c_api.TF_AddInput(desc, inputs);
			c_api.TF_AddInput(desc, min);
			c_api.TF_AddInput(desc, max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (num_bits.HasValue)
				c_api.TF_SetAttrInt (desc, "num_bits", num_bits.Value);
			
			if (narrow_range.HasValue)
				c_api.TF_SetAttrBool (desc, "narrow_range", Convert.ToByte(narrow_range.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var outputs = new TF_Output (op, _idx++);
			return outputs;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchCholesky'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchCholesky (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchCholesky", MakeName ("BatchCholesky", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OutfeedEnqueue'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation OutfeedEnqueue (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OutfeedEnqueue", MakeName ("OutfeedEnqueue", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="gradients">
		/// </param>
		/// <param name="inputs">
		/// </param>
		/// <param name="min">
		/// </param>
		/// <param name="max">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxVarsGradient'.
		/// </param>
		/// <param name="num_bits">
		///   Optional argument
		/// </param>
		/// <param name="narrow_range">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   backprops_wrt_input:
		///   backprop_wrt_min:
		///   backprop_wrt_max:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output backprops_wrt_input, TF_Output backprop_wrt_min, TF_Output backprop_wrt_max) FakeQuantWithMinMaxVarsGradient (TF_Output gradients, TF_Output inputs, TF_Output min, TF_Output max, long? num_bits = null, bool? narrow_range = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FakeQuantWithMinMaxVarsGradient", MakeName ("FakeQuantWithMinMaxVarsGradient", operName));
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, inputs);
			c_api.TF_AddInput(desc, min);
			c_api.TF_AddInput(desc, max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (num_bits.HasValue)
				c_api.TF_SetAttrInt (desc, "num_bits", num_bits.Value);
			
			if (narrow_range.HasValue)
				c_api.TF_SetAttrBool (desc, "narrow_range", Convert.ToByte(narrow_range.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var backprops_wrt_input = new TF_Output (op, _idx++);
			var backprop_wrt_min = new TF_Output (op, _idx++);
			var backprop_wrt_max = new TF_Output (op, _idx++);
			return (backprops_wrt_input, backprop_wrt_min, backprop_wrt_max);
		}

		/// <summary>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="min">
		/// </param>
		/// <param name="max">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxVarsPerChannel'.
		/// </param>
		/// <param name="num_bits">
		///   Optional argument
		/// </param>
		/// <param name="narrow_range">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FakeQuantWithMinMaxVarsPerChannel (TF_Output inputs, TF_Output min, TF_Output max, long? num_bits = null, bool? narrow_range = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FakeQuantWithMinMaxVarsPerChannel", MakeName ("FakeQuantWithMinMaxVarsPerChannel", operName));
			c_api.TF_AddInput(desc, inputs);
			c_api.TF_AddInput(desc, min);
			c_api.TF_AddInput(desc, max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (num_bits.HasValue)
				c_api.TF_SetAttrInt (desc, "num_bits", num_bits.Value);
			
			if (narrow_range.HasValue)
				c_api.TF_SetAttrBool (desc, "narrow_range", Convert.ToByte(narrow_range.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var outputs = new TF_Output (op, _idx++);
			return outputs;
		}

		/// <summary>
		/// </summary>
		/// <param name="gradients">
		/// </param>
		/// <param name="inputs">
		/// </param>
		/// <param name="min">
		/// </param>
		/// <param name="max">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxVarsPerChannelGradient'.
		/// </param>
		/// <param name="num_bits">
		///   Optional argument
		/// </param>
		/// <param name="narrow_range">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   backprops_wrt_input:
		///   backprop_wrt_min:
		///   backprop_wrt_max:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output backprops_wrt_input, TF_Output backprop_wrt_min, TF_Output backprop_wrt_max) FakeQuantWithMinMaxVarsPerChannelGradient (TF_Output gradients, TF_Output inputs, TF_Output min, TF_Output max, long? num_bits = null, bool? narrow_range = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FakeQuantWithMinMaxVarsPerChannelGradient", MakeName ("FakeQuantWithMinMaxVarsPerChannelGradient", operName));
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, inputs);
			c_api.TF_AddInput(desc, min);
			c_api.TF_AddInput(desc, max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (num_bits.HasValue)
				c_api.TF_SetAttrInt (desc, "num_bits", num_bits.Value);
			
			if (narrow_range.HasValue)
				c_api.TF_SetAttrBool (desc, "narrow_range", Convert.ToByte(narrow_range.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var backprops_wrt_input = new TF_Output (op, _idx++);
			var backprop_wrt_min = new TF_Output (op, _idx++);
			var backprop_wrt_max = new TF_Output (op, _idx++);
			return (backprops_wrt_input, backprop_wrt_min, backprop_wrt_max);
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="segment_ids">
		/// </param>
		/// <param name="num_segments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnsortedSegmentProd'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output UnsortedSegmentProd (TF_Output data, TF_Output segment_ids, TF_Output num_segments, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnsortedSegmentProd", MakeName ("UnsortedSegmentProd", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, segment_ids);
			c_api.TF_AddInput(desc, num_segments);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyAdagrad'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <param name="update_slots">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceSparseApplyAdagrad (TF_Output var, TF_Output accum, TF_Output lr, TF_Output grad, TF_Output indices, bool? use_locking = null, bool? update_slots = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyAdagrad", MakeName ("ResourceSparseApplyAdagrad", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (update_slots.HasValue)
				c_api.TF_SetAttrBool (desc, "update_slots", Convert.ToByte(update_slots.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="method">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Fingerprint'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Fingerprint (TF_Output data, TF_Output method, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Fingerprint", MakeName ("Fingerprint", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, method);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var fingerprint = new TF_Output (op, _idx++);
			return fingerprint;
		}

		/// <summary>
		/// </summary>
		/// <param name="diagonal">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatrixDiag'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchMatrixDiag (TF_Output diagonal, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatrixDiag", MakeName ("BatchMatrixDiag", operName));
			c_api.TF_AddInput(desc, diagonal);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AnonymousMemoryCache'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   handle:
		///   deleter:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output handle, TF_Output deleter) AnonymousMemoryCache (string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AnonymousMemoryCache", MakeName ("AnonymousMemoryCache", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			var deleter = new TF_Output (op, _idx++);
			return (handle, deleter);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="diagonal">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatrixSetDiag'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchMatrixSetDiag (TF_Output input, TF_Output diagonal, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatrixSetDiag", MakeName ("BatchMatrixSetDiag", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, diagonal);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayConcat'.
		/// </param>
		/// <param name="element_shape_except0">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   value:
		///   lengths:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output value, TF_Output lengths) TensorArrayConcat (TF_Output handle, TF_Output flow_in, TF_DataType dtype, long[] element_shape_except0 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayConcat", MakeName ("TensorArrayConcat", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (element_shape_except0 != null)
				c_api.TF_SetAttrShape (desc, "element_shape_except0", ref element_shape_except0[0], element_shape_except0.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			var lengths = new TF_Output (op, _idx++);
			return (value, lengths);
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="num_threads">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalPrivateThreadPoolDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalPrivateThreadPoolDataset (TF_Output input_dataset, TF_Output num_threads, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalPrivateThreadPoolDataset", MakeName ("ExperimentalPrivateThreadPoolDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, num_threads);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="num_lower">
		/// </param>
		/// <param name="num_upper">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatrixBandPart'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchMatrixBandPart (TF_Output input, TF_Output num_lower, TF_Output num_upper, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatrixBandPart", MakeName ("BatchMatrixBandPart", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, num_lower);
			c_api.TF_AddInput(desc, num_upper);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var band = new TF_Output (op, _idx++);
			return band;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="filename">
		/// </param>
		/// <param name="cache">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CacheDatasetV2'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CacheDatasetV2 (TF_Output input_dataset, TF_Output filename, TF_Output cache, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CacheDatasetV2", MakeName ("CacheDatasetV2", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, filename);
			c_api.TF_AddInput(desc, cache);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="contents">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeWav'.
		/// </param>
		/// <param name="desired_channels">
		///   Optional argument
		/// </param>
		/// <param name="desired_samples">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   audio:
		///   sample_rate:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output audio, TF_Output sample_rate) DecodeWav (TF_Output contents, long? desired_channels = null, long? desired_samples = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodeWav", MakeName ("DecodeWav", operName));
			c_api.TF_AddInput(desc, contents);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (desired_channels.HasValue)
				c_api.TF_SetAttrInt (desc, "desired_channels", desired_channels.Value);
			
			if (desired_samples.HasValue)
				c_api.TF_SetAttrInt (desc, "desired_samples", desired_samples.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var audio = new TF_Output (op, _idx++);
			var sample_rate = new TF_Output (op, _idx++);
			return (audio, sample_rate);
		}

		/// <summary>
		/// </summary>
		/// <param name="sparse_indices">
		/// </param>
		/// <param name="output_shape">
		/// </param>
		/// <param name="sparse_values">
		/// </param>
		/// <param name="default_value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseToDense'.
		/// </param>
		/// <param name="validate_indices">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseToDense (TF_Output sparse_indices, TF_Output output_shape, TF_Output sparse_values, TF_Output default_value, bool? validate_indices = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseToDense", MakeName ("SparseToDense", operName));
			c_api.TF_AddInput(desc, sparse_indices);
			c_api.TF_AddInput(desc, output_shape);
			c_api.TF_AddInput(desc, sparse_values);
			c_api.TF_AddInput(desc, default_value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (validate_indices.HasValue)
				c_api.TF_SetAttrBool (desc, "validate_indices", Convert.ToByte(validate_indices.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var dense = new TF_Output (op, _idx++);
			return dense;
		}

		/// <summary>
		/// </summary>
		/// <param name="audio">
		/// </param>
		/// <param name="sample_rate">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodeWav'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output EncodeWav (TF_Output audio, TF_Output sample_rate, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EncodeWav", MakeName ("EncodeWav", operName));
			c_api.TF_AddInput(desc, audio);
			c_api.TF_AddInput(desc, sample_rate);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var contents = new TF_Output (op, _idx++);
			return contents;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AudioSpectrogram'.
		/// </param>
		/// <param name="magnitude_squared">
		///   Optional argument
		/// </param>
		/// <param name="window_size">
		/// </param>
		/// <param name="stride">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AudioSpectrogram (TF_Output input, long window_size, long stride, bool? magnitude_squared = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AudioSpectrogram", MakeName ("AudioSpectrogram", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "window_size", window_size);
			c_api.TF_SetAttrInt (desc, "stride", stride);
			if (magnitude_squared.HasValue)
				c_api.TF_SetAttrBool (desc, "magnitude_squared", Convert.ToByte(magnitude_squared.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var spectrogram = new TF_Output (op, _idx++);
			return spectrogram;
		}

		/// <summary>
		/// </summary>
		/// <param name="weights">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SdcaShrinkL1'.
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation SdcaShrinkL1 (TF_Output[] weights, float l1, float l2, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SdcaShrinkL1", MakeName ("SdcaShrinkL1", operName));
			c_api.TF_AddInputList(desc, weights[0], weights.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFloat (desc, "l1", l1);
			c_api.TF_SetAttrFloat (desc, "l2", l2);
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="spectrogram">
		/// </param>
		/// <param name="sample_rate">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Mfcc'.
		/// </param>
		/// <param name="upper_frequency_limit">
		///   Optional argument
		/// </param>
		/// <param name="lower_frequency_limit">
		///   Optional argument
		/// </param>
		/// <param name="filterbank_channel_count">
		///   Optional argument
		/// </param>
		/// <param name="dct_coefficient_count">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Mfcc (TF_Output spectrogram, TF_Output sample_rate, float? upper_frequency_limit = null, float? lower_frequency_limit = null, long? filterbank_channel_count = null, long? dct_coefficient_count = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Mfcc", MakeName ("Mfcc", operName));
			c_api.TF_AddInput(desc, spectrogram);
			c_api.TF_AddInput(desc, sample_rate);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (upper_frequency_limit.HasValue)
				c_api.TF_SetAttrFloat (desc, "upper_frequency_limit", upper_frequency_limit.Value);
			
			if (lower_frequency_limit.HasValue)
				c_api.TF_SetAttrFloat (desc, "lower_frequency_limit", lower_frequency_limit.Value);
			
			if (filterbank_channel_count.HasValue)
				c_api.TF_SetAttrInt (desc, "filterbank_channel_count", filterbank_channel_count.Value);
			
			if (dct_coefficient_count.HasValue)
				c_api.TF_SetAttrInt (desc, "dct_coefficient_count", dct_coefficient_count.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="orig_input_tensor_shape">
		/// </param>
		/// <param name="out_backprop">
		/// </param>
		/// <param name="row_pooling_sequence">
		/// </param>
		/// <param name="col_pooling_sequence">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FractionalAvgPoolGrad'.
		/// </param>
		/// <param name="overlapping">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FractionalAvgPoolGrad (TF_Output orig_input_tensor_shape, TF_Output out_backprop, TF_Output row_pooling_sequence, TF_Output col_pooling_sequence, bool? overlapping = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FractionalAvgPoolGrad", MakeName ("FractionalAvgPoolGrad", operName));
			c_api.TF_AddInput(desc, orig_input_tensor_shape);
			c_api.TF_AddInput(desc, out_backprop);
			c_api.TF_AddInput(desc, row_pooling_sequence);
			c_api.TF_AddInput(desc, col_pooling_sequence);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (overlapping.HasValue)
				c_api.TF_SetAttrBool (desc, "overlapping", Convert.ToByte(overlapping.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IFFT3D'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IFFT3D (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IFFT3D", MakeName ("IFFT3D", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SerializeIterator'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SerializeIterator (TF_Output resource_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SerializeIterator", MakeName ("SerializeIterator", operName));
			c_api.TF_AddInput(desc, resource_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var serialized = new TF_Output (op, _idx++);
			return serialized;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="algorithm">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatefulStandardNormalV2'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StatefulStandardNormalV2 (TF_Output resource, TF_Output algorithm, TF_Output shape, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatefulStandardNormalV2", MakeName ("StatefulStandardNormalV2", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, algorithm);
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="batch_size">
		/// </param>
		/// <param name="padded_shapes">
		/// </param>
		/// <param name="padding_values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PaddedBatchDataset'.
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output PaddedBatchDataset (TF_Output input_dataset, TF_Output batch_size, TF_Output[] padded_shapes, TF_Output[] padding_values, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PaddedBatchDataset", MakeName ("PaddedBatchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, batch_size);
			c_api.TF_AddInputList(desc, padded_shapes[0], padded_shapes.Length);
			c_api.TF_AddInputList(desc, padding_values[0], padding_values.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="y">
		/// </param>
		/// <param name="dy">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RsqrtGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RsqrtGrad (TF_Output y, TF_Output dy, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RsqrtGrad", MakeName ("RsqrtGrad", operName));
			c_api.TF_AddInput(desc, y);
			c_api.TF_AddInput(desc, dy);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="indices">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="dense_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseTensorSliceDataset'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseTensorSliceDataset (TF_Output indices, TF_Output values, TF_Output dense_shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseTensorSliceDataset", MakeName ("SparseTensorSliceDataset", operName));
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, values);
			c_api.TF_AddInput(desc, dense_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="predictions">
		/// </param>
		/// <param name="targets">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InTopK'.
		/// </param>
		/// <param name="k">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output InTopK (TF_Output predictions, TF_Output targets, long k, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InTopK", MakeName ("InTopK", operName));
			c_api.TF_AddInput(desc, predictions);
			c_api.TF_AddInput(desc, targets);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "k", k);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var precision = new TF_Output (op, _idx++);
			return precision;
		}

		/// <summary>
		/// </summary>
		/// <param name="batched_tensor">
		/// </param>
		/// <param name="batch_index">
		/// </param>
		/// <param name="id">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Unbatch'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="timeout_micros">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Unbatch (TF_Output batched_tensor, TF_Output batch_index, TF_Output id, long timeout_micros, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Unbatch", MakeName ("Unbatch", operName));
			c_api.TF_AddInput(desc, batched_tensor);
			c_api.TF_AddInput(desc, batch_index);
			c_api.TF_AddInput(desc, id);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "timeout_micros", timeout_micros);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var unbatched_tensor = new TF_Output (op, _idx++);
			return unbatched_tensor;
		}

		/// <summary>
		/// </summary>
		/// <param name="original_input">
		/// </param>
		/// <param name="batch_index">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="id">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnbatchGrad'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output UnbatchGrad (TF_Output original_input, TF_Output batch_index, TF_Output grad, TF_Output id, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnbatchGrad", MakeName ("UnbatchGrad", operName));
			c_api.TF_AddInput(desc, original_input);
			c_api.TF_AddInput(desc, batch_index);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, id);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var batched_grad = new TF_Output (op, _idx++);
			return batched_grad;
		}

		/// <summary>
		/// </summary>
		/// <param name="tree_ensemble_handle">
		/// </param>
		/// <param name="mean_gradients">
		/// </param>
		/// <param name="mean_hessians">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesCenterBias'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BoostedTreesCenterBias (TF_Output tree_ensemble_handle, TF_Output mean_gradients, TF_Output mean_hessians, TF_Output l1, TF_Output l2, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesCenterBias", MakeName ("BoostedTreesCenterBias", operName));
			c_api.TF_AddInput(desc, tree_ensemble_handle);
			c_api.TF_AddInput(desc, mean_gradients);
			c_api.TF_AddInput(desc, mean_hessians);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var continue_centering = new TF_Output (op, _idx++);
			return continue_centering;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyAdagrad'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <param name="update_slots">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseApplyAdagrad (TF_Output var, TF_Output accum, TF_Output lr, TF_Output grad, TF_Output indices, bool? use_locking = null, bool? update_slots = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyAdagrad", MakeName ("SparseApplyAdagrad", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (update_slots.HasValue)
				c_api.TF_SetAttrBool (desc, "update_slots", Convert.ToByte(update_slots.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Invert'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Invert (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Invert", MakeName ("Invert", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="table_handle">
		/// </param>
		/// <param name="keys">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableRemoveV2'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LookupTableRemoveV2 (TF_Output table_handle, TF_Output keys, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableRemoveV2", MakeName ("LookupTableRemoveV2", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, keys);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PopulationCount'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output PopulationCount (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PopulationCount", MakeName ("PopulationCount", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArray'.
		/// </param>
		/// <param name="dynamic_size">
		///   Optional argument
		/// </param>
		/// <param name="clear_after_read">
		///   Optional argument
		/// </param>
		/// <param name="tensor_array_name">
		///   Optional argument
		/// </param>
		/// <param name="element_shape">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArray (TF_Output size, TF_DataType dtype, bool? dynamic_size = null, bool? clear_after_read = null, string tensor_array_name = null, long[] element_shape = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArray", MakeName ("TensorArray", operName));
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (dynamic_size.HasValue)
				c_api.TF_SetAttrBool (desc, "dynamic_size", Convert.ToByte(dynamic_size.Value));
			
			if (clear_after_read.HasValue)
				c_api.TF_SetAttrBool (desc, "clear_after_read", Convert.ToByte(clear_after_read.Value));
			
			if (tensor_array_name != null)
				c_api.TF_SetAttrString (desc, "tensor_array_name", tensor_array_name);
			
			if (element_shape != null)
				c_api.TF_SetAttrShape (desc, "element_shape", ref element_shape[0], element_shape.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BitwiseAnd'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BitwiseAnd (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BitwiseAnd", MakeName ("BitwiseAnd", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BitwiseXor'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BitwiseXor (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BitwiseXor", MakeName ("BitwiseXor", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="tree_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorForestTreeSize'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorForestTreeSize (TF_Output tree_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorForestTreeSize", MakeName ("TensorForestTreeSize", operName));
			c_api.TF_AddInput(desc, tree_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var tree_size = new TF_Output (op, _idx++);
			return tree_size;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LeftShift'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LeftShift (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LeftShift", MakeName ("LeftShift", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WrapDatasetVariant'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output WrapDatasetVariant (TF_Output input_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WrapDatasetVariant", MakeName ("WrapDatasetVariant", operName));
			c_api.TF_AddInput(desc, input_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			return output_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Add'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Add (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Add", MakeName ("Add", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesEnsembleResourceHandleOp'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BoostedTreesEnsembleResourceHandleOp (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesEnsembleResourceHandleOp", MakeName ("BoostedTreesEnsembleResourceHandleOp", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var resource = new TF_Output (op, _idx++);
			return resource;
		}

		/// <summary>
		/// </summary>
		/// <param name="tree_ensemble_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IsBoostedTreesEnsembleInitialized'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IsBoostedTreesEnsembleInitialized (TF_Output tree_ensemble_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IsBoostedTreesEnsembleInitialized", MakeName ("IsBoostedTreesEnsembleInitialized", operName));
			c_api.TF_AddInput(desc, tree_ensemble_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var is_initialized = new TF_Output (op, _idx++);
			return is_initialized;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceAccumulatorNumAccumulated'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ResourceAccumulatorNumAccumulated (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceAccumulatorNumAccumulated", MakeName ("ResourceAccumulatorNumAccumulated", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var num_accumulated = new TF_Output (op, _idx++);
			return num_accumulated;
		}

		/// <summary>
		/// </summary>
		/// <param name="out_backprop">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BiasAddGrad'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BiasAddGrad (TF_Output out_backprop, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BiasAddGrad", MakeName ("BiasAddGrad", operName));
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="buffer_size">
		/// </param>
		/// <param name="seed">
		/// </param>
		/// <param name="seed2">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ShuffleDataset'.
		/// </param>
		/// <param name="reshuffle_each_iteration">
		///   Optional argument
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ShuffleDataset (TF_Output input_dataset, TF_Output buffer_size, TF_Output seed, TF_Output seed2, TF_DataType[] output_types, long[][] output_shapes, bool? reshuffle_each_iteration = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ShuffleDataset", MakeName ("ShuffleDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, buffer_size);
			c_api.TF_AddInput(desc, seed);
			c_api.TF_AddInput(desc, seed2);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (reshuffle_each_iteration.HasValue)
				c_api.TF_SetAttrBool (desc, "reshuffle_each_iteration", Convert.ToByte(reshuffle_each_iteration.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGather'.
		/// </param>
		/// <param name="element_shape">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayGather (TF_Output handle, TF_Output indices, TF_Output flow_in, TF_DataType dtype, long[] element_shape = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayGather", MakeName ("TensorArrayGather", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (element_shape != null)
				c_api.TF_SetAttrShape (desc, "element_shape", ref element_shape[0], element_shape.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			return value;
		}

		/// <summary>
		/// </summary>
		/// <param name="node_id_range">
		/// </param>
		/// <param name="stats_summary">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="tree_complexity">
		/// </param>
		/// <param name="min_node_weight">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesCalculateBestFeatureSplit'.
		/// </param>
		/// <param name="split_type">
		///   Optional argument
		/// </param>
		/// <param name="logits_dimension">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   node_ids:
		///   gains:
		///   feature_dimensions:
		///   thresholds:
		///   left_node_contribs:
		///   right_node_contribs:
		///   split_with_default_directions:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output node_ids, TF_Output gains, TF_Output feature_dimensions, TF_Output thresholds, TF_Output left_node_contribs, TF_Output right_node_contribs, TF_Output split_with_default_directions) BoostedTreesCalculateBestFeatureSplit (TF_Output node_id_range, TF_Output stats_summary, TF_Output l1, TF_Output l2, TF_Output tree_complexity, TF_Output min_node_weight, long logits_dimension, string split_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesCalculateBestFeatureSplit", MakeName ("BoostedTreesCalculateBestFeatureSplit", operName));
			c_api.TF_AddInput(desc, node_id_range);
			c_api.TF_AddInput(desc, stats_summary);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, tree_complexity);
			c_api.TF_AddInput(desc, min_node_weight);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "logits_dimension", logits_dimension);
			if (split_type != null)
				c_api.TF_SetAttrString (desc, "split_type", split_type);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var node_ids = new TF_Output (op, _idx++);
			var gains = new TF_Output (op, _idx++);
			var feature_dimensions = new TF_Output (op, _idx++);
			var thresholds = new TF_Output (op, _idx++);
			var left_node_contribs = new TF_Output (op, _idx++);
			var right_node_contribs = new TF_Output (op, _idx++);
			var split_with_default_directions = new TF_Output (op, _idx++);
			return (node_ids, gains, feature_dimensions, thresholds, left_node_contribs, right_node_contribs, split_with_default_directions);
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="keys">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BarrierInsertMany'.
		/// </param>
		/// <param name="component_index">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation BarrierInsertMany (TF_Output handle, TF_Output keys, TF_Output values, long component_index, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BarrierInsertMany", MakeName ("BarrierInsertMany", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, keys);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "component_index", component_index);
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="node_id_range">
		/// </param>
		/// <param name="stats_summary_indices">
		/// </param>
		/// <param name="stats_summary_values">
		/// </param>
		/// <param name="stats_summary_shape">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="tree_complexity">
		/// </param>
		/// <param name="min_node_weight">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesSparseCalculateBestFeatureSplit'.
		/// </param>
		/// <param name="split_type">
		///   Optional argument
		/// </param>
		/// <param name="logits_dimension">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   node_ids:
		///   gains:
		///   feature_dimensions:
		///   thresholds:
		///   left_node_contribs:
		///   right_node_contribs:
		///   split_with_default_directions:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output node_ids, TF_Output gains, TF_Output feature_dimensions, TF_Output thresholds, TF_Output left_node_contribs, TF_Output right_node_contribs, TF_Output split_with_default_directions) BoostedTreesSparseCalculateBestFeatureSplit (TF_Output node_id_range, TF_Output stats_summary_indices, TF_Output stats_summary_values, TF_Output stats_summary_shape, TF_Output l1, TF_Output l2, TF_Output tree_complexity, TF_Output min_node_weight, long logits_dimension, string split_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesSparseCalculateBestFeatureSplit", MakeName ("BoostedTreesSparseCalculateBestFeatureSplit", operName));
			c_api.TF_AddInput(desc, node_id_range);
			c_api.TF_AddInput(desc, stats_summary_indices);
			c_api.TF_AddInput(desc, stats_summary_values);
			c_api.TF_AddInput(desc, stats_summary_shape);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, tree_complexity);
			c_api.TF_AddInput(desc, min_node_weight);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "logits_dimension", logits_dimension);
			if (split_type != null)
				c_api.TF_SetAttrString (desc, "split_type", split_type);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var node_ids = new TF_Output (op, _idx++);
			var gains = new TF_Output (op, _idx++);
			var feature_dimensions = new TF_Output (op, _idx++);
			var thresholds = new TF_Output (op, _idx++);
			var left_node_contribs = new TF_Output (op, _idx++);
			var right_node_contribs = new TF_Output (op, _idx++);
			var split_with_default_directions = new TF_Output (op, _idx++);
			return (node_ids, gains, feature_dimensions, thresholds, left_node_contribs, right_node_contribs, split_with_default_directions);
		}

		/// <summary>
		/// </summary>
		/// <param name="tree_ensemble_handle">
		/// </param>
		/// <param name="stamp_token">
		/// </param>
		/// <param name="tree_ensemble_serialized">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesCreateEnsemble'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation BoostedTreesCreateEnsemble (TF_Output tree_ensemble_handle, TF_Output stamp_token, TF_Output tree_ensemble_serialized, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesCreateEnsemble", MakeName ("BoostedTreesCreateEnsemble", operName));
			c_api.TF_AddInput(desc, tree_ensemble_handle);
			c_api.TF_AddInput(desc, stamp_token);
			c_api.TF_AddInput(desc, tree_ensemble_serialized);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="tree_ensemble_handle">
		/// </param>
		/// <param name="stamp_token">
		/// </param>
		/// <param name="tree_ensemble_serialized">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesDeserializeEnsemble'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation BoostedTreesDeserializeEnsemble (TF_Output tree_ensemble_handle, TF_Output stamp_token, TF_Output tree_ensemble_serialized, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesDeserializeEnsemble", MakeName ("BoostedTreesDeserializeEnsemble", operName));
			c_api.TF_AddInput(desc, tree_ensemble_handle);
			c_api.TF_AddInput(desc, stamp_token);
			c_api.TF_AddInput(desc, tree_ensemble_serialized);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="value">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BiasAddV1'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BiasAddV1 (TF_Output value, TF_Output bias, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BiasAddV1", MakeName ("BiasAddV1", operName));
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, bias);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceConditionalAccumulator'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="reduction_type">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ResourceConditionalAccumulator (TF_DataType dtype, long[] shape, string container = null, string shared_name = null, string reduction_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceConditionalAccumulator", MakeName ("ResourceConditionalAccumulator", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (reduction_type != null)
				c_api.TF_SetAttrString (desc, "reduction_type", reduction_type);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="tree_ensemble_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesGetEnsembleStates'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   stamp_token:
		///   num_trees:
		///   num_finalized_trees:
		///   num_attempted_layers:
		///   last_layer_nodes_range:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output stamp_token, TF_Output num_trees, TF_Output num_finalized_trees, TF_Output num_attempted_layers, TF_Output last_layer_nodes_range) BoostedTreesGetEnsembleStates (TF_Output tree_ensemble_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesGetEnsembleStates", MakeName ("BoostedTreesGetEnsembleStates", operName));
			c_api.TF_AddInput(desc, tree_ensemble_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var stamp_token = new TF_Output (op, _idx++);
			var num_trees = new TF_Output (op, _idx++);
			var num_finalized_trees = new TF_Output (op, _idx++);
			var num_attempted_layers = new TF_Output (op, _idx++);
			var last_layer_nodes_range = new TF_Output (op, _idx++);
			return (stamp_token, num_trees, num_finalized_trees, num_attempted_layers, last_layer_nodes_range);
		}

		/// <summary>
		/// </summary>
		/// <param name="shape">
		/// </param>
		/// <param name="alpha">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomGamma'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RandomGamma (TF_Output shape, TF_Output alpha, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomGamma", MakeName ("RandomGamma", operName));
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, alpha);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="patterns">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalMatchingFilesDataset'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalMatchingFilesDataset (TF_Output patterns, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalMatchingFilesDataset", MakeName ("ExperimentalMatchingFilesDataset", operName));
			c_api.TF_AddInput(desc, patterns);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WholeFileReader'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output WholeFileReader (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WholeFileReader", MakeName ("WholeFileReader", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterMul'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ScatterMul (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterMul", MakeName ("ScatterMul", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NonSerializableDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output NonSerializableDataset (TF_Output input_dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NonSerializableDataset", MakeName ("NonSerializableDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="w_in">
		/// </param>
		/// <param name="w_out">
		/// </param>
		/// <param name="examples">
		/// </param>
		/// <param name="labels">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NegTrain'.
		/// </param>
		/// <param name="vocab_count">
		/// </param>
		/// <param name="num_negative_samples">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation NegTrain (TF_Output w_in, TF_Output w_out, TF_Output examples, TF_Output labels, TF_Output lr, long[] vocab_count, long num_negative_samples, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NegTrain", MakeName ("NegTrain", operName));
			c_api.TF_AddInput(desc, w_in);
			c_api.TF_AddInput(desc, w_out);
			c_api.TF_AddInput(desc, examples);
			c_api.TF_AddInput(desc, labels);
			c_api.TF_AddInput(desc, lr);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "vocab_count", ref vocab_count[0], vocab_count.Length);
			c_api.TF_SetAttrInt (desc, "num_negative_samples", num_negative_samples);
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="node_ids">
		/// </param>
		/// <param name="gradients">
		/// </param>
		/// <param name="hessians">
		/// </param>
		/// <param name="bucketized_features_list">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesMakeStatsSummary'.
		/// </param>
		/// <param name="max_splits">
		/// </param>
		/// <param name="num_buckets">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BoostedTreesMakeStatsSummary (TF_Output node_ids, TF_Output gradients, TF_Output hessians, TF_Output[] bucketized_features_list, long max_splits, long num_buckets, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesMakeStatsSummary", MakeName ("BoostedTreesMakeStatsSummary", operName));
			c_api.TF_AddInput(desc, node_ids);
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, hessians);
			c_api.TF_AddInputList(desc, bucketized_features_list[0], bucketized_features_list.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "max_splits", max_splits);
			c_api.TF_SetAttrInt (desc, "num_buckets", num_buckets);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var stats_summary = new TF_Output (op, _idx++);
			return stats_summary;
		}

		/// <summary>
		/// </summary>
		/// <param name="node_ids">
		/// </param>
		/// <param name="gradients">
		/// </param>
		/// <param name="hessians">
		/// </param>
		/// <param name="feature_indices">
		/// </param>
		/// <param name="feature_values">
		/// </param>
		/// <param name="feature_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesSparseAggregateStats'.
		/// </param>
		/// <param name="max_splits">
		/// </param>
		/// <param name="num_buckets">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   stats_summary_indices:
		///   stats_summary_values:
		///   stats_summary_shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output stats_summary_indices, TF_Output stats_summary_values, TF_Output stats_summary_shape) BoostedTreesSparseAggregateStats (TF_Output node_ids, TF_Output gradients, TF_Output hessians, TF_Output feature_indices, TF_Output feature_values, TF_Output feature_shape, long max_splits, long num_buckets, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesSparseAggregateStats", MakeName ("BoostedTreesSparseAggregateStats", operName));
			c_api.TF_AddInput(desc, node_ids);
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, hessians);
			c_api.TF_AddInput(desc, feature_indices);
			c_api.TF_AddInput(desc, feature_values);
			c_api.TF_AddInput(desc, feature_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "max_splits", max_splits);
			c_api.TF_SetAttrInt (desc, "num_buckets", num_buckets);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var stats_summary_indices = new TF_Output (op, _idx++);
			var stats_summary_values = new TF_Output (op, _idx++);
			var stats_summary_shape = new TF_Output (op, _idx++);
			return (stats_summary_indices, stats_summary_values, stats_summary_shape);
		}

		/// <summary>
		/// </summary>
		/// <param name="tree_ensemble_handle">
		/// </param>
		/// <param name="bucketized_features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesPredict'.
		/// </param>
		/// <param name="logits_dimension">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BoostedTreesPredict (TF_Output tree_ensemble_handle, TF_Output[] bucketized_features, long logits_dimension, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesPredict", MakeName ("BoostedTreesPredict", operName));
			c_api.TF_AddInput(desc, tree_ensemble_handle);
			c_api.TF_AddInputList(desc, bucketized_features[0], bucketized_features.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "logits_dimension", logits_dimension);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var logits = new TF_Output (op, _idx++);
			return logits;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyProximalAdagrad'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ApplyProximalAdagrad (TF_Output var, TF_Output accum, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyProximalAdagrad", MakeName ("ApplyProximalAdagrad", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="tree_ensemble_handle">
		/// </param>
		/// <param name="bucketized_features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesExampleDebugOutputs'.
		/// </param>
		/// <param name="logits_dimension">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BoostedTreesExampleDebugOutputs (TF_Output tree_ensemble_handle, TF_Output[] bucketized_features, long logits_dimension, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesExampleDebugOutputs", MakeName ("BoostedTreesExampleDebugOutputs", operName));
			c_api.TF_AddInput(desc, tree_ensemble_handle);
			c_api.TF_AddInputList(desc, bucketized_features[0], bucketized_features.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "logits_dimension", logits_dimension);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var examples_debug_outputs_serialized = new TF_Output (op, _idx++);
			return examples_debug_outputs_serialized;
		}

		/// <summary>
		/// </summary>
		/// <param name="t">
		/// </param>
		/// <param name="clip_value_min">
		/// </param>
		/// <param name="clip_value_max">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ClipByValue'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ClipByValue (TF_Output t, TF_Output clip_value_min, TF_Output clip_value_max, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ClipByValue", MakeName ("ClipByValue", operName));
			c_api.TF_AddInput(desc, t);
			c_api.TF_AddInput(desc, clip_value_min);
			c_api.TF_AddInput(desc, clip_value_max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="y">
		/// </param>
		/// <param name="dy">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SigmoidGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SigmoidGrad (TF_Output y, TF_Output dy, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SigmoidGrad", MakeName ("SigmoidGrad", operName));
			c_api.TF_AddInput(desc, y);
			c_api.TF_AddInput(desc, dy);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="accumulators">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingAdagradParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LoadTPUEmbeddingAdagradParameters (TF_Output parameters, TF_Output accumulators, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingAdagradParameters", MakeName ("LoadTPUEmbeddingAdagradParameters", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, accumulators);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="tree_ensemble_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesSerializeEnsemble'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   stamp_token:
		///   tree_ensemble_serialized:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output stamp_token, TF_Output tree_ensemble_serialized) BoostedTreesSerializeEnsemble (TF_Output tree_ensemble_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesSerializeEnsemble", MakeName ("BoostedTreesSerializeEnsemble", operName));
			c_api.TF_AddInput(desc, tree_ensemble_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var stamp_token = new TF_Output (op, _idx++);
			var tree_ensemble_serialized = new TF_Output (op, _idx++);
			return (stamp_token, tree_ensemble_serialized);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Real'.
		/// </param>
		/// <param name="Tout">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Real (TF_Output input, TF_DataType? Tout = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Real", MakeName ("Real", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Tout.HasValue)
				c_api.TF_SetAttrType (desc, "Tout", Tout.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_sizes">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="out_backprop">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DepthwiseConv2dNativeBackpropInput'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DepthwiseConv2dNativeBackpropInput (TF_Output input_sizes, TF_Output filter, TF_Output out_backprop, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DepthwiseConv2dNativeBackpropInput", MakeName ("DepthwiseConv2dNativeBackpropInput", operName));
			c_api.TF_AddInput(desc, input_sizes);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="contents">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeJpeg'.
		/// </param>
		/// <param name="channels">
		///   Optional argument
		/// </param>
		/// <param name="ratio">
		///   Optional argument
		/// </param>
		/// <param name="fancy_upscaling">
		///   Optional argument
		/// </param>
		/// <param name="try_recover_truncated">
		///   Optional argument
		/// </param>
		/// <param name="acceptable_fraction">
		///   Optional argument
		/// </param>
		/// <param name="dct_method">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DecodeJpeg (TF_Output contents, long? channels = null, long? ratio = null, bool? fancy_upscaling = null, bool? try_recover_truncated = null, float? acceptable_fraction = null, string dct_method = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodeJpeg", MakeName ("DecodeJpeg", operName));
			c_api.TF_AddInput(desc, contents);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (channels.HasValue)
				c_api.TF_SetAttrInt (desc, "channels", channels.Value);
			
			if (ratio.HasValue)
				c_api.TF_SetAttrInt (desc, "ratio", ratio.Value);
			
			if (fancy_upscaling.HasValue)
				c_api.TF_SetAttrBool (desc, "fancy_upscaling", Convert.ToByte(fancy_upscaling.Value));
			
			if (try_recover_truncated.HasValue)
				c_api.TF_SetAttrBool (desc, "try_recover_truncated", Convert.ToByte(try_recover_truncated.Value));
			
			if (acceptable_fraction.HasValue)
				c_api.TF_SetAttrFloat (desc, "acceptable_fraction", acceptable_fraction.Value);
			
			if (dct_method != null)
				c_api.TF_SetAttrString (desc, "dct_method", dct_method);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var image = new TF_Output (op, _idx++);
			return image;
		}

		/// <summary>
		/// </summary>
		/// <param name="address">
		/// </param>
		/// <param name="method">
		/// </param>
		/// <param name="request">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TryRpc'.
		/// </param>
		/// <param name="protocol">
		///   Optional argument
		/// </param>
		/// <param name="fail_fast">
		///   Optional argument
		/// </param>
		/// <param name="timeout_in_ms">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   response:
		///   status_code:
		///   status_message:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output response, TF_Output status_code, TF_Output status_message) TryRpc (TF_Output address, TF_Output method, TF_Output request, string protocol = null, bool? fail_fast = null, long? timeout_in_ms = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TryRpc", MakeName ("TryRpc", operName));
			c_api.TF_AddInput(desc, address);
			c_api.TF_AddInput(desc, method);
			c_api.TF_AddInput(desc, request);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (protocol != null)
				c_api.TF_SetAttrString (desc, "protocol", protocol);
			
			if (fail_fast.HasValue)
				c_api.TF_SetAttrBool (desc, "fail_fast", Convert.ToByte(fail_fast.Value));
			
			if (timeout_in_ms.HasValue)
				c_api.TF_SetAttrInt (desc, "timeout_in_ms", timeout_in_ms.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var response = new TF_Output (op, _idx++);
			var status_code = new TF_Output (op, _idx++);
			var status_message = new TF_Output (op, _idx++);
			return (response, status_code, status_message);
		}

		/// <summary>
		/// </summary>
		/// <param name="tree_ensemble_handle">
		/// </param>
		/// <param name="cached_tree_ids">
		/// </param>
		/// <param name="cached_node_ids">
		/// </param>
		/// <param name="bucketized_features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesTrainingPredict'.
		/// </param>
		/// <param name="logits_dimension">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   partial_logits:
		///   tree_ids:
		///   node_ids:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output partial_logits, TF_Output tree_ids, TF_Output node_ids) BoostedTreesTrainingPredict (TF_Output tree_ensemble_handle, TF_Output cached_tree_ids, TF_Output cached_node_ids, TF_Output[] bucketized_features, long logits_dimension, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesTrainingPredict", MakeName ("BoostedTreesTrainingPredict", operName));
			c_api.TF_AddInput(desc, tree_ensemble_handle);
			c_api.TF_AddInput(desc, cached_tree_ids);
			c_api.TF_AddInput(desc, cached_node_ids);
			c_api.TF_AddInputList(desc, bucketized_features[0], bucketized_features.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "logits_dimension", logits_dimension);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var partial_logits = new TF_Output (op, _idx++);
			var tree_ids = new TF_Output (op, _idx++);
			var node_ids = new TF_Output (op, _idx++);
			return (partial_logits, tree_ids, node_ids);
		}

		/// <summary>
		/// </summary>
		/// <param name="tree_ensemble_handle">
		/// </param>
		/// <param name="feature_ids">
		/// </param>
		/// <param name="node_ids">
		/// </param>
		/// <param name="gains">
		/// </param>
		/// <param name="thresholds">
		/// </param>
		/// <param name="left_node_contribs">
		/// </param>
		/// <param name="right_node_contribs">
		/// </param>
		/// <param name="max_depth">
		/// </param>
		/// <param name="learning_rate">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesUpdateEnsemble'.
		/// </param>
		/// <param name="pruning_mode">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation BoostedTreesUpdateEnsemble (TF_Output tree_ensemble_handle, TF_Output feature_ids, TF_Output[] node_ids, TF_Output[] gains, TF_Output[] thresholds, TF_Output[] left_node_contribs, TF_Output[] right_node_contribs, TF_Output max_depth, TF_Output learning_rate, long pruning_mode, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesUpdateEnsemble", MakeName ("BoostedTreesUpdateEnsemble", operName));
			c_api.TF_AddInput(desc, tree_ensemble_handle);
			c_api.TF_AddInput(desc, feature_ids);
			c_api.TF_AddInputList(desc, node_ids[0], node_ids.Length);
			c_api.TF_AddInputList(desc, gains[0], gains.Length);
			c_api.TF_AddInputList(desc, thresholds[0], thresholds.Length);
			c_api.TF_AddInputList(desc, left_node_contribs[0], left_node_contribs.Length);
			c_api.TF_AddInputList(desc, right_node_contribs[0], right_node_contribs.Length);
			c_api.TF_AddInput(desc, max_depth);
			c_api.TF_AddInput(desc, learning_rate);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "pruning_mode", pruning_mode);
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesQuantileStreamResourceHandleOp'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BoostedTreesQuantileStreamResourceHandleOp (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesQuantileStreamResourceHandleOp", MakeName ("BoostedTreesQuantileStreamResourceHandleOp", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var resource = new TF_Output (op, _idx++);
			return resource;
		}

		/// <summary>
		/// </summary>
		/// <param name="start">
		/// </param>
		/// <param name="stop">
		/// </param>
		/// <param name="step">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RangeDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RangeDataset (TF_Output start, TF_Output stop, TF_Output step, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RangeDataset", MakeName ("RangeDataset", operName));
			c_api.TF_AddInput(desc, start);
			c_api.TF_AddInput(desc, stop);
			c_api.TF_AddInput(desc, step);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterNdSub'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ScatterNdSub (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterNdSub", MakeName ("ScatterNdSub", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		/// </summary>
		/// <param name="quantile_stream_resource_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IsBoostedTreesQuantileStreamResourceInitialized'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IsBoostedTreesQuantileStreamResourceInitialized (TF_Output quantile_stream_resource_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IsBoostedTreesQuantileStreamResourceInitialized", MakeName ("IsBoostedTreesQuantileStreamResourceInitialized", operName));
			c_api.TF_AddInput(desc, quantile_stream_resource_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var is_initialized = new TF_Output (op, _idx++);
			return is_initialized;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LRN'.
		/// </param>
		/// <param name="depth_radius">
		///   Optional argument
		/// </param>
		/// <param name="bias">
		///   Optional argument
		/// </param>
		/// <param name="alpha">
		///   Optional argument
		/// </param>
		/// <param name="beta">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LRN (TF_Output input, long? depth_radius = null, float? bias = null, float? alpha = null, float? beta = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LRN", MakeName ("LRN", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (depth_radius.HasValue)
				c_api.TF_SetAttrInt (desc, "depth_radius", depth_radius.Value);
			
			if (bias.HasValue)
				c_api.TF_SetAttrFloat (desc, "bias", bias.Value);
			
			if (alpha.HasValue)
				c_api.TF_SetAttrFloat (desc, "alpha", alpha.Value);
			
			if (beta.HasValue)
				c_api.TF_SetAttrFloat (desc, "beta", beta.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="quantile_stream_resource_handle">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="num_streams">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesCreateQuantileStreamResource'.
		/// </param>
		/// <param name="max_elements">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation BoostedTreesCreateQuantileStreamResource (TF_Output quantile_stream_resource_handle, TF_Output epsilon, TF_Output num_streams, long? max_elements = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesCreateQuantileStreamResource", MakeName ("BoostedTreesCreateQuantileStreamResource", operName));
			c_api.TF_AddInput(desc, quantile_stream_resource_handle);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, num_streams);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (max_elements.HasValue)
				c_api.TF_SetAttrInt (desc, "max_elements", max_elements.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="quantile_stream_resource_handle">
		/// </param>
		/// <param name="num_buckets">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesQuantileStreamResourceFlush'.
		/// </param>
		/// <param name="generate_quantiles">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation BoostedTreesQuantileStreamResourceFlush (TF_Output quantile_stream_resource_handle, TF_Output num_buckets, bool? generate_quantiles = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesQuantileStreamResourceFlush", MakeName ("BoostedTreesQuantileStreamResourceFlush", operName));
			c_api.TF_AddInput(desc, quantile_stream_resource_handle);
			c_api.TF_AddInput(desc, num_buckets);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (generate_quantiles.HasValue)
				c_api.TF_SetAttrBool (desc, "generate_quantiles", Convert.ToByte(generate_quantiles.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="axis">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Cumprod'.
		/// </param>
		/// <param name="exclusive">
		///   Optional argument
		/// </param>
		/// <param name="reverse">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Cumprod (TF_Output x, TF_Output axis, bool? exclusive = null, bool? reverse = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Cumprod", MakeName ("Cumprod", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, axis);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (exclusive.HasValue)
				c_api.TF_SetAttrBool (desc, "exclusive", Convert.ToByte(exclusive.Value));
			
			if (reverse.HasValue)
				c_api.TF_SetAttrBool (desc, "reverse", Convert.ToByte(reverse.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorForestTreeResourceHandleOp'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorForestTreeResourceHandleOp (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorForestTreeResourceHandleOp", MakeName ("TensorForestTreeResourceHandleOp", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var resource = new TF_Output (op, _idx++);
			return resource;
		}

		/// <summary>
		/// </summary>
		/// <param name="table_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableSize'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LookupTableSize (TF_Output table_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableSize", MakeName ("LookupTableSize", operName));
			c_api.TF_AddInput(desc, table_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		/// </summary>
		/// <param name="tree_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorForestTreeIsInitializedOp'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorForestTreeIsInitializedOp (TF_Output tree_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorForestTreeIsInitializedOp", MakeName ("TensorForestTreeIsInitializedOp", operName));
			c_api.TF_AddInput(desc, tree_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var is_initialized = new TF_Output (op, _idx++);
			return is_initialized;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="count">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RepeatDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RepeatDataset (TF_Output input_dataset, TF_Output count, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RepeatDataset", MakeName ("RepeatDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, count);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StackPopV2'.
		/// </param>
		/// <param name="elem_type">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StackPopV2 (TF_Output handle, TF_DataType elem_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StackPopV2", MakeName ("StackPopV2", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "elem_type", elem_type);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var elem = new TF_Output (op, _idx++);
			return elem;
		}

		/// <summary>
		/// </summary>
		/// <param name="a">
		/// </param>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Igamma'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Igamma (TF_Output a, TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Igamma", MakeName ("Igamma", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="tree_handle">
		/// </param>
		/// <param name="tree_config">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorForestCreateTreeVariable'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation TensorForestCreateTreeVariable (TF_Output tree_handle, TF_Output tree_config, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorForestCreateTreeVariable", MakeName ("TensorForestCreateTreeVariable", operName));
			c_api.TF_AddInput(desc, tree_handle);
			c_api.TF_AddInput(desc, tree_config);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="tree_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorForestTreeSerialize'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorForestTreeSerialize (TF_Output tree_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorForestTreeSerialize", MakeName ("TensorForestTreeSerialize", operName));
			c_api.TF_AddInput(desc, tree_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var tree_config = new TF_Output (op, _idx++);
			return tree_config;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Erfc'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Erfc (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Erfc", MakeName ("Erfc", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="logits">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Softmax'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Softmax (TF_Output logits, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Softmax", MakeName ("Softmax", operName));
			c_api.TF_AddInput(desc, logits);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var softmax = new TF_Output (op, _idx++);
			return softmax;
		}

		/// <summary>
		/// </summary>
		/// <param name="y">
		/// </param>
		/// <param name="dy">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReciprocalGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ReciprocalGrad (TF_Output y, TF_Output dy, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReciprocalGrad", MakeName ("ReciprocalGrad", operName));
			c_api.TF_AddInput(desc, y);
			c_api.TF_AddInput(desc, dy);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="buffer_size">
		/// </param>
		/// <param name="seed">
		/// </param>
		/// <param name="seed2">
		/// </param>
		/// <param name="count">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ShuffleAndRepeatDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ShuffleAndRepeatDataset (TF_Output input_dataset, TF_Output buffer_size, TF_Output seed, TF_Output seed2, TF_Output count, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ShuffleAndRepeatDataset", MakeName ("ShuffleAndRepeatDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, buffer_size);
			c_api.TF_AddInput(desc, seed);
			c_api.TF_AddInput(desc, seed2);
			c_api.TF_AddInput(desc, count);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="images">
		/// </param>
		/// <param name="size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeArea'.
		/// </param>
		/// <param name="align_corners">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ResizeArea (TF_Output images, TF_Output size, bool? align_corners = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResizeArea", MakeName ("ResizeArea", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (align_corners.HasValue)
				c_api.TF_SetAttrBool (desc, "align_corners", Convert.ToByte(align_corners.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var resized_images = new TF_Output (op, _idx++);
			return resized_images;
		}

		/// <summary>
		/// </summary>
		/// <param name="tree_handle">
		/// </param>
		/// <param name="tree_config">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorForestTreeDeserialize'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation TensorForestTreeDeserialize (TF_Output tree_handle, TF_Output tree_config, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorForestTreeDeserialize", MakeName ("TensorForestTreeDeserialize", operName));
			c_api.TF_AddInput(desc, tree_handle);
			c_api.TF_AddInput(desc, tree_config);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="tree_handle">
		/// </param>
		/// <param name="dense_features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorForestTreePredict'.
		/// </param>
		/// <param name="logits_dimension">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorForestTreePredict (TF_Output tree_handle, TF_Output dense_features, long logits_dimension, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorForestTreePredict", MakeName ("TensorForestTreePredict", operName));
			c_api.TF_AddInput(desc, tree_handle);
			c_api.TF_AddInput(desc, dense_features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "logits_dimension", logits_dimension);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var logits = new TF_Output (op, _idx++);
			return logits;
		}

		/// <summary>
		/// </summary>
		/// <param name="true_classes">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LearnedUnigramCandidateSampler'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="num_true">
		/// </param>
		/// <param name="num_sampled">
		/// </param>
		/// <param name="unique">
		/// </param>
		/// <param name="range_max">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sampled_candidates:
		///   true_expected_count:
		///   sampled_expected_count:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output sampled_candidates, TF_Output true_expected_count, TF_Output sampled_expected_count) LearnedUnigramCandidateSampler (TF_Output true_classes, long num_true, long num_sampled, bool unique, long range_max, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LearnedUnigramCandidateSampler", MakeName ("LearnedUnigramCandidateSampler", operName));
			c_api.TF_AddInput(desc, true_classes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_true", num_true);
			c_api.TF_SetAttrInt (desc, "num_sampled", num_sampled);
			c_api.TF_SetAttrBool (desc, "unique", Convert.ToByte(unique));
			c_api.TF_SetAttrInt (desc, "range_max", range_max);
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var sampled_candidates = new TF_Output (op, _idx++);
			var true_expected_count = new TF_Output (op, _idx++);
			var sampled_expected_count = new TF_Output (op, _idx++);
			return (sampled_candidates, true_expected_count, sampled_expected_count);
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="ms">
		/// </param>
		/// <param name="mom">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="rho">
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyRMSProp'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseApplyRMSProp (TF_Output var, TF_Output ms, TF_Output mom, TF_Output lr, TF_Output rho, TF_Output momentum, TF_Output epsilon, TF_Output grad, TF_Output indices, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyRMSProp", MakeName ("SparseApplyRMSProp", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, momentum);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="another_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ConcatenateDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ConcatenateDataset (TF_Output input_dataset, TF_Output another_dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ConcatenateDataset", MakeName ("ConcatenateDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, another_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableHashTable'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="use_node_name_sharing">
		///   Optional argument
		/// </param>
		/// <param name="key_dtype">
		/// </param>
		/// <param name="value_dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MutableHashTable (TF_DataType key_dtype, TF_DataType value_dtype, string container = null, string shared_name = null, bool? use_node_name_sharing = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MutableHashTable", MakeName ("MutableHashTable", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "key_dtype", key_dtype);
			c_api.TF_SetAttrType (desc, "value_dtype", value_dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (use_node_name_sharing.HasValue)
				c_api.TF_SetAttrBool (desc, "use_node_name_sharing", Convert.ToByte(use_node_name_sharing.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var table_handle = new TF_Output (op, _idx++);
			return table_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="true_classes">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ThreadUnsafeUnigramCandidateSampler'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="num_true">
		/// </param>
		/// <param name="num_sampled">
		/// </param>
		/// <param name="unique">
		/// </param>
		/// <param name="range_max">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sampled_candidates:
		///   true_expected_count:
		///   sampled_expected_count:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output sampled_candidates, TF_Output true_expected_count, TF_Output sampled_expected_count) ThreadUnsafeUnigramCandidateSampler (TF_Output true_classes, long num_true, long num_sampled, bool unique, long range_max, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ThreadUnsafeUnigramCandidateSampler", MakeName ("ThreadUnsafeUnigramCandidateSampler", operName));
			c_api.TF_AddInput(desc, true_classes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_true", num_true);
			c_api.TF_SetAttrInt (desc, "num_sampled", num_sampled);
			c_api.TF_SetAttrBool (desc, "unique", Convert.ToByte(unique));
			c_api.TF_SetAttrInt (desc, "range_max", range_max);
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var sampled_candidates = new TF_Output (op, _idx++);
			var true_expected_count = new TF_Output (op, _idx++);
			var sampled_expected_count = new TF_Output (op, _idx++);
			return (sampled_candidates, true_expected_count, sampled_expected_count);
		}

		/// <summary>
		/// </summary>
		/// <param name="sparse_handles">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TakeManySparseFromTensorsMap'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sparse_indices:
		///   sparse_values:
		///   sparse_shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output sparse_indices, TF_Output sparse_values, TF_Output sparse_shape) TakeManySparseFromTensorsMap (TF_Output sparse_handles, TF_DataType dtype, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TakeManySparseFromTensorsMap", MakeName ("TakeManySparseFromTensorsMap", operName));
			c_api.TF_AddInput(desc, sparse_handles);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var sparse_indices = new TF_Output (op, _idx++);
			var sparse_values = new TF_Output (op, _idx++);
			var sparse_shape = new TF_Output (op, _idx++);
			return (sparse_indices, sparse_values, sparse_shape);
		}

		/// <summary>
		/// </summary>
		/// <param name="true_classes">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FixedUnigramCandidateSampler'.
		/// </param>
		/// <param name="vocab_file">
		///   Optional argument
		/// </param>
		/// <param name="distortion">
		///   Optional argument
		/// </param>
		/// <param name="num_reserved_ids">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		///   Optional argument
		/// </param>
		/// <param name="shard">
		///   Optional argument
		/// </param>
		/// <param name="unigrams">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="num_true">
		/// </param>
		/// <param name="num_sampled">
		/// </param>
		/// <param name="unique">
		/// </param>
		/// <param name="range_max">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sampled_candidates:
		///   true_expected_count:
		///   sampled_expected_count:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output sampled_candidates, TF_Output true_expected_count, TF_Output sampled_expected_count) FixedUnigramCandidateSampler (TF_Output true_classes, long num_true, long num_sampled, bool unique, long range_max, string vocab_file = null, float? distortion = null, long? num_reserved_ids = null, long? num_shards = null, long? shard = null, float[] unigrams = null, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FixedUnigramCandidateSampler", MakeName ("FixedUnigramCandidateSampler", operName));
			c_api.TF_AddInput(desc, true_classes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_true", num_true);
			c_api.TF_SetAttrInt (desc, "num_sampled", num_sampled);
			c_api.TF_SetAttrBool (desc, "unique", Convert.ToByte(unique));
			c_api.TF_SetAttrInt (desc, "range_max", range_max);
			if (vocab_file != null)
				c_api.TF_SetAttrString (desc, "vocab_file", vocab_file);
			
			if (distortion.HasValue)
				c_api.TF_SetAttrFloat (desc, "distortion", distortion.Value);
			
			if (num_reserved_ids.HasValue)
				c_api.TF_SetAttrInt (desc, "num_reserved_ids", num_reserved_ids.Value);
			
			if (num_shards.HasValue)
				c_api.TF_SetAttrInt (desc, "num_shards", num_shards.Value);
			
			if (shard.HasValue)
				c_api.TF_SetAttrInt (desc, "shard", shard.Value);
			
			if (unigrams != null)
				c_api.TF_SetAttrFloatList (desc, "unigrams", ref unigrams[0], unigrams.Length);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var sampled_candidates = new TF_Output (op, _idx++);
			var true_expected_count = new TF_Output (op, _idx++);
			var sampled_expected_count = new TF_Output (op, _idx++);
			return (sampled_candidates, true_expected_count, sampled_expected_count);
		}

		/// <summary>
		/// </summary>
		/// <param name="true_classes">
		/// </param>
		/// <param name="sampled_candidates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ComputeAccidentalHits'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="num_true">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   indices:
		///   ids:
		///   weights:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output indices, TF_Output ids, TF_Output weights) ComputeAccidentalHits (TF_Output true_classes, TF_Output sampled_candidates, long num_true, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ComputeAccidentalHits", MakeName ("ComputeAccidentalHits", operName));
			c_api.TF_AddInput(desc, true_classes);
			c_api.TF_AddInput(desc, sampled_candidates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_true", num_true);
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var indices = new TF_Output (op, _idx++);
			var ids = new TF_Output (op, _idx++);
			var weights = new TF_Output (op, _idx++);
			return (indices, ids, weights);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ControlTrigger'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ControlTrigger (string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ControlTrigger", MakeName ("ControlTrigger", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_indices">
		/// </param>
		/// <param name="input_values">
		/// </param>
		/// <param name="input_shape">
		/// </param>
		/// <param name="reduction_axes">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReduceSumSparse'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices:
		///   output_values:
		///   output_shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output_indices, TF_Output output_values, TF_Output output_shape) SparseReduceSumSparse (TF_Output input_indices, TF_Output input_values, TF_Output input_shape, TF_Output reduction_axes, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseReduceSumSparse", MakeName ("SparseReduceSumSparse", operName));
			c_api.TF_AddInput(desc, input_indices);
			c_api.TF_AddInput(desc, input_values);
			c_api.TF_AddInput(desc, input_shape);
			c_api.TF_AddInput(desc, reduction_axes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_indices = new TF_Output (op, _idx++);
			var output_values = new TF_Output (op, _idx++);
			var output_shape = new TF_Output (op, _idx++);
			return (output_indices, output_values, output_shape);
		}

		/// <summary>
		/// </summary>
		/// <param name="new_vocab_file">
		/// </param>
		/// <param name="old_vocab_file">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GenerateVocabRemapping'.
		/// </param>
		/// <param name="old_vocab_size">
		///   Optional argument
		/// </param>
		/// <param name="new_vocab_offset">
		/// </param>
		/// <param name="num_new_vocab">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   remapping:
		///   num_present:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output remapping, TF_Output num_present) GenerateVocabRemapping (TF_Output new_vocab_file, TF_Output old_vocab_file, long new_vocab_offset, long num_new_vocab, long? old_vocab_size = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GenerateVocabRemapping", MakeName ("GenerateVocabRemapping", operName));
			c_api.TF_AddInput(desc, new_vocab_file);
			c_api.TF_AddInput(desc, old_vocab_file);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "new_vocab_offset", new_vocab_offset);
			c_api.TF_SetAttrInt (desc, "num_new_vocab", num_new_vocab);
			if (old_vocab_size.HasValue)
				c_api.TF_SetAttrInt (desc, "old_vocab_size", old_vocab_size.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var remapping = new TF_Output (op, _idx++);
			var num_present = new TF_Output (op, _idx++);
			return (remapping, num_present);
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="shape_to_prepend">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGradWithShape'.
		/// </param>
		/// <param name="source">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   grad_handle:
		///   flow_out:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output grad_handle, TF_Output flow_out) TensorArrayGradWithShape (TF_Output handle, TF_Output flow_in, TF_Output shape_to_prepend, string source, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayGradWithShape", MakeName ("TensorArrayGradWithShape", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			c_api.TF_AddInput(desc, shape_to_prepend);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "source", source);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var grad_handle = new TF_Output (op, _idx++);
			var flow_out = new TF_Output (op, _idx++);
			return (grad_handle, flow_out);
		}

		/// <summary>
		/// </summary>
		/// <param name="ckpt_path">
		/// </param>
		/// <param name="old_tensor_name">
		/// </param>
		/// <param name="row_remapping">
		/// </param>
		/// <param name="col_remapping">
		/// </param>
		/// <param name="initializing_values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadAndRemapMatrix'.
		/// </param>
		/// <param name="max_rows_in_memory">
		///   Optional argument
		/// </param>
		/// <param name="num_rows">
		/// </param>
		/// <param name="num_cols">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LoadAndRemapMatrix (TF_Output ckpt_path, TF_Output old_tensor_name, TF_Output row_remapping, TF_Output col_remapping, TF_Output initializing_values, long num_rows, long num_cols, long? max_rows_in_memory = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadAndRemapMatrix", MakeName ("LoadAndRemapMatrix", operName));
			c_api.TF_AddInput(desc, ckpt_path);
			c_api.TF_AddInput(desc, old_tensor_name);
			c_api.TF_AddInput(desc, row_remapping);
			c_api.TF_AddInput(desc, col_remapping);
			c_api.TF_AddInput(desc, initializing_values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_rows", num_rows);
			c_api.TF_SetAttrInt (desc, "num_cols", num_cols);
			if (max_rows_in_memory.HasValue)
				c_api.TF_SetAttrInt (desc, "max_rows_in_memory", max_rows_in_memory.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_matrix = new TF_Output (op, _idx++);
			return output_matrix;
		}

		/// <summary>
		/// </summary>
		/// <param name="distances">
		/// </param>
		/// <param name="seed">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'KMC2ChainInitialization'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output KMC2ChainInitialization (TF_Output distances, TF_Output seed, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "KMC2ChainInitialization", MakeName ("KMC2ChainInitialization", operName));
			c_api.TF_AddInput(desc, distances);
			c_api.TF_AddInput(desc, seed);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var index = new TF_Output (op, _idx++);
			return index;
		}

		/// <summary>
		/// </summary>
		/// <param name="points">
		/// </param>
		/// <param name="centers">
		/// </param>
		/// <param name="k">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NearestNeighbors'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   nearest_center_indices:
		///   nearest_center_distances:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output nearest_center_indices, TF_Output nearest_center_distances) NearestNeighbors (TF_Output points, TF_Output centers, TF_Output k, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NearestNeighbors", MakeName ("NearestNeighbors", operName));
			c_api.TF_AddInput(desc, points);
			c_api.TF_AddInput(desc, centers);
			c_api.TF_AddInput(desc, k);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var nearest_center_indices = new TF_Output (op, _idx++);
			var nearest_center_distances = new TF_Output (op, _idx++);
			return (nearest_center_indices, nearest_center_distances);
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalLatencyStatsDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalLatencyStatsDataset (TF_Output input_dataset, TF_Output tag, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalLatencyStatsDataset", MakeName ("ExperimentalLatencyStatsDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, tag);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="step">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="tensor">
		/// </param>
		/// <param name="sample_rate">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteAudioSummary'.
		/// </param>
		/// <param name="max_outputs">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation WriteAudioSummary (TF_Output writer, TF_Output step, TF_Output tag, TF_Output tensor, TF_Output sample_rate, long? max_outputs = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WriteAudioSummary", MakeName ("WriteAudioSummary", operName));
			c_api.TF_AddInput(desc, writer);
			c_api.TF_AddInput(desc, step);
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, sample_rate);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (max_outputs.HasValue)
				c_api.TF_SetAttrInt (desc, "max_outputs", max_outputs.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomShuffleQueueV2'.
		/// </param>
		/// <param name="shapes">
		///   Optional argument
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="min_after_dequeue">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="component_types">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RandomShuffleQueueV2 (TF_DataType[] component_types, long[][] shapes = null, long? capacity = null, long? min_after_dequeue = null, long? seed = null, long? seed2 = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomShuffleQueueV2", MakeName ("RandomShuffleQueueV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (shapes != null)
				c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (min_after_dequeue.HasValue)
				c_api.TF_SetAttrInt (desc, "min_after_dequeue", min_after_dequeue.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="set_indices">
		/// </param>
		/// <param name="set_values">
		/// </param>
		/// <param name="set_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SetSize'.
		/// </param>
		/// <param name="validate_indices">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SetSize (TF_Output set_indices, TF_Output set_values, TF_Output set_shape, bool? validate_indices = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SetSize", MakeName ("SetSize", operName));
			c_api.TF_AddInput(desc, set_indices);
			c_api.TF_AddInput(desc, set_values);
			c_api.TF_AddInput(desc, set_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (validate_indices.HasValue)
				c_api.TF_SetAttrBool (desc, "validate_indices", Convert.ToByte(validate_indices.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CollectiveGather'.
		/// </param>
		/// <param name="group_size">
		/// </param>
		/// <param name="group_key">
		/// </param>
		/// <param name="instance_key">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CollectiveGather (TF_Output input, long group_size, long group_key, long instance_key, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CollectiveGather", MakeName ("CollectiveGather", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "group_size", group_size);
			c_api.TF_SetAttrInt (desc, "group_key", group_key);
			c_api.TF_SetAttrInt (desc, "instance_key", instance_key);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var data = new TF_Output (op, _idx++);
			return data;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CollectiveBcastSend'.
		/// </param>
		/// <param name="group_size">
		/// </param>
		/// <param name="group_key">
		/// </param>
		/// <param name="instance_key">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CollectiveBcastSend (TF_Output input, long group_size, long group_key, long instance_key, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CollectiveBcastSend", MakeName ("CollectiveBcastSend", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "group_size", group_size);
			c_api.TF_SetAttrInt (desc, "group_key", group_key);
			c_api.TF_SetAttrInt (desc, "instance_key", instance_key);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var data = new TF_Output (op, _idx++);
			return data;
		}

		/// <summary>
		/// </summary>
		/// <param name="contents">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeBmp'.
		/// </param>
		/// <param name="channels">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DecodeBmp (TF_Output contents, long? channels = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodeBmp", MakeName ("DecodeBmp", operName));
			c_api.TF_AddInput(desc, contents);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (channels.HasValue)
				c_api.TF_SetAttrInt (desc, "channels", channels.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var image = new TF_Output (op, _idx++);
			return image;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CollectiveBcastRecv'.
		/// </param>
		/// <param name="T">
		/// </param>
		/// <param name="group_size">
		/// </param>
		/// <param name="group_key">
		/// </param>
		/// <param name="instance_key">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CollectiveBcastRecv (TF_DataType T, long group_size, long group_key, long instance_key, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CollectiveBcastRecv", MakeName ("CollectiveBcastRecv", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "T", T);
			c_api.TF_SetAttrInt (desc, "group_size", group_size);
			c_api.TF_SetAttrInt (desc, "group_key", group_key);
			c_api.TF_SetAttrInt (desc, "instance_key", instance_key);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var data = new TF_Output (op, _idx++);
			return data;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DataFormatDimMap'.
		/// </param>
		/// <param name="src_format">
		///   Optional argument
		/// </param>
		/// <param name="dst_format">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DataFormatDimMap (TF_Output x, string src_format = null, string dst_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DataFormatDimMap", MakeName ("DataFormatDimMap", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (src_format != null)
				c_api.TF_SetAttrString (desc, "src_format", src_format);
			
			if (dst_format != null)
				c_api.TF_SetAttrString (desc, "dst_format", dst_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="contents">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodePng'.
		/// </param>
		/// <param name="channels">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DecodePng (TF_Output contents, long? channels = null, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodePng", MakeName ("DecodePng", operName));
			c_api.TF_AddInput(desc, contents);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (channels.HasValue)
				c_api.TF_SetAttrInt (desc, "channels", channels.Value);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var image = new TF_Output (op, _idx++);
			return image;
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="pred">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Switch'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_false:
		///   output_true:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output_false, TF_Output output_true) Switch (TF_Output data, TF_Output pred, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Switch", MakeName ("Switch", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, pred);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_false = new TF_Output (op, _idx++);
			var output_true = new TF_Output (op, _idx++);
			return (output_false, output_true);
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Log'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Log (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Log", MakeName ("Log", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="selector_input_dataset">
		/// </param>
		/// <param name="data_input_datasets">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalDirectedInterleaveDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalDirectedInterleaveDataset (TF_Output selector_input_dataset, TF_Output[] data_input_datasets, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalDirectedInterleaveDataset", MakeName ("ExperimentalDirectedInterleaveDataset", operName));
			c_api.TF_AddInput(desc, selector_input_dataset);
			c_api.TF_AddInputList(desc, data_input_datasets[0], data_input_datasets.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Qr'.
		/// </param>
		/// <param name="full_matrices">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   q:
		///   r:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output q, TF_Output r) Qr (TF_Output input, bool? full_matrices = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Qr", MakeName ("Qr", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (full_matrices.HasValue)
				c_api.TF_SetAttrBool (desc, "full_matrices", Convert.ToByte(full_matrices.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var q = new TF_Output (op, _idx++);
			var r = new TF_Output (op, _idx++);
			return (q, r);
		}

		/// <summary>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Einsum'.
		/// </param>
		/// <param name="equation">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Einsum (TF_Output[] inputs, string equation, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Einsum", MakeName ("Einsum", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "equation", equation);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="pred">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RefSwitch'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_false:
		///   output_true:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output_false, TF_Output output_true) RefSwitch (TF_Output data, TF_Output pred, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RefSwitch", MakeName ("RefSwitch", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, pred);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_false = new TF_Output (op, _idx++);
			var output_true = new TF_Output (op, _idx++);
			return (output_false, output_true);
		}

		/// <summary>
		/// </summary>
		/// <param name="y_backprop">
		/// </param>
		/// <param name="x">
		/// </param>
		/// <param name="scale">
		/// </param>
		/// <param name="reserve_space_1">
		/// </param>
		/// <param name="reserve_space_2">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedBatchNormGrad'.
		/// </param>
		/// <param name="epsilon">
		///   Optional argument
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="is_training">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   x_backprop:
		///   scale_backprop:
		///   offset_backprop:
		///   reserve_space_3:
		///   reserve_space_4:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output x_backprop, TF_Output scale_backprop, TF_Output offset_backprop, TF_Output reserve_space_3, TF_Output reserve_space_4) FusedBatchNormGrad (TF_Output y_backprop, TF_Output x, TF_Output scale, TF_Output reserve_space_1, TF_Output reserve_space_2, float? epsilon = null, string data_format = null, bool? is_training = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FusedBatchNormGrad", MakeName ("FusedBatchNormGrad", operName));
			c_api.TF_AddInput(desc, y_backprop);
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, scale);
			c_api.TF_AddInput(desc, reserve_space_1);
			c_api.TF_AddInput(desc, reserve_space_2);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (epsilon.HasValue)
				c_api.TF_SetAttrFloat (desc, "epsilon", epsilon.Value);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (is_training.HasValue)
				c_api.TF_SetAttrBool (desc, "is_training", Convert.ToByte(is_training.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var x_backprop = new TF_Output (op, _idx++);
			var scale_backprop = new TF_Output (op, _idx++);
			var offset_backprop = new TF_Output (op, _idx++);
			var reserve_space_3 = new TF_Output (op, _idx++);
			var reserve_space_4 = new TF_Output (op, _idx++);
			return (x_backprop, scale_backprop, offset_backprop, reserve_space_3, reserve_space_4);
		}

		/// <summary>
		/// </summary>
		/// <param name="index">
		/// </param>
		/// <param name="inputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RefSelect'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RefSelect (TF_Output index, TF_Output[] inputs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RefSelect", MakeName ("RefSelect", operName));
			c_api.TF_AddInput(desc, index);
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayUnpack'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayUnpack (TF_Output handle, TF_Output value, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayUnpack", MakeName ("TensorArrayUnpack", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var flow_out = new TF_Output (op, _idx++);
			return flow_out;
		}

		/// <summary>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Merge'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   value_index:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output value_index) Merge (TF_Output[] inputs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Merge", MakeName ("Merge", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var value_index = new TF_Output (op, _idx++);
			return (output, value_index);
		}

		/// <summary>
		/// </summary>
		/// <param name="orig_input">
		/// </param>
		/// <param name="orig_output">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGradGrad'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="ksize">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPoolGradGrad (TF_Output orig_input, TF_Output orig_output, TF_Output grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPoolGradGrad", MakeName ("MaxPoolGradGrad", operName));
			c_api.TF_AddInput(desc, orig_input);
			c_api.TF_AddInput(desc, orig_output);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="gradient_accumulator">
		/// </param>
		/// <param name="gradient_squared_accumulator">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="global_step">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdagradDA'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceApplyAdagradDA (TF_Output var, TF_Output gradient_accumulator, TF_Output gradient_squared_accumulator, TF_Output grad, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output global_step, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyAdagradDA", MakeName ("ResourceApplyAdagradDA", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, gradient_accumulator);
			c_api.TF_AddInput(desc, gradient_squared_accumulator);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, global_step);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayConcatV3'.
		/// </param>
		/// <param name="element_shape_except0">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   value:
		///   lengths:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output value, TF_Output lengths) TensorArrayConcatV3 (TF_Output handle, TF_Output flow_in, TF_DataType dtype, long[] element_shape_except0 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayConcatV3", MakeName ("TensorArrayConcatV3", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (element_shape_except0 != null)
				c_api.TF_SetAttrShape (desc, "element_shape_except0", ref element_shape_except0[0], element_shape_except0.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			var lengths = new TF_Output (op, _idx++);
			return (value, lengths);
		}

		/// <summary>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RefMerge'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   value_index:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output value_index) RefMerge (TF_Output[] inputs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RefMerge", MakeName ("RefMerge", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var value_index = new TF_Output (op, _idx++);
			return (output, value_index);
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RefEnter'.
		/// </param>
		/// <param name="is_constant">
		///   Optional argument
		/// </param>
		/// <param name="parallel_iterations">
		///   Optional argument
		/// </param>
		/// <param name="frame_name">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RefEnter (TF_Output data, string frame_name, bool? is_constant = null, long? parallel_iterations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RefEnter", MakeName ("RefEnter", operName));
			c_api.TF_AddInput(desc, data);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "frame_name", frame_name);
			if (is_constant.HasValue)
				c_api.TF_SetAttrBool (desc, "is_constant", Convert.ToByte(is_constant.Value));
			
			if (parallel_iterations.HasValue)
				c_api.TF_SetAttrInt (desc, "parallel_iterations", parallel_iterations.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="contents">
		/// </param>
		/// <param name="crop_window">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeAndCropJpeg'.
		/// </param>
		/// <param name="channels">
		///   Optional argument
		/// </param>
		/// <param name="ratio">
		///   Optional argument
		/// </param>
		/// <param name="fancy_upscaling">
		///   Optional argument
		/// </param>
		/// <param name="try_recover_truncated">
		///   Optional argument
		/// </param>
		/// <param name="acceptable_fraction">
		///   Optional argument
		/// </param>
		/// <param name="dct_method">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DecodeAndCropJpeg (TF_Output contents, TF_Output crop_window, long? channels = null, long? ratio = null, bool? fancy_upscaling = null, bool? try_recover_truncated = null, float? acceptable_fraction = null, string dct_method = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodeAndCropJpeg", MakeName ("DecodeAndCropJpeg", operName));
			c_api.TF_AddInput(desc, contents);
			c_api.TF_AddInput(desc, crop_window);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (channels.HasValue)
				c_api.TF_SetAttrInt (desc, "channels", channels.Value);
			
			if (ratio.HasValue)
				c_api.TF_SetAttrInt (desc, "ratio", ratio.Value);
			
			if (fancy_upscaling.HasValue)
				c_api.TF_SetAttrBool (desc, "fancy_upscaling", Convert.ToByte(fancy_upscaling.Value));
			
			if (try_recover_truncated.HasValue)
				c_api.TF_SetAttrBool (desc, "try_recover_truncated", Convert.ToByte(try_recover_truncated.Value));
			
			if (acceptable_fraction.HasValue)
				c_api.TF_SetAttrFloat (desc, "acceptable_fraction", acceptable_fraction.Value);
			
			if (dct_method != null)
				c_api.TF_SetAttrString (desc, "dct_method", dct_method);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var image = new TF_Output (op, _idx++);
			return image;
		}

		/// <summary>
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Softsign'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Softsign (TF_Output features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Softsign", MakeName ("Softsign", operName));
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var activations = new TF_Output (op, _idx++);
			return activations;
		}

		/// <summary>
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="momenta">
		/// </param>
		/// <param name="velocities">
		/// </param>
		/// <param name="gradient_accumulators">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingADAMParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LoadTPUEmbeddingADAMParametersGradAccumDebug (TF_Output parameters, TF_Output momenta, TF_Output velocities, TF_Output gradient_accumulators, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingADAMParametersGradAccumDebug", MakeName ("LoadTPUEmbeddingADAMParametersGradAccumDebug", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, momenta);
			c_api.TF_AddInput(desc, velocities);
			c_api.TF_AddInput(desc, gradient_accumulators);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="selector_input_dataset">
		/// </param>
		/// <param name="data_input_datasets">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DirectedInterleaveDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DirectedInterleaveDataset (TF_Output selector_input_dataset, TF_Output[] data_input_datasets, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DirectedInterleaveDataset", MakeName ("DirectedInterleaveDataset", operName));
			c_api.TF_AddInput(desc, selector_input_dataset);
			c_api.TF_AddInputList(desc, data_input_datasets[0], data_input_datasets.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StackClose'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation StackClose (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StackClose", MakeName ("StackClose", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Exit'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Exit (TF_Output data, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Exit", MakeName ("Exit", operName));
			c_api.TF_AddInput(desc, data);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RefExit'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RefExit (TF_Output data, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RefExit", MakeName ("RefExit", operName));
			c_api.TF_AddInput(desc, data);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NextIteration'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output NextIteration (TF_Output data, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NextIteration", MakeName ("NextIteration", operName));
			c_api.TF_AddInput(desc, data);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalNonSerializableDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalNonSerializableDataset (TF_Output input_dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalNonSerializableDataset", MakeName ("ExperimentalNonSerializableDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DeleteSessionTensor'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation DeleteSessionTensor (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DeleteSessionTensor", MakeName ("DeleteSessionTensor", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoopCond'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LoopCond (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoopCond", MakeName ("LoopCond", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Abort'.
		/// </param>
		/// <param name="error_msg">
		///   Optional argument
		/// </param>
		/// <param name="exit_without_error">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation Abort (string error_msg = null, bool? exit_without_error = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Abort", MakeName ("Abort", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (error_msg != null)
				c_api.TF_SetAttrString (desc, "error_msg", error_msg);
			
			if (exit_without_error.HasValue)
				c_api.TF_SetAttrBool (desc, "exit_without_error", Convert.ToByte(exit_without_error.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedDepthwiseConv2DWithBiasAndRelu'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedDepthwiseConv2DWithBiasAndRelu (TF_Output input, TF_Output filter, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedDepthwiseConv2DWithBiasAndRelu", MakeName ("QuantizedDepthwiseConv2DWithBiasAndRelu", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="labels_indices">
		/// </param>
		/// <param name="labels_values">
		/// </param>
		/// <param name="sequence_length">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CTCLoss'.
		/// </param>
		/// <param name="preprocess_collapse_repeated">
		///   Optional argument
		/// </param>
		/// <param name="ctc_merge_repeated">
		///   Optional argument
		/// </param>
		/// <param name="ignore_longer_outputs_than_inputs">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   loss:
		///   gradient:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output loss, TF_Output gradient) CTCLoss (TF_Output inputs, TF_Output labels_indices, TF_Output labels_values, TF_Output sequence_length, bool? preprocess_collapse_repeated = null, bool? ctc_merge_repeated = null, bool? ignore_longer_outputs_than_inputs = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CTCLoss", MakeName ("CTCLoss", operName));
			c_api.TF_AddInput(desc, inputs);
			c_api.TF_AddInput(desc, labels_indices);
			c_api.TF_AddInput(desc, labels_values);
			c_api.TF_AddInput(desc, sequence_length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (preprocess_collapse_repeated.HasValue)
				c_api.TF_SetAttrBool (desc, "preprocess_collapse_repeated", Convert.ToByte(preprocess_collapse_repeated.Value));
			
			if (ctc_merge_repeated.HasValue)
				c_api.TF_SetAttrBool (desc, "ctc_merge_repeated", Convert.ToByte(ctc_merge_repeated.Value));
			
			if (ignore_longer_outputs_than_inputs.HasValue)
				c_api.TF_SetAttrBool (desc, "ignore_longer_outputs_than_inputs", Convert.ToByte(ignore_longer_outputs_than_inputs.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var loss = new TF_Output (op, _idx++);
			var gradient = new TF_Output (op, _idx++);
			return (loss, gradient);
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Sign'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Sign (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Sign", MakeName ("Sign", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="min_freezed_output">
		/// </param>
		/// <param name="max_freezed_output">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DAndReluAndRequantize'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="padding_list">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DAndReluAndRequantize (TF_Output input, TF_Output filter, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, TF_Output min_freezed_output, TF_Output max_freezed_output, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, long[] padding_list = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DAndReluAndRequantize", MakeName ("QuantizedConv2DAndReluAndRequantize", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			c_api.TF_AddInput(desc, min_freezed_output);
			c_api.TF_AddInput(desc, max_freezed_output);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			if (padding_list != null)
				c_api.TF_SetAttrIntList (desc, "padding_list", ref padding_list[0], padding_list.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WholeFileReaderV2'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output WholeFileReaderV2 (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WholeFileReaderV2", MakeName ("WholeFileReaderV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="shape">
		/// </param>
		/// <param name="seed">
		/// </param>
		/// <param name="minval">
		/// </param>
		/// <param name="maxval">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatelessRandomUniformInt'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StatelessRandomUniformInt (TF_Output shape, TF_Output seed, TF_Output minval, TF_Output maxval, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatelessRandomUniformInt", MakeName ("StatelessRandomUniformInt", operName));
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, seed);
			c_api.TF_AddInput(desc, minval);
			c_api.TF_AddInput(desc, maxval);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="sequence_length">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CTCGreedyDecoder'.
		/// </param>
		/// <param name="merge_repeated">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   decoded_indices:
		///   decoded_values:
		///   decoded_shape:
		///   log_probability:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output decoded_indices, TF_Output decoded_values, TF_Output decoded_shape, TF_Output log_probability) CTCGreedyDecoder (TF_Output inputs, TF_Output sequence_length, bool? merge_repeated = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CTCGreedyDecoder", MakeName ("CTCGreedyDecoder", operName));
			c_api.TF_AddInput(desc, inputs);
			c_api.TF_AddInput(desc, sequence_length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (merge_repeated.HasValue)
				c_api.TF_SetAttrBool (desc, "merge_repeated", Convert.ToByte(merge_repeated.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var decoded_indices = new TF_Output (op, _idx++);
			var decoded_values = new TF_Output (op, _idx++);
			var decoded_shape = new TF_Output (op, _idx++);
			var log_probability = new TF_Output (op, _idx++);
			return (decoded_indices, decoded_values, decoded_shape, log_probability);
		}

		/// <summary>
		/// </summary>
		/// <param name="images">
		/// </param>
		/// <param name="size">
		/// </param>
		/// <param name="scale">
		/// </param>
		/// <param name="translation">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScaleAndTranslate'.
		/// </param>
		/// <param name="kernel_type">
		///   Optional argument
		/// </param>
		/// <param name="antialias">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ScaleAndTranslate (TF_Output images, TF_Output size, TF_Output scale, TF_Output translation, string kernel_type = null, bool? antialias = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScaleAndTranslate", MakeName ("ScaleAndTranslate", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, size);
			c_api.TF_AddInput(desc, scale);
			c_api.TF_AddInput(desc, translation);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (kernel_type != null)
				c_api.TF_SetAttrString (desc, "kernel_type", kernel_type);
			
			if (antialias.HasValue)
				c_api.TF_SetAttrBool (desc, "antialias", Convert.ToByte(antialias.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var resized_images = new TF_Output (op, _idx++);
			return resized_images;
		}

		/// <summary>
		/// </summary>
		/// <param name="num_layers">
		/// </param>
		/// <param name="num_units">
		/// </param>
		/// <param name="input_size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNParamsSize'.
		/// </param>
		/// <param name="rnn_mode">
		///   Optional argument
		/// </param>
		/// <param name="input_mode">
		///   Optional argument
		/// </param>
		/// <param name="direction">
		///   Optional argument
		/// </param>
		/// <param name="dropout">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="num_proj">
		///   Optional argument
		/// </param>
		/// <param name="T">
		/// </param>
		/// <param name="S">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CudnnRNNParamsSize (TF_Output num_layers, TF_Output num_units, TF_Output input_size, TF_DataType T, TF_DataType S, string rnn_mode = null, string input_mode = null, string direction = null, float? dropout = null, long? seed = null, long? seed2 = null, long? num_proj = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CudnnRNNParamsSize", MakeName ("CudnnRNNParamsSize", operName));
			c_api.TF_AddInput(desc, num_layers);
			c_api.TF_AddInput(desc, num_units);
			c_api.TF_AddInput(desc, input_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "T", T);
			c_api.TF_SetAttrType (desc, "S", S);
			if (rnn_mode != null)
				c_api.TF_SetAttrString (desc, "rnn_mode", rnn_mode);
			
			if (input_mode != null)
				c_api.TF_SetAttrString (desc, "input_mode", input_mode);
			
			if (direction != null)
				c_api.TF_SetAttrString (desc, "direction", direction);
			
			if (dropout.HasValue)
				c_api.TF_SetAttrFloat (desc, "dropout", dropout.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (num_proj.HasValue)
				c_api.TF_SetAttrInt (desc, "num_proj", num_proj.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var params_size = new TF_Output (op, _idx++);
			return params_size;
		}

		/// <summary>
		/// </summary>
		/// <param name="filenames">
		/// </param>
		/// <param name="header_bytes">
		/// </param>
		/// <param name="record_bytes">
		/// </param>
		/// <param name="footer_bytes">
		/// </param>
		/// <param name="buffer_size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FixedLengthRecordDataset'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FixedLengthRecordDataset (TF_Output filenames, TF_Output header_bytes, TF_Output record_bytes, TF_Output footer_bytes, TF_Output buffer_size, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FixedLengthRecordDataset", MakeName ("FixedLengthRecordDataset", operName));
			c_api.TF_AddInput(desc, filenames);
			c_api.TF_AddInput(desc, header_bytes);
			c_api.TF_AddInput(desc, record_bytes);
			c_api.TF_AddInput(desc, footer_bytes);
			c_api.TF_AddInput(desc, buffer_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ConfigureTPUEmbedding'.
		/// </param>
		/// <param name="config">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ConfigureTPUEmbedding (string config, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ConfigureTPUEmbedding", MakeName ("ConfigureTPUEmbedding", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "config", config);
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_h">
		/// </param>
		/// <param name="input_c">
		/// </param>
		/// <param name="parameters">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNN'.
		/// </param>
		/// <param name="rnn_mode">
		///   Optional argument
		/// </param>
		/// <param name="input_mode">
		///   Optional argument
		/// </param>
		/// <param name="direction">
		///   Optional argument
		/// </param>
		/// <param name="dropout">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="is_training">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   output_h:
		///   output_c:
		///   reserve_space:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output output_h, TF_Output output_c, TF_Output reserve_space) CudnnRNN (TF_Output input, TF_Output input_h, TF_Output input_c, TF_Output parameters, string rnn_mode = null, string input_mode = null, string direction = null, float? dropout = null, long? seed = null, long? seed2 = null, bool? is_training = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CudnnRNN", MakeName ("CudnnRNN", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_h);
			c_api.TF_AddInput(desc, input_c);
			c_api.TF_AddInput(desc, parameters);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (rnn_mode != null)
				c_api.TF_SetAttrString (desc, "rnn_mode", rnn_mode);
			
			if (input_mode != null)
				c_api.TF_SetAttrString (desc, "input_mode", input_mode);
			
			if (direction != null)
				c_api.TF_SetAttrString (desc, "direction", direction);
			
			if (dropout.HasValue)
				c_api.TF_SetAttrFloat (desc, "dropout", dropout.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (is_training.HasValue)
				c_api.TF_SetAttrBool (desc, "is_training", Convert.ToByte(is_training.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var output_h = new TF_Output (op, _idx++);
			var output_c = new TF_Output (op, _idx++);
			var reserve_space = new TF_Output (op, _idx++);
			return (output, output_h, output_c, reserve_space);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_h">
		/// </param>
		/// <param name="input_c">
		/// </param>
		/// <param name="parameters">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNV2'.
		/// </param>
		/// <param name="rnn_mode">
		///   Optional argument
		/// </param>
		/// <param name="input_mode">
		///   Optional argument
		/// </param>
		/// <param name="direction">
		///   Optional argument
		/// </param>
		/// <param name="dropout">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="is_training">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   output_h:
		///   output_c:
		///   reserve_space:
		///   host_reserved:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output output_h, TF_Output output_c, TF_Output reserve_space, TF_Output host_reserved) CudnnRNNV2 (TF_Output input, TF_Output input_h, TF_Output input_c, TF_Output parameters, string rnn_mode = null, string input_mode = null, string direction = null, float? dropout = null, long? seed = null, long? seed2 = null, bool? is_training = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CudnnRNNV2", MakeName ("CudnnRNNV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_h);
			c_api.TF_AddInput(desc, input_c);
			c_api.TF_AddInput(desc, parameters);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (rnn_mode != null)
				c_api.TF_SetAttrString (desc, "rnn_mode", rnn_mode);
			
			if (input_mode != null)
				c_api.TF_SetAttrString (desc, "input_mode", input_mode);
			
			if (direction != null)
				c_api.TF_SetAttrString (desc, "direction", direction);
			
			if (dropout.HasValue)
				c_api.TF_SetAttrFloat (desc, "dropout", dropout.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (is_training.HasValue)
				c_api.TF_SetAttrBool (desc, "is_training", Convert.ToByte(is_training.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var output_h = new TF_Output (op, _idx++);
			var output_c = new TF_Output (op, _idx++);
			var reserve_space = new TF_Output (op, _idx++);
			var host_reserved = new TF_Output (op, _idx++);
			return (output, output_h, output_c, reserve_space, host_reserved);
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatMul'.
		/// </param>
		/// <param name="adj_x">
		///   Optional argument
		/// </param>
		/// <param name="adj_y">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchMatMul (TF_Output x, TF_Output y, bool? adj_x = null, bool? adj_y = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatMul", MakeName ("BatchMatMul", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (adj_x.HasValue)
				c_api.TF_SetAttrBool (desc, "adj_x", Convert.ToByte(adj_x.Value));
			
			if (adj_y.HasValue)
				c_api.TF_SetAttrBool (desc, "adj_y", Convert.ToByte(adj_y.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="string_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MultiDeviceIteratorFromStringHandle'.
		/// </param>
		/// <param name="output_types">
		///   Optional argument
		/// </param>
		/// <param name="output_shapes">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MultiDeviceIteratorFromStringHandle (TF_Output string_handle, TF_DataType[] output_types = null, long[][] output_shapes = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MultiDeviceIteratorFromStringHandle", MakeName ("MultiDeviceIteratorFromStringHandle", operName));
			c_api.TF_AddInput(desc, string_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (output_types != null)
				c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			
			if (output_shapes != null)
				c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var multi_device_iterator = new TF_Output (op, _idx++);
			return multi_device_iterator;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_h">
		/// </param>
		/// <param name="input_c">
		/// </param>
		/// <param name="parameters">
		/// </param>
		/// <param name="output">
		/// </param>
		/// <param name="output_h">
		/// </param>
		/// <param name="output_c">
		/// </param>
		/// <param name="output_backprop">
		/// </param>
		/// <param name="output_h_backprop">
		/// </param>
		/// <param name="output_c_backprop">
		/// </param>
		/// <param name="reserve_space">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNBackprop'.
		/// </param>
		/// <param name="rnn_mode">
		///   Optional argument
		/// </param>
		/// <param name="input_mode">
		///   Optional argument
		/// </param>
		/// <param name="direction">
		///   Optional argument
		/// </param>
		/// <param name="dropout">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   input_backprop:
		///   input_h_backprop:
		///   input_c_backprop:
		///   params_backprop:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output input_backprop, TF_Output input_h_backprop, TF_Output input_c_backprop, TF_Output params_backprop) CudnnRNNBackprop (TF_Output input, TF_Output input_h, TF_Output input_c, TF_Output parameters, TF_Output output, TF_Output output_h, TF_Output output_c, TF_Output output_backprop, TF_Output output_h_backprop, TF_Output output_c_backprop, TF_Output reserve_space, string rnn_mode = null, string input_mode = null, string direction = null, float? dropout = null, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CudnnRNNBackprop", MakeName ("CudnnRNNBackprop", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_h);
			c_api.TF_AddInput(desc, input_c);
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, output);
			c_api.TF_AddInput(desc, output_h);
			c_api.TF_AddInput(desc, output_c);
			c_api.TF_AddInput(desc, output_backprop);
			c_api.TF_AddInput(desc, output_h_backprop);
			c_api.TF_AddInput(desc, output_c_backprop);
			c_api.TF_AddInput(desc, reserve_space);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (rnn_mode != null)
				c_api.TF_SetAttrString (desc, "rnn_mode", rnn_mode);
			
			if (input_mode != null)
				c_api.TF_SetAttrString (desc, "input_mode", input_mode);
			
			if (direction != null)
				c_api.TF_SetAttrString (desc, "direction", direction);
			
			if (dropout.HasValue)
				c_api.TF_SetAttrFloat (desc, "dropout", dropout.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var input_backprop = new TF_Output (op, _idx++);
			var input_h_backprop = new TF_Output (op, _idx++);
			var input_c_backprop = new TF_Output (op, _idx++);
			var params_backprop = new TF_Output (op, _idx++);
			return (input_backprop, input_h_backprop, input_c_backprop, params_backprop);
		}

		/// <summary>
		/// </summary>
		/// <param name="num_layers">
		/// </param>
		/// <param name="num_units">
		/// </param>
		/// <param name="input_size">
		/// </param>
		/// <param name="weights">
		/// </param>
		/// <param name="biases">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNCanonicalToParams'.
		/// </param>
		/// <param name="rnn_mode">
		///   Optional argument
		/// </param>
		/// <param name="input_mode">
		///   Optional argument
		/// </param>
		/// <param name="direction">
		///   Optional argument
		/// </param>
		/// <param name="dropout">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CudnnRNNCanonicalToParams (TF_Output num_layers, TF_Output num_units, TF_Output input_size, TF_Output[] weights, TF_Output[] biases, string rnn_mode = null, string input_mode = null, string direction = null, float? dropout = null, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CudnnRNNCanonicalToParams", MakeName ("CudnnRNNCanonicalToParams", operName));
			c_api.TF_AddInput(desc, num_layers);
			c_api.TF_AddInput(desc, num_units);
			c_api.TF_AddInput(desc, input_size);
			c_api.TF_AddInputList(desc, weights[0], weights.Length);
			c_api.TF_AddInputList(desc, biases[0], biases.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (rnn_mode != null)
				c_api.TF_SetAttrString (desc, "rnn_mode", rnn_mode);
			
			if (input_mode != null)
				c_api.TF_SetAttrString (desc, "input_mode", input_mode);
			
			if (direction != null)
				c_api.TF_SetAttrString (desc, "direction", direction);
			
			if (dropout.HasValue)
				c_api.TF_SetAttrFloat (desc, "dropout", dropout.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			return parameters;
		}

		/// <summary>
		/// </summary>
		/// <param name="images">
		/// </param>
		/// <param name="boxes">
		/// </param>
		/// <param name="colors">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DrawBoundingBoxesV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DrawBoundingBoxesV2 (TF_Output images, TF_Output boxes, TF_Output colors, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DrawBoundingBoxesV2", MakeName ("DrawBoundingBoxesV2", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, boxes);
			c_api.TF_AddInput(desc, colors);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Bucketize'.
		/// </param>
		/// <param name="boundaries">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Bucketize (TF_Output input, float[] boundaries, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Bucketize", MakeName ("Bucketize", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFloatList (desc, "boundaries", ref boundaries[0], boundaries.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="indices">
		/// </param>
		/// <param name="data">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DynamicStitch'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DynamicStitch (TF_Output[] indices, TF_Output[] data, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DynamicStitch", MakeName ("DynamicStitch", operName));
			c_api.TF_AddInputList(desc, indices[0], indices.Length);
			c_api.TF_AddInputList(desc, data[0], data.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var merged = new TF_Output (op, _idx++);
			return merged;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterNdUpdate'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ScatterNdUpdate (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterNdUpdate", MakeName ("ScatterNdUpdate", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomShuffleQueue'.
		/// </param>
		/// <param name="shapes">
		///   Optional argument
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="min_after_dequeue">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="component_types">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RandomShuffleQueue (TF_DataType[] component_types, long[][] shapes = null, long? capacity = null, long? min_after_dequeue = null, long? seed = null, long? seed2 = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomShuffleQueue", MakeName ("RandomShuffleQueue", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (shapes != null)
				c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (min_after_dequeue.HasValue)
				c_api.TF_SetAttrInt (desc, "min_after_dequeue", min_after_dequeue.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FIFOQueueV2'.
		/// </param>
		/// <param name="shapes">
		///   Optional argument
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="component_types">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FIFOQueueV2 (TF_DataType[] component_types, long[][] shapes = null, long? capacity = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FIFOQueueV2", MakeName ("FIFOQueueV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (shapes != null)
				c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="num_required">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AccumulatorTakeGradient'.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AccumulatorTakeGradient (TF_Output handle, TF_Output num_required, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AccumulatorTakeGradient", MakeName ("AccumulatorTakeGradient", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, num_required);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var average = new TF_Output (op, _idx++);
			return average;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AssignAdd'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AssignAdd (TF_Output reference, TF_Output value, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AssignAdd", MakeName ("AssignAdd", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalDatasetCardinality'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalDatasetCardinality (TF_Output input_dataset, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalDatasetCardinality", MakeName ("ExperimentalDatasetCardinality", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var cardinality = new TF_Output (op, _idx++);
			return cardinality;
		}

		/// <summary>
		/// </summary>
		/// <param name="real">
		/// </param>
		/// <param name="imag">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Complex'.
		/// </param>
		/// <param name="Tout">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Complex (TF_Output real, TF_Output imag, TF_DataType? Tout = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Complex", MakeName ("Complex", operName));
			c_api.TF_AddInput(desc, real);
			c_api.TF_AddInput(desc, imag);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Tout.HasValue)
				c_api.TF_SetAttrType (desc, "Tout", Tout.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="linear">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="lr_power">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyFtrl'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ApplyFtrl (TF_Output var, TF_Output accum, TF_Output linear, TF_Output grad, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output lr_power, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyFtrl", MakeName ("ApplyFtrl", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, linear);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, lr_power);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PaddingFIFOQueue'.
		/// </param>
		/// <param name="shapes">
		///   Optional argument
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="component_types">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output PaddingFIFOQueue (TF_DataType[] component_types, long[][] shapes = null, long? capacity = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PaddingFIFOQueue", MakeName ("PaddingFIFOQueue", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (shapes != null)
				c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="linear">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="l2_shrinkage">
		/// </param>
		/// <param name="lr_power">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyFtrlV2'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ApplyFtrlV2 (TF_Output var, TF_Output accum, TF_Output linear, TF_Output grad, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output l2_shrinkage, TF_Output lr_power, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyFtrlV2", MakeName ("ApplyFtrlV2", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, linear);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, l2_shrinkage);
			c_api.TF_AddInput(desc, lr_power);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PaddingFIFOQueueV2'.
		/// </param>
		/// <param name="shapes">
		///   Optional argument
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="component_types">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output PaddingFIFOQueueV2 (TF_DataType[] component_types, long[][] shapes = null, long? capacity = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PaddingFIFOQueueV2", MakeName ("PaddingFIFOQueueV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (shapes != null)
				c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'VarIsInitializedOp'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output VarIsInitializedOp (TF_Output resource, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "VarIsInitializedOp", MakeName ("VarIsInitializedOp", operName));
			c_api.TF_AddInput(desc, resource);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var is_initialized = new TF_Output (op, _idx++);
			return is_initialized;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixExponential'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MatrixExponential (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixExponential", MakeName ("MatrixExponential", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PriorityQueue'.
		/// </param>
		/// <param name="component_types">
		///   Optional argument
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output PriorityQueue (long[][] shapes, TF_DataType[] component_types = null, long? capacity = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PriorityQueue", MakeName ("PriorityQueue", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			if (component_types != null)
				c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Imag'.
		/// </param>
		/// <param name="Tout">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Imag (TF_Output input, TF_DataType? Tout = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Imag", MakeName ("Imag", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Tout.HasValue)
				c_api.TF_SetAttrType (desc, "Tout", Tout.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="max_size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StackV2'.
		/// </param>
		/// <param name="stack_name">
		///   Optional argument
		/// </param>
		/// <param name="elem_type">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StackV2 (TF_Output max_size, TF_DataType elem_type, string stack_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StackV2", MakeName ("StackV2", operName));
			c_api.TF_AddInput(desc, max_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "elem_type", elem_type);
			if (stack_name != null)
				c_api.TF_SetAttrString (desc, "stack_name", stack_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQueue'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FakeQueue (TF_Output resource, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FakeQueue", MakeName ("FakeQueue", operName));
			c_api.TF_AddInput(desc, resource);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Round'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Round (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Round", MakeName ("Round", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Lu'.
		/// </param>
		/// <param name="output_idx_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   lu:
		///   p:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output lu, TF_Output p) Lu (TF_Output input, TF_DataType? output_idx_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Lu", MakeName ("Lu", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (output_idx_type.HasValue)
				c_api.TF_SetAttrType (desc, "output_idx_type", output_idx_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var lu = new TF_Output (op, _idx++);
			var p = new TF_Output (op, _idx++);
			return (lu, p);
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="components">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueEnqueue'.
		/// </param>
		/// <param name="timeout_ms">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation QueueEnqueue (TF_Output handle, TF_Output[] components, long? timeout_ms = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueEnqueue", MakeName ("QueueEnqueue", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInputList(desc, components[0], components.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (timeout_ms.HasValue)
				c_api.TF_SetAttrInt (desc, "timeout_ms", timeout_ms.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="components">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueEnqueueV2'.
		/// </param>
		/// <param name="timeout_ms">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation QueueEnqueueV2 (TF_Output handle, TF_Output[] components, long? timeout_ms = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueEnqueueV2", MakeName ("QueueEnqueueV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInputList(desc, components[0], components.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (timeout_ms.HasValue)
				c_api.TF_SetAttrInt (desc, "timeout_ms", timeout_ms.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="min_x">
		/// </param>
		/// <param name="max_x">
		/// </param>
		/// <param name="min_y">
		/// </param>
		/// <param name="max_y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedAdd'.
		/// </param>
		/// <param name="Toutput">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   z:
		///   min_z:
		///   max_z:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output z, TF_Output min_z, TF_Output max_z) QuantizedAdd (TF_Output x, TF_Output y, TF_Output min_x, TF_Output max_x, TF_Output min_y, TF_Output max_y, TF_DataType? Toutput = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedAdd", MakeName ("QuantizedAdd", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			c_api.TF_AddInput(desc, min_x);
			c_api.TF_AddInput(desc, max_x);
			c_api.TF_AddInput(desc, min_y);
			c_api.TF_AddInput(desc, max_y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Toutput.HasValue)
				c_api.TF_SetAttrType (desc, "Toutput", Toutput.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			var min_z = new TF_Output (op, _idx++);
			var max_z = new TF_Output (op, _idx++);
			return (z, min_z, max_z);
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyKerasMomentum'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <param name="use_nesterov">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceSparseApplyKerasMomentum (TF_Output var, TF_Output accum, TF_Output lr, TF_Output grad, TF_Output indices, TF_Output momentum, bool? use_locking = null, bool? use_nesterov = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyKerasMomentum", MakeName ("ResourceSparseApplyKerasMomentum", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, momentum);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (use_nesterov.HasValue)
				c_api.TF_SetAttrBool (desc, "use_nesterov", Convert.ToByte(use_nesterov.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="components">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueEnqueueMany'.
		/// </param>
		/// <param name="timeout_ms">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation QueueEnqueueMany (TF_Output handle, TF_Output[] components, long? timeout_ms = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueEnqueueMany", MakeName ("QueueEnqueueMany", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInputList(desc, components[0], components.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (timeout_ms.HasValue)
				c_api.TF_SetAttrInt (desc, "timeout_ms", timeout_ms.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="reader_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderResetV2'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ReaderResetV2 (TF_Output reader_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderResetV2", MakeName ("ReaderResetV2", operName));
			c_api.TF_AddInput(desc, reader_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="algorithm">
		/// </param>
		/// <param name="delta">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RngSkip'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation RngSkip (TF_Output resource, TF_Output algorithm, TF_Output delta, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RngSkip", MakeName ("RngSkip", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, algorithm);
			c_api.TF_AddInput(desc, delta);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="components">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueEnqueueManyV2'.
		/// </param>
		/// <param name="timeout_ms">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation QueueEnqueueManyV2 (TF_Output handle, TF_Output[] components, long? timeout_ms = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueEnqueueManyV2", MakeName ("QueueEnqueueManyV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInputList(desc, components[0], components.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (timeout_ms.HasValue)
				c_api.TF_SetAttrInt (desc, "timeout_ms", timeout_ms.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="stats_aggregator">
		/// </param>
		/// <param name="summary">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatsAggregatorSetSummaryWriter'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation StatsAggregatorSetSummaryWriter (TF_Output stats_aggregator, TF_Output summary, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatsAggregatorSetSummaryWriter", MakeName ("StatsAggregatorSetSummaryWriter", operName));
			c_api.TF_AddInput(desc, stats_aggregator);
			c_api.TF_AddInput(desc, summary);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="seed">
		/// </param>
		/// <param name="seed2">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RandomDataset (TF_Output seed, TF_Output seed2, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomDataset", MakeName ("RandomDataset", operName));
			c_api.TF_AddInput(desc, seed);
			c_api.TF_AddInput(desc, seed2);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="segment_ids">
		/// </param>
		/// <param name="num_segments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnsortedSegmentMax'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output UnsortedSegmentMax (TF_Output data, TF_Output segment_ids, TF_Output num_segments, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnsortedSegmentMax", MakeName ("UnsortedSegmentMax", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, segment_ids);
			c_api.TF_AddInput(desc, num_segments);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="batch_size">
		/// </param>
		/// <param name="row_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DenseToSparseBatchDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DenseToSparseBatchDataset (TF_Output input_dataset, TF_Output batch_size, TF_Output row_shape, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DenseToSparseBatchDataset", MakeName ("DenseToSparseBatchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, batch_size);
			c_api.TF_AddInput(desc, row_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="segment_ids">
		/// </param>
		/// <param name="num_segments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentSumWithNumSegments'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseSegmentSumWithNumSegments (TF_Output data, TF_Output indices, TF_Output segment_ids, TF_Output num_segments, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSegmentSumWithNumSegments", MakeName ("SparseSegmentSumWithNumSegments", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, segment_ids);
			c_api.TF_AddInput(desc, num_segments);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TruncateMod'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TruncateMod (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TruncateMod", MakeName ("TruncateMod", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingFTRLParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters:
		///   accumulators:
		///   linears:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output parameters, TF_Output accumulators, TF_Output linears) RetrieveTPUEmbeddingFTRLParameters (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingFTRLParameters", MakeName ("RetrieveTPUEmbeddingFTRLParameters", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var accumulators = new TF_Output (op, _idx++);
			var linears = new TF_Output (op, _idx++);
			return (parameters, accumulators, linears);
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueClose'.
		/// </param>
		/// <param name="cancel_pending_enqueues">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation QueueClose (TF_Output handle, bool? cancel_pending_enqueues = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueClose", MakeName ("QueueClose", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (cancel_pending_enqueues.HasValue)
				c_api.TF_SetAttrBool (desc, "cancel_pending_enqueues", Convert.ToByte(cancel_pending_enqueues.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="element_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListPopBack'.
		/// </param>
		/// <param name="element_dtype">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_handle:
		///   tensor:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output_handle, TF_Output tensor) TensorListPopBack (TF_Output input_handle, TF_Output element_shape, TF_DataType element_dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListPopBack", MakeName ("TensorListPopBack", operName));
			c_api.TF_AddInput(desc, input_handle);
			c_api.TF_AddInput(desc, element_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "element_dtype", element_dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			var tensor = new TF_Output (op, _idx++);
			return (output_handle, tensor);
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueCloseV2'.
		/// </param>
		/// <param name="cancel_pending_enqueues">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation QueueCloseV2 (TF_Output handle, bool? cancel_pending_enqueues = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueCloseV2", MakeName ("QueueCloseV2", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (cancel_pending_enqueues.HasValue)
				c_api.TF_SetAttrBool (desc, "cancel_pending_enqueues", Convert.ToByte(cancel_pending_enqueues.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="images">
		/// </param>
		/// <param name="contrast_factor">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AdjustContrastv2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AdjustContrastv2 (TF_Output images, TF_Output contrast_factor, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AdjustContrastv2", MakeName ("AdjustContrastv2", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, contrast_factor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueIsClosed'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output QueueIsClosed (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueIsClosed", MakeName ("QueueIsClosed", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var is_closed = new TF_Output (op, _idx++);
			return is_closed;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueSize'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output QueueSize (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueSize", MakeName ("QueueSize", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueSizeV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output QueueSizeV2 (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueSizeV2", MakeName ("QueueSizeV2", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AccumulatorNumAccumulated'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AccumulatorNumAccumulated (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AccumulatorNumAccumulated", MakeName ("AccumulatorNumAccumulated", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var num_accumulated = new TF_Output (op, _idx++);
			return num_accumulated;
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="segment_ids">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SegmentProd'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SegmentProd (TF_Output data, TF_Output segment_ids, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SegmentProd", MakeName ("SegmentProd", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, segment_ids);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="patterns">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatchingFilesDataset'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MatchingFilesDataset (TF_Output patterns, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatchingFilesDataset", MakeName ("MatchingFilesDataset", operName));
			c_api.TF_AddInput(desc, patterns);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="filename">
		/// </param>
		/// <param name="tensor_names">
		/// </param>
		/// <param name="shapes_and_slices">
		/// </param>
		/// <param name="data">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SaveSlices'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation SaveSlices (TF_Output filename, TF_Output tensor_names, TF_Output shapes_and_slices, TF_Output[] data, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SaveSlices", MakeName ("SaveSlices", operName));
			c_api.TF_AddInput(desc, filename);
			c_api.TF_AddInput(desc, tensor_names);
			c_api.TF_AddInput(desc, shapes_and_slices);
			c_api.TF_AddInputList(desc, data[0], data.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ConditionalAccumulator'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="reduction_type">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ConditionalAccumulator (TF_DataType dtype, long[] shape, string container = null, string shared_name = null, string reduction_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ConditionalAccumulator", MakeName ("ConditionalAccumulator", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (reduction_type != null)
				c_api.TF_SetAttrString (desc, "reduction_type", reduction_type);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="local_step">
		/// </param>
		/// <param name="gradient">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AccumulatorApplyGradient'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation AccumulatorApplyGradient (TF_Output handle, TF_Output local_step, TF_Output gradient, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AccumulatorApplyGradient", MakeName ("AccumulatorApplyGradient", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, local_step);
			c_api.TF_AddInput(desc, gradient);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IsFinite'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IsFinite (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IsFinite", MakeName ("IsFinite", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="new_global_step">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceAccumulatorSetGlobalStep'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceAccumulatorSetGlobalStep (TF_Output handle, TF_Output new_global_step, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceAccumulatorSetGlobalStep", MakeName ("ResourceAccumulatorSetGlobalStep", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, new_global_step);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="tensor">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListPushBack'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorListPushBack (TF_Output input_handle, TF_Output tensor, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListPushBack", MakeName ("TensorListPushBack", operName));
			c_api.TF_AddInput(desc, input_handle);
			c_api.TF_AddInput(desc, tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			return output_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="local_step">
		/// </param>
		/// <param name="gradient">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceAccumulatorApplyGradient'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceAccumulatorApplyGradient (TF_Output handle, TF_Output local_step, TF_Output gradient, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceAccumulatorApplyGradient", MakeName ("ResourceAccumulatorApplyGradient", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, local_step);
			c_api.TF_AddInput(desc, gradient);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="m">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="alpha">
		/// </param>
		/// <param name="sign_decay">
		/// </param>
		/// <param name="beta">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAddSign'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ApplyAddSign (TF_Output var, TF_Output m, TF_Output lr, TF_Output alpha, TF_Output sign_decay, TF_Output beta, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyAddSign", MakeName ("ApplyAddSign", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, alpha);
			c_api.TF_AddInput(desc, sign_decay);
			c_api.TF_AddInput(desc, beta);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingFTRLParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters:
		///   accumulators:
		///   linears:
		///   gradient_accumulators:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output parameters, TF_Output accumulators, TF_Output linears, TF_Output gradient_accumulators) RetrieveTPUEmbeddingFTRLParametersGradAccumDebug (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingFTRLParametersGradAccumDebug", MakeName ("RetrieveTPUEmbeddingFTRLParametersGradAccumDebug", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var accumulators = new TF_Output (op, _idx++);
			var linears = new TF_Output (op, _idx++);
			var gradient_accumulators = new TF_Output (op, _idx++);
			return (parameters, accumulators, linears, gradient_accumulators);
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="algorithm">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <param name="counts">
		/// </param>
		/// <param name="probs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatefulRandomBinomial'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StatefulRandomBinomial (TF_Output resource, TF_Output algorithm, TF_Output shape, TF_Output counts, TF_Output probs, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatefulRandomBinomial", MakeName ("StatefulRandomBinomial", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, algorithm);
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, counts);
			c_api.TF_AddInput(desc, probs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringFormat'.
		/// </param>
		/// <param name="template">
		///   Optional argument
		/// </param>
		/// <param name="placeholder">
		///   Optional argument
		/// </param>
		/// <param name="summarize">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StringFormat (TF_Output[] inputs, string template = null, string placeholder = null, long? summarize = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringFormat", MakeName ("StringFormat", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (template != null)
				c_api.TF_SetAttrString (desc, "template", template);
			
			if (placeholder != null)
				c_api.TF_SetAttrString (desc, "placeholder", placeholder);
			
			if (summarize.HasValue)
				c_api.TF_SetAttrInt (desc, "summarize", summarize.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseConditionalAccumulator'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="reduction_type">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseConditionalAccumulator (TF_DataType dtype, long[] shape, string container = null, string shared_name = null, string reduction_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseConditionalAccumulator", MakeName ("SparseConditionalAccumulator", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (reduction_type != null)
				c_api.TF_SetAttrString (desc, "reduction_type", reduction_type);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GreaterEqual'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output GreaterEqual (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GreaterEqual", MakeName ("GreaterEqual", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="local_step">
		/// </param>
		/// <param name="gradient_indices">
		/// </param>
		/// <param name="gradient_values">
		/// </param>
		/// <param name="gradient_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseAccumulatorApplyGradient'.
		/// </param>
		/// <param name="has_known_shape">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation SparseAccumulatorApplyGradient (TF_Output handle, TF_Output local_step, TF_Output gradient_indices, TF_Output gradient_values, TF_Output gradient_shape, bool has_known_shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseAccumulatorApplyGradient", MakeName ("SparseAccumulatorApplyGradient", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, local_step);
			c_api.TF_AddInput(desc, gradient_indices);
			c_api.TF_AddInput(desc, gradient_values);
			c_api.TF_AddInput(desc, gradient_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrBool (desc, "has_known_shape", Convert.ToByte(has_known_shape));
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterNdAdd'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceScatterNdAdd (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceScatterNdAdd", MakeName ("ResourceScatterNdAdd", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="num_required">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseAccumulatorTakeGradient'.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   indices:
		///   values:
		///   shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output indices, TF_Output values, TF_Output shape) SparseAccumulatorTakeGradient (TF_Output handle, TF_Output num_required, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseAccumulatorTakeGradient", MakeName ("SparseAccumulatorTakeGradient", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, num_required);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var indices = new TF_Output (op, _idx++);
			var values = new TF_Output (op, _idx++);
			var shape = new TF_Output (op, _idx++);
			return (indices, values, shape);
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StackCloseV2'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation StackCloseV2 (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StackCloseV2", MakeName ("StackCloseV2", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Stack'.
		/// </param>
		/// <param name="stack_name">
		///   Optional argument
		/// </param>
		/// <param name="elem_type">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Stack (TF_DataType elem_type, string stack_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Stack", MakeName ("Stack", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "elem_type", elem_type);
			if (stack_name != null)
				c_api.TF_SetAttrString (desc, "stack_name", stack_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayV3'.
		/// </param>
		/// <param name="element_shape">
		///   Optional argument
		/// </param>
		/// <param name="dynamic_size">
		///   Optional argument
		/// </param>
		/// <param name="clear_after_read">
		///   Optional argument
		/// </param>
		/// <param name="identical_element_shapes">
		///   Optional argument
		/// </param>
		/// <param name="tensor_array_name">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   handle:
		///   flow:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output handle, TF_Output flow) TensorArrayV3 (TF_Output size, TF_DataType dtype, long[] element_shape = null, bool? dynamic_size = null, bool? clear_after_read = null, bool? identical_element_shapes = null, string tensor_array_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayV3", MakeName ("TensorArrayV3", operName));
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (element_shape != null)
				c_api.TF_SetAttrShape (desc, "element_shape", ref element_shape[0], element_shape.Length);
			
			if (dynamic_size.HasValue)
				c_api.TF_SetAttrBool (desc, "dynamic_size", Convert.ToByte(dynamic_size.Value));
			
			if (clear_after_read.HasValue)
				c_api.TF_SetAttrBool (desc, "clear_after_read", Convert.ToByte(clear_after_read.Value));
			
			if (identical_element_shapes.HasValue)
				c_api.TF_SetAttrBool (desc, "identical_element_shapes", Convert.ToByte(identical_element_shapes.Value));
			
			if (tensor_array_name != null)
				c_api.TF_SetAttrString (desc, "tensor_array_name", tensor_array_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			var flow = new TF_Output (op, _idx++);
			return (handle, flow);
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGradV3'.
		/// </param>
		/// <param name="source">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   grad_handle:
		///   flow_out:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output grad_handle, TF_Output flow_out) TensorArrayGradV3 (TF_Output handle, TF_Output flow_in, string source, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayGradV3", MakeName ("TensorArrayGradV3", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "source", source);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var grad_handle = new TF_Output (op, _idx++);
			var flow_out = new TF_Output (op, _idx++);
			return (grad_handle, flow_out);
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="index">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayWriteV3'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayWriteV3 (TF_Output handle, TF_Output index, TF_Output value, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayWriteV3", MakeName ("TensorArrayWriteV3", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, index);
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var flow_out = new TF_Output (op, _idx++);
			return flow_out;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="index">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayReadV3'.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayReadV3 (TF_Output handle, TF_Output index, TF_Output flow_in, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayReadV3", MakeName ("TensorArrayReadV3", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, index);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			return value;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGatherV3'.
		/// </param>
		/// <param name="element_shape">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayGatherV3 (TF_Output handle, TF_Output indices, TF_Output flow_in, TF_DataType dtype, long[] element_shape = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayGatherV3", MakeName ("TensorArrayGatherV3", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (element_shape != null)
				c_api.TF_SetAttrShape (desc, "element_shape", ref element_shape[0], element_shape.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			return value;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BarrierReadySize'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BarrierReadySize (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BarrierReadySize", MakeName ("BarrierReadySize", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		/// </summary>
		/// <param name="orig_input">
		/// </param>
		/// <param name="orig_output">
		/// </param>
		/// <param name="out_backprop">
		/// </param>
		/// <param name="row_pooling_sequence">
		/// </param>
		/// <param name="col_pooling_sequence">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FractionalMaxPoolGrad'.
		/// </param>
		/// <param name="overlapping">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FractionalMaxPoolGrad (TF_Output orig_input, TF_Output orig_output, TF_Output out_backprop, TF_Output row_pooling_sequence, TF_Output col_pooling_sequence, bool? overlapping = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FractionalMaxPoolGrad", MakeName ("FractionalMaxPoolGrad", operName));
			c_api.TF_AddInput(desc, orig_input);
			c_api.TF_AddInput(desc, orig_output);
			c_api.TF_AddInput(desc, out_backprop);
			c_api.TF_AddInput(desc, row_pooling_sequence);
			c_api.TF_AddInput(desc, col_pooling_sequence);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (overlapping.HasValue)
				c_api.TF_SetAttrBool (desc, "overlapping", Convert.ToByte(overlapping.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayScatterV3'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayScatterV3 (TF_Output handle, TF_Output indices, TF_Output value, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayScatterV3", MakeName ("TensorArrayScatterV3", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var flow_out = new TF_Output (op, _idx++);
			return flow_out;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayCloseV3'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation TensorArrayCloseV3 (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayCloseV3", MakeName ("TensorArrayCloseV3", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RealDiv'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RealDiv (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RealDiv", MakeName ("RealDiv", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayV2'.
		/// </param>
		/// <param name="element_shape">
		///   Optional argument
		/// </param>
		/// <param name="dynamic_size">
		///   Optional argument
		/// </param>
		/// <param name="clear_after_read">
		///   Optional argument
		/// </param>
		/// <param name="tensor_array_name">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayV2 (TF_Output size, TF_DataType dtype, long[] element_shape = null, bool? dynamic_size = null, bool? clear_after_read = null, string tensor_array_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayV2", MakeName ("TensorArrayV2", operName));
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (element_shape != null)
				c_api.TF_SetAttrShape (desc, "element_shape", ref element_shape[0], element_shape.Length);
			
			if (dynamic_size.HasValue)
				c_api.TF_SetAttrBool (desc, "dynamic_size", Convert.ToByte(dynamic_size.Value));
			
			if (clear_after_read.HasValue)
				c_api.TF_SetAttrBool (desc, "clear_after_read", Convert.ToByte(clear_after_read.Value));
			
			if (tensor_array_name != null)
				c_api.TF_SetAttrString (desc, "tensor_array_name", tensor_array_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="orig_input_shape">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AvgPoolGrad'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="ksize">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AvgPoolGrad (TF_Output orig_input_shape, TF_Output grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AvgPoolGrad", MakeName ("AvgPoolGrad", operName));
			c_api.TF_AddInput(desc, orig_input_shape);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGradV2'.
		/// </param>
		/// <param name="source">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayGradV2 (TF_Output handle, TF_Output flow_in, string source, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayGradV2", MakeName ("TensorArrayGradV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "source", source);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var grad_handle = new TF_Output (op, _idx++);
			return grad_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RecordInput'.
		/// </param>
		/// <param name="file_random_seed">
		///   Optional argument
		/// </param>
		/// <param name="file_shuffle_shift_ratio">
		///   Optional argument
		/// </param>
		/// <param name="file_buffer_size">
		///   Optional argument
		/// </param>
		/// <param name="file_parallelism">
		///   Optional argument
		/// </param>
		/// <param name="batch_size">
		///   Optional argument
		/// </param>
		/// <param name="compression_type">
		///   Optional argument
		/// </param>
		/// <param name="file_pattern">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RecordInput (string file_pattern, long? file_random_seed = null, float? file_shuffle_shift_ratio = null, long? file_buffer_size = null, long? file_parallelism = null, long? batch_size = null, string compression_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RecordInput", MakeName ("RecordInput", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "file_pattern", file_pattern);
			if (file_random_seed.HasValue)
				c_api.TF_SetAttrInt (desc, "file_random_seed", file_random_seed.Value);
			
			if (file_shuffle_shift_ratio.HasValue)
				c_api.TF_SetAttrFloat (desc, "file_shuffle_shift_ratio", file_shuffle_shift_ratio.Value);
			
			if (file_buffer_size.HasValue)
				c_api.TF_SetAttrInt (desc, "file_buffer_size", file_buffer_size.Value);
			
			if (file_parallelism.HasValue)
				c_api.TF_SetAttrInt (desc, "file_parallelism", file_parallelism.Value);
			
			if (batch_size.HasValue)
				c_api.TF_SetAttrInt (desc, "batch_size", batch_size.Value);
			
			if (compression_type != null)
				c_api.TF_SetAttrString (desc, "compression_type", compression_type);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var records = new TF_Output (op, _idx++);
			return records;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalUnbatchDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalUnbatchDataset (TF_Output input_dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalUnbatchDataset", MakeName ("ExperimentalUnbatchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="index">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayWrite'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayWrite (TF_Output handle, TF_Output index, TF_Output value, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayWrite", MakeName ("TensorArrayWrite", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, index);
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var flow_out = new TF_Output (op, _idx++);
			return flow_out;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="window_size">
		/// </param>
		/// <param name="window_shift">
		/// </param>
		/// <param name="window_stride">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalSlidingWindowDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalSlidingWindowDataset (TF_Output input_dataset, TF_Output window_size, TF_Output window_shift, TF_Output window_stride, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalSlidingWindowDataset", MakeName ("ExperimentalSlidingWindowDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, window_size);
			c_api.TF_AddInput(desc, window_shift);
			c_api.TF_AddInput(desc, window_stride);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="gradients">
		/// </param>
		/// <param name="features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SoftplusGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SoftplusGrad (TF_Output gradients, TF_Output features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SoftplusGrad", MakeName ("SoftplusGrad", operName));
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var backprops = new TF_Output (op, _idx++);
			return backprops;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="index">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayRead'.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayRead (TF_Output handle, TF_Output index, TF_Output flow_in, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayRead", MakeName ("TensorArrayRead", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, index);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			return value;
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="segment_ids">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SegmentSum'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SegmentSum (TF_Output data, TF_Output segment_ids, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SegmentSum", MakeName ("SegmentSum", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, segment_ids);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Floor'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Floor (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Floor", MakeName ("Floor", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="index">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayReadV2'.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayReadV2 (TF_Output handle, TF_Output index, TF_Output flow_in, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayReadV2", MakeName ("TensorArrayReadV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, index);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			return value;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayPack'.
		/// </param>
		/// <param name="element_shape">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayPack (TF_Output handle, TF_Output flow_in, TF_DataType dtype, long[] element_shape = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayPack", MakeName ("TensorArrayPack", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (element_shape != null)
				c_api.TF_SetAttrShape (desc, "element_shape", ref element_shape[0], element_shape.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			return value;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="buffer_size">
		/// </param>
		/// <param name="seed_generator">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ShuffleDatasetV2'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ShuffleDatasetV2 (TF_Output input_dataset, TF_Output buffer_size, TF_Output seed_generator, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ShuffleDatasetV2", MakeName ("ShuffleDatasetV2", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, buffer_size);
			c_api.TF_AddInput(desc, seed_generator);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGatherV2'.
		/// </param>
		/// <param name="element_shape">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayGatherV2 (TF_Output handle, TF_Output indices, TF_Output flow_in, TF_DataType dtype, long[] element_shape = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayGatherV2", MakeName ("TensorArrayGatherV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (element_shape != null)
				c_api.TF_SetAttrShape (desc, "element_shape", ref element_shape[0], element_shape.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			return value;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorToStringHandle'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IteratorToStringHandle (TF_Output resource_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IteratorToStringHandle", MakeName ("IteratorToStringHandle", operName));
			c_api.TF_AddInput(desc, resource_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var string_handle = new TF_Output (op, _idx++);
			return string_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayScatter'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayScatter (TF_Output handle, TF_Output indices, TF_Output value, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayScatter", MakeName ("TensorArrayScatter", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var flow_out = new TF_Output (op, _idx++);
			return flow_out;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="scale">
		/// </param>
		/// <param name="offset">
		/// </param>
		/// <param name="mean">
		/// </param>
		/// <param name="variance">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedBatchNormV3'.
		/// </param>
		/// <param name="epsilon">
		///   Optional argument
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="is_training">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   y:
		///   batch_mean:
		///   batch_variance:
		///   reserve_space_1:
		///   reserve_space_2:
		///   reserve_space_3:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output y, TF_Output batch_mean, TF_Output batch_variance, TF_Output reserve_space_1, TF_Output reserve_space_2, TF_Output reserve_space_3) FusedBatchNormV3 (TF_Output x, TF_Output scale, TF_Output offset, TF_Output mean, TF_Output variance, float? epsilon = null, string data_format = null, bool? is_training = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FusedBatchNormV3", MakeName ("FusedBatchNormV3", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, scale);
			c_api.TF_AddInput(desc, offset);
			c_api.TF_AddInput(desc, mean);
			c_api.TF_AddInput(desc, variance);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (epsilon.HasValue)
				c_api.TF_SetAttrFloat (desc, "epsilon", epsilon.Value);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (is_training.HasValue)
				c_api.TF_SetAttrBool (desc, "is_training", Convert.ToByte(is_training.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			var batch_mean = new TF_Output (op, _idx++);
			var batch_variance = new TF_Output (op, _idx++);
			var reserve_space_1 = new TF_Output (op, _idx++);
			var reserve_space_2 = new TF_Output (op, _idx++);
			var reserve_space_3 = new TF_Output (op, _idx++);
			return (y, batch_mean, batch_variance, reserve_space_1, reserve_space_2, reserve_space_3);
		}

		/// <summary>
		/// </summary>
		/// <param name="input_indices">
		/// </param>
		/// <param name="input_shape">
		/// </param>
		/// <param name="new_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReshape'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices:
		///   output_shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output_indices, TF_Output output_shape) SparseReshape (TF_Output input_indices, TF_Output input_shape, TF_Output new_shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseReshape", MakeName ("SparseReshape", operName));
			c_api.TF_AddInput(desc, input_indices);
			c_api.TF_AddInput(desc, input_shape);
			c_api.TF_AddInput(desc, new_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_indices = new TF_Output (op, _idx++);
			var output_shape = new TF_Output (op, _idx++);
			return (output_indices, output_shape);
		}

		/// <summary>
		/// </summary>
		/// <param name="sparse_indices">
		/// </param>
		/// <param name="sparse_values">
		/// </param>
		/// <param name="sparse_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AddSparseToTensorsMap'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AddSparseToTensorsMap (TF_Output sparse_indices, TF_Output sparse_values, TF_Output sparse_shape, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AddSparseToTensorsMap", MakeName ("AddSparseToTensorsMap", operName));
			c_api.TF_AddInput(desc, sparse_indices);
			c_api.TF_AddInput(desc, sparse_values);
			c_api.TF_AddInput(desc, sparse_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var sparse_handle = new TF_Output (op, _idx++);
			return sparse_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayScatterV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayScatterV2 (TF_Output handle, TF_Output indices, TF_Output value, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayScatterV2", MakeName ("TensorArrayScatterV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var flow_out = new TF_Output (op, _idx++);
			return flow_out;
		}

		/// <summary>
		/// </summary>
		/// <param name="driver_name">
		/// </param>
		/// <param name="data_source_name">
		/// </param>
		/// <param name="query">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SqlDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SqlDataset (TF_Output driver_name, TF_Output data_source_name, TF_Output query, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SqlDataset", MakeName ("SqlDataset", operName));
			c_api.TF_AddInput(desc, driver_name);
			c_api.TF_AddInput(desc, data_source_name);
			c_api.TF_AddInput(desc, query);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="pattern">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatchingFiles'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MatchingFiles (TF_Output pattern, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatchingFiles", MakeName ("MatchingFiles", operName));
			c_api.TF_AddInput(desc, pattern);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var filenames = new TF_Output (op, _idx++);
			return filenames;
		}

		/// <summary>
		/// </summary>
		/// <param name="a">
		/// </param>
		/// <param name="b">
		/// </param>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Betainc'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Betainc (TF_Output a, TF_Output b, TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Betainc", MakeName ("Betainc", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, b);
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_sizes">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="out_backprop">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv2DBackpropInput'.
		/// </param>
		/// <param name="use_cudnn_on_gpu">
		///   Optional argument
		/// </param>
		/// <param name="explicit_paddings">
		///   Optional argument
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Conv2DBackpropInput (TF_Output input_sizes, TF_Output filter, TF_Output out_backprop, long[] strides, string padding, bool? use_cudnn_on_gpu = null, long[] explicit_paddings = null, string data_format = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Conv2DBackpropInput", MakeName ("Conv2DBackpropInput", operName));
			c_api.TF_AddInput(desc, input_sizes);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (use_cudnn_on_gpu.HasValue)
				c_api.TF_SetAttrBool (desc, "use_cudnn_on_gpu", Convert.ToByte(use_cudnn_on_gpu.Value));
			
			if (explicit_paddings != null)
				c_api.TF_SetAttrIntList (desc, "explicit_paddings", ref explicit_paddings[0], explicit_paddings.Length);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="stats_aggregator">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="counter_prefix">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SetStatsAggregatorDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SetStatsAggregatorDataset (TF_Output input_dataset, TF_Output stats_aggregator, TF_Output tag, TF_Output counter_prefix, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SetStatsAggregatorDataset", MakeName ("SetStatsAggregatorDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, stats_aggregator);
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, counter_prefix);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapClear'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation OrderedMapClear (TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OrderedMapClear", MakeName ("OrderedMapClear", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayConcatV2'.
		/// </param>
		/// <param name="element_shape_except0">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   value:
		///   lengths:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output value, TF_Output lengths) TensorArrayConcatV2 (TF_Output handle, TF_Output flow_in, TF_DataType dtype, long[] element_shape_except0 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayConcatV2", MakeName ("TensorArrayConcatV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (element_shape_except0 != null)
				c_api.TF_SetAttrShape (desc, "element_shape_except0", ref element_shape_except0[0], element_shape_except0.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			var lengths = new TF_Output (op, _idx++);
			return (value, lengths);
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalBytesProducedStatsDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalBytesProducedStatsDataset (TF_Output input_dataset, TF_Output tag, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalBytesProducedStatsDataset", MakeName ("ExperimentalBytesProducedStatsDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, tag);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="lengths">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArraySplitV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArraySplitV2 (TF_Output handle, TF_Output value, TF_Output lengths, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArraySplitV2", MakeName ("TensorArraySplitV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, lengths);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var flow_out = new TF_Output (op, _idx++);
			return flow_out;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="ksize">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolV2'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPoolV2 (TF_Output input, TF_Output ksize, TF_Output strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPoolV2", MakeName ("MaxPoolV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, ksize);
			c_api.TF_AddInput(desc, strides);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="y">
		/// </param>
		/// <param name="dy">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SqrtGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SqrtGrad (TF_Output y, TF_Output dy, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SqrtGrad", MakeName ("SqrtGrad", operName));
			c_api.TF_AddInput(desc, y);
			c_api.TF_AddInput(desc, dy);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArraySize'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArraySize (TF_Output handle, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArraySize", MakeName ("TensorArraySize", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		/// </summary>
		/// <param name="iterator">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorGetNextAsOptional'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IteratorGetNextAsOptional (TF_Output iterator, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IteratorGetNextAsOptional", MakeName ("IteratorGetNextAsOptional", operName));
			c_api.TF_AddInput(desc, iterator);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var optional = new TF_Output (op, _idx++);
			return optional;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArraySizeV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArraySizeV2 (TF_Output handle, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArraySizeV2", MakeName ("TensorArraySizeV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayCloseV2'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation TensorArrayCloseV2 (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayCloseV2", MakeName ("TensorArrayCloseV2", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BarrierClose'.
		/// </param>
		/// <param name="cancel_pending_enqueues">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation BarrierClose (TF_Output handle, bool? cancel_pending_enqueues = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BarrierClose", MakeName ("BarrierClose", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (cancel_pending_enqueues.HasValue)
				c_api.TF_SetAttrBool (desc, "cancel_pending_enqueues", Convert.ToByte(cancel_pending_enqueues.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BarrierIncompleteSize'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BarrierIncompleteSize (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BarrierIncompleteSize", MakeName ("BarrierIncompleteSize", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		/// </summary>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GetSessionHandle'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output GetSessionHandle (TF_Output value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GetSessionHandle", MakeName ("GetSessionHandle", operName));
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GetSessionHandleV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output GetSessionHandleV2 (TF_Output value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GetSessionHandleV2", MakeName ("GetSessionHandleV2", operName));
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="graph_def">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DatasetFromGraph'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DatasetFromGraph (TF_Output graph_def, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DatasetFromGraph", MakeName ("DatasetFromGraph", operName));
			c_api.TF_AddInput(desc, graph_def);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="set1_indices">
		/// </param>
		/// <param name="set1_values">
		/// </param>
		/// <param name="set1_shape">
		/// </param>
		/// <param name="set2_indices">
		/// </param>
		/// <param name="set2_values">
		/// </param>
		/// <param name="set2_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseToSparseSetOperation'.
		/// </param>
		/// <param name="validate_indices">
		///   Optional argument
		/// </param>
		/// <param name="set_operation">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   result_indices:
		///   result_values:
		///   result_shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output result_indices, TF_Output result_values, TF_Output result_shape) SparseToSparseSetOperation (TF_Output set1_indices, TF_Output set1_values, TF_Output set1_shape, TF_Output set2_indices, TF_Output set2_values, TF_Output set2_shape, string set_operation, bool? validate_indices = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseToSparseSetOperation", MakeName ("SparseToSparseSetOperation", operName));
			c_api.TF_AddInput(desc, set1_indices);
			c_api.TF_AddInput(desc, set1_values);
			c_api.TF_AddInput(desc, set1_shape);
			c_api.TF_AddInput(desc, set2_indices);
			c_api.TF_AddInput(desc, set2_values);
			c_api.TF_AddInput(desc, set2_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "set_operation", set_operation);
			if (validate_indices.HasValue)
				c_api.TF_SetAttrBool (desc, "validate_indices", Convert.ToByte(validate_indices.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var result_indices = new TF_Output (op, _idx++);
			var result_values = new TF_Output (op, _idx++);
			var result_shape = new TF_Output (op, _idx++);
			return (result_indices, result_values, result_shape);
		}

		/// <summary>
		/// </summary>
		/// <param name="request">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WorkerHeartbeat'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output WorkerHeartbeat (TF_Output request, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WorkerHeartbeat", MakeName ("WorkerHeartbeat", operName));
			c_api.TF_AddInput(desc, request);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var response = new TF_Output (op, _idx++);
			return response;
		}

		/// <summary>
		/// </summary>
		/// <param name="values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Stage'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation Stage (TF_Output[] values, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Stage", MakeName ("Stage", operName));
			c_api.TF_AddInputList(desc, values[0], values.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="condition">
		/// </param>
		/// <param name="t">
		/// </param>
		/// <param name="e">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Select'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Select (TF_Output condition, TF_Output t, TF_Output e, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Select", MakeName ("Select", operName));
			c_api.TF_AddInput(desc, condition);
			c_api.TF_AddInput(desc, t);
			c_api.TF_AddInput(desc, e);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StageSize'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StageSize (TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StageSize", MakeName ("StageSize", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StageClear'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation StageClear (TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StageClear", MakeName ("StageClear", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Asinh'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Asinh (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Asinh", MakeName ("Asinh", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="logdir">
		/// </param>
		/// <param name="max_queue">
		/// </param>
		/// <param name="flush_millis">
		/// </param>
		/// <param name="filename_suffix">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CreateSummaryFileWriter'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation CreateSummaryFileWriter (TF_Output writer, TF_Output logdir, TF_Output max_queue, TF_Output flush_millis, TF_Output filename_suffix, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CreateSummaryFileWriter", MakeName ("CreateSummaryFileWriter", operName));
			c_api.TF_AddInput(desc, writer);
			c_api.TF_AddInput(desc, logdir);
			c_api.TF_AddInput(desc, max_queue);
			c_api.TF_AddInput(desc, flush_millis);
			c_api.TF_AddInput(desc, filename_suffix);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="key">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MapStage'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation MapStage (TF_Output key, TF_Output indices, TF_Output[] values, TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MapStage", MakeName ("MapStage", operName));
			c_api.TF_AddInput(desc, key);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInputList(desc, values[0], values.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MapSize'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MapSize (TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MapSize", MakeName ("MapSize", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="sleep_microseconds">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SleepDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SleepDataset (TF_Output input_dataset, TF_Output sleep_microseconds, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SleepDataset", MakeName ("SleepDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, sleep_microseconds);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="string_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorFromStringHandle'.
		/// </param>
		/// <param name="output_types">
		///   Optional argument
		/// </param>
		/// <param name="output_shapes">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IteratorFromStringHandle (TF_Output string_handle, TF_DataType[] output_types = null, long[][] output_shapes = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IteratorFromStringHandle", MakeName ("IteratorFromStringHandle", operName));
			c_api.TF_AddInput(desc, string_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (output_types != null)
				c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			
			if (output_shapes != null)
				c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var resource_handle = new TF_Output (op, _idx++);
			return resource_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MapClear'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation MapClear (TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MapClear", MakeName ("MapClear", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Bitcast'.
		/// </param>
		/// <param name="type">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Bitcast (TF_Output input, TF_DataType type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Bitcast", MakeName ("Bitcast", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "type", type);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="a_indices">
		/// </param>
		/// <param name="a_values">
		/// </param>
		/// <param name="a_shape">
		/// </param>
		/// <param name="b_indices">
		/// </param>
		/// <param name="b_values">
		/// </param>
		/// <param name="b_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSparseMaximum'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices:
		///   output_values:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output_indices, TF_Output output_values) SparseSparseMaximum (TF_Output a_indices, TF_Output a_values, TF_Output a_shape, TF_Output b_indices, TF_Output b_values, TF_Output b_shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSparseMaximum", MakeName ("SparseSparseMaximum", operName));
			c_api.TF_AddInput(desc, a_indices);
			c_api.TF_AddInput(desc, a_values);
			c_api.TF_AddInput(desc, a_shape);
			c_api.TF_AddInput(desc, b_indices);
			c_api.TF_AddInput(desc, b_values);
			c_api.TF_AddInput(desc, b_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_indices = new TF_Output (op, _idx++);
			var output_values = new TF_Output (op, _idx++);
			return (output_indices, output_values);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters:
		///   accumulators:
		///   updates:
		///   gradient_accumulators:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output parameters, TF_Output accumulators, TF_Output updates, TF_Output gradient_accumulators) RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug", MakeName ("RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var accumulators = new TF_Output (op, _idx++);
			var updates = new TF_Output (op, _idx++);
			var gradient_accumulators = new TF_Output (op, _idx++);
			return (parameters, accumulators, updates, gradient_accumulators);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapSize'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output OrderedMapSize (TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OrderedMapSize", MakeName ("OrderedMapSize", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		/// </summary>
		/// <param name="dataset">
		/// </param>
		/// <param name="iterator">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MakeIterator'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation MakeIterator (TF_Output dataset, TF_Output iterator, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MakeIterator", MakeName ("MakeIterator", operName));
			c_api.TF_AddInput(desc, dataset);
			c_api.TF_AddInput(desc, iterator);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapIncompleteSize'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output OrderedMapIncompleteSize (TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OrderedMapIncompleteSize", MakeName ("OrderedMapIncompleteSize", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringUpper'.
		/// </param>
		/// <param name="encoding">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StringUpper (TF_Output input, string encoding = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringUpper", MakeName ("StringUpper", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (encoding != null)
				c_api.TF_SetAttrString (desc, "encoding", encoding);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="optional">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OptionalHasValue'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output OptionalHasValue (TF_Output optional, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OptionalHasValue", MakeName ("OptionalHasValue", operName));
			c_api.TF_AddInput(desc, optional);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var has_value = new TF_Output (op, _idx++);
			return has_value;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IdentityReader'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IdentityReader (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IdentityReader", MakeName ("IdentityReader", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="components">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorDataset'.
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorDataset (TF_Output[] components, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorDataset", MakeName ("TensorDataset", operName));
			c_api.TF_AddInputList(desc, components[0], components.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="components">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorSliceDataset'.
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorSliceDataset (TF_Output[] components, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorSliceDataset", MakeName ("TensorSliceDataset", operName));
			c_api.TF_AddInputList(desc, components[0], components.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="address">
		/// </param>
		/// <param name="method">
		/// </param>
		/// <param name="request">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Rpc'.
		/// </param>
		/// <param name="protocol">
		///   Optional argument
		/// </param>
		/// <param name="fail_fast">
		///   Optional argument
		/// </param>
		/// <param name="timeout_in_ms">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Rpc (TF_Output address, TF_Output method, TF_Output request, string protocol = null, bool? fail_fast = null, long? timeout_in_ms = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Rpc", MakeName ("Rpc", operName));
			c_api.TF_AddInput(desc, address);
			c_api.TF_AddInput(desc, method);
			c_api.TF_AddInput(desc, request);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (protocol != null)
				c_api.TF_SetAttrString (desc, "protocol", protocol);
			
			if (fail_fast.HasValue)
				c_api.TF_SetAttrBool (desc, "fail_fast", Convert.ToByte(fail_fast.Value));
			
			if (timeout_in_ms.HasValue)
				c_api.TF_SetAttrInt (desc, "timeout_in_ms", timeout_in_ms.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var response = new TF_Output (op, _idx++);
			return response;
		}

		/// <summary>
		/// </summary>
		/// <param name="dataset">
		/// </param>
		/// <param name="multi_device_iterator">
		/// </param>
		/// <param name="max_buffer_size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MultiDeviceIteratorInit'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MultiDeviceIteratorInit (TF_Output dataset, TF_Output multi_device_iterator, TF_Output max_buffer_size, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MultiDeviceIteratorInit", MakeName ("MultiDeviceIteratorInit", operName));
			c_api.TF_AddInput(desc, dataset);
			c_api.TF_AddInput(desc, multi_device_iterator);
			c_api.TF_AddInput(desc, max_buffer_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var incarnation_id = new TF_Output (op, _idx++);
			return incarnation_id;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_datasets">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ZipDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ZipDataset (TF_Output[] input_datasets, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ZipDataset", MakeName ("ZipDataset", operName));
			c_api.TF_AddInputList(desc, input_datasets[0], input_datasets.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="count">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SkipDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SkipDataset (TF_Output input_dataset, TF_Output count, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SkipDataset", MakeName ("SkipDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, count);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="db_uri">
		/// </param>
		/// <param name="experiment_name">
		/// </param>
		/// <param name="run_name">
		/// </param>
		/// <param name="user_name">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CreateSummaryDbWriter'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation CreateSummaryDbWriter (TF_Output writer, TF_Output db_uri, TF_Output experiment_name, TF_Output run_name, TF_Output user_name, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CreateSummaryDbWriter", MakeName ("CreateSummaryDbWriter", operName));
			c_api.TF_AddInput(desc, writer);
			c_api.TF_AddInput(desc, db_uri);
			c_api.TF_AddInput(desc, experiment_name);
			c_api.TF_AddInput(desc, run_name);
			c_api.TF_AddInput(desc, user_name);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="a">
		/// </param>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Igammac'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Igammac (TF_Output a, TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Igammac", MakeName ("Igammac", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="buffer_size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PrefetchDataset'.
		/// </param>
		/// <param name="slack_period">
		///   Optional argument
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output PrefetchDataset (TF_Output input_dataset, TF_Output buffer_size, TF_DataType[] output_types, long[][] output_shapes, long? slack_period = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PrefetchDataset", MakeName ("PrefetchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, buffer_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (slack_period.HasValue)
				c_api.TF_SetAttrInt (desc, "slack_period", slack_period.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_sizes">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="out_backprop">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv3DBackpropInputV2'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Conv3DBackpropInputV2 (TF_Output input_sizes, TF_Output filter, TF_Output out_backprop, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Conv3DBackpropInputV2", MakeName ("Conv3DBackpropInputV2", operName));
			c_api.TF_AddInput(desc, input_sizes);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="gradient_accumulator">
		/// </param>
		/// <param name="gradient_squared_accumulator">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="global_step">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyAdagradDA'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceSparseApplyAdagradDA (TF_Output var, TF_Output gradient_accumulator, TF_Output gradient_squared_accumulator, TF_Output grad, TF_Output indices, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output global_step, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyAdagradDA", MakeName ("ResourceSparseApplyAdagradDA", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, gradient_accumulator);
			c_api.TF_AddInput(desc, gradient_squared_accumulator);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, global_step);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Expm1'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Expm1 (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Expm1", MakeName ("Expm1", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FilterByLastComponentDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FilterByLastComponentDataset (TF_Output input_dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FilterByLastComponentDataset", MakeName ("FilterByLastComponentDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="size">
		/// </param>
		/// <param name="shift">
		/// </param>
		/// <param name="stride">
		/// </param>
		/// <param name="drop_remainder">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WindowDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output WindowDataset (TF_Output input_dataset, TF_Output size, TF_Output shift, TF_Output stride, TF_Output drop_remainder, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WindowDataset", MakeName ("WindowDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, size);
			c_api.TF_AddInput(desc, shift);
			c_api.TF_AddInput(desc, stride);
			c_api.TF_AddInput(desc, drop_remainder);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="deleter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DeleteRandomSeedGenerator'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation DeleteRandomSeedGenerator (TF_Output handle, TF_Output deleter, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DeleteRandomSeedGenerator", MakeName ("DeleteRandomSeedGenerator", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, deleter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="batch_size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchDataset (TF_Output input_dataset, TF_Output batch_size, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchDataset", MakeName ("BatchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, batch_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DatasetCardinality'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DatasetCardinality (TF_Output input_dataset, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DatasetCardinality", MakeName ("DatasetCardinality", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var cardinality = new TF_Output (op, _idx++);
			return cardinality;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="batch_size">
		/// </param>
		/// <param name="drop_remainder">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchDatasetV2'.
		/// </param>
		/// <param name="parallel_copy">
		///   Optional argument
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchDatasetV2 (TF_Output input_dataset, TF_Output batch_size, TF_Output drop_remainder, TF_DataType[] output_types, long[][] output_shapes, bool? parallel_copy = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchDatasetV2", MakeName ("BatchDatasetV2", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, batch_size);
			c_api.TF_AddInput(desc, drop_remainder);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (parallel_copy.HasValue)
				c_api.TF_SetAttrBool (desc, "parallel_copy", Convert.ToByte(parallel_copy.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="contents">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExtractJpegShape'.
		/// </param>
		/// <param name="output_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExtractJpegShape (TF_Output contents, TF_DataType? output_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExtractJpegShape", MakeName ("ExtractJpegShape", operName));
			c_api.TF_AddInput(desc, contents);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (output_type.HasValue)
				c_api.TF_SetAttrType (desc, "output_type", output_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var image_shape = new TF_Output (op, _idx++);
			return image_shape;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="index">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ShardDataset'.
		/// </param>
		/// <param name="require_non_empty">
		///   Optional argument
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ShardDataset (TF_Output input_dataset, TF_Output num_shards, TF_Output index, TF_DataType[] output_types, long[][] output_shapes, bool? require_non_empty = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ShardDataset", MakeName ("ShardDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, num_shards);
			c_api.TF_AddInput(desc, index);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (require_non_empty.HasValue)
				c_api.TF_SetAttrBool (desc, "require_non_empty", Convert.ToByte(require_non_empty.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="driver_name">
		/// </param>
		/// <param name="data_source_name">
		/// </param>
		/// <param name="query">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalSqlDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalSqlDataset (TF_Output driver_name, TF_Output data_source_name, TF_Output query, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalSqlDataset", MakeName ("ExperimentalSqlDataset", operName));
			c_api.TF_AddInput(desc, driver_name);
			c_api.TF_AddInput(desc, data_source_name);
			c_api.TF_AddInput(desc, query);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OptionalNone'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output OptionalNone (string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OptionalNone", MakeName ("OptionalNone", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var optional = new TF_Output (op, _idx++);
			return optional;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="batch_size">
		/// </param>
		/// <param name="padded_shapes">
		/// </param>
		/// <param name="padding_values">
		/// </param>
		/// <param name="drop_remainder">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PaddedBatchDatasetV2'.
		/// </param>
		/// <param name="parallel_copy">
		///   Optional argument
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output PaddedBatchDatasetV2 (TF_Output input_dataset, TF_Output batch_size, TF_Output[] padded_shapes, TF_Output[] padding_values, TF_Output drop_remainder, long[][] output_shapes, bool? parallel_copy = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PaddedBatchDatasetV2", MakeName ("PaddedBatchDatasetV2", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, batch_size);
			c_api.TF_AddInputList(desc, padded_shapes[0], padded_shapes.Length);
			c_api.TF_AddInputList(desc, padding_values[0], padding_values.Length);
			c_api.TF_AddInput(desc, drop_remainder);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (parallel_copy.HasValue)
				c_api.TF_SetAttrBool (desc, "parallel_copy", Convert.ToByte(parallel_copy.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="alpha">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="delta">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyProximalGradientDescent'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceApplyProximalGradientDescent (TF_Output var, TF_Output alpha, TF_Output l1, TF_Output l2, TF_Output delta, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyProximalGradientDescent", MakeName ("ResourceApplyProximalGradientDescent", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, alpha);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, delta);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="deleter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DeleteMemoryCache'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation DeleteMemoryCache (TF_Output handle, TF_Output deleter, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DeleteMemoryCache", MakeName ("DeleteMemoryCache", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, deleter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="filename">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CacheDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CacheDataset (TF_Output input_dataset, TF_Output filename, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CacheDataset", MakeName ("CacheDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, filename);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="filenames">
		/// </param>
		/// <param name="compression_type">
		/// </param>
		/// <param name="buffer_size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TextLineDataset'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TextLineDataset (TF_Output filenames, TF_Output compression_type, TF_Output buffer_size, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TextLineDataset", MakeName ("TextLineDataset", operName));
			c_api.TF_AddInput(desc, filenames);
			c_api.TF_AddInput(desc, compression_type);
			c_api.TF_AddInput(desc, buffer_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="filenames">
		/// </param>
		/// <param name="compression_type">
		/// </param>
		/// <param name="buffer_size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TFRecordDataset'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TFRecordDataset (TF_Output filenames, TF_Output compression_type, TF_Output buffer_size, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TFRecordDataset", MakeName ("TFRecordDataset", operName));
			c_api.TF_AddInput(desc, filenames);
			c_api.TF_AddInput(desc, compression_type);
			c_api.TF_AddInput(desc, buffer_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="reader_handle">
		/// </param>
		/// <param name="queue_handle">
		/// </param>
		/// <param name="num_records">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderReadUpTo'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   keys:
		///   values:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output keys, TF_Output values) ReaderReadUpTo (TF_Output reader_handle, TF_Output queue_handle, TF_Output num_records, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderReadUpTo", MakeName ("ReaderReadUpTo", operName));
			c_api.TF_AddInput(desc, reader_handle);
			c_api.TF_AddInput(desc, queue_handle);
			c_api.TF_AddInput(desc, num_records);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var keys = new TF_Output (op, _idx++);
			var values = new TF_Output (op, _idx++);
			return (keys, values);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Iterator'.
		/// </param>
		/// <param name="shared_name">
		/// </param>
		/// <param name="container">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Iterator (string shared_name, string container, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Iterator", MakeName ("Iterator", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			c_api.TF_SetAttrString (desc, "container", container);
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorV2'.
		/// </param>
		/// <param name="shared_name">
		/// </param>
		/// <param name="container">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IteratorV2 (string shared_name, string container, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IteratorV2", MakeName ("IteratorV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			c_api.TF_SetAttrString (desc, "container", container);
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="mutex">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MutexLock'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MutexLock (TF_Output mutex, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MutexLock", MakeName ("MutexLock", operName));
			c_api.TF_AddInput(desc, mutex);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var mutex_lock = new TF_Output (op, _idx++);
			return mutex_lock;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AnonymousIterator'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AnonymousIterator (TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AnonymousIterator", MakeName ("AnonymousIterator", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AnonymousIteratorV2'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   handle:
		///   deleter:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output handle, TF_Output deleter) AnonymousIteratorV2 (TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AnonymousIteratorV2", MakeName ("AnonymousIteratorV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			var deleter = new TF_Output (op, _idx++);
			return (handle, deleter);
		}

		/// <summary>
		/// </summary>
		/// <param name="logits">
		/// </param>
		/// <param name="num_samples">
		/// </param>
		/// <param name="seed">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatelessMultinomial'.
		/// </param>
		/// <param name="output_dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StatelessMultinomial (TF_Output logits, TF_Output num_samples, TF_Output seed, TF_DataType? output_dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatelessMultinomial", MakeName ("StatelessMultinomial", operName));
			c_api.TF_AddInput(desc, logits);
			c_api.TF_AddInput(desc, num_samples);
			c_api.TF_AddInput(desc, seed);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (output_dtype.HasValue)
				c_api.TF_SetAttrType (desc, "output_dtype", output_dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="multi_device_iterator">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MultiDeviceIteratorToStringHandle'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MultiDeviceIteratorToStringHandle (TF_Output multi_device_iterator, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MultiDeviceIteratorToStringHandle", MakeName ("MultiDeviceIteratorToStringHandle", operName));
			c_api.TF_AddInput(desc, multi_device_iterator);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var string_handle = new TF_Output (op, _idx++);
			return string_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="deleter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DeleteIterator'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation DeleteIterator (TF_Output handle, TF_Output deleter, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DeleteIterator", MakeName ("DeleteIterator", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, deleter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="argmax">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGradWithArgmax'.
		/// </param>
		/// <param name="include_batch_in_index">
		///   Optional argument
		/// </param>
		/// <param name="ksize">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPoolGradWithArgmax (TF_Output input, TF_Output grad, TF_Output argmax, long[] ksize, long[] strides, string padding, bool? include_batch_in_index = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPoolGradWithArgmax", MakeName ("MaxPoolGradWithArgmax", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, argmax);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (include_batch_in_index.HasValue)
				c_api.TF_SetAttrBool (desc, "include_batch_in_index", Convert.ToByte(include_batch_in_index.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="images">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RGBToHSV'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RGBToHSV (TF_Output images, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RGBToHSV", MakeName ("RGBToHSV", operName));
			c_api.TF_AddInput(desc, images);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalIgnoreErrorsDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalIgnoreErrorsDataset (TF_Output input_dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalIgnoreErrorsDataset", MakeName ("ExperimentalIgnoreErrorsDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LatencyStatsDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LatencyStatsDataset (TF_Output input_dataset, TF_Output tag, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LatencyStatsDataset", MakeName ("LatencyStatsDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, tag);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DPerChannel'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DPerChannel (TF_Output input, TF_Output filter, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DPerChannel", MakeName ("QuantizedConv2DPerChannel", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="string_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorFromStringHandleV2'.
		/// </param>
		/// <param name="output_types">
		///   Optional argument
		/// </param>
		/// <param name="output_shapes">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IteratorFromStringHandleV2 (TF_Output string_handle, TF_DataType[] output_types = null, long[][] output_shapes = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IteratorFromStringHandleV2", MakeName ("IteratorFromStringHandleV2", operName));
			c_api.TF_AddInput(desc, string_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (output_types != null)
				c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			
			if (output_shapes != null)
				c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var resource_handle = new TF_Output (op, _idx++);
			return resource_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="filenames">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalLMDBDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalLMDBDataset (TF_Output filenames, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalLMDBDataset", MakeName ("ExperimentalLMDBDataset", operName));
			c_api.TF_AddInput(desc, filenames);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="matrix">
		/// </param>
		/// <param name="rhs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatrixTriangularSolve'.
		/// </param>
		/// <param name="lower">
		///   Optional argument
		/// </param>
		/// <param name="adjoint">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchMatrixTriangularSolve (TF_Output matrix, TF_Output rhs, bool? lower = null, bool? adjoint = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatrixTriangularSolve", MakeName ("BatchMatrixTriangularSolve", operName));
			c_api.TF_AddInput(desc, matrix);
			c_api.TF_AddInput(desc, rhs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (lower.HasValue)
				c_api.TF_SetAttrBool (desc, "lower", Convert.ToByte(lower.Value));
			
			if (adjoint.HasValue)
				c_api.TF_SetAttrBool (desc, "adjoint", Convert.ToByte(adjoint.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="optimizations">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OptimizeDataset'.
		/// </param>
		/// <param name="optimization_configs">
		///   Optional argument
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output OptimizeDataset (TF_Output input_dataset, TF_Output optimizations, TF_DataType[] output_types, long[][] output_shapes, string[] optimization_configs = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OptimizeDataset", MakeName ("OptimizeDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, optimizations);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (optimization_configs != null)
				c_api.TF_SetAttrStringList (desc, "optimization_configs", optimization_configs);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UniqueDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output UniqueDataset (TF_Output input_dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UniqueDataset", MakeName ("UniqueDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NotEqual'.
		/// </param>
		/// <param name="incompatible_shape_error">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output NotEqual (TF_Output x, TF_Output y, bool? incompatible_shape_error = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NotEqual", MakeName ("NotEqual", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (incompatible_shape_error.HasValue)
				c_api.TF_SetAttrBool (desc, "incompatible_shape_error", Convert.ToByte(incompatible_shape_error.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="start">
		/// </param>
		/// <param name="stop">
		/// </param>
		/// <param name="num">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LinSpace'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LinSpace (TF_Output start, TF_Output stop, TF_Output num, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LinSpace", MakeName ("LinSpace", operName));
			c_api.TF_AddInput(desc, start);
			c_api.TF_AddInput(desc, stop);
			c_api.TF_AddInput(desc, num);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="components">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OptionalFromValue'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output OptionalFromValue (TF_Output[] components, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OptionalFromValue", MakeName ("OptionalFromValue", operName));
			c_api.TF_AddInputList(desc, components[0], components.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var optional = new TF_Output (op, _idx++);
			return optional;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ModelDataset'.
		/// </param>
		/// <param name="algorithm">
		///   Optional argument
		/// </param>
		/// <param name="cpu_budget">
		///   Optional argument
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ModelDataset (TF_Output input_dataset, TF_DataType[] output_types, long[][] output_shapes, long? algorithm = null, long? cpu_budget = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ModelDataset", MakeName ("ModelDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (algorithm.HasValue)
				c_api.TF_SetAttrInt (desc, "algorithm", algorithm.Value);
			
			if (cpu_budget.HasValue)
				c_api.TF_SetAttrInt (desc, "cpu_budget", cpu_budget.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MulNoNan'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MulNoNan (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MulNoNan", MakeName ("MulNoNan", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="sizes">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodeProto'.
		/// </param>
		/// <param name="descriptor_source">
		///   Optional argument
		/// </param>
		/// <param name="field_names">
		/// </param>
		/// <param name="message_type">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output EncodeProto (TF_Output sizes, TF_Output[] values, string[] field_names, string message_type, string descriptor_source = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EncodeProto", MakeName ("EncodeProto", operName));
			c_api.TF_AddInput(desc, sizes);
			c_api.TF_AddInputList(desc, values[0], values.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrStringList (desc, "field_names", field_names);
			c_api.TF_SetAttrString (desc, "message_type", message_type);
			if (descriptor_source != null)
				c_api.TF_SetAttrString (desc, "descriptor_source", descriptor_source);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var bytes = new TF_Output (op, _idx++);
			return bytes;
		}

		/// <summary>
		/// </summary>
		/// <param name="iterator">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatsAggregatorSummary'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StatsAggregatorSummary (TF_Output iterator, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatsAggregatorSummary", MakeName ("StatsAggregatorSummary", operName));
			c_api.TF_AddInput(desc, iterator);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var summary = new TF_Output (op, _idx++);
			return summary;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="transformations">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AssertNextDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AssertNextDataset (TF_Output input_dataset, TF_Output transformations, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AssertNextDataset", MakeName ("AssertNextDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, transformations);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="transformations">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalAssertNextDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalAssertNextDataset (TF_Output input_dataset, TF_Output transformations, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalAssertNextDataset", MakeName ("ExperimentalAssertNextDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, transformations);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="image">
		/// </param>
		/// <param name="size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomCrop'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RandomCrop (TF_Output image, TF_Output size, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomCrop", MakeName ("RandomCrop", operName));
			c_api.TF_AddInput(desc, image);
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="num_workers">
		/// </param>
		/// <param name="index">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalAutoShardDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalAutoShardDataset (TF_Output input_dataset, TF_Output num_workers, TF_Output index, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalAutoShardDataset", MakeName ("ExperimentalAutoShardDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, num_workers);
			c_api.TF_AddInput(desc, index);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_datasets">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalChooseFastestDataset'.
		/// </param>
		/// <param name="num_experiments">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalChooseFastestDataset (TF_Output[] input_datasets, long num_experiments, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalChooseFastestDataset", MakeName ("ExperimentalChooseFastestDataset", operName));
			c_api.TF_AddInputList(desc, input_datasets[0], input_datasets.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_experiments", num_experiments);
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="a">
		/// </param>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IgammaGradA'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IgammaGradA (TF_Output a, TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IgammaGradA", MakeName ("IgammaGradA", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="h_prev">
		/// </param>
		/// <param name="w_ru">
		/// </param>
		/// <param name="w_c">
		/// </param>
		/// <param name="b_ru">
		/// </param>
		/// <param name="b_c">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GRUBlockCell'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   r:
		///   u:
		///   c:
		///   h:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output r, TF_Output u, TF_Output c, TF_Output h) GRUBlockCell (TF_Output x, TF_Output h_prev, TF_Output w_ru, TF_Output w_c, TF_Output b_ru, TF_Output b_c, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GRUBlockCell", MakeName ("GRUBlockCell", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, h_prev);
			c_api.TF_AddInput(desc, w_ru);
			c_api.TF_AddInput(desc, w_c);
			c_api.TF_AddInput(desc, b_ru);
			c_api.TF_AddInput(desc, b_c);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var r = new TF_Output (op, _idx++);
			var u = new TF_Output (op, _idx++);
			var c = new TF_Output (op, _idx++);
			var h = new TF_Output (op, _idx++);
			return (r, u, c, h);
		}

		/// <summary>
		/// </summary>
		/// <param name="filenames">
		/// </param>
		/// <param name="compression_type">
		/// </param>
		/// <param name="buffer_size">
		/// </param>
		/// <param name="header">
		/// </param>
		/// <param name="field_delim">
		/// </param>
		/// <param name="use_quote_delim">
		/// </param>
		/// <param name="na_value">
		/// </param>
		/// <param name="select_cols">
		/// </param>
		/// <param name="record_defaults">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CSVDataset'.
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CSVDataset (TF_Output filenames, TF_Output compression_type, TF_Output buffer_size, TF_Output header, TF_Output field_delim, TF_Output use_quote_delim, TF_Output na_value, TF_Output select_cols, TF_Output[] record_defaults, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CSVDataset", MakeName ("CSVDataset", operName));
			c_api.TF_AddInput(desc, filenames);
			c_api.TF_AddInput(desc, compression_type);
			c_api.TF_AddInput(desc, buffer_size);
			c_api.TF_AddInput(desc, header);
			c_api.TF_AddInput(desc, field_delim);
			c_api.TF_AddInput(desc, use_quote_delim);
			c_api.TF_AddInput(desc, na_value);
			c_api.TF_AddInput(desc, select_cols);
			c_api.TF_AddInputList(desc, record_defaults[0], record_defaults.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="t">
		/// </param>
		/// <param name="m">
		/// </param>
		/// <param name="v">
		/// </param>
		/// <param name="gamma">
		/// </param>
		/// <param name="backprop">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchNormWithGlobalNormalizationGrad'.
		/// </param>
		/// <param name="variance_epsilon">
		/// </param>
		/// <param name="scale_after_normalization">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   dx:
		///   dm:
		///   dv:
		///   db:
		///   dg:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output dx, TF_Output dm, TF_Output dv, TF_Output db, TF_Output dg) BatchNormWithGlobalNormalizationGrad (TF_Output t, TF_Output m, TF_Output v, TF_Output gamma, TF_Output backprop, float variance_epsilon, bool scale_after_normalization, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchNormWithGlobalNormalizationGrad", MakeName ("BatchNormWithGlobalNormalizationGrad", operName));
			c_api.TF_AddInput(desc, t);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, v);
			c_api.TF_AddInput(desc, gamma);
			c_api.TF_AddInput(desc, backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFloat (desc, "variance_epsilon", variance_epsilon);
			c_api.TF_SetAttrBool (desc, "scale_after_normalization", Convert.ToByte(scale_after_normalization));
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var dx = new TF_Output (op, _idx++);
			var dm = new TF_Output (op, _idx++);
			var dv = new TF_Output (op, _idx++);
			var db = new TF_Output (op, _idx++);
			var dg = new TF_Output (op, _idx++);
			return (dx, dm, dv, db, dg);
		}

		/// <summary>
		/// </summary>
		/// <param name="filenames">
		/// </param>
		/// <param name="compression_type">
		/// </param>
		/// <param name="buffer_size">
		/// </param>
		/// <param name="header">
		/// </param>
		/// <param name="field_delim">
		/// </param>
		/// <param name="use_quote_delim">
		/// </param>
		/// <param name="na_value">
		/// </param>
		/// <param name="select_cols">
		/// </param>
		/// <param name="record_defaults">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalCSVDataset'.
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalCSVDataset (TF_Output filenames, TF_Output compression_type, TF_Output buffer_size, TF_Output header, TF_Output field_delim, TF_Output use_quote_delim, TF_Output na_value, TF_Output select_cols, TF_Output[] record_defaults, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalCSVDataset", MakeName ("ExperimentalCSVDataset", operName));
			c_api.TF_AddInput(desc, filenames);
			c_api.TF_AddInput(desc, compression_type);
			c_api.TF_AddInput(desc, buffer_size);
			c_api.TF_AddInput(desc, header);
			c_api.TF_AddInput(desc, field_delim);
			c_api.TF_AddInput(desc, use_quote_delim);
			c_api.TF_AddInput(desc, na_value);
			c_api.TF_AddInput(desc, select_cols);
			c_api.TF_AddInputList(desc, record_defaults[0], record_defaults.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="filename">
		/// </param>
		/// <param name="compression_type">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DatasetToTFRecord'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation DatasetToTFRecord (TF_Output input_dataset, TF_Output filename, TF_Output compression_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DatasetToTFRecord", MakeName ("DatasetToTFRecord", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, filename);
			c_api.TF_AddInput(desc, compression_type);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Acos'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Acos (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Acos", MakeName ("Acos", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="filename">
		/// </param>
		/// <param name="compression_type">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalDatasetToTFRecord'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ExperimentalDatasetToTFRecord (TF_Output input_dataset, TF_Output filename, TF_Output compression_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalDatasetToTFRecord", MakeName ("ExperimentalDatasetToTFRecord", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, filename);
			c_api.TF_AddInput(desc, compression_type);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="batch_size">
		/// </param>
		/// <param name="row_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalDenseToSparseBatchDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalDenseToSparseBatchDataset (TF_Output input_dataset, TF_Output batch_size, TF_Output row_shape, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalDenseToSparseBatchDataset", MakeName ("ExperimentalDenseToSparseBatchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, batch_size);
			c_api.TF_AddInput(desc, row_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="window_size">
		/// </param>
		/// <param name="window_shift">
		/// </param>
		/// <param name="window_stride">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SlidingWindowDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SlidingWindowDataset (TF_Output input_dataset, TF_Output window_size, TF_Output window_shift, TF_Output window_stride, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SlidingWindowDataset", MakeName ("SlidingWindowDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, window_size);
			c_api.TF_AddInput(desc, window_shift);
			c_api.TF_AddInput(desc, window_stride);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorGetDevice'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IteratorGetDevice (TF_Output resource, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IteratorGetDevice", MakeName ("IteratorGetDevice", operName));
			c_api.TF_AddInput(desc, resource);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var device = new TF_Output (op, _idx++);
			return device;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IgnoreErrorsDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IgnoreErrorsDataset (TF_Output input_dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IgnoreErrorsDataset", MakeName ("IgnoreErrorsDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="filenames">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LMDBDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LMDBDataset (TF_Output filenames, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LMDBDataset", MakeName ("LMDBDataset", operName));
			c_api.TF_AddInput(desc, filenames);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="max_intra_op_parallelism">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxIntraOpParallelismDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxIntraOpParallelismDataset (TF_Output input_dataset, TF_Output max_intra_op_parallelism, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxIntraOpParallelismDataset", MakeName ("MaxIntraOpParallelismDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, max_intra_op_parallelism);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="max_intra_op_parallelism">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalMaxIntraOpParallelismDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalMaxIntraOpParallelismDataset (TF_Output input_dataset, TF_Output max_intra_op_parallelism, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalMaxIntraOpParallelismDataset", MakeName ("ExperimentalMaxIntraOpParallelismDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, max_intra_op_parallelism);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="num_parallel_calls">
		/// </param>
		/// <param name="dense_defaults">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ParseExampleDataset'.
		/// </param>
		/// <param name="sloppy">
		///   Optional argument
		/// </param>
		/// <param name="sparse_keys">
		/// </param>
		/// <param name="dense_keys">
		/// </param>
		/// <param name="sparse_types">
		/// </param>
		/// <param name="dense_shapes">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ParseExampleDataset (TF_Output input_dataset, TF_Output num_parallel_calls, TF_Output[] dense_defaults, string[] sparse_keys, string[] dense_keys, TF_DataType[] sparse_types, long[][] dense_shapes, TF_DataType[] output_types, long[][] output_shapes, bool? sloppy = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ParseExampleDataset", MakeName ("ParseExampleDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, num_parallel_calls);
			c_api.TF_AddInputList(desc, dense_defaults[0], dense_defaults.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrStringList (desc, "sparse_keys", sparse_keys);
			c_api.TF_SetAttrStringList (desc, "dense_keys", dense_keys);
			c_api.TF_SetAttrTypeList (desc, "sparse_types", sparse_types);
			c_api.TF_SetAttrShapeList (desc, "dense_shapes", dense_shapes);
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (sloppy.HasValue)
				c_api.TF_SetAttrBool (desc, "sloppy", Convert.ToByte(sloppy.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="out_backprop">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv3DBackpropInput'.
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Conv3DBackpropInput (TF_Output input, TF_Output filter, TF_Output out_backprop, long[] strides, string padding, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Conv3DBackpropInput", MakeName ("Conv3DBackpropInput", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TruncateDiv'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TruncateDiv (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TruncateDiv", MakeName ("TruncateDiv", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="num_parallel_calls">
		/// </param>
		/// <param name="dense_defaults">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalParseExampleDataset'.
		/// </param>
		/// <param name="sloppy">
		///   Optional argument
		/// </param>
		/// <param name="sparse_keys">
		/// </param>
		/// <param name="dense_keys">
		/// </param>
		/// <param name="sparse_types">
		/// </param>
		/// <param name="dense_shapes">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalParseExampleDataset (TF_Output input_dataset, TF_Output num_parallel_calls, TF_Output[] dense_defaults, string[] sparse_keys, string[] dense_keys, TF_DataType[] sparse_types, long[][] dense_shapes, TF_DataType[] output_types, long[][] output_shapes, bool? sloppy = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalParseExampleDataset", MakeName ("ExperimentalParseExampleDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, num_parallel_calls);
			c_api.TF_AddInputList(desc, dense_defaults[0], dense_defaults.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrStringList (desc, "sparse_keys", sparse_keys);
			c_api.TF_SetAttrStringList (desc, "dense_keys", dense_keys);
			c_api.TF_SetAttrTypeList (desc, "sparse_types", sparse_types);
			c_api.TF_SetAttrShapeList (desc, "dense_shapes", dense_shapes);
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (sloppy.HasValue)
				c_api.TF_SetAttrBool (desc, "sloppy", Convert.ToByte(sloppy.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceCountUpTo'.
		/// </param>
		/// <param name="limit">
		/// </param>
		/// <param name="T">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ResourceCountUpTo (TF_Output resource, long limit, TF_DataType T, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceCountUpTo", MakeName ("ResourceCountUpTo", operName));
			c_api.TF_AddInput(desc, resource);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "limit", limit);
			c_api.TF_SetAttrType (desc, "T", T);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Angle'.
		/// </param>
		/// <param name="Tout">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Angle (TF_Output input, TF_DataType? Tout = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Angle", MakeName ("Angle", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Tout.HasValue)
				c_api.TF_SetAttrType (desc, "Tout", Tout.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="seed">
		/// </param>
		/// <param name="seed2">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalRandomDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalRandomDataset (TF_Output seed, TF_Output seed2, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalRandomDataset", MakeName ("ExperimentalRandomDataset", operName));
			c_api.TF_AddInput(desc, seed);
			c_api.TF_AddInput(desc, seed2);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="sleep_microseconds">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalSleepDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalSleepDataset (TF_Output input_dataset, TF_Output sleep_microseconds, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalSleepDataset", MakeName ("ExperimentalSleepDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, sleep_microseconds);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="y_backprop">
		/// </param>
		/// <param name="x">
		/// </param>
		/// <param name="scale">
		/// </param>
		/// <param name="reserve_space_1">
		/// </param>
		/// <param name="reserve_space_2">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedBatchNormGradV2'.
		/// </param>
		/// <param name="epsilon">
		///   Optional argument
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="is_training">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   x_backprop:
		///   scale_backprop:
		///   offset_backprop:
		///   reserve_space_3:
		///   reserve_space_4:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output x_backprop, TF_Output scale_backprop, TF_Output offset_backprop, TF_Output reserve_space_3, TF_Output reserve_space_4) FusedBatchNormGradV2 (TF_Output y_backprop, TF_Output x, TF_Output scale, TF_Output reserve_space_1, TF_Output reserve_space_2, float? epsilon = null, string data_format = null, bool? is_training = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FusedBatchNormGradV2", MakeName ("FusedBatchNormGradV2", operName));
			c_api.TF_AddInput(desc, y_backprop);
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, scale);
			c_api.TF_AddInput(desc, reserve_space_1);
			c_api.TF_AddInput(desc, reserve_space_2);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (epsilon.HasValue)
				c_api.TF_SetAttrFloat (desc, "epsilon", epsilon.Value);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (is_training.HasValue)
				c_api.TF_SetAttrBool (desc, "is_training", Convert.ToByte(is_training.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var x_backprop = new TF_Output (op, _idx++);
			var scale_backprop = new TF_Output (op, _idx++);
			var offset_backprop = new TF_Output (op, _idx++);
			var reserve_space_3 = new TF_Output (op, _idx++);
			var reserve_space_4 = new TF_Output (op, _idx++);
			return (x_backprop, scale_backprop, offset_backprop, reserve_space_3, reserve_space_4);
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="num_replicas">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalRebatchDataset'.
		/// </param>
		/// <param name="use_fallback">
		///   Optional argument
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalRebatchDataset (TF_Output input_dataset, TF_Output num_replicas, TF_DataType[] output_types, long[][] output_shapes, bool? use_fallback = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalRebatchDataset", MakeName ("ExperimentalRebatchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, num_replicas);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (use_fallback.HasValue)
				c_api.TF_SetAttrBool (desc, "use_fallback", Convert.ToByte(use_fallback.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="num_replicas">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RebatchDataset'.
		/// </param>
		/// <param name="use_fallback">
		///   Optional argument
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RebatchDataset (TF_Output input_dataset, TF_Output num_replicas, TF_DataType[] output_types, long[][] output_shapes, bool? use_fallback = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RebatchDataset", MakeName ("RebatchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, num_replicas);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (use_fallback.HasValue)
				c_api.TF_SetAttrBool (desc, "use_fallback", Convert.ToByte(use_fallback.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="filename">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReadFile'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ReadFile (TF_Output filename, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReadFile", MakeName ("ReadFile", operName));
			c_api.TF_AddInput(desc, filename);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var contents = new TF_Output (op, _idx++);
			return contents;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatsAggregatorHandle'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StatsAggregatorHandle (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatsAggregatorHandle", MakeName ("StatsAggregatorHandle", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalStatsAggregatorHandle'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalStatsAggregatorHandle (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalStatsAggregatorHandle", MakeName ("ExperimentalStatsAggregatorHandle", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="thread_pool">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalThreadPoolDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalThreadPoolDataset (TF_Output input_dataset, TF_Output thread_pool, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalThreadPoolDataset", MakeName ("ExperimentalThreadPoolDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, thread_pool);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="reader_handle">
		/// </param>
		/// <param name="state">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderRestoreState'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ReaderRestoreState (TF_Output reader_handle, TF_Output state, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderRestoreState", MakeName ("ReaderRestoreState", operName));
			c_api.TF_AddInput(desc, reader_handle);
			c_api.TF_AddInput(desc, state);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ThreadPoolHandle'.
		/// </param>
		/// <param name="max_intra_op_parallelism">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="num_threads">
		/// </param>
		/// <param name="display_name">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ThreadPoolHandle (long num_threads, string display_name, long? max_intra_op_parallelism = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ThreadPoolHandle", MakeName ("ThreadPoolHandle", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_threads", num_threads);
			c_api.TF_SetAttrString (desc, "display_name", display_name);
			if (max_intra_op_parallelism.HasValue)
				c_api.TF_SetAttrInt (desc, "max_intra_op_parallelism", max_intra_op_parallelism.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnbatchDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output UnbatchDataset (TF_Output input_dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnbatchDataset", MakeName ("UnbatchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedDepthwiseConv2DWithBias'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedDepthwiseConv2DWithBias (TF_Output input, TF_Output filter, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedDepthwiseConv2DWithBias", MakeName ("QuantizedDepthwiseConv2DWithBias", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalUniqueDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalUniqueDataset (TF_Output input_dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalUniqueDataset", MakeName ("ExperimentalUniqueDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IdentityReaderV2'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IdentityReaderV2 (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IdentityReaderV2", MakeName ("IdentityReaderV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="images">
		/// </param>
		/// <param name="boxes">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DrawBoundingBoxes'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DrawBoundingBoxes (TF_Output images, TF_Output boxes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DrawBoundingBoxes", MakeName ("DrawBoundingBoxes", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, boxes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="images">
		/// </param>
		/// <param name="size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeBicubic'.
		/// </param>
		/// <param name="align_corners">
		///   Optional argument
		/// </param>
		/// <param name="half_pixel_centers">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ResizeBicubic (TF_Output images, TF_Output size, bool? align_corners = null, bool? half_pixel_centers = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResizeBicubic", MakeName ("ResizeBicubic", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (align_corners.HasValue)
				c_api.TF_SetAttrBool (desc, "align_corners", Convert.ToByte(align_corners.Value));
			
			if (half_pixel_centers.HasValue)
				c_api.TF_SetAttrBool (desc, "half_pixel_centers", Convert.ToByte(half_pixel_centers.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var resized_images = new TF_Output (op, _idx++);
			return resized_images;
		}

		/// <summary>
		/// </summary>
		/// <param name="predictions">
		/// </param>
		/// <param name="targets">
		/// </param>
		/// <param name="k">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InTopKV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output InTopKV2 (TF_Output predictions, TF_Output targets, TF_Output k, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InTopKV2", MakeName ("InTopKV2", operName));
			c_api.TF_AddInput(desc, predictions);
			c_api.TF_AddInput(desc, targets);
			c_api.TF_AddInput(desc, k);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var precision = new TF_Output (op, _idx++);
			return precision;
		}

		/// <summary>
		/// </summary>
		/// <param name="grads">
		/// </param>
		/// <param name="original_image">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeBicubicGrad'.
		/// </param>
		/// <param name="align_corners">
		///   Optional argument
		/// </param>
		/// <param name="half_pixel_centers">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ResizeBicubicGrad (TF_Output grads, TF_Output original_image, bool? align_corners = null, bool? half_pixel_centers = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResizeBicubicGrad", MakeName ("ResizeBicubicGrad", operName));
			c_api.TF_AddInput(desc, grads);
			c_api.TF_AddInput(desc, original_image);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (align_corners.HasValue)
				c_api.TF_SetAttrBool (desc, "align_corners", Convert.ToByte(align_corners.Value));
			
			if (half_pixel_centers.HasValue)
				c_api.TF_SetAttrBool (desc, "half_pixel_centers", Convert.ToByte(half_pixel_centers.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="grads">
		/// </param>
		/// <param name="original_image">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeBilinearGrad'.
		/// </param>
		/// <param name="align_corners">
		///   Optional argument
		/// </param>
		/// <param name="half_pixel_centers">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ResizeBilinearGrad (TF_Output grads, TF_Output original_image, bool? align_corners = null, bool? half_pixel_centers = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResizeBilinearGrad", MakeName ("ResizeBilinearGrad", operName));
			c_api.TF_AddInput(desc, grads);
			c_api.TF_AddInput(desc, original_image);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (align_corners.HasValue)
				c_api.TF_SetAttrBool (desc, "align_corners", Convert.ToByte(align_corners.Value));
			
			if (half_pixel_centers.HasValue)
				c_api.TF_SetAttrBool (desc, "half_pixel_centers", Convert.ToByte(half_pixel_centers.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="image">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodeJpeg'.
		/// </param>
		/// <param name="format">
		///   Optional argument
		/// </param>
		/// <param name="quality">
		///   Optional argument
		/// </param>
		/// <param name="progressive">
		///   Optional argument
		/// </param>
		/// <param name="optimize_size">
		///   Optional argument
		/// </param>
		/// <param name="chroma_downsampling">
		///   Optional argument
		/// </param>
		/// <param name="density_unit">
		///   Optional argument
		/// </param>
		/// <param name="x_density">
		///   Optional argument
		/// </param>
		/// <param name="y_density">
		///   Optional argument
		/// </param>
		/// <param name="xmp_metadata">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output EncodeJpeg (TF_Output image, string format = null, long? quality = null, bool? progressive = null, bool? optimize_size = null, bool? chroma_downsampling = null, string density_unit = null, long? x_density = null, long? y_density = null, string xmp_metadata = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EncodeJpeg", MakeName ("EncodeJpeg", operName));
			c_api.TF_AddInput(desc, image);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (format != null)
				c_api.TF_SetAttrString (desc, "format", format);
			
			if (quality.HasValue)
				c_api.TF_SetAttrInt (desc, "quality", quality.Value);
			
			if (progressive.HasValue)
				c_api.TF_SetAttrBool (desc, "progressive", Convert.ToByte(progressive.Value));
			
			if (optimize_size.HasValue)
				c_api.TF_SetAttrBool (desc, "optimize_size", Convert.ToByte(optimize_size.Value));
			
			if (chroma_downsampling.HasValue)
				c_api.TF_SetAttrBool (desc, "chroma_downsampling", Convert.ToByte(chroma_downsampling.Value));
			
			if (density_unit != null)
				c_api.TF_SetAttrString (desc, "density_unit", density_unit);
			
			if (x_density.HasValue)
				c_api.TF_SetAttrInt (desc, "x_density", x_density.Value);
			
			if (y_density.HasValue)
				c_api.TF_SetAttrInt (desc, "y_density", y_density.Value);
			
			if (xmp_metadata != null)
				c_api.TF_SetAttrString (desc, "xmp_metadata", xmp_metadata);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var contents = new TF_Output (op, _idx++);
			return contents;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BesselI1e'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BesselI1e (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BesselI1e", MakeName ("BesselI1e", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="images">
		/// </param>
		/// <param name="contrast_factor">
		/// </param>
		/// <param name="min_value">
		/// </param>
		/// <param name="max_value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AdjustContrast'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AdjustContrast (TF_Output images, TF_Output contrast_factor, TF_Output min_value, TF_Output max_value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AdjustContrast", MakeName ("AdjustContrast", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, contrast_factor);
			c_api.TF_AddInput(desc, min_value);
			c_api.TF_AddInput(desc, max_value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="images">
		/// </param>
		/// <param name="delta">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AdjustHue'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AdjustHue (TF_Output images, TF_Output delta, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AdjustHue", MakeName ("AdjustHue", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, delta);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="image">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodePng'.
		/// </param>
		/// <param name="compression">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output EncodePng (TF_Output image, long? compression = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EncodePng", MakeName ("EncodePng", operName));
			c_api.TF_AddInput(desc, image);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (compression.HasValue)
				c_api.TF_SetAttrInt (desc, "compression", compression.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var contents = new TF_Output (op, _idx++);
			return contents;
		}

		/// <summary>
		/// </summary>
		/// <param name="contents">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeGif'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DecodeGif (TF_Output contents, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodeGif", MakeName ("DecodeGif", operName));
			c_api.TF_AddInput(desc, contents);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var image = new TF_Output (op, _idx++);
			return image;
		}

		/// <summary>
		/// </summary>
		/// <param name="images">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'HSVToRGB'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output HSVToRGB (TF_Output images, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "HSVToRGB", MakeName ("HSVToRGB", operName));
			c_api.TF_AddInput(desc, images);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="image_size">
		/// </param>
		/// <param name="bounding_boxes">
		/// </param>
		/// <param name="min_object_covered">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SampleDistortedBoundingBoxV2'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="aspect_ratio_range">
		///   Optional argument
		/// </param>
		/// <param name="area_range">
		///   Optional argument
		/// </param>
		/// <param name="max_attempts">
		///   Optional argument
		/// </param>
		/// <param name="use_image_if_no_bounding_boxes">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   begin:
		///   size:
		///   bboxes:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output begin, TF_Output size, TF_Output bboxes) SampleDistortedBoundingBoxV2 (TF_Output image_size, TF_Output bounding_boxes, TF_Output min_object_covered, long? seed = null, long? seed2 = null, float[] aspect_ratio_range = null, float[] area_range = null, long? max_attempts = null, bool? use_image_if_no_bounding_boxes = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SampleDistortedBoundingBoxV2", MakeName ("SampleDistortedBoundingBoxV2", operName));
			c_api.TF_AddInput(desc, image_size);
			c_api.TF_AddInput(desc, bounding_boxes);
			c_api.TF_AddInput(desc, min_object_covered);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (aspect_ratio_range != null)
				c_api.TF_SetAttrFloatList (desc, "aspect_ratio_range", ref aspect_ratio_range[0], aspect_ratio_range.Length);
			
			if (area_range != null)
				c_api.TF_SetAttrFloatList (desc, "area_range", ref area_range[0], area_range.Length);
			
			if (max_attempts.HasValue)
				c_api.TF_SetAttrInt (desc, "max_attempts", max_attempts.Value);
			
			if (use_image_if_no_bounding_boxes.HasValue)
				c_api.TF_SetAttrBool (desc, "use_image_if_no_bounding_boxes", Convert.ToByte(use_image_if_no_bounding_boxes.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var begin = new TF_Output (op, _idx++);
			var size = new TF_Output (op, _idx++);
			var bboxes = new TF_Output (op, _idx++);
			return (begin, size, bboxes);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="size">
		/// </param>
		/// <param name="offsets">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExtractGlimpse'.
		/// </param>
		/// <param name="centered">
		///   Optional argument
		/// </param>
		/// <param name="normalized">
		///   Optional argument
		/// </param>
		/// <param name="uniform_noise">
		///   Optional argument
		/// </param>
		/// <param name="noise">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExtractGlimpse (TF_Output input, TF_Output size, TF_Output offsets, bool? centered = null, bool? normalized = null, bool? uniform_noise = null, string noise = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExtractGlimpse", MakeName ("ExtractGlimpse", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, size);
			c_api.TF_AddInput(desc, offsets);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (centered.HasValue)
				c_api.TF_SetAttrBool (desc, "centered", Convert.ToByte(centered.Value));
			
			if (normalized.HasValue)
				c_api.TF_SetAttrBool (desc, "normalized", Convert.ToByte(normalized.Value));
			
			if (uniform_noise.HasValue)
				c_api.TF_SetAttrBool (desc, "uniform_noise", Convert.ToByte(uniform_noise.Value));
			
			if (noise != null)
				c_api.TF_SetAttrString (desc, "noise", noise);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var glimpse = new TF_Output (op, _idx++);
			return glimpse;
		}

		/// <summary>
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="ms">
		/// </param>
		/// <param name="mom">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingRMSPropParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LoadTPUEmbeddingRMSPropParameters (TF_Output parameters, TF_Output ms, TF_Output mom, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingRMSPropParameters", MakeName ("LoadTPUEmbeddingRMSPropParameters", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="prefix">
		/// </param>
		/// <param name="tensor_names">
		/// </param>
		/// <param name="shape_and_slices">
		/// </param>
		/// <param name="tensors">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SaveV2'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation SaveV2 (TF_Output prefix, TF_Output tensor_names, TF_Output shape_and_slices, TF_Output[] tensors, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SaveV2", MakeName ("SaveV2", operName));
			c_api.TF_AddInput(desc, prefix);
			c_api.TF_AddInput(desc, tensor_names);
			c_api.TF_AddInput(desc, shape_and_slices);
			c_api.TF_AddInputList(desc, tensors[0], tensors.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableHashTableOfTensorsV2'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="use_node_name_sharing">
		///   Optional argument
		/// </param>
		/// <param name="value_shape">
		///   Optional argument
		/// </param>
		/// <param name="key_dtype">
		/// </param>
		/// <param name="value_dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MutableHashTableOfTensorsV2 (TF_DataType key_dtype, TF_DataType value_dtype, string container = null, string shared_name = null, bool? use_node_name_sharing = null, long[] value_shape = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MutableHashTableOfTensorsV2", MakeName ("MutableHashTableOfTensorsV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "key_dtype", key_dtype);
			c_api.TF_SetAttrType (desc, "value_dtype", value_dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (use_node_name_sharing.HasValue)
				c_api.TF_SetAttrBool (desc, "use_node_name_sharing", Convert.ToByte(use_node_name_sharing.Value));
			
			if (value_shape != null)
				c_api.TF_SetAttrShape (desc, "value_shape", ref value_shape[0], value_shape.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var table_handle = new TF_Output (op, _idx++);
			return table_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IsInf'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IsInf (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IsInf", MakeName ("IsInf", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="image">
		/// </param>
		/// <param name="boxes">
		/// </param>
		/// <param name="box_ind">
		/// </param>
		/// <param name="crop_size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CropAndResize'.
		/// </param>
		/// <param name="method">
		///   Optional argument
		/// </param>
		/// <param name="extrapolation_value">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CropAndResize (TF_Output image, TF_Output boxes, TF_Output box_ind, TF_Output crop_size, string method = null, float? extrapolation_value = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CropAndResize", MakeName ("CropAndResize", operName));
			c_api.TF_AddInput(desc, image);
			c_api.TF_AddInput(desc, boxes);
			c_api.TF_AddInput(desc, box_ind);
			c_api.TF_AddInput(desc, crop_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (method != null)
				c_api.TF_SetAttrString (desc, "method", method);
			
			if (extrapolation_value.HasValue)
				c_api.TF_SetAttrFloat (desc, "extrapolation_value", extrapolation_value.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var crops = new TF_Output (op, _idx++);
			return crops;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TFRecordReaderV2'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="compression_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TFRecordReaderV2 (string container = null, string shared_name = null, string compression_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TFRecordReaderV2", MakeName ("TFRecordReaderV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (compression_type != null)
				c_api.TF_SetAttrString (desc, "compression_type", compression_type);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="grads">
		/// </param>
		/// <param name="boxes">
		/// </param>
		/// <param name="box_ind">
		/// </param>
		/// <param name="image_size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CropAndResizeGradImage'.
		/// </param>
		/// <param name="method">
		///   Optional argument
		/// </param>
		/// <param name="T">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CropAndResizeGradImage (TF_Output grads, TF_Output boxes, TF_Output box_ind, TF_Output image_size, TF_DataType T, string method = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CropAndResizeGradImage", MakeName ("CropAndResizeGradImage", operName));
			c_api.TF_AddInput(desc, grads);
			c_api.TF_AddInput(desc, boxes);
			c_api.TF_AddInput(desc, box_ind);
			c_api.TF_AddInput(desc, image_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "T", T);
			if (method != null)
				c_api.TF_SetAttrString (desc, "method", method);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="grads">
		/// </param>
		/// <param name="image">
		/// </param>
		/// <param name="boxes">
		/// </param>
		/// <param name="box_ind">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CropAndResizeGradBoxes'.
		/// </param>
		/// <param name="method">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CropAndResizeGradBoxes (TF_Output grads, TF_Output image, TF_Output boxes, TF_Output box_ind, string method = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CropAndResizeGradBoxes", MakeName ("CropAndResizeGradBoxes", operName));
			c_api.TF_AddInput(desc, grads);
			c_api.TF_AddInput(desc, image);
			c_api.TF_AddInput(desc, boxes);
			c_api.TF_AddInput(desc, box_ind);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (method != null)
				c_api.TF_SetAttrString (desc, "method", method);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="accumulators">
		/// </param>
		/// <param name="linears">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingFTRLParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LoadTPUEmbeddingFTRLParameters (TF_Output parameters, TF_Output accumulators, TF_Output linears, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingFTRLParameters", MakeName ("LoadTPUEmbeddingFTRLParameters", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, accumulators);
			c_api.TF_AddInput(desc, linears);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="boxes">
		/// </param>
		/// <param name="scores">
		/// </param>
		/// <param name="max_output_size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NonMaxSuppression'.
		/// </param>
		/// <param name="iou_threshold">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output NonMaxSuppression (TF_Output boxes, TF_Output scores, TF_Output max_output_size, float? iou_threshold = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NonMaxSuppression", MakeName ("NonMaxSuppression", operName));
			c_api.TF_AddInput(desc, boxes);
			c_api.TF_AddInput(desc, scores);
			c_api.TF_AddInput(desc, max_output_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (iou_threshold.HasValue)
				c_api.TF_SetAttrFloat (desc, "iou_threshold", iou_threshold.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var selected_indices = new TF_Output (op, _idx++);
			return selected_indices;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Atanh'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Atanh (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Atanh", MakeName ("Atanh", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="boxes">
		/// </param>
		/// <param name="scores">
		/// </param>
		/// <param name="max_output_size">
		/// </param>
		/// <param name="iou_threshold">
		/// </param>
		/// <param name="score_threshold">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NonMaxSuppressionV3'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output NonMaxSuppressionV3 (TF_Output boxes, TF_Output scores, TF_Output max_output_size, TF_Output iou_threshold, TF_Output score_threshold, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NonMaxSuppressionV3", MakeName ("NonMaxSuppressionV3", operName));
			c_api.TF_AddInput(desc, boxes);
			c_api.TF_AddInput(desc, scores);
			c_api.TF_AddInput(desc, max_output_size);
			c_api.TF_AddInput(desc, iou_threshold);
			c_api.TF_AddInput(desc, score_threshold);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var selected_indices = new TF_Output (op, _idx++);
			return selected_indices;
		}

		/// <summary>
		/// </summary>
		/// <param name="boxes">
		/// </param>
		/// <param name="scores">
		/// </param>
		/// <param name="max_output_size">
		/// </param>
		/// <param name="iou_threshold">
		/// </param>
		/// <param name="score_threshold">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NonMaxSuppressionV4'.
		/// </param>
		/// <param name="pad_to_max_output_size">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   selected_indices:
		///   valid_outputs:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output selected_indices, TF_Output valid_outputs) NonMaxSuppressionV4 (TF_Output boxes, TF_Output scores, TF_Output max_output_size, TF_Output iou_threshold, TF_Output score_threshold, bool? pad_to_max_output_size = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NonMaxSuppressionV4", MakeName ("NonMaxSuppressionV4", operName));
			c_api.TF_AddInput(desc, boxes);
			c_api.TF_AddInput(desc, scores);
			c_api.TF_AddInput(desc, max_output_size);
			c_api.TF_AddInput(desc, iou_threshold);
			c_api.TF_AddInput(desc, score_threshold);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (pad_to_max_output_size.HasValue)
				c_api.TF_SetAttrBool (desc, "pad_to_max_output_size", Convert.ToByte(pad_to_max_output_size.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var selected_indices = new TF_Output (op, _idx++);
			var valid_outputs = new TF_Output (op, _idx++);
			return (selected_indices, valid_outputs);
		}

		/// <summary>
		/// </summary>
		/// <param name="boxes">
		/// </param>
		/// <param name="scores">
		/// </param>
		/// <param name="max_output_size">
		/// </param>
		/// <param name="iou_threshold">
		/// </param>
		/// <param name="score_threshold">
		/// </param>
		/// <param name="soft_nms_sigma">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NonMaxSuppressionV5'.
		/// </param>
		/// <param name="pad_to_max_output_size">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   selected_indices:
		///   selected_scores:
		///   valid_outputs:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output selected_indices, TF_Output selected_scores, TF_Output valid_outputs) NonMaxSuppressionV5 (TF_Output boxes, TF_Output scores, TF_Output max_output_size, TF_Output iou_threshold, TF_Output score_threshold, TF_Output soft_nms_sigma, bool? pad_to_max_output_size = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NonMaxSuppressionV5", MakeName ("NonMaxSuppressionV5", operName));
			c_api.TF_AddInput(desc, boxes);
			c_api.TF_AddInput(desc, scores);
			c_api.TF_AddInput(desc, max_output_size);
			c_api.TF_AddInput(desc, iou_threshold);
			c_api.TF_AddInput(desc, score_threshold);
			c_api.TF_AddInput(desc, soft_nms_sigma);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (pad_to_max_output_size.HasValue)
				c_api.TF_SetAttrBool (desc, "pad_to_max_output_size", Convert.ToByte(pad_to_max_output_size.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var selected_indices = new TF_Output (op, _idx++);
			var selected_scores = new TF_Output (op, _idx++);
			var valid_outputs = new TF_Output (op, _idx++);
			return (selected_indices, selected_scores, valid_outputs);
		}

		/// <summary>
		/// </summary>
		/// <param name="overlaps">
		/// </param>
		/// <param name="scores">
		/// </param>
		/// <param name="max_output_size">
		/// </param>
		/// <param name="overlap_threshold">
		/// </param>
		/// <param name="score_threshold">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NonMaxSuppressionWithOverlaps'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output NonMaxSuppressionWithOverlaps (TF_Output overlaps, TF_Output scores, TF_Output max_output_size, TF_Output overlap_threshold, TF_Output score_threshold, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NonMaxSuppressionWithOverlaps", MakeName ("NonMaxSuppressionWithOverlaps", operName));
			c_api.TF_AddInput(desc, overlaps);
			c_api.TF_AddInput(desc, scores);
			c_api.TF_AddInput(desc, max_output_size);
			c_api.TF_AddInput(desc, overlap_threshold);
			c_api.TF_AddInput(desc, score_threshold);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var selected_indices = new TF_Output (op, _idx++);
			return selected_indices;
		}

		/// <summary>
		/// </summary>
		/// <param name="boxes">
		/// </param>
		/// <param name="scores">
		/// </param>
		/// <param name="max_output_size_per_class">
		/// </param>
		/// <param name="max_total_size">
		/// </param>
		/// <param name="iou_threshold">
		/// </param>
		/// <param name="score_threshold">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CombinedNonMaxSuppression'.
		/// </param>
		/// <param name="pad_per_class">
		///   Optional argument
		/// </param>
		/// <param name="clip_boxes">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   nmsed_boxes:
		///   nmsed_scores:
		///   nmsed_classes:
		///   valid_detections:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output nmsed_boxes, TF_Output nmsed_scores, TF_Output nmsed_classes, TF_Output valid_detections) CombinedNonMaxSuppression (TF_Output boxes, TF_Output scores, TF_Output max_output_size_per_class, TF_Output max_total_size, TF_Output iou_threshold, TF_Output score_threshold, bool? pad_per_class = null, bool? clip_boxes = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CombinedNonMaxSuppression", MakeName ("CombinedNonMaxSuppression", operName));
			c_api.TF_AddInput(desc, boxes);
			c_api.TF_AddInput(desc, scores);
			c_api.TF_AddInput(desc, max_output_size_per_class);
			c_api.TF_AddInput(desc, max_total_size);
			c_api.TF_AddInput(desc, iou_threshold);
			c_api.TF_AddInput(desc, score_threshold);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (pad_per_class.HasValue)
				c_api.TF_SetAttrBool (desc, "pad_per_class", Convert.ToByte(pad_per_class.Value));
			
			if (clip_boxes.HasValue)
				c_api.TF_SetAttrBool (desc, "clip_boxes", Convert.ToByte(clip_boxes.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var nmsed_boxes = new TF_Output (op, _idx++);
			var nmsed_scores = new TF_Output (op, _idx++);
			var nmsed_classes = new TF_Output (op, _idx++);
			var valid_detections = new TF_Output (op, _idx++);
			return (nmsed_boxes, nmsed_scores, nmsed_classes, valid_detections);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="reduction_indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Prod'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Prod (TF_Output input, TF_Output reduction_indices, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Prod", MakeName ("Prod", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, reduction_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="reverse_index_map">
		/// </param>
		/// <param name="grad_values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseFillEmptyRowsGrad'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   d_values:
		///   d_default_value:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output d_values, TF_Output d_default_value) SparseFillEmptyRowsGrad (TF_Output reverse_index_map, TF_Output grad_values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseFillEmptyRowsGrad", MakeName ("SparseFillEmptyRowsGrad", operName));
			c_api.TF_AddInput(desc, reverse_index_map);
			c_api.TF_AddInput(desc, grad_values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var d_values = new TF_Output (op, _idx++);
			var d_default_value = new TF_Output (op, _idx++);
			return (d_values, d_default_value);
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SquaredDifference'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SquaredDifference (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SquaredDifference", MakeName ("SquaredDifference", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="algorithm">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <param name="minval">
		/// </param>
		/// <param name="maxval">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatefulUniformInt'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StatefulUniformInt (TF_Output resource, TF_Output algorithm, TF_Output shape, TF_Output minval, TF_Output maxval, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatefulUniformInt", MakeName ("StatefulUniformInt", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, algorithm);
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, minval);
			c_api.TF_AddInput(desc, maxval);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="filename">
		/// </param>
		/// <param name="tensor_names">
		/// </param>
		/// <param name="data">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Save'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation Save (TF_Output filename, TF_Output tensor_names, TF_Output[] data, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Save", MakeName ("Save", operName));
			c_api.TF_AddInput(desc, filename);
			c_api.TF_AddInput(desc, tensor_names);
			c_api.TF_AddInputList(desc, data[0], data.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableHashTableOfTensors'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="use_node_name_sharing">
		///   Optional argument
		/// </param>
		/// <param name="value_shape">
		///   Optional argument
		/// </param>
		/// <param name="key_dtype">
		/// </param>
		/// <param name="value_dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MutableHashTableOfTensors (TF_DataType key_dtype, TF_DataType value_dtype, string container = null, string shared_name = null, bool? use_node_name_sharing = null, long[] value_shape = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MutableHashTableOfTensors", MakeName ("MutableHashTableOfTensors", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "key_dtype", key_dtype);
			c_api.TF_SetAttrType (desc, "value_dtype", value_dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (use_node_name_sharing.HasValue)
				c_api.TF_SetAttrBool (desc, "use_node_name_sharing", Convert.ToByte(use_node_name_sharing.Value));
			
			if (value_shape != null)
				c_api.TF_SetAttrShape (desc, "value_shape", ref value_shape[0], value_shape.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var table_handle = new TF_Output (op, _idx++);
			return table_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="segment_ids">
		/// </param>
		/// <param name="num_segments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnsortedSegmentMin'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output UnsortedSegmentMin (TF_Output data, TF_Output segment_ids, TF_Output num_segments, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnsortedSegmentMin", MakeName ("UnsortedSegmentMin", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, segment_ids);
			c_api.TF_AddInput(desc, num_segments);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter_sizes">
		/// </param>
		/// <param name="out_backprop">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv3DBackpropFilterV2'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Conv3DBackpropFilterV2 (TF_Output input, TF_Output filter_sizes, TF_Output out_backprop, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Conv3DBackpropFilterV2", MakeName ("Conv3DBackpropFilterV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter_sizes);
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="file_pattern">
		/// </param>
		/// <param name="tensor_name">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Restore'.
		/// </param>
		/// <param name="preferred_shard">
		///   Optional argument
		/// </param>
		/// <param name="dt">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Restore (TF_Output file_pattern, TF_Output tensor_name, TF_DataType dt, long? preferred_shard = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Restore", MakeName ("Restore", operName));
			c_api.TF_AddInput(desc, file_pattern);
			c_api.TF_AddInput(desc, tensor_name);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dt", dt);
			if (preferred_shard.HasValue)
				c_api.TF_SetAttrInt (desc, "preferred_shard", preferred_shard.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var tensor = new TF_Output (op, _idx++);
			return tensor;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="k">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TopKV2'.
		/// </param>
		/// <param name="sorted">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   values:
		///   indices:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output values, TF_Output indices) TopKV2 (TF_Output input, TF_Output k, bool? sorted = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TopKV2", MakeName ("TopKV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, k);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (sorted.HasValue)
				c_api.TF_SetAttrBool (desc, "sorted", Convert.ToByte(sorted.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var values = new TF_Output (op, _idx++);
			var indices = new TF_Output (op, _idx++);
			return (values, indices);
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyAdagradV2'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <param name="update_slots">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseApplyAdagradV2 (TF_Output var, TF_Output accum, TF_Output lr, TF_Output epsilon, TF_Output grad, TF_Output indices, bool? use_locking = null, bool? update_slots = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyAdagradV2", MakeName ("SparseApplyAdagradV2", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (update_slots.HasValue)
				c_api.TF_SetAttrBool (desc, "update_slots", Convert.ToByte(update_slots.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="file_pattern">
		/// </param>
		/// <param name="tensor_name">
		/// </param>
		/// <param name="shape_and_slice">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RestoreSlice'.
		/// </param>
		/// <param name="preferred_shard">
		///   Optional argument
		/// </param>
		/// <param name="dt">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RestoreSlice (TF_Output file_pattern, TF_Output tensor_name, TF_Output shape_and_slice, TF_DataType dt, long? preferred_shard = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RestoreSlice", MakeName ("RestoreSlice", operName));
			c_api.TF_AddInput(desc, file_pattern);
			c_api.TF_AddInput(desc, tensor_name);
			c_api.TF_AddInput(desc, shape_and_slice);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dt", dt);
			if (preferred_shard.HasValue)
				c_api.TF_SetAttrInt (desc, "preferred_shard", preferred_shard.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var tensor = new TF_Output (op, _idx++);
			return tensor;
		}

		/// <summary>
		/// </summary>
		/// <param name="basename">
		/// </param>
		/// <param name="shard">
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ShardedFilename'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ShardedFilename (TF_Output basename, TF_Output shard, TF_Output num_shards, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ShardedFilename", MakeName ("ShardedFilename", operName));
			c_api.TF_AddInput(desc, basename);
			c_api.TF_AddInput(desc, shard);
			c_api.TF_AddInput(desc, num_shards);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var filename = new TF_Output (op, _idx++);
			return filename;
		}

		/// <summary>
		/// </summary>
		/// <param name="value">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BiasAdd'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BiasAdd (TF_Output value, TF_Output bias, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BiasAdd", MakeName ("BiasAdd", operName));
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, bias);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="basename">
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ShardedFilespec'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ShardedFilespec (TF_Output basename, TF_Output num_shards, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ShardedFilespec", MakeName ("ShardedFilespec", operName));
			c_api.TF_AddInput(desc, basename);
			c_api.TF_AddInput(desc, num_shards);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var filename = new TF_Output (op, _idx++);
			return filename;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TextLineReader'.
		/// </param>
		/// <param name="skip_header_lines">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TextLineReader (long? skip_header_lines = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TextLineReader", MakeName ("TextLineReader", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (skip_header_lines.HasValue)
				c_api.TF_SetAttrInt (desc, "skip_header_lines", skip_header_lines.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Relu6'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Relu6 (TF_Output features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Relu6", MakeName ("Relu6", operName));
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var activations = new TF_Output (op, _idx++);
			return activations;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TextLineReaderV2'.
		/// </param>
		/// <param name="skip_header_lines">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TextLineReaderV2 (long? skip_header_lines = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TextLineReaderV2", MakeName ("TextLineReaderV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (skip_header_lines.HasValue)
				c_api.TF_SetAttrInt (desc, "skip_header_lines", skip_header_lines.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="element_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListGather'.
		/// </param>
		/// <param name="element_dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorListGather (TF_Output input_handle, TF_Output indices, TF_Output element_shape, TF_DataType element_dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListGather", MakeName ("TensorListGather", operName));
			c_api.TF_AddInput(desc, input_handle);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, element_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "element_dtype", element_dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var values = new TF_Output (op, _idx++);
			return values;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="algorithm">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatefulUniformFullInt'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StatefulUniformFullInt (TF_Output resource, TF_Output algorithm, TF_Output shape, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatefulUniformFullInt", MakeName ("StatefulUniformFullInt", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, algorithm);
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FixedLengthRecordReader'.
		/// </param>
		/// <param name="header_bytes">
		///   Optional argument
		/// </param>
		/// <param name="footer_bytes">
		///   Optional argument
		/// </param>
		/// <param name="hop_bytes">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="record_bytes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FixedLengthRecordReader (long record_bytes, long? header_bytes = null, long? footer_bytes = null, long? hop_bytes = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FixedLengthRecordReader", MakeName ("FixedLengthRecordReader", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "record_bytes", record_bytes);
			if (header_bytes.HasValue)
				c_api.TF_SetAttrInt (desc, "header_bytes", header_bytes.Value);
			
			if (footer_bytes.HasValue)
				c_api.TF_SetAttrInt (desc, "footer_bytes", footer_bytes.Value);
			
			if (hop_bytes.HasValue)
				c_api.TF_SetAttrInt (desc, "hop_bytes", hop_bytes.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FixedLengthRecordReaderV2'.
		/// </param>
		/// <param name="header_bytes">
		///   Optional argument
		/// </param>
		/// <param name="footer_bytes">
		///   Optional argument
		/// </param>
		/// <param name="hop_bytes">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="encoding">
		///   Optional argument
		/// </param>
		/// <param name="record_bytes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FixedLengthRecordReaderV2 (long record_bytes, long? header_bytes = null, long? footer_bytes = null, long? hop_bytes = null, string container = null, string shared_name = null, string encoding = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FixedLengthRecordReaderV2", MakeName ("FixedLengthRecordReaderV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "record_bytes", record_bytes);
			if (header_bytes.HasValue)
				c_api.TF_SetAttrInt (desc, "header_bytes", header_bytes.Value);
			
			if (footer_bytes.HasValue)
				c_api.TF_SetAttrInt (desc, "footer_bytes", footer_bytes.Value);
			
			if (hop_bytes.HasValue)
				c_api.TF_SetAttrInt (desc, "hop_bytes", hop_bytes.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (encoding != null)
				c_api.TF_SetAttrString (desc, "encoding", encoding);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="n">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NthElement'.
		/// </param>
		/// <param name="reverse">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output NthElement (TF_Output input, TF_Output n, bool? reverse = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NthElement", MakeName ("NthElement", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, n);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (reverse.HasValue)
				c_api.TF_SetAttrBool (desc, "reverse", Convert.ToByte(reverse.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var values = new TF_Output (op, _idx++);
			return values;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixSquareRoot'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MatrixSquareRoot (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixSquareRoot", MakeName ("MatrixSquareRoot", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OutfeedEnqueueTuple'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation OutfeedEnqueueTuple (TF_Output[] inputs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OutfeedEnqueueTuple", MakeName ("OutfeedEnqueueTuple", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LMDBReader'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LMDBReader (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LMDBReader", MakeName ("LMDBReader", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="reader_handle">
		/// </param>
		/// <param name="queue_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderRead'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   key:
		///   value:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output key, TF_Output value) ReaderRead (TF_Output reader_handle, TF_Output queue_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderRead", MakeName ("ReaderRead", operName));
			c_api.TF_AddInput(desc, reader_handle);
			c_api.TF_AddInput(desc, queue_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var key = new TF_Output (op, _idx++);
			var value = new TF_Output (op, _idx++);
			return (key, value);
		}

		/// <summary>
		/// </summary>
		/// <param name="reader_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderNumRecordsProduced'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ReaderNumRecordsProduced (TF_Output reader_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderNumRecordsProduced", MakeName ("ReaderNumRecordsProduced", operName));
			c_api.TF_AddInput(desc, reader_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var records_produced = new TF_Output (op, _idx++);
			return records_produced;
		}

		/// <summary>
		/// </summary>
		/// <param name="reader_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderNumWorkUnitsCompleted'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ReaderNumWorkUnitsCompleted (TF_Output reader_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderNumWorkUnitsCompleted", MakeName ("ReaderNumWorkUnitsCompleted", operName));
			c_api.TF_AddInput(desc, reader_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var units_completed = new TF_Output (op, _idx++);
			return units_completed;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LogMatrixDeterminant'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sign:
		///   log_abs_determinant:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output sign, TF_Output log_abs_determinant) LogMatrixDeterminant (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LogMatrixDeterminant", MakeName ("LogMatrixDeterminant", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var sign = new TF_Output (op, _idx++);
			var log_abs_determinant = new TF_Output (op, _idx++);
			return (sign, log_abs_determinant);
		}

		/// <summary>
		/// </summary>
		/// <param name="reader_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderNumWorkUnitsCompletedV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ReaderNumWorkUnitsCompletedV2 (TF_Output reader_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderNumWorkUnitsCompletedV2", MakeName ("ReaderNumWorkUnitsCompletedV2", operName));
			c_api.TF_AddInput(desc, reader_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var units_completed = new TF_Output (op, _idx++);
			return units_completed;
		}

		/// <summary>
		/// </summary>
		/// <param name="reader_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderSerializeState'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ReaderSerializeState (TF_Output reader_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderSerializeState", MakeName ("ReaderSerializeState", operName));
			c_api.TF_AddInput(desc, reader_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var state = new TF_Output (op, _idx++);
			return state;
		}

		/// <summary>
		/// </summary>
		/// <param name="reader_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderSerializeStateV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ReaderSerializeStateV2 (TF_Output reader_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderSerializeStateV2", MakeName ("ReaderSerializeStateV2", operName));
			c_api.TF_AddInput(desc, reader_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var state = new TF_Output (op, _idx++);
			return state;
		}

		/// <summary>
		/// </summary>
		/// <param name="reader_handle">
		/// </param>
		/// <param name="state">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderRestoreStateV2'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ReaderRestoreStateV2 (TF_Output reader_handle, TF_Output state, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderRestoreStateV2", MakeName ("ReaderRestoreStateV2", operName));
			c_api.TF_AddInput(desc, reader_handle);
			c_api.TF_AddInput(desc, state);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AssignSubVariableOp'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation AssignSubVariableOp (TF_Output resource, TF_Output value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AssignSubVariableOp", MakeName ("AssignSubVariableOp", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="reader_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderReset'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ReaderReset (TF_Output reader_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderReset", MakeName ("ReaderReset", operName));
			c_api.TF_AddInput(desc, reader_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="filename">
		/// </param>
		/// <param name="contents">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteFile'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation WriteFile (TF_Output filename, TF_Output contents, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WriteFile", MakeName ("WriteFile", operName));
			c_api.TF_AddInput(desc, filename);
			c_api.TF_AddInput(desc, contents);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="logits">
		/// </param>
		/// <param name="num_samples">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Multinomial'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="output_dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Multinomial (TF_Output logits, TF_Output num_samples, long? seed = null, long? seed2 = null, TF_DataType? output_dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Multinomial", MakeName ("Multinomial", operName));
			c_api.TF_AddInput(desc, logits);
			c_api.TF_AddInput(desc, num_samples);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (output_dtype.HasValue)
				c_api.TF_SetAttrType (desc, "output_dtype", output_dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TopK'.
		/// </param>
		/// <param name="sorted">
		///   Optional argument
		/// </param>
		/// <param name="k">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   values:
		///   indices:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output values, TF_Output indices) TopK (TF_Output input, long k, bool? sorted = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TopK", MakeName ("TopK", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "k", k);
			if (sorted.HasValue)
				c_api.TF_SetAttrBool (desc, "sorted", Convert.ToByte(sorted.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var values = new TF_Output (op, _idx++);
			var indices = new TF_Output (op, _idx++);
			return (values, indices);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Cholesky'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Cholesky (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Cholesky", MakeName ("Cholesky", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="l">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CholeskyGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CholeskyGrad (TF_Output l, TF_Output grad, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CholeskyGrad", MakeName ("CholeskyGrad", operName));
			c_api.TF_AddInput(desc, l);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="m">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="logbase">
		/// </param>
		/// <param name="sign_decay">
		/// </param>
		/// <param name="beta">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyPowerSign'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ApplyPowerSign (TF_Output var, TF_Output m, TF_Output lr, TF_Output logbase, TF_Output sign_decay, TF_Output beta, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyPowerSign", MakeName ("ApplyPowerSign", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, logbase);
			c_api.TF_AddInput(desc, sign_decay);
			c_api.TF_AddInput(desc, beta);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SelfAdjointEig'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SelfAdjointEig (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SelfAdjointEig", MakeName ("SelfAdjointEig", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SelfAdjointEigV2'.
		/// </param>
		/// <param name="compute_v">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   e:
		///   v:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output e, TF_Output v) SelfAdjointEigV2 (TF_Output input, bool? compute_v = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SelfAdjointEigV2", MakeName ("SelfAdjointEigV2", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (compute_v.HasValue)
				c_api.TF_SetAttrBool (desc, "compute_v", Convert.ToByte(compute_v.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var e = new TF_Output (op, _idx++);
			var v = new TF_Output (op, _idx++);
			return (e, v);
		}

		/// <summary>
		/// </summary>
		/// <param name="sparse_indices">
		/// </param>
		/// <param name="sparse_values">
		/// </param>
		/// <param name="sparse_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SerializeSparse'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SerializeSparse (TF_Output sparse_indices, TF_Output sparse_values, TF_Output sparse_shape, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SerializeSparse", MakeName ("SerializeSparse", operName));
			c_api.TF_AddInput(desc, sparse_indices);
			c_api.TF_AddInput(desc, sparse_values);
			c_api.TF_AddInput(desc, sparse_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var serialized_sparse = new TF_Output (op, _idx++);
			return serialized_sparse;
		}

		/// <summary>
		/// </summary>
		/// <param name="matrix">
		/// </param>
		/// <param name="rhs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixSolve'.
		/// </param>
		/// <param name="adjoint">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MatrixSolve (TF_Output matrix, TF_Output rhs, bool? adjoint = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixSolve", MakeName ("MatrixSolve", operName));
			c_api.TF_AddInput(desc, matrix);
			c_api.TF_AddInput(desc, rhs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (adjoint.HasValue)
				c_api.TF_SetAttrBool (desc, "adjoint", Convert.ToByte(adjoint.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="matrix">
		/// </param>
		/// <param name="rhs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixTriangularSolve'.
		/// </param>
		/// <param name="lower">
		///   Optional argument
		/// </param>
		/// <param name="adjoint">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MatrixTriangularSolve (TF_Output matrix, TF_Output rhs, bool? lower = null, bool? adjoint = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixTriangularSolve", MakeName ("MatrixTriangularSolve", operName));
			c_api.TF_AddInput(desc, matrix);
			c_api.TF_AddInput(desc, rhs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (lower.HasValue)
				c_api.TF_SetAttrBool (desc, "lower", Convert.ToByte(lower.Value));
			
			if (adjoint.HasValue)
				c_api.TF_SetAttrBool (desc, "adjoint", Convert.ToByte(adjoint.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="matrix">
		/// </param>
		/// <param name="rhs">
		/// </param>
		/// <param name="l2_regularizer">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixSolveLs'.
		/// </param>
		/// <param name="fast">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MatrixSolveLs (TF_Output matrix, TF_Output rhs, TF_Output l2_regularizer, bool? fast = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixSolveLs", MakeName ("MatrixSolveLs", operName));
			c_api.TF_AddInput(desc, matrix);
			c_api.TF_AddInput(desc, rhs);
			c_api.TF_AddInput(desc, l2_regularizer);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (fast.HasValue)
				c_api.TF_SetAttrBool (desc, "fast", Convert.ToByte(fast.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CountUpTo'.
		/// </param>
		/// <param name="limit">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CountUpTo (TF_Output reference, long limit, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CountUpTo", MakeName ("CountUpTo", operName));
			c_api.TF_AddInput(desc, reference);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "limit", limit);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Svd'.
		/// </param>
		/// <param name="compute_uv">
		///   Optional argument
		/// </param>
		/// <param name="full_matrices">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   s:
		///   u:
		///   v:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output s, TF_Output u, TF_Output v) Svd (TF_Output input, bool? compute_uv = null, bool? full_matrices = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Svd", MakeName ("Svd", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (compute_uv.HasValue)
				c_api.TF_SetAttrBool (desc, "compute_uv", Convert.ToByte(compute_uv.Value));
			
			if (full_matrices.HasValue)
				c_api.TF_SetAttrBool (desc, "full_matrices", Convert.ToByte(full_matrices.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var s = new TF_Output (op, _idx++);
			var u = new TF_Output (op, _idx++);
			var v = new TF_Output (op, _idx++);
			return (s, u, v);
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Exp'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Exp (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Exp", MakeName ("Exp", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="superdiag">
		/// </param>
		/// <param name="maindiag">
		/// </param>
		/// <param name="subdiag">
		/// </param>
		/// <param name="rhs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TridiagonalMatMul'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TridiagonalMatMul (TF_Output superdiag, TF_Output maindiag, TF_Output subdiag, TF_Output rhs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TridiagonalMatMul", MakeName ("TridiagonalMatMul", operName));
			c_api.TF_AddInput(desc, superdiag);
			c_api.TF_AddInput(desc, maindiag);
			c_api.TF_AddInput(desc, subdiag);
			c_api.TF_AddInput(desc, rhs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="diagonals">
		/// </param>
		/// <param name="rhs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TridiagonalSolve'.
		/// </param>
		/// <param name="partial_pivoting">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TridiagonalSolve (TF_Output diagonals, TF_Output rhs, bool? partial_pivoting = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TridiagonalSolve", MakeName ("TridiagonalSolve", operName));
			c_api.TF_AddInput(desc, diagonals);
			c_api.TF_AddInput(desc, rhs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (partial_pivoting.HasValue)
				c_api.TF_SetAttrBool (desc, "partial_pivoting", Convert.ToByte(partial_pivoting.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_min">
		/// </param>
		/// <param name="input_max">
		/// </param>
		/// <param name="requested_output_min">
		/// </param>
		/// <param name="requested_output_max">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Requantize'.
		/// </param>
		/// <param name="out_type">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   output_min:
		///   output_max:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output output_min, TF_Output output_max) Requantize (TF_Output input, TF_Output input_min, TF_Output input_max, TF_Output requested_output_min, TF_Output requested_output_max, TF_DataType out_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Requantize", MakeName ("Requantize", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_min);
			c_api.TF_AddInput(desc, input_max);
			c_api.TF_AddInput(desc, requested_output_min);
			c_api.TF_AddInput(desc, requested_output_max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "out_type", out_type);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var output_min = new TF_Output (op, _idx++);
			var output_max = new TF_Output (op, _idx++);
			return (output, output_min, output_max);
		}

		/// <summary>
		/// </summary>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomShuffle'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RandomShuffle (TF_Output value, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomShuffle", MakeName ("RandomShuffle", operName));
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchSelfAdjointEig'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchSelfAdjointEig (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchSelfAdjointEig", MakeName ("BatchSelfAdjointEig", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatrixDeterminant'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchMatrixDeterminant (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatrixDeterminant", MakeName ("BatchMatrixDeterminant", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="l">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchCholeskyGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchCholeskyGrad (TF_Output l, TF_Output grad, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchCholeskyGrad", MakeName ("BatchCholeskyGrad", operName));
			c_api.TF_AddInput(desc, l);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="matrix">
		/// </param>
		/// <param name="rhs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatrixSolve'.
		/// </param>
		/// <param name="adjoint">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchMatrixSolve (TF_Output matrix, TF_Output rhs, bool? adjoint = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatrixSolve", MakeName ("BatchMatrixSolve", operName));
			c_api.TF_AddInput(desc, matrix);
			c_api.TF_AddInput(desc, rhs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (adjoint.HasValue)
				c_api.TF_SetAttrBool (desc, "adjoint", Convert.ToByte(adjoint.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="matrix">
		/// </param>
		/// <param name="rhs">
		/// </param>
		/// <param name="l2_regularizer">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatrixSolveLs'.
		/// </param>
		/// <param name="fast">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchMatrixSolveLs (TF_Output matrix, TF_Output rhs, TF_Output l2_regularizer, bool? fast = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatrixSolveLs", MakeName ("BatchMatrixSolveLs", operName));
			c_api.TF_AddInput(desc, matrix);
			c_api.TF_AddInput(desc, rhs);
			c_api.TF_AddInput(desc, l2_regularizer);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (fast.HasValue)
				c_api.TF_SetAttrBool (desc, "fast", Convert.ToByte(fast.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterDiv'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceScatterDiv (TF_Output resource, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceScatterDiv", MakeName ("ResourceScatterDiv", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="table_handle">
		/// </param>
		/// <param name="keys">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableImport'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LookupTableImport (TF_Output table_handle, TF_Output keys, TF_Output values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableImport", MakeName ("LookupTableImport", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, keys);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchSvd'.
		/// </param>
		/// <param name="compute_uv">
		///   Optional argument
		/// </param>
		/// <param name="full_matrices">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   s:
		///   u:
		///   v:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output s, TF_Output u, TF_Output v) BatchSvd (TF_Output input, bool? compute_uv = null, bool? full_matrices = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchSvd", MakeName ("BatchSvd", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (compute_uv.HasValue)
				c_api.TF_SetAttrBool (desc, "compute_uv", Convert.ToByte(compute_uv.Value));
			
			if (full_matrices.HasValue)
				c_api.TF_SetAttrBool (desc, "full_matrices", Convert.ToByte(full_matrices.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var s = new TF_Output (op, _idx++);
			var u = new TF_Output (op, _idx++);
			var v = new TF_Output (op, _idx++);
			return (s, u, v);
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IsNan'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IsNan (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IsNan", MakeName ("IsNan", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdagradV2'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <param name="update_slots">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceApplyAdagradV2 (TF_Output var, TF_Output accum, TF_Output lr, TF_Output epsilon, TF_Output grad, bool? use_locking = null, bool? update_slots = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyAdagradV2", MakeName ("ResourceApplyAdagradV2", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (update_slots.HasValue)
				c_api.TF_SetAttrBool (desc, "update_slots", Convert.ToByte(update_slots.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_handles">
		/// </param>
		/// <param name="tensor">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListPushBackBatch'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorListPushBackBatch (TF_Output input_handles, TF_Output tensor, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListPushBackBatch", MakeName ("TensorListPushBackBatch", operName));
			c_api.TF_AddInput(desc, input_handles);
			c_api.TF_AddInput(desc, tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_handles = new TF_Output (op, _idx++);
			return output_handles;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TPUOrdinalSelector'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TPUOrdinalSelector (string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TPUOrdinalSelector", MakeName ("TPUOrdinalSelector", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var device_ordinals = new TF_Output (op, _idx++);
			return device_ordinals;
		}

		/// <summary>
		/// </summary>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FractionalAvgPool'.
		/// </param>
		/// <param name="pseudo_random">
		///   Optional argument
		/// </param>
		/// <param name="overlapping">
		///   Optional argument
		/// </param>
		/// <param name="deterministic">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="pooling_ratio">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   row_pooling_sequence:
		///   col_pooling_sequence:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output row_pooling_sequence, TF_Output col_pooling_sequence) FractionalAvgPool (TF_Output value, float[] pooling_ratio, bool? pseudo_random = null, bool? overlapping = null, bool? deterministic = null, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FractionalAvgPool", MakeName ("FractionalAvgPool", operName));
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFloatList (desc, "pooling_ratio", ref pooling_ratio[0], pooling_ratio.Length);
			if (pseudo_random.HasValue)
				c_api.TF_SetAttrBool (desc, "pseudo_random", Convert.ToByte(pseudo_random.Value));
			
			if (overlapping.HasValue)
				c_api.TF_SetAttrBool (desc, "overlapping", Convert.ToByte(overlapping.Value));
			
			if (deterministic.HasValue)
				c_api.TF_SetAttrBool (desc, "deterministic", Convert.ToByte(deterministic.Value));
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var row_pooling_sequence = new TF_Output (op, _idx++);
			var col_pooling_sequence = new TF_Output (op, _idx++);
			return (output, row_pooling_sequence, col_pooling_sequence);
		}

		/// <summary>
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListLength'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorListLength (TF_Output input_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListLength", MakeName ("TensorListLength", operName));
			c_api.TF_AddInput(desc, input_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var length = new TF_Output (op, _idx++);
			return length;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="reduction_indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Mean'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Mean (TF_Output input, TF_Output reduction_indices, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Mean", MakeName ("Mean", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, reduction_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="element_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListStack'.
		/// </param>
		/// <param name="num_elements">
		///   Optional argument
		/// </param>
		/// <param name="element_dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorListStack (TF_Output input_handle, TF_Output element_shape, TF_DataType element_dtype, long? num_elements = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListStack", MakeName ("TensorListStack", operName));
			c_api.TF_AddInput(desc, input_handle);
			c_api.TF_AddInput(desc, element_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "element_dtype", element_dtype);
			if (num_elements.HasValue)
				c_api.TF_SetAttrInt (desc, "num_elements", num_elements.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var tensor = new TF_Output (op, _idx++);
			return tensor;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListConcat'.
		/// </param>
		/// <param name="element_shape">
		///   Optional argument
		/// </param>
		/// <param name="element_dtype">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   tensor:
		///   lengths:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output tensor, TF_Output lengths) TensorListConcat (TF_Output input_handle, TF_DataType element_dtype, long[] element_shape = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListConcat", MakeName ("TensorListConcat", operName));
			c_api.TF_AddInput(desc, input_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "element_dtype", element_dtype);
			if (element_shape != null)
				c_api.TF_SetAttrShape (desc, "element_shape", ref element_shape[0], element_shape.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var tensor = new TF_Output (op, _idx++);
			var lengths = new TF_Output (op, _idx++);
			return (tensor, lengths);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingADAMParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters:
		///   momenta:
		///   velocities:
		///   gradient_accumulators:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output parameters, TF_Output momenta, TF_Output velocities, TF_Output gradient_accumulators) RetrieveTPUEmbeddingADAMParametersGradAccumDebug (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingADAMParametersGradAccumDebug", MakeName ("RetrieveTPUEmbeddingADAMParametersGradAccumDebug", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var momenta = new TF_Output (op, _idx++);
			var velocities = new TF_Output (op, _idx++);
			var gradient_accumulators = new TF_Output (op, _idx++);
			return (parameters, momenta, velocities, gradient_accumulators);
		}

		/// <summary>
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="element_shape">
		/// </param>
		/// <param name="leading_dims">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListConcatV2'.
		/// </param>
		/// <param name="element_dtype">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   tensor:
		///   lengths:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output tensor, TF_Output lengths) TensorListConcatV2 (TF_Output input_handle, TF_Output element_shape, TF_Output leading_dims, TF_DataType element_dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListConcatV2", MakeName ("TensorListConcatV2", operName));
			c_api.TF_AddInput(desc, input_handle);
			c_api.TF_AddInput(desc, element_shape);
			c_api.TF_AddInput(desc, leading_dims);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "element_dtype", element_dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var tensor = new TF_Output (op, _idx++);
			var lengths = new TF_Output (op, _idx++);
			return (tensor, lengths);
		}

		/// <summary>
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="element_shape">
		/// </param>
		/// <param name="lengths">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListSplit'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorListSplit (TF_Output tensor, TF_Output element_shape, TF_Output lengths, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListSplit", MakeName ("TensorListSplit", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, element_shape);
			c_api.TF_AddInput(desc, lengths);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			return output_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="tag">
		/// </param>
		/// <param name="tensor">
		/// </param>
		/// <param name="serialized_summary_metadata">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorSummaryV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorSummaryV2 (TF_Output tag, TF_Output tensor, TF_Output serialized_summary_metadata, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorSummaryV2", MakeName ("TensorSummaryV2", operName));
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, serialized_summary_metadata);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var summary = new TF_Output (op, _idx++);
			return summary;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListElementShape'.
		/// </param>
		/// <param name="shape_type">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorListElementShape (TF_Output input_handle, TF_DataType shape_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListElementShape", MakeName ("TensorListElementShape", operName));
			c_api.TF_AddInput(desc, input_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "shape_type", shape_type);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var element_shape = new TF_Output (op, _idx++);
			return element_shape;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Assign'.
		/// </param>
		/// <param name="validate_shape">
		///   Optional argument
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Assign (TF_Output reference, TF_Output value, bool? validate_shape = null, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Assign", MakeName ("Assign", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (validate_shape.HasValue)
				c_api.TF_SetAttrBool (desc, "validate_shape", Convert.ToByte(validate_shape.Value));
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		/// </summary>
		/// <param name="element_shape">
		/// </param>
		/// <param name="num_elements">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListReserve'.
		/// </param>
		/// <param name="element_dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorListReserve (TF_Output element_shape, TF_Output num_elements, TF_DataType element_dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListReserve", MakeName ("TensorListReserve", operName));
			c_api.TF_AddInput(desc, element_shape);
			c_api.TF_AddInput(desc, num_elements);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "element_dtype", element_dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="index">
		/// </param>
		/// <param name="element_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListGetItem'.
		/// </param>
		/// <param name="element_dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorListGetItem (TF_Output input_handle, TF_Output index, TF_Output element_shape, TF_DataType element_dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListGetItem", MakeName ("TensorListGetItem", operName));
			c_api.TF_AddInput(desc, input_handle);
			c_api.TF_AddInput(desc, index);
			c_api.TF_AddInput(desc, element_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "element_dtype", element_dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var item = new TF_Output (op, _idx++);
			return item;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListResize'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorListResize (TF_Output input_handle, TF_Output size, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListResize", MakeName ("TensorListResize", operName));
			c_api.TF_AddInput(desc, input_handle);
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			return output_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReadVariableOp'.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ReadVariableOp (TF_Output resource, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReadVariableOp", MakeName ("ReadVariableOp", operName));
			c_api.TF_AddInput(desc, resource);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			return value;
		}

		/// <summary>
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="element_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListScatter'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorListScatter (TF_Output tensor, TF_Output indices, TF_Output element_shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListScatter", MakeName ("TensorListScatter", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, element_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			return output_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="algorithm">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatefulTruncatedNormal'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StatefulTruncatedNormal (TF_Output resource, TF_Output algorithm, TF_Output shape, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatefulTruncatedNormal", MakeName ("StatefulTruncatedNormal", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, algorithm);
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="element_shape">
		/// </param>
		/// <param name="num_elements">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListScatterV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorListScatterV2 (TF_Output tensor, TF_Output indices, TF_Output element_shape, TF_Output num_elements, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListScatterV2", MakeName ("TensorListScatterV2", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, element_shape);
			c_api.TF_AddInput(desc, num_elements);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			return output_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="x1">
		/// </param>
		/// <param name="x2">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NextAfter'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output NextAfter (TF_Output x1, TF_Output x2, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NextAfter", MakeName ("NextAfter", operName));
			c_api.TF_AddInput(desc, x1);
			c_api.TF_AddInput(desc, x2);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingMomentumParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters:
		///   momenta:
		///   gradient_accumulators:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output parameters, TF_Output momenta, TF_Output gradient_accumulators) RetrieveTPUEmbeddingMomentumParametersGradAccumDebug (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingMomentumParametersGradAccumDebug", MakeName ("RetrieveTPUEmbeddingMomentumParametersGradAccumDebug", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var momenta = new TF_Output (op, _idx++);
			var gradient_accumulators = new TF_Output (op, _idx++);
			return (parameters, momenta, gradient_accumulators);
		}

		/// <summary>
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="tensor">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListScatterIntoExistingList'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorListScatterIntoExistingList (TF_Output input_handle, TF_Output tensor, TF_Output indices, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListScatterIntoExistingList", MakeName ("TensorListScatterIntoExistingList", operName));
			c_api.TF_AddInput(desc, input_handle);
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			return output_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="condition">
		/// </param>
		/// <param name="data">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Assert'.
		/// </param>
		/// <param name="summarize">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation Assert (TF_Output condition, TF_Output[] data, long? summarize = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Assert", MakeName ("Assert", operName));
			c_api.TF_AddInput(desc, condition);
			c_api.TF_AddInputList(desc, data[0], data.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (summarize.HasValue)
				c_api.TF_SetAttrInt (desc, "summarize", summarize.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="data">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Print'.
		/// </param>
		/// <param name="message">
		///   Optional argument
		/// </param>
		/// <param name="first_n">
		///   Optional argument
		/// </param>
		/// <param name="summarize">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Print (TF_Output input, TF_Output[] data, string message = null, long? first_n = null, long? summarize = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Print", MakeName ("Print", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInputList(desc, data[0], data.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (message != null)
				c_api.TF_SetAttrString (desc, "message", message);
			
			if (first_n.HasValue)
				c_api.TF_SetAttrInt (desc, "first_n", first_n.Value);
			
			if (summarize.HasValue)
				c_api.TF_SetAttrInt (desc, "summarize", summarize.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PrintV2'.
		/// </param>
		/// <param name="output_stream">
		///   Optional argument
		/// </param>
		/// <param name="end">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation PrintV2 (TF_Output input, string output_stream = null, string end = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PrintV2", MakeName ("PrintV2", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (output_stream != null)
				c_api.TF_SetAttrString (desc, "output_stream", output_stream);
			
			if (end != null)
				c_api.TF_SetAttrString (desc, "end", end);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorSummary'.
		/// </param>
		/// <param name="description">
		///   Optional argument
		/// </param>
		/// <param name="labels">
		///   Optional argument
		/// </param>
		/// <param name="display_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorSummary (TF_Output tensor, string description = null, string[] labels = null, string display_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorSummary", MakeName ("TensorSummary", operName));
			c_api.TF_AddInput(desc, tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (description != null)
				c_api.TF_SetAttrString (desc, "description", description);
			
			if (labels != null)
				c_api.TF_SetAttrStringList (desc, "labels", labels);
			
			if (display_name != null)
				c_api.TF_SetAttrString (desc, "display_name", display_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var summary = new TF_Output (op, _idx++);
			return summary;
		}

		/// <summary>
		/// </summary>
		/// <param name="tag">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'HistogramSummary'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output HistogramSummary (TF_Output tag, TF_Output values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "HistogramSummary", MakeName ("HistogramSummary", operName));
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var summary = new TF_Output (op, _idx++);
			return summary;
		}

		/// <summary>
		/// </summary>
		/// <param name="tag">
		/// </param>
		/// <param name="tensor">
		/// </param>
		/// <param name="sample_rate">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AudioSummaryV2'.
		/// </param>
		/// <param name="max_outputs">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AudioSummaryV2 (TF_Output tag, TF_Output tensor, TF_Output sample_rate, long? max_outputs = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AudioSummaryV2", MakeName ("AudioSummaryV2", operName));
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, sample_rate);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (max_outputs.HasValue)
				c_api.TF_SetAttrInt (desc, "max_outputs", max_outputs.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var summary = new TF_Output (op, _idx++);
			return summary;
		}

		/// <summary>
		/// </summary>
		/// <param name="tag">
		/// </param>
		/// <param name="tensor">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AudioSummary'.
		/// </param>
		/// <param name="max_outputs">
		///   Optional argument
		/// </param>
		/// <param name="sample_rate">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AudioSummary (TF_Output tag, TF_Output tensor, float sample_rate, long? max_outputs = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AudioSummary", MakeName ("AudioSummary", operName));
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFloat (desc, "sample_rate", sample_rate);
			if (max_outputs.HasValue)
				c_api.TF_SetAttrInt (desc, "max_outputs", max_outputs.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var summary = new TF_Output (op, _idx++);
			return summary;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="m">
		/// </param>
		/// <param name="v">
		/// </param>
		/// <param name="beta1_power">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="beta1">
		/// </param>
		/// <param name="beta2">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdaMax'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceApplyAdaMax (TF_Output var, TF_Output m, TF_Output v, TF_Output beta1_power, TF_Output lr, TF_Output beta1, TF_Output beta2, TF_Output epsilon, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyAdaMax", MakeName ("ResourceApplyAdaMax", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, v);
			c_api.TF_AddInput(desc, beta1_power);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, beta1);
			c_api.TF_AddInput(desc, beta2);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MergeSummary'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MergeSummary (TF_Output[] inputs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MergeSummary", MakeName ("MergeSummary", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var summary = new TF_Output (op, _idx++);
			return summary;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnicodeScript'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output UnicodeScript (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnicodeScript", MakeName ("UnicodeScript", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Timestamp'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Timestamp (string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Timestamp", MakeName ("Timestamp", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var ts = new TF_Output (op, _idx++);
			return ts;
		}

		/// <summary>
		/// </summary>
		/// <param name="table_handle">
		/// </param>
		/// <param name="keys">
		/// </param>
		/// <param name="default_value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableFind'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LookupTableFind (TF_Output table_handle, TF_Output keys, TF_Output default_value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableFind", MakeName ("LookupTableFind", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, keys);
			c_api.TF_AddInput(desc, default_value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var values = new TF_Output (op, _idx++);
			return values;
		}

		/// <summary>
		/// </summary>
		/// <param name="gradients">
		/// </param>
		/// <param name="outputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SeluGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SeluGrad (TF_Output gradients, TF_Output outputs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SeluGrad", MakeName ("SeluGrad", operName));
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, outputs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var backprops = new TF_Output (op, _idx++);
			return backprops;
		}

		/// <summary>
		/// </summary>
		/// <param name="table_handle">
		/// </param>
		/// <param name="keys">
		/// </param>
		/// <param name="default_value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableFindV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LookupTableFindV2 (TF_Output table_handle, TF_Output keys, TF_Output default_value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableFindV2", MakeName ("LookupTableFindV2", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, keys);
			c_api.TF_AddInput(desc, default_value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var values = new TF_Output (op, _idx++);
			return values;
		}

		/// <summary>
		/// </summary>
		/// <param name="table_handle">
		/// </param>
		/// <param name="keys">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableInsert'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LookupTableInsert (TF_Output table_handle, TF_Output keys, TF_Output values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableInsert", MakeName ("LookupTableInsert", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, keys);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SerializeTensor'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SerializeTensor (TF_Output tensor, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SerializeTensor", MakeName ("SerializeTensor", operName));
			c_api.TF_AddInput(desc, tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var serialized = new TF_Output (op, _idx++);
			return serialized;
		}

		/// <summary>
		/// </summary>
		/// <param name="y">
		/// </param>
		/// <param name="dy">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InvGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output InvGrad (TF_Output y, TF_Output dy, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InvGrad", MakeName ("InvGrad", operName));
			c_api.TF_AddInput(desc, y);
			c_api.TF_AddInput(desc, dy);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="table_handle">
		/// </param>
		/// <param name="keys">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableInsertV2'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LookupTableInsertV2 (TF_Output table_handle, TF_Output keys, TF_Output values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableInsertV2", MakeName ("LookupTableInsertV2", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, keys);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="table_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableSizeV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LookupTableSizeV2 (TF_Output table_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableSizeV2", MakeName ("LookupTableSizeV2", operName));
			c_api.TF_AddInput(desc, table_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		/// </summary>
		/// <param name="table_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableExport'.
		/// </param>
		/// <param name="Tkeys">
		/// </param>
		/// <param name="Tvalues">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   keys:
		///   values:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output keys, TF_Output values) LookupTableExport (TF_Output table_handle, TF_DataType Tkeys, TF_DataType Tvalues, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableExport", MakeName ("LookupTableExport", operName));
			c_api.TF_AddInput(desc, table_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "Tkeys", Tkeys);
			c_api.TF_SetAttrType (desc, "Tvalues", Tvalues);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var keys = new TF_Output (op, _idx++);
			var values = new TF_Output (op, _idx++);
			return (keys, values);
		}

		/// <summary>
		/// </summary>
		/// <param name="table_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableExportV2'.
		/// </param>
		/// <param name="Tkeys">
		/// </param>
		/// <param name="Tvalues">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   keys:
		///   values:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output keys, TF_Output values) LookupTableExportV2 (TF_Output table_handle, TF_DataType Tkeys, TF_DataType Tvalues, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableExportV2", MakeName ("LookupTableExportV2", operName));
			c_api.TF_AddInput(desc, table_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "Tkeys", Tkeys);
			c_api.TF_SetAttrType (desc, "Tvalues", Tvalues);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var keys = new TF_Output (op, _idx++);
			var values = new TF_Output (op, _idx++);
			return (keys, values);
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Rsqrt'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Rsqrt (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Rsqrt", MakeName ("Rsqrt", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AssignAddVariableOp'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation AssignAddVariableOp (TF_Output resource, TF_Output value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AssignAddVariableOp", MakeName ("AssignAddVariableOp", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="table_handle">
		/// </param>
		/// <param name="keys">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableImportV2'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LookupTableImportV2 (TF_Output table_handle, TF_Output keys, TF_Output values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableImportV2", MakeName ("LookupTableImportV2", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, keys);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'HashTable'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="use_node_name_sharing">
		///   Optional argument
		/// </param>
		/// <param name="key_dtype">
		/// </param>
		/// <param name="value_dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output HashTable (TF_DataType key_dtype, TF_DataType value_dtype, string container = null, string shared_name = null, bool? use_node_name_sharing = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "HashTable", MakeName ("HashTable", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "key_dtype", key_dtype);
			c_api.TF_SetAttrType (desc, "value_dtype", value_dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (use_node_name_sharing.HasValue)
				c_api.TF_SetAttrBool (desc, "use_node_name_sharing", Convert.ToByte(use_node_name_sharing.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var table_handle = new TF_Output (op, _idx++);
			return table_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'HashTableV2'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="use_node_name_sharing">
		///   Optional argument
		/// </param>
		/// <param name="key_dtype">
		/// </param>
		/// <param name="value_dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output HashTableV2 (TF_DataType key_dtype, TF_DataType value_dtype, string container = null, string shared_name = null, bool? use_node_name_sharing = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "HashTableV2", MakeName ("HashTableV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "key_dtype", key_dtype);
			c_api.TF_SetAttrType (desc, "value_dtype", value_dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (use_node_name_sharing.HasValue)
				c_api.TF_SetAttrBool (desc, "use_node_name_sharing", Convert.ToByte(use_node_name_sharing.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var table_handle = new TF_Output (op, _idx++);
			return table_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableHashTableV2'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="use_node_name_sharing">
		///   Optional argument
		/// </param>
		/// <param name="key_dtype">
		/// </param>
		/// <param name="value_dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MutableHashTableV2 (TF_DataType key_dtype, TF_DataType value_dtype, string container = null, string shared_name = null, bool? use_node_name_sharing = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MutableHashTableV2", MakeName ("MutableHashTableV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "key_dtype", key_dtype);
			c_api.TF_SetAttrType (desc, "value_dtype", value_dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (use_node_name_sharing.HasValue)
				c_api.TF_SetAttrBool (desc, "use_node_name_sharing", Convert.ToByte(use_node_name_sharing.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var table_handle = new TF_Output (op, _idx++);
			return table_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="empty_key">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableDenseHashTable'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="use_node_name_sharing">
		///   Optional argument
		/// </param>
		/// <param name="value_shape">
		///   Optional argument
		/// </param>
		/// <param name="initial_num_buckets">
		///   Optional argument
		/// </param>
		/// <param name="max_load_factor">
		///   Optional argument
		/// </param>
		/// <param name="value_dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MutableDenseHashTable (TF_Output empty_key, TF_DataType value_dtype, string container = null, string shared_name = null, bool? use_node_name_sharing = null, long[] value_shape = null, long? initial_num_buckets = null, float? max_load_factor = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MutableDenseHashTable", MakeName ("MutableDenseHashTable", operName));
			c_api.TF_AddInput(desc, empty_key);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "value_dtype", value_dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (use_node_name_sharing.HasValue)
				c_api.TF_SetAttrBool (desc, "use_node_name_sharing", Convert.ToByte(use_node_name_sharing.Value));
			
			if (value_shape != null)
				c_api.TF_SetAttrShape (desc, "value_shape", ref value_shape[0], value_shape.Length);
			
			if (initial_num_buckets.HasValue)
				c_api.TF_SetAttrInt (desc, "initial_num_buckets", initial_num_buckets.Value);
			
			if (max_load_factor.HasValue)
				c_api.TF_SetAttrFloat (desc, "max_load_factor", max_load_factor.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var table_handle = new TF_Output (op, _idx++);
			return table_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="empty_key">
		/// </param>
		/// <param name="deleted_key">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableDenseHashTableV2'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="use_node_name_sharing">
		///   Optional argument
		/// </param>
		/// <param name="value_shape">
		///   Optional argument
		/// </param>
		/// <param name="initial_num_buckets">
		///   Optional argument
		/// </param>
		/// <param name="max_load_factor">
		///   Optional argument
		/// </param>
		/// <param name="value_dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MutableDenseHashTableV2 (TF_Output empty_key, TF_Output deleted_key, TF_DataType value_dtype, string container = null, string shared_name = null, bool? use_node_name_sharing = null, long[] value_shape = null, long? initial_num_buckets = null, float? max_load_factor = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MutableDenseHashTableV2", MakeName ("MutableDenseHashTableV2", operName));
			c_api.TF_AddInput(desc, empty_key);
			c_api.TF_AddInput(desc, deleted_key);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "value_dtype", value_dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (use_node_name_sharing.HasValue)
				c_api.TF_SetAttrBool (desc, "use_node_name_sharing", Convert.ToByte(use_node_name_sharing.Value));
			
			if (value_shape != null)
				c_api.TF_SetAttrShape (desc, "value_shape", ref value_shape[0], value_shape.Length);
			
			if (initial_num_buckets.HasValue)
				c_api.TF_SetAttrInt (desc, "initial_num_buckets", initial_num_buckets.Value);
			
			if (max_load_factor.HasValue)
				c_api.TF_SetAttrFloat (desc, "max_load_factor", max_load_factor.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var table_handle = new TF_Output (op, _idx++);
			return table_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="cs_prev">
		/// </param>
		/// <param name="h_prev">
		/// </param>
		/// <param name="w">
		/// </param>
		/// <param name="wci">
		/// </param>
		/// <param name="wcf">
		/// </param>
		/// <param name="wco">
		/// </param>
		/// <param name="b">
		/// </param>
		/// <param name="i">
		/// </param>
		/// <param name="cs">
		/// </param>
		/// <param name="f">
		/// </param>
		/// <param name="o">
		/// </param>
		/// <param name="ci">
		/// </param>
		/// <param name="co">
		/// </param>
		/// <param name="cs_grad">
		/// </param>
		/// <param name="h_grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LSTMBlockCellGrad'.
		/// </param>
		/// <param name="use_peephole">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   cs_prev_grad:
		///   dicfo:
		///   wci_grad:
		///   wcf_grad:
		///   wco_grad:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output cs_prev_grad, TF_Output dicfo, TF_Output wci_grad, TF_Output wcf_grad, TF_Output wco_grad) LSTMBlockCellGrad (TF_Output x, TF_Output cs_prev, TF_Output h_prev, TF_Output w, TF_Output wci, TF_Output wcf, TF_Output wco, TF_Output b, TF_Output i, TF_Output cs, TF_Output f, TF_Output o, TF_Output ci, TF_Output co, TF_Output cs_grad, TF_Output h_grad, bool use_peephole, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LSTMBlockCellGrad", MakeName ("LSTMBlockCellGrad", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, cs_prev);
			c_api.TF_AddInput(desc, h_prev);
			c_api.TF_AddInput(desc, w);
			c_api.TF_AddInput(desc, wci);
			c_api.TF_AddInput(desc, wcf);
			c_api.TF_AddInput(desc, wco);
			c_api.TF_AddInput(desc, b);
			c_api.TF_AddInput(desc, i);
			c_api.TF_AddInput(desc, cs);
			c_api.TF_AddInput(desc, f);
			c_api.TF_AddInput(desc, o);
			c_api.TF_AddInput(desc, ci);
			c_api.TF_AddInput(desc, co);
			c_api.TF_AddInput(desc, cs_grad);
			c_api.TF_AddInput(desc, h_grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrBool (desc, "use_peephole", Convert.ToByte(use_peephole));
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var cs_prev_grad = new TF_Output (op, _idx++);
			var dicfo = new TF_Output (op, _idx++);
			var wci_grad = new TF_Output (op, _idx++);
			var wcf_grad = new TF_Output (op, _idx++);
			var wco_grad = new TF_Output (op, _idx++);
			return (cs_prev_grad, dicfo, wci_grad, wcf_grad, wco_grad);
		}

		/// <summary>
		/// </summary>
		/// <param name="table_handle">
		/// </param>
		/// <param name="keys">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InitializeTable'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation InitializeTable (TF_Output table_handle, TF_Output keys, TF_Output values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InitializeTable", MakeName ("InitializeTable", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, keys);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="shape">
		/// </param>
		/// <param name="rate">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomPoisson'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RandomPoisson (TF_Output shape, TF_Output rate, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomPoisson", MakeName ("RandomPoisson", operName));
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, rate);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="set1">
		/// </param>
		/// <param name="set2">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DenseToDenseSetOperation'.
		/// </param>
		/// <param name="validate_indices">
		///   Optional argument
		/// </param>
		/// <param name="set_operation">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   result_indices:
		///   result_values:
		///   result_shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output result_indices, TF_Output result_values, TF_Output result_shape) DenseToDenseSetOperation (TF_Output set1, TF_Output set2, string set_operation, bool? validate_indices = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DenseToDenseSetOperation", MakeName ("DenseToDenseSetOperation", operName));
			c_api.TF_AddInput(desc, set1);
			c_api.TF_AddInput(desc, set2);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "set_operation", set_operation);
			if (validate_indices.HasValue)
				c_api.TF_SetAttrBool (desc, "validate_indices", Convert.ToByte(validate_indices.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var result_indices = new TF_Output (op, _idx++);
			var result_values = new TF_Output (op, _idx++);
			var result_shape = new TF_Output (op, _idx++);
			return (result_indices, result_values, result_shape);
		}

		/// <summary>
		/// </summary>
		/// <param name="table_handle">
		/// </param>
		/// <param name="keys">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InitializeTableV2'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation InitializeTableV2 (TF_Output table_handle, TF_Output keys, TF_Output values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InitializeTableV2", MakeName ("InitializeTableV2", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, keys);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="shape">
		/// </param>
		/// <param name="rate">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomPoissonV2'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RandomPoissonV2 (TF_Output shape, TF_Output rate, long? seed = null, long? seed2 = null, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomPoissonV2", MakeName ("RandomPoissonV2", operName));
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, rate);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="a">
		/// </param>
		/// <param name="b">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseMatMul'.
		/// </param>
		/// <param name="transpose_a">
		///   Optional argument
		/// </param>
		/// <param name="transpose_b">
		///   Optional argument
		/// </param>
		/// <param name="a_is_sparse">
		///   Optional argument
		/// </param>
		/// <param name="b_is_sparse">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseMatMul (TF_Output a, TF_Output b, bool? transpose_a = null, bool? transpose_b = null, bool? a_is_sparse = null, bool? b_is_sparse = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseMatMul", MakeName ("SparseMatMul", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (transpose_a.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_a", Convert.ToByte(transpose_a.Value));
			
			if (transpose_b.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_b", Convert.ToByte(transpose_b.Value));
			
			if (a_is_sparse.HasValue)
				c_api.TF_SetAttrBool (desc, "a_is_sparse", Convert.ToByte(a_is_sparse.Value));
			
			if (b_is_sparse.HasValue)
				c_api.TF_SetAttrBool (desc, "b_is_sparse", Convert.ToByte(b_is_sparse.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var product = new TF_Output (op, _idx++);
			return product;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="m">
		/// </param>
		/// <param name="v">
		/// </param>
		/// <param name="beta1_power">
		/// </param>
		/// <param name="beta2_power">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="beta1">
		/// </param>
		/// <param name="beta2">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdam'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <param name="use_nesterov">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ApplyAdam (TF_Output var, TF_Output m, TF_Output v, TF_Output beta1_power, TF_Output beta2_power, TF_Output lr, TF_Output beta1, TF_Output beta2, TF_Output epsilon, TF_Output grad, bool? use_locking = null, bool? use_nesterov = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyAdam", MakeName ("ApplyAdam", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, v);
			c_api.TF_AddInput(desc, beta1_power);
			c_api.TF_AddInput(desc, beta2_power);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, beta1);
			c_api.TF_AddInput(desc, beta2);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (use_nesterov.HasValue)
				c_api.TF_SetAttrBool (desc, "use_nesterov", Convert.ToByte(use_nesterov.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="table_handle">
		/// </param>
		/// <param name="filename">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InitializeTableFromTextFile'.
		/// </param>
		/// <param name="vocab_size">
		///   Optional argument
		/// </param>
		/// <param name="delimiter">
		///   Optional argument
		/// </param>
		/// <param name="key_index">
		/// </param>
		/// <param name="value_index">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation InitializeTableFromTextFile (TF_Output table_handle, TF_Output filename, long key_index, long value_index, long? vocab_size = null, string delimiter = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InitializeTableFromTextFile", MakeName ("InitializeTableFromTextFile", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, filename);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "key_index", key_index);
			c_api.TF_SetAttrInt (desc, "value_index", value_index);
			if (vocab_size.HasValue)
				c_api.TF_SetAttrInt (desc, "vocab_size", vocab_size.Value);
			
			if (delimiter != null)
				c_api.TF_SetAttrString (desc, "delimiter", delimiter);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Tanh'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Tanh (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Tanh", MakeName ("Tanh", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="table_handle">
		/// </param>
		/// <param name="filename">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InitializeTableFromTextFileV2'.
		/// </param>
		/// <param name="vocab_size">
		///   Optional argument
		/// </param>
		/// <param name="delimiter">
		///   Optional argument
		/// </param>
		/// <param name="key_index">
		/// </param>
		/// <param name="value_index">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation InitializeTableFromTextFileV2 (TF_Output table_handle, TF_Output filename, long key_index, long value_index, long? vocab_size = null, string delimiter = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InitializeTableFromTextFileV2", MakeName ("InitializeTableFromTextFileV2", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, filename);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "key_index", key_index);
			c_api.TF_SetAttrInt (desc, "value_index", value_index);
			if (vocab_size.HasValue)
				c_api.TF_SetAttrInt (desc, "vocab_size", vocab_size.Value);
			
			if (delimiter != null)
				c_api.TF_SetAttrString (desc, "delimiter", delimiter);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="a">
		/// </param>
		/// <param name="b">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_a">
		/// </param>
		/// <param name="max_a">
		/// </param>
		/// <param name="min_b">
		/// </param>
		/// <param name="max_b">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedMatMulWithBias'.
		/// </param>
		/// <param name="Toutput">
		///   Optional argument
		/// </param>
		/// <param name="transpose_a">
		///   Optional argument
		/// </param>
		/// <param name="transpose_b">
		///   Optional argument
		/// </param>
		/// <param name="input_quant_mode">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_out:
		///   max_out:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_out, TF_Output max_out) QuantizedMatMulWithBias (TF_Output a, TF_Output b, TF_Output bias, TF_Output min_a, TF_Output max_a, TF_Output min_b, TF_Output max_b, TF_DataType? Toutput = null, bool? transpose_a = null, bool? transpose_b = null, string input_quant_mode = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedMatMulWithBias", MakeName ("QuantizedMatMulWithBias", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, b);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_a);
			c_api.TF_AddInput(desc, max_a);
			c_api.TF_AddInput(desc, min_b);
			c_api.TF_AddInput(desc, max_b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Toutput.HasValue)
				c_api.TF_SetAttrType (desc, "Toutput", Toutput.Value);
			
			if (transpose_a.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_a", Convert.ToByte(transpose_a.Value));
			
			if (transpose_b.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_b", Convert.ToByte(transpose_b.Value));
			
			if (input_quant_mode != null)
				c_api.TF_SetAttrString (desc, "input_quant_mode", input_quant_mode);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_out = new TF_Output (op, _idx++);
			var max_out = new TF_Output (op, _idx++);
			return (output, min_out, max_out);
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="linear">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="l2_shrinkage">
		/// </param>
		/// <param name="lr_power">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyFtrlV2'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceSparseApplyFtrlV2 (TF_Output var, TF_Output accum, TF_Output linear, TF_Output grad, TF_Output indices, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output l2_shrinkage, TF_Output lr_power, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyFtrlV2", MakeName ("ResourceSparseApplyFtrlV2", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, linear);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, l2_shrinkage);
			c_api.TF_AddInput(desc, lr_power);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AccumulateNV2'.
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AccumulateNV2 (TF_Output[] inputs, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AccumulateNV2", MakeName ("AccumulateNV2", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var sum = new TF_Output (op, _idx++);
			return sum;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatMulV2'.
		/// </param>
		/// <param name="adj_x">
		///   Optional argument
		/// </param>
		/// <param name="adj_y">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchMatMulV2 (TF_Output x, TF_Output y, bool? adj_x = null, bool? adj_y = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatMulV2", MakeName ("BatchMatMulV2", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (adj_x.HasValue)
				c_api.TF_SetAttrBool (desc, "adj_x", Convert.ToByte(adj_x.Value));
			
			if (adj_y.HasValue)
				c_api.TF_SetAttrBool (desc, "adj_y", Convert.ToByte(adj_y.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Cast'.
		/// </param>
		/// <param name="Truncate">
		///   Optional argument
		/// </param>
		/// <param name="DstT">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Cast (TF_Output x, TF_DataType DstT, bool? Truncate = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Cast", MakeName ("Cast", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "DstT", DstT);
			if (Truncate.HasValue)
				c_api.TF_SetAttrBool (desc, "Truncate", Convert.ToByte(Truncate.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Abs'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Abs (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Abs", MakeName ("Abs", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ComplexAbs'.
		/// </param>
		/// <param name="Tout">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ComplexAbs (TF_Output x, TF_DataType? Tout = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ComplexAbs", MakeName ("ComplexAbs", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Tout.HasValue)
				c_api.TF_SetAttrType (desc, "Tout", Tout.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Dilation2D'.
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="rates">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Dilation2D (TF_Output input, TF_Output filter, long[] strides, long[] rates, string padding, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Dilation2D", MakeName ("Dilation2D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrIntList (desc, "rates", ref rates[0], rates.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Neg'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Neg (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Neg", MakeName ("Neg", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="min_freezed_output">
		/// </param>
		/// <param name="max_freezed_output">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DAndRequantize'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="padding_list">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DAndRequantize (TF_Output input, TF_Output filter, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, TF_Output min_freezed_output, TF_Output max_freezed_output, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, long[] padding_list = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DAndRequantize", MakeName ("QuantizedConv2DAndRequantize", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			c_api.TF_AddInput(desc, min_freezed_output);
			c_api.TF_AddInput(desc, max_freezed_output);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			if (padding_list != null)
				c_api.TF_SetAttrIntList (desc, "padding_list", ref padding_list[0], padding_list.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterMax'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceScatterMax (TF_Output resource, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceScatterMax", MakeName ("ResourceScatterMax", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Reciprocal'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Reciprocal (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Reciprocal", MakeName ("Reciprocal", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Square'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Square (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Square", MakeName ("Square", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DataFormatVecPermute'.
		/// </param>
		/// <param name="src_format">
		///   Optional argument
		/// </param>
		/// <param name="dst_format">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DataFormatVecPermute (TF_Output x, string src_format = null, string dst_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DataFormatVecPermute", MakeName ("DataFormatVecPermute", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (src_format != null)
				c_api.TF_SetAttrString (desc, "src_format", src_format);
			
			if (dst_format != null)
				c_api.TF_SetAttrString (desc, "dst_format", dst_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Sqrt'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Sqrt (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Sqrt", MakeName ("Sqrt", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Log1p'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Log1p (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Log1p", MakeName ("Log1p", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="seq_len_max">
		/// </param>
		/// <param name="x">
		/// </param>
		/// <param name="cs_prev">
		/// </param>
		/// <param name="h_prev">
		/// </param>
		/// <param name="w">
		/// </param>
		/// <param name="wci">
		/// </param>
		/// <param name="wcf">
		/// </param>
		/// <param name="wco">
		/// </param>
		/// <param name="b">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BlockLSTM'.
		/// </param>
		/// <param name="forget_bias">
		///   Optional argument
		/// </param>
		/// <param name="cell_clip">
		///   Optional argument
		/// </param>
		/// <param name="use_peephole">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   i:
		///   cs:
		///   f:
		///   o:
		///   ci:
		///   co:
		///   h:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output i, TF_Output cs, TF_Output f, TF_Output o, TF_Output ci, TF_Output co, TF_Output h) BlockLSTM (TF_Output seq_len_max, TF_Output x, TF_Output cs_prev, TF_Output h_prev, TF_Output w, TF_Output wci, TF_Output wcf, TF_Output wco, TF_Output b, float? forget_bias = null, float? cell_clip = null, bool? use_peephole = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BlockLSTM", MakeName ("BlockLSTM", operName));
			c_api.TF_AddInput(desc, seq_len_max);
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, cs_prev);
			c_api.TF_AddInput(desc, h_prev);
			c_api.TF_AddInput(desc, w);
			c_api.TF_AddInput(desc, wci);
			c_api.TF_AddInput(desc, wcf);
			c_api.TF_AddInput(desc, wco);
			c_api.TF_AddInput(desc, b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (forget_bias.HasValue)
				c_api.TF_SetAttrFloat (desc, "forget_bias", forget_bias.Value);
			
			if (cell_clip.HasValue)
				c_api.TF_SetAttrFloat (desc, "cell_clip", cell_clip.Value);
			
			if (use_peephole.HasValue)
				c_api.TF_SetAttrBool (desc, "use_peephole", Convert.ToByte(use_peephole.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var i = new TF_Output (op, _idx++);
			var cs = new TF_Output (op, _idx++);
			var f = new TF_Output (op, _idx++);
			var o = new TF_Output (op, _idx++);
			var ci = new TF_Output (op, _idx++);
			var co = new TF_Output (op, _idx++);
			var h = new TF_Output (op, _idx++);
			return (i, cs, f, o, ci, co, h);
		}

		/// <summary>
		/// </summary>
		/// <param name="string_tensor">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringToHashBucket'.
		/// </param>
		/// <param name="num_buckets">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StringToHashBucket (TF_Output string_tensor, long num_buckets, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringToHashBucket", MakeName ("StringToHashBucket", operName));
			c_api.TF_AddInput(desc, string_tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_buckets", num_buckets);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Sinh'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Sinh (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Sinh", MakeName ("Sinh", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Cosh'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Cosh (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Cosh", MakeName ("Cosh", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Acosh'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Acosh (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Acosh", MakeName ("Acosh", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="shape">
		/// </param>
		/// <param name="seed">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatelessRandomUniform'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StatelessRandomUniform (TF_Output shape, TF_Output seed, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatelessRandomUniform", MakeName ("StatelessRandomUniform", operName));
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, seed);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="y">
		/// </param>
		/// <param name="dy">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TanhGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TanhGrad (TF_Output y, TF_Output dy, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TanhGrad", MakeName ("TanhGrad", operName));
			c_api.TF_AddInput(desc, y);
			c_api.TF_AddInput(desc, dy);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Digamma'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Digamma (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Digamma", MakeName ("Digamma", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPool3D'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="ksize">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPool3D (TF_Output input, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPool3D", MakeName ("MaxPool3D", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Erf'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Erf (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Erf", MakeName ("Erf", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomStandardNormal'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RandomStandardNormal (TF_Output shape, TF_DataType dtype, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomStandardNormal", MakeName ("RandomStandardNormal", operName));
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Cos'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Cos (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Cos", MakeName ("Cos", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="min_freezed_output">
		/// </param>
		/// <param name="max_freezed_output">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DWithBiasAndRequantize'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="padding_list">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DWithBiasAndRequantize (TF_Output input, TF_Output filter, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, TF_Output min_freezed_output, TF_Output max_freezed_output, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, long[] padding_list = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DWithBiasAndRequantize", MakeName ("QuantizedConv2DWithBiasAndRequantize", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			c_api.TF_AddInput(desc, min_freezed_output);
			c_api.TF_AddInput(desc, max_freezed_output);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			if (padding_list != null)
				c_api.TF_SetAttrIntList (desc, "padding_list", ref padding_list[0], padding_list.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Asin'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Asin (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Asin", MakeName ("Asin", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_min">
		/// </param>
		/// <param name="input_max">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RequantizationRange'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_min:
		///   output_max:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output_min, TF_Output output_max) RequantizationRange (TF_Output input, TF_Output input_min, TF_Output input_max, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RequantizationRange", MakeName ("RequantizationRange", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_min);
			c_api.TF_AddInput(desc, input_max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_min = new TF_Output (op, _idx++);
			var output_max = new TF_Output (op, _idx++);
			return (output_min, output_max);
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Atan'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Atan (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Atan", MakeName ("Atan", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="threshold">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CompareAndBitpack'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CompareAndBitpack (TF_Output input, TF_Output threshold, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CompareAndBitpack", MakeName ("CompareAndBitpack", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, threshold);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterSub'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceScatterSub (TF_Output resource, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceScatterSub", MakeName ("ResourceScatterSub", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BesselI0e'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BesselI0e (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BesselI0e", MakeName ("BesselI0e", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="a">
		/// </param>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Polygamma'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Polygamma (TF_Output a, TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Polygamma", MakeName ("Polygamma", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AddV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AddV2 (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AddV2", MakeName ("AddV2", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Sub'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Sub (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Sub", MakeName ("Sub", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="accumulators">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingProximalAdagradParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LoadTPUEmbeddingProximalAdagradParameters (TF_Output parameters, TF_Output accumulators, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingProximalAdagradParameters", MakeName ("LoadTPUEmbeddingProximalAdagradParameters", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, accumulators);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Mul'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Mul (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Mul", MakeName ("Mul", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FloorDiv'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FloorDiv (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FloorDiv", MakeName ("FloorDiv", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Xlogy'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Xlogy (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Xlogy", MakeName ("Xlogy", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Xdivy'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Xdivy (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Xdivy", MakeName ("Xdivy", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Maximum'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Maximum (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Maximum", MakeName ("Maximum", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Minimum'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Minimum (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Minimum", MakeName ("Minimum", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Mod'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Mod (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Mod", MakeName ("Mod", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Pow'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Pow (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Pow", MakeName ("Pow", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="a">
		/// </param>
		/// <param name="b">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_a">
		/// </param>
		/// <param name="max_a">
		/// </param>
		/// <param name="min_b">
		/// </param>
		/// <param name="max_b">
		/// </param>
		/// <param name="min_freezed_output">
		/// </param>
		/// <param name="max_freezed_output">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedMatMulWithBiasAndReluAndRequantize'.
		/// </param>
		/// <param name="Toutput">
		///   Optional argument
		/// </param>
		/// <param name="transpose_a">
		///   Optional argument
		/// </param>
		/// <param name="transpose_b">
		///   Optional argument
		/// </param>
		/// <param name="input_quant_mode">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_out:
		///   max_out:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_out, TF_Output max_out) QuantizedMatMulWithBiasAndReluAndRequantize (TF_Output a, TF_Output b, TF_Output bias, TF_Output min_a, TF_Output max_a, TF_Output min_b, TF_Output max_b, TF_Output min_freezed_output, TF_Output max_freezed_output, TF_DataType? Toutput = null, bool? transpose_a = null, bool? transpose_b = null, string input_quant_mode = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedMatMulWithBiasAndReluAndRequantize", MakeName ("QuantizedMatMulWithBiasAndReluAndRequantize", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, b);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_a);
			c_api.TF_AddInput(desc, max_a);
			c_api.TF_AddInput(desc, min_b);
			c_api.TF_AddInput(desc, max_b);
			c_api.TF_AddInput(desc, min_freezed_output);
			c_api.TF_AddInput(desc, max_freezed_output);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Toutput.HasValue)
				c_api.TF_SetAttrType (desc, "Toutput", Toutput.Value);
			
			if (transpose_a.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_a", Convert.ToByte(transpose_a.Value));
			
			if (transpose_b.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_b", Convert.ToByte(transpose_b.Value));
			
			if (input_quant_mode != null)
				c_api.TF_SetAttrString (desc, "input_quant_mode", input_quant_mode);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_out = new TF_Output (op, _idx++);
			var max_out = new TF_Output (op, _idx++);
			return (output, min_out, max_out);
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="alpha">
		/// </param>
		/// <param name="delta">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyGradientDescent'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ApplyGradientDescent (TF_Output var, TF_Output alpha, TF_Output delta, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyGradientDescent", MakeName ("ApplyGradientDescent", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, alpha);
			c_api.TF_AddInput(desc, delta);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="q">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Zeta'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Zeta (TF_Output x, TF_Output q, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Zeta", MakeName ("Zeta", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, q);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="y">
		/// </param>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Atan2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Atan2 (TF_Output y, TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Atan2", MakeName ("Atan2", operName));
			c_api.TF_AddInput(desc, y);
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Less'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Less (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Less", MakeName ("Less", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LessEqual'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LessEqual (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LessEqual", MakeName ("LessEqual", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Greater'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Greater (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Greater", MakeName ("Greater", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="m">
		/// </param>
		/// <param name="v">
		/// </param>
		/// <param name="vhat">
		/// </param>
		/// <param name="beta1_power">
		/// </param>
		/// <param name="beta2_power">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="beta1">
		/// </param>
		/// <param name="beta2">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdamWithAmsgrad'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceApplyAdamWithAmsgrad (TF_Output var, TF_Output m, TF_Output v, TF_Output vhat, TF_Output beta1_power, TF_Output beta2_power, TF_Output lr, TF_Output beta1, TF_Output beta2, TF_Output epsilon, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyAdamWithAmsgrad", MakeName ("ResourceApplyAdamWithAmsgrad", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, v);
			c_api.TF_AddInput(desc, vhat);
			c_api.TF_AddInput(desc, beta1_power);
			c_api.TF_AddInput(desc, beta2_power);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, beta1);
			c_api.TF_AddInput(desc, beta2);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="alpha">
		/// </param>
		/// <param name="delta">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyGradientDescent'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceApplyGradientDescent (TF_Output var, TF_Output alpha, TF_Output delta, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyGradientDescent", MakeName ("ResourceApplyGradientDescent", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, alpha);
			c_api.TF_AddInput(desc, delta);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Equal'.
		/// </param>
		/// <param name="incompatible_shape_error">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Equal (TF_Output x, TF_Output y, bool? incompatible_shape_error = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Equal", MakeName ("Equal", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (incompatible_shape_error.HasValue)
				c_api.TF_SetAttrBool (desc, "incompatible_shape_error", Convert.ToByte(incompatible_shape_error.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Variable'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Variable (long[] shape, TF_DataType dtype, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Variable", MakeName ("Variable", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var reference = new TF_Output (op, _idx++);
			return reference;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LogicalNot'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LogicalNot (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LogicalNot", MakeName ("LogicalNot", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="reduction_indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EuclideanNorm'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output EuclideanNorm (TF_Output input, TF_Output reduction_indices, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EuclideanNorm", MakeName ("EuclideanNorm", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, reduction_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LogicalAnd'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LogicalAnd (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LogicalAnd", MakeName ("LogicalAnd", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LogicalOr'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LogicalOr (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LogicalOr", MakeName ("LogicalOr", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="a">
		/// </param>
		/// <param name="b">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatMul'.
		/// </param>
		/// <param name="transpose_a">
		///   Optional argument
		/// </param>
		/// <param name="transpose_b">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MatMul (TF_Output a, TF_Output b, bool? transpose_a = null, bool? transpose_b = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatMul", MakeName ("MatMul", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (transpose_a.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_a", Convert.ToByte(transpose_a.Value));
			
			if (transpose_b.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_b", Convert.ToByte(transpose_b.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var product = new TF_Output (op, _idx++);
			return product;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="reduction_indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Sum'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Sum (TF_Output input, TF_Output reduction_indices, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Sum", MakeName ("Sum", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, reduction_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="reduction_indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Max'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Max (TF_Output input, TF_Output reduction_indices, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Max", MakeName ("Max", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, reduction_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="dimension">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ArgMax'.
		/// </param>
		/// <param name="output_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ArgMax (TF_Output input, TF_Output dimension, TF_DataType? output_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ArgMax", MakeName ("ArgMax", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, dimension);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (output_type.HasValue)
				c_api.TF_SetAttrType (desc, "output_type", output_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="dimension">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ArgMin'.
		/// </param>
		/// <param name="output_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ArgMin (TF_Output input, TF_Output dimension, TF_DataType? output_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ArgMin", MakeName ("ArgMin", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, dimension);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (output_type.HasValue)
				c_api.TF_SetAttrType (desc, "output_type", output_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="segment_ids">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SegmentMean'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SegmentMean (TF_Output data, TF_Output segment_ids, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SegmentMean", MakeName ("SegmentMean", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, segment_ids);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_grads">
		/// </param>
		/// <param name="input_image">
		/// </param>
		/// <param name="output_image">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LRNGrad'.
		/// </param>
		/// <param name="depth_radius">
		///   Optional argument
		/// </param>
		/// <param name="bias">
		///   Optional argument
		/// </param>
		/// <param name="alpha">
		///   Optional argument
		/// </param>
		/// <param name="beta">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LRNGrad (TF_Output input_grads, TF_Output input_image, TF_Output output_image, long? depth_radius = null, float? bias = null, float? alpha = null, float? beta = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LRNGrad", MakeName ("LRNGrad", operName));
			c_api.TF_AddInput(desc, input_grads);
			c_api.TF_AddInput(desc, input_image);
			c_api.TF_AddInput(desc, output_image);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (depth_radius.HasValue)
				c_api.TF_SetAttrInt (desc, "depth_radius", depth_radius.Value);
			
			if (bias.HasValue)
				c_api.TF_SetAttrFloat (desc, "bias", bias.Value);
			
			if (alpha.HasValue)
				c_api.TF_SetAttrFloat (desc, "alpha", alpha.Value);
			
			if (beta.HasValue)
				c_api.TF_SetAttrFloat (desc, "beta", beta.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CloseSummaryWriter'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation CloseSummaryWriter (TF_Output writer, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CloseSummaryWriter", MakeName ("CloseSummaryWriter", operName));
			c_api.TF_AddInput(desc, writer);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="segment_ids">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SegmentMin'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SegmentMin (TF_Output data, TF_Output segment_ids, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SegmentMin", MakeName ("SegmentMin", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, segment_ids);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="segment_ids">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SegmentMax'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SegmentMax (TF_Output data, TF_Output segment_ids, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SegmentMax", MakeName ("SegmentMax", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, segment_ids);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="segment_ids">
		/// </param>
		/// <param name="num_segments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnsortedSegmentSum'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output UnsortedSegmentSum (TF_Output data, TF_Output segment_ids, TF_Output num_segments, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnsortedSegmentSum", MakeName ("UnsortedSegmentSum", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, segment_ids);
			c_api.TF_AddInput(desc, num_segments);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="segment_ids">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentSum'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseSegmentSum (TF_Output data, TF_Output indices, TF_Output segment_ids, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSegmentSum", MakeName ("SparseSegmentSum", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, segment_ids);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="segment_ids">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentMean'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseSegmentMean (TF_Output data, TF_Output indices, TF_Output segment_ids, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSegmentMean", MakeName ("SparseSegmentMean", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, segment_ids);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyProximalAdagrad'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseApplyProximalAdagrad (TF_Output var, TF_Output accum, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output grad, TF_Output indices, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyProximalAdagrad", MakeName ("SparseApplyProximalAdagrad", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="segment_ids">
		/// </param>
		/// <param name="output_dim0">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentMeanGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseSegmentMeanGrad (TF_Output grad, TF_Output indices, TF_Output segment_ids, TF_Output output_dim0, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSegmentMeanGrad", MakeName ("SparseSegmentMeanGrad", operName));
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, segment_ids);
			c_api.TF_AddInput(desc, output_dim0);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="segment_ids">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentSqrtN'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseSegmentSqrtN (TF_Output data, TF_Output indices, TF_Output segment_ids, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSegmentSqrtN", MakeName ("SparseSegmentSqrtN", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, segment_ids);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="segment_ids">
		/// </param>
		/// <param name="num_segments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentSqrtNWithNumSegments'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseSegmentSqrtNWithNumSegments (TF_Output data, TF_Output indices, TF_Output segment_ids, TF_Output num_segments, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSegmentSqrtNWithNumSegments", MakeName ("SparseSegmentSqrtNWithNumSegments", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, segment_ids);
			c_api.TF_AddInput(desc, num_segments);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="reduction_indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Any'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Any (TF_Output input, TF_Output reduction_indices, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Any", MakeName ("Any", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, reduction_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="start">
		/// </param>
		/// <param name="limit">
		/// </param>
		/// <param name="delta">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Range'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Range (TF_Output start, TF_Output limit, TF_Output delta, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Range", MakeName ("Range", operName));
			c_api.TF_AddInput(desc, start);
			c_api.TF_AddInput(desc, limit);
			c_api.TF_AddInput(desc, delta);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Conj'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Conj (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Conj", MakeName ("Conj", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AssignVariableOp'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation AssignVariableOp (TF_Output resource, TF_Output value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AssignVariableOp", MakeName ("AssignVariableOp", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="a">
		/// </param>
		/// <param name="b">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Cross'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Cross (TF_Output a, TF_Output b, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Cross", MakeName ("Cross", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var product = new TF_Output (op, _idx++);
			return product;
		}

		/// <summary>
		/// </summary>
		/// <param name="values">
		/// </param>
		/// <param name="value_range">
		/// </param>
		/// <param name="nbins">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'HistogramFixedWidth'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output HistogramFixedWidth (TF_Output values, TF_Output value_range, TF_Output nbins, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "HistogramFixedWidth", MakeName ("HistogramFixedWidth", operName));
			c_api.TF_AddInput(desc, values);
			c_api.TF_AddInput(desc, value_range);
			c_api.TF_AddInput(desc, nbins);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="arr">
		/// </param>
		/// <param name="size">
		/// </param>
		/// <param name="weights">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Bincount'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Bincount (TF_Output arr, TF_Output size, TF_Output weights, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Bincount", MakeName ("Bincount", operName));
			c_api.TF_AddInput(desc, arr);
			c_api.TF_AddInput(desc, size);
			c_api.TF_AddInput(desc, weights);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var bins = new TF_Output (op, _idx++);
			return bins;
		}

		/// <summary>
		/// </summary>
		/// <param name="t">
		/// </param>
		/// <param name="m">
		/// </param>
		/// <param name="v">
		/// </param>
		/// <param name="beta">
		/// </param>
		/// <param name="gamma">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchNormWithGlobalNormalization'.
		/// </param>
		/// <param name="variance_epsilon">
		/// </param>
		/// <param name="scale_after_normalization">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchNormWithGlobalNormalization (TF_Output t, TF_Output m, TF_Output v, TF_Output beta, TF_Output gamma, float variance_epsilon, bool scale_after_normalization, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchNormWithGlobalNormalization", MakeName ("BatchNormWithGlobalNormalization", operName));
			c_api.TF_AddInput(desc, t);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, v);
			c_api.TF_AddInput(desc, beta);
			c_api.TF_AddInput(desc, gamma);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFloat (desc, "variance_epsilon", variance_epsilon);
			c_api.TF_SetAttrBool (desc, "scale_after_normalization", Convert.ToByte(scale_after_normalization));
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var result = new TF_Output (op, _idx++);
			return result;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="linear">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="l2_shrinkage">
		/// </param>
		/// <param name="lr_power">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyFtrlV2'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseApplyFtrlV2 (TF_Output var, TF_Output accum, TF_Output linear, TF_Output grad, TF_Output indices, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output l2_shrinkage, TF_Output lr_power, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyFtrlV2", MakeName ("SparseApplyFtrlV2", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, linear);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, l2_shrinkage);
			c_api.TF_AddInput(desc, lr_power);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="axis">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Cumsum'.
		/// </param>
		/// <param name="exclusive">
		///   Optional argument
		/// </param>
		/// <param name="reverse">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Cumsum (TF_Output x, TF_Output axis, bool? exclusive = null, bool? reverse = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Cumsum", MakeName ("Cumsum", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, axis);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (exclusive.HasValue)
				c_api.TF_SetAttrBool (desc, "exclusive", Convert.ToByte(exclusive.Value));
			
			if (reverse.HasValue)
				c_api.TF_SetAttrBool (desc, "reverse", Convert.ToByte(reverse.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="a">
		/// </param>
		/// <param name="b">
		/// </param>
		/// <param name="min_a">
		/// </param>
		/// <param name="max_a">
		/// </param>
		/// <param name="min_b">
		/// </param>
		/// <param name="max_b">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedMatMul'.
		/// </param>
		/// <param name="Toutput">
		///   Optional argument
		/// </param>
		/// <param name="transpose_a">
		///   Optional argument
		/// </param>
		/// <param name="transpose_b">
		///   Optional argument
		/// </param>
		/// <param name="Tactivation">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_out:
		///   max_out:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_out, TF_Output max_out) QuantizedMatMul (TF_Output a, TF_Output b, TF_Output min_a, TF_Output max_a, TF_Output min_b, TF_Output max_b, TF_DataType? Toutput = null, bool? transpose_a = null, bool? transpose_b = null, TF_DataType? Tactivation = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedMatMul", MakeName ("QuantizedMatMul", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, b);
			c_api.TF_AddInput(desc, min_a);
			c_api.TF_AddInput(desc, max_a);
			c_api.TF_AddInput(desc, min_b);
			c_api.TF_AddInput(desc, max_b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Toutput.HasValue)
				c_api.TF_SetAttrType (desc, "Toutput", Toutput.Value);
			
			if (transpose_a.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_a", Convert.ToByte(transpose_a.Value));
			
			if (transpose_b.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_b", Convert.ToByte(transpose_b.Value));
			
			if (Tactivation.HasValue)
				c_api.TF_SetAttrType (desc, "Tactivation", Tactivation.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_out = new TF_Output (op, _idx++);
			var max_out = new TF_Output (op, _idx++);
			return (output, min_out, max_out);
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="min_x">
		/// </param>
		/// <param name="max_x">
		/// </param>
		/// <param name="min_y">
		/// </param>
		/// <param name="max_y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedMul'.
		/// </param>
		/// <param name="Toutput">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   z:
		///   min_z:
		///   max_z:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output z, TF_Output min_z, TF_Output max_z) QuantizedMul (TF_Output x, TF_Output y, TF_Output min_x, TF_Output max_x, TF_Output min_y, TF_Output max_y, TF_DataType? Toutput = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedMul", MakeName ("QuantizedMul", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			c_api.TF_AddInput(desc, min_x);
			c_api.TF_AddInput(desc, max_x);
			c_api.TF_AddInput(desc, min_y);
			c_api.TF_AddInput(desc, max_y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Toutput.HasValue)
				c_api.TF_SetAttrType (desc, "Toutput", Toutput.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			var min_z = new TF_Output (op, _idx++);
			var max_z = new TF_Output (op, _idx++);
			return (z, min_z, max_z);
		}

		/// <summary>
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="labels">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SoftmaxCrossEntropyWithLogits'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   loss:
		///   backprop:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output loss, TF_Output backprop) SoftmaxCrossEntropyWithLogits (TF_Output features, TF_Output labels, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SoftmaxCrossEntropyWithLogits", MakeName ("SoftmaxCrossEntropyWithLogits", operName));
			c_api.TF_AddInput(desc, features);
			c_api.TF_AddInput(desc, labels);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var loss = new TF_Output (op, _idx++);
			var backprop = new TF_Output (op, _idx++);
			return (loss, backprop);
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="cs_prev">
		/// </param>
		/// <param name="h_prev">
		/// </param>
		/// <param name="w">
		/// </param>
		/// <param name="wci">
		/// </param>
		/// <param name="wcf">
		/// </param>
		/// <param name="wco">
		/// </param>
		/// <param name="b">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LSTMBlockCell'.
		/// </param>
		/// <param name="forget_bias">
		///   Optional argument
		/// </param>
		/// <param name="cell_clip">
		///   Optional argument
		/// </param>
		/// <param name="use_peephole">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   i:
		///   cs:
		///   f:
		///   o:
		///   ci:
		///   co:
		///   h:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output i, TF_Output cs, TF_Output f, TF_Output o, TF_Output ci, TF_Output co, TF_Output h) LSTMBlockCell (TF_Output x, TF_Output cs_prev, TF_Output h_prev, TF_Output w, TF_Output wci, TF_Output wcf, TF_Output wco, TF_Output b, float? forget_bias = null, float? cell_clip = null, bool? use_peephole = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LSTMBlockCell", MakeName ("LSTMBlockCell", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, cs_prev);
			c_api.TF_AddInput(desc, h_prev);
			c_api.TF_AddInput(desc, w);
			c_api.TF_AddInput(desc, wci);
			c_api.TF_AddInput(desc, wcf);
			c_api.TF_AddInput(desc, wco);
			c_api.TF_AddInput(desc, b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (forget_bias.HasValue)
				c_api.TF_SetAttrFloat (desc, "forget_bias", forget_bias.Value);
			
			if (cell_clip.HasValue)
				c_api.TF_SetAttrFloat (desc, "cell_clip", cell_clip.Value);
			
			if (use_peephole.HasValue)
				c_api.TF_SetAttrBool (desc, "use_peephole", Convert.ToByte(use_peephole.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var i = new TF_Output (op, _idx++);
			var cs = new TF_Output (op, _idx++);
			var f = new TF_Output (op, _idx++);
			var o = new TF_Output (op, _idx++);
			var ci = new TF_Output (op, _idx++);
			var co = new TF_Output (op, _idx++);
			var h = new TF_Output (op, _idx++);
			return (i, cs, f, o, ci, co, h);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_min">
		/// </param>
		/// <param name="input_max">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizeDownAndShrinkRange'.
		/// </param>
		/// <param name="out_type">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   output_min:
		///   output_max:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output output_min, TF_Output output_max) QuantizeDownAndShrinkRange (TF_Output input, TF_Output input_min, TF_Output input_max, TF_DataType out_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizeDownAndShrinkRange", MakeName ("QuantizeDownAndShrinkRange", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_min);
			c_api.TF_AddInput(desc, input_max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "out_type", out_type);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var output_min = new TF_Output (op, _idx++);
			var output_max = new TF_Output (op, _idx++);
			return (output, output_min, output_max);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="min_freezed_output">
		/// </param>
		/// <param name="max_freezed_output">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DWithBiasAndReluAndRequantize'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="padding_list">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DWithBiasAndReluAndRequantize (TF_Output input, TF_Output filter, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, TF_Output min_freezed_output, TF_Output max_freezed_output, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, long[] padding_list = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DWithBiasAndReluAndRequantize", MakeName ("QuantizedConv2DWithBiasAndReluAndRequantize", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			c_api.TF_AddInput(desc, min_freezed_output);
			c_api.TF_AddInput(desc, max_freezed_output);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			if (padding_list != null)
				c_api.TF_SetAttrIntList (desc, "padding_list", ref padding_list[0], padding_list.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_min">
		/// </param>
		/// <param name="input_max">
		/// </param>
		/// <param name="requested_output_min">
		/// </param>
		/// <param name="requested_output_max">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RequantizePerChannel'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   output_min:
		///   output_max:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output output_min, TF_Output output_max) RequantizePerChannel (TF_Output input, TF_Output input_min, TF_Output input_max, TF_Output requested_output_min, TF_Output requested_output_max, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RequantizePerChannel", MakeName ("RequantizePerChannel", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_min);
			c_api.TF_AddInput(desc, input_max);
			c_api.TF_AddInput(desc, requested_output_min);
			c_api.TF_AddInput(desc, requested_output_max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var output_min = new TF_Output (op, _idx++);
			var output_max = new TF_Output (op, _idx++);
			return (output, output_min, output_max);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="out_backprop">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Dilation2DBackpropInput'.
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="rates">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Dilation2DBackpropInput (TF_Output input, TF_Output filter, TF_Output out_backprop, long[] strides, long[] rates, string padding, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Dilation2DBackpropInput", MakeName ("Dilation2DBackpropInput", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrIntList (desc, "rates", ref rates[0], rates.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var in_backprop = new TF_Output (op, _idx++);
			return in_backprop;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_min">
		/// </param>
		/// <param name="input_max">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RequantizationRangePerChannel'.
		/// </param>
		/// <param name="clip_value_max">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_min:
		///   output_max:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output_min, TF_Output output_max) RequantizationRangePerChannel (TF_Output input, TF_Output input_min, TF_Output input_max, float clip_value_max, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RequantizationRangePerChannel", MakeName ("RequantizationRangePerChannel", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_min);
			c_api.TF_AddInput(desc, input_max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFloat (desc, "clip_value_max", clip_value_max);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_min = new TF_Output (op, _idx++);
			var output_max = new TF_Output (op, _idx++);
			return (output_min, output_max);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NcclReduce'.
		/// </param>
		/// <param name="reduction">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output NcclReduce (TF_Output[] input, string reduction, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NcclReduce", MakeName ("NcclReduce", operName));
			c_api.TF_AddInputList(desc, input[0], input.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "reduction", reduction);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var data = new TF_Output (op, _idx++);
			return data;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NcclBroadcast'.
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output NcclBroadcast (TF_Output input, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NcclBroadcast", MakeName ("NcclBroadcast", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AvgPool'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="ksize">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AvgPool (TF_Output value, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AvgPool", MakeName ("AvgPool", operName));
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="y_backprop">
		/// </param>
		/// <param name="x">
		/// </param>
		/// <param name="scale">
		/// </param>
		/// <param name="reserve_space_1">
		/// </param>
		/// <param name="reserve_space_2">
		/// </param>
		/// <param name="reserve_space_3">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedBatchNormGradV3'.
		/// </param>
		/// <param name="epsilon">
		///   Optional argument
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="is_training">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   x_backprop:
		///   scale_backprop:
		///   offset_backprop:
		///   reserve_space_4:
		///   reserve_space_5:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output x_backprop, TF_Output scale_backprop, TF_Output offset_backprop, TF_Output reserve_space_4, TF_Output reserve_space_5) FusedBatchNormGradV3 (TF_Output y_backprop, TF_Output x, TF_Output scale, TF_Output reserve_space_1, TF_Output reserve_space_2, TF_Output reserve_space_3, float? epsilon = null, string data_format = null, bool? is_training = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FusedBatchNormGradV3", MakeName ("FusedBatchNormGradV3", operName));
			c_api.TF_AddInput(desc, y_backprop);
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, scale);
			c_api.TF_AddInput(desc, reserve_space_1);
			c_api.TF_AddInput(desc, reserve_space_2);
			c_api.TF_AddInput(desc, reserve_space_3);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (epsilon.HasValue)
				c_api.TF_SetAttrFloat (desc, "epsilon", epsilon.Value);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (is_training.HasValue)
				c_api.TF_SetAttrBool (desc, "is_training", Convert.ToByte(is_training.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var x_backprop = new TF_Output (op, _idx++);
			var scale_backprop = new TF_Output (op, _idx++);
			var offset_backprop = new TF_Output (op, _idx++);
			var reserve_space_4 = new TF_Output (op, _idx++);
			var reserve_space_5 = new TF_Output (op, _idx++);
			return (x_backprop, scale_backprop, offset_backprop, reserve_space_4, reserve_space_5);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv2D'.
		/// </param>
		/// <param name="use_cudnn_on_gpu">
		///   Optional argument
		/// </param>
		/// <param name="explicit_paddings">
		///   Optional argument
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Conv2D (TF_Output input, TF_Output filter, long[] strides, string padding, bool? use_cudnn_on_gpu = null, long[] explicit_paddings = null, string data_format = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Conv2D", MakeName ("Conv2D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (use_cudnn_on_gpu.HasValue)
				c_api.TF_SetAttrBool (desc, "use_cudnn_on_gpu", Convert.ToByte(use_cudnn_on_gpu.Value));
			
			if (explicit_paddings != null)
				c_api.TF_SetAttrIntList (desc, "explicit_paddings", ref explicit_paddings[0], explicit_paddings.Length);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter_sizes">
		/// </param>
		/// <param name="out_backprop">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv2DBackpropFilter'.
		/// </param>
		/// <param name="use_cudnn_on_gpu">
		///   Optional argument
		/// </param>
		/// <param name="explicit_paddings">
		///   Optional argument
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Conv2DBackpropFilter (TF_Output input, TF_Output filter_sizes, TF_Output out_backprop, long[] strides, string padding, bool? use_cudnn_on_gpu = null, long[] explicit_paddings = null, string data_format = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Conv2DBackpropFilter", MakeName ("Conv2DBackpropFilter", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter_sizes);
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (use_cudnn_on_gpu.HasValue)
				c_api.TF_SetAttrBool (desc, "use_cudnn_on_gpu", Convert.ToByte(use_cudnn_on_gpu.Value));
			
			if (explicit_paddings != null)
				c_api.TF_SetAttrIntList (desc, "explicit_paddings", ref explicit_paddings[0], explicit_paddings.Length);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="sp_indices">
		/// </param>
		/// <param name="sp_values">
		/// </param>
		/// <param name="sp_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSoftmax'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseSoftmax (TF_Output sp_indices, TF_Output sp_values, TF_Output sp_shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSoftmax", MakeName ("SparseSoftmax", operName));
			c_api.TF_AddInput(desc, sp_indices);
			c_api.TF_AddInput(desc, sp_values);
			c_api.TF_AddInput(desc, sp_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="size">
		/// </param>
		/// <param name="paddings">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedResizeAndPadConv2D'.
		/// </param>
		/// <param name="resize_align_corners">
		///   Optional argument
		/// </param>
		/// <param name="mode">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FusedResizeAndPadConv2D (TF_Output input, TF_Output size, TF_Output paddings, TF_Output filter, string mode, long[] strides, string padding, bool? resize_align_corners = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FusedResizeAndPadConv2D", MakeName ("FusedResizeAndPadConv2D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, size);
			c_api.TF_AddInput(desc, paddings);
			c_api.TF_AddInput(desc, filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "mode", mode);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (resize_align_corners.HasValue)
				c_api.TF_SetAttrBool (desc, "resize_align_corners", Convert.ToByte(resize_align_corners.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="paddings">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedPadConv2D'.
		/// </param>
		/// <param name="mode">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FusedPadConv2D (TF_Output input, TF_Output paddings, TF_Output filter, string mode, long[] strides, string padding, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FusedPadConv2D", MakeName ("FusedPadConv2D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, paddings);
			c_api.TF_AddInput(desc, filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "mode", mode);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="sp_indices">
		/// </param>
		/// <param name="sp_values">
		/// </param>
		/// <param name="sp_shape">
		/// </param>
		/// <param name="dense">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseDenseCwiseMul'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseDenseCwiseMul (TF_Output sp_indices, TF_Output sp_values, TF_Output sp_shape, TF_Output dense, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseDenseCwiseMul", MakeName ("SparseDenseCwiseMul", operName));
			c_api.TF_AddInput(desc, sp_indices);
			c_api.TF_AddInput(desc, sp_values);
			c_api.TF_AddInput(desc, sp_shape);
			c_api.TF_AddInput(desc, dense);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="logits">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LogSoftmax'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LogSoftmax (TF_Output logits, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LogSoftmax", MakeName ("LogSoftmax", operName));
			c_api.TF_AddInput(desc, logits);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var logsoftmax = new TF_Output (op, _idx++);
			return logsoftmax;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="m">
		/// </param>
		/// <param name="v">
		/// </param>
		/// <param name="beta1_power">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="beta1">
		/// </param>
		/// <param name="beta2">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdaMax'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ApplyAdaMax (TF_Output var, TF_Output m, TF_Output v, TF_Output beta1_power, TF_Output lr, TF_Output beta1, TF_Output beta2, TF_Output epsilon, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyAdaMax", MakeName ("ApplyAdaMax", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, v);
			c_api.TF_AddInput(desc, beta1_power);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, beta1);
			c_api.TF_AddInput(desc, beta2);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DepthwiseConv2dNative'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DepthwiseConv2dNative (TF_Output input, TF_Output filter, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DepthwiseConv2dNative", MakeName ("DepthwiseConv2dNative", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="accum_update">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="rho">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyAdadelta'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseApplyAdadelta (TF_Output var, TF_Output accum, TF_Output accum_update, TF_Output lr, TF_Output rho, TF_Output epsilon, TF_Output grad, TF_Output indices, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyAdadelta", MakeName ("SparseApplyAdadelta", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, accum_update);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter_sizes">
		/// </param>
		/// <param name="out_backprop">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DepthwiseConv2dNativeBackpropFilter'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DepthwiseConv2dNativeBackpropFilter (TF_Output input, TF_Output filter_sizes, TF_Output out_backprop, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DepthwiseConv2dNativeBackpropFilter", MakeName ("DepthwiseConv2dNativeBackpropFilter", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter_sizes);
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="orig_input">
		/// </param>
		/// <param name="orig_output">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPool3DGrad'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="ksize">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPool3DGrad (TF_Output orig_input, TF_Output orig_output, TF_Output grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPool3DGrad", MakeName ("MaxPool3DGrad", operName));
			c_api.TF_AddInput(desc, orig_input);
			c_api.TF_AddInput(desc, orig_output);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="orig_input">
		/// </param>
		/// <param name="orig_output">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPool3DGradGrad'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="ksize">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPool3DGradGrad (TF_Output orig_input, TF_Output orig_output, TF_Output grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPool3DGradGrad", MakeName ("MaxPool3DGradGrad", operName));
			c_api.TF_AddInput(desc, orig_input);
			c_api.TF_AddInput(desc, orig_output);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterDiv'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ScatterDiv (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterDiv", MakeName ("ScatterDiv", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		/// </summary>
		/// <param name="t">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'L2Loss'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output L2Loss (TF_Output t, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "L2Loss", MakeName ("L2Loss", operName));
			c_api.TF_AddInput(desc, t);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="orig_input">
		/// </param>
		/// <param name="orig_output">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGrad'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="ksize">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPoolGrad (TF_Output orig_input, TF_Output orig_output, TF_Output grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPoolGrad", MakeName ("MaxPoolGrad", operName));
			c_api.TF_AddInput(desc, orig_input);
			c_api.TF_AddInput(desc, orig_output);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="orig_input">
		/// </param>
		/// <param name="orig_output">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="ksize">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGradV2'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPoolGradV2 (TF_Output orig_input, TF_Output orig_output, TF_Output grad, TF_Output ksize, TF_Output strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPoolGradV2", MakeName ("MaxPoolGradV2", operName));
			c_api.TF_AddInput(desc, orig_input);
			c_api.TF_AddInput(desc, orig_output);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, ksize);
			c_api.TF_AddInput(desc, strides);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Elu'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Elu (TF_Output features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Elu", MakeName ("Elu", operName));
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var activations = new TF_Output (op, _idx++);
			return activations;
		}

		/// <summary>
		/// </summary>
		/// <param name="orig_input">
		/// </param>
		/// <param name="orig_output">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="ksize">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGradGradV2'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPoolGradGradV2 (TF_Output orig_input, TF_Output orig_output, TF_Output grad, TF_Output ksize, TF_Output strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPoolGradGradV2", MakeName ("MaxPoolGradGradV2", operName));
			c_api.TF_AddInput(desc, orig_input);
			c_api.TF_AddInput(desc, orig_output);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, ksize);
			c_api.TF_AddInput(desc, strides);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolWithArgmax'.
		/// </param>
		/// <param name="Targmax">
		///   Optional argument
		/// </param>
		/// <param name="include_batch_in_index">
		///   Optional argument
		/// </param>
		/// <param name="ksize">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   argmax:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output argmax) MaxPoolWithArgmax (TF_Output input, long[] ksize, long[] strides, string padding, TF_DataType? Targmax = null, bool? include_batch_in_index = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPoolWithArgmax", MakeName ("MaxPoolWithArgmax", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (Targmax.HasValue)
				c_api.TF_SetAttrType (desc, "Targmax", Targmax.Value);
			
			if (include_batch_in_index.HasValue)
				c_api.TF_SetAttrBool (desc, "include_batch_in_index", Convert.ToByte(include_batch_in_index.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var argmax = new TF_Output (op, _idx++);
			return (output, argmax);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="argmax">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGradGradWithArgmax'.
		/// </param>
		/// <param name="include_batch_in_index">
		///   Optional argument
		/// </param>
		/// <param name="ksize">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPoolGradGradWithArgmax (TF_Output input, TF_Output grad, TF_Output argmax, long[] ksize, long[] strides, string padding, bool? include_batch_in_index = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPoolGradGradWithArgmax", MakeName ("MaxPoolGradGradWithArgmax", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, argmax);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (include_batch_in_index.HasValue)
				c_api.TF_SetAttrBool (desc, "include_batch_in_index", Convert.ToByte(include_batch_in_index.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="out_backprop">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Dilation2DBackpropFilter'.
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="rates">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Dilation2DBackpropFilter (TF_Output input, TF_Output filter, TF_Output out_backprop, long[] strides, long[] rates, string padding, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Dilation2DBackpropFilter", MakeName ("Dilation2DBackpropFilter", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrIntList (desc, "rates", ref rates[0], rates.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var filter_backprop = new TF_Output (op, _idx++);
			return filter_backprop;
		}

		/// <summary>
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Relu'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Relu (TF_Output features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Relu", MakeName ("Relu", operName));
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var activations = new TF_Output (op, _idx++);
			return activations;
		}

		/// <summary>
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LeakyRelu'.
		/// </param>
		/// <param name="alpha">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LeakyRelu (TF_Output features, float? alpha = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LeakyRelu", MakeName ("LeakyRelu", operName));
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (alpha.HasValue)
				c_api.TF_SetAttrFloat (desc, "alpha", alpha.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var activations = new TF_Output (op, _idx++);
			return activations;
		}

		/// <summary>
		/// </summary>
		/// <param name="gradients">
		/// </param>
		/// <param name="features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LeakyReluGrad'.
		/// </param>
		/// <param name="alpha">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LeakyReluGrad (TF_Output gradients, TF_Output features, float? alpha = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LeakyReluGrad", MakeName ("LeakyReluGrad", operName));
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (alpha.HasValue)
				c_api.TF_SetAttrFloat (desc, "alpha", alpha.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var backprops = new TF_Output (op, _idx++);
			return backprops;
		}

		/// <summary>
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Selu'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Selu (TF_Output features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Selu", MakeName ("Selu", operName));
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var activations = new TF_Output (op, _idx++);
			return activations;
		}

		/// <summary>
		/// </summary>
		/// <param name="gradients">
		/// </param>
		/// <param name="features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SoftsignGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SoftsignGrad (TF_Output gradients, TF_Output features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SoftsignGrad", MakeName ("SoftsignGrad", operName));
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var backprops = new TF_Output (op, _idx++);
			return backprops;
		}

		/// <summary>
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="labels">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSoftmaxCrossEntropyWithLogits'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   loss:
		///   backprop:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output loss, TF_Output backprop) SparseSoftmaxCrossEntropyWithLogits (TF_Output features, TF_Output labels, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSoftmaxCrossEntropyWithLogits", MakeName ("SparseSoftmaxCrossEntropyWithLogits", operName));
			c_api.TF_AddInput(desc, features);
			c_api.TF_AddInput(desc, labels);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var loss = new TF_Output (op, _idx++);
			var backprop = new TF_Output (op, _idx++);
			return (loss, backprop);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedAvgPool'.
		/// </param>
		/// <param name="ksize">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedAvgPool (TF_Output input, TF_Output min_input, TF_Output max_input, long[] ksize, long[] strides, string padding, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedAvgPool", MakeName ("QuantizedAvgPool", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_bias">
		/// </param>
		/// <param name="max_bias">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedBiasAdd'.
		/// </param>
		/// <param name="out_type">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_out:
		///   max_out:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_out, TF_Output max_out) QuantizedBiasAdd (TF_Output input, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_bias, TF_Output max_bias, TF_DataType out_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedBiasAdd", MakeName ("QuantizedBiasAdd", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_bias);
			c_api.TF_AddInput(desc, max_bias);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "out_type", out_type);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_out = new TF_Output (op, _idx++);
			var max_out = new TF_Output (op, _idx++);
			return (output, min_out, max_out);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2D'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2D (TF_Output input, TF_Output filter, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2D", MakeName ("QuantizedConv2D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="min_features">
		/// </param>
		/// <param name="max_features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedRelu'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   activations:
		///   min_activations:
		///   max_activations:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output activations, TF_Output min_activations, TF_Output max_activations) QuantizedRelu (TF_Output features, TF_Output min_features, TF_Output max_features, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedRelu", MakeName ("QuantizedRelu", operName));
			c_api.TF_AddInput(desc, features);
			c_api.TF_AddInput(desc, min_features);
			c_api.TF_AddInput(desc, max_features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var activations = new TF_Output (op, _idx++);
			var min_activations = new TF_Output (op, _idx++);
			var max_activations = new TF_Output (op, _idx++);
			return (activations, min_activations, max_activations);
		}

		/// <summary>
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="min_features">
		/// </param>
		/// <param name="max_features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedRelu6'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   activations:
		///   min_activations:
		///   max_activations:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output activations, TF_Output min_activations, TF_Output max_activations) QuantizedRelu6 (TF_Output features, TF_Output min_features, TF_Output max_features, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedRelu6", MakeName ("QuantizedRelu6", operName));
			c_api.TF_AddInput(desc, features);
			c_api.TF_AddInput(desc, min_features);
			c_api.TF_AddInput(desc, max_features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var activations = new TF_Output (op, _idx++);
			var min_activations = new TF_Output (op, _idx++);
			var max_activations = new TF_Output (op, _idx++);
			return (activations, min_activations, max_activations);
		}

		/// <summary>
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="max_value">
		/// </param>
		/// <param name="min_features">
		/// </param>
		/// <param name="max_features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedReluX'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   activations:
		///   min_activations:
		///   max_activations:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output activations, TF_Output min_activations, TF_Output max_activations) QuantizedReluX (TF_Output features, TF_Output max_value, TF_Output min_features, TF_Output max_features, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedReluX", MakeName ("QuantizedReluX", operName));
			c_api.TF_AddInput(desc, features);
			c_api.TF_AddInput(desc, max_value);
			c_api.TF_AddInput(desc, min_features);
			c_api.TF_AddInput(desc, max_features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var activations = new TF_Output (op, _idx++);
			var min_activations = new TF_Output (op, _idx++);
			var max_activations = new TF_Output (op, _idx++);
			return (activations, min_activations, max_activations);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DWithBias'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="padding_list">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DWithBias (TF_Output input, TF_Output filter, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, long[] padding_list = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DWithBias", MakeName ("QuantizedConv2DWithBias", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			if (padding_list != null)
				c_api.TF_SetAttrIntList (desc, "padding_list", ref padding_list[0], padding_list.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DAndRelu'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="padding_list">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DAndRelu (TF_Output input, TF_Output filter, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, long[] padding_list = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DAndRelu", MakeName ("QuantizedConv2DAndRelu", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			if (padding_list != null)
				c_api.TF_SetAttrIntList (desc, "padding_list", ref padding_list[0], padding_list.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DWithBiasAndRelu'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="padding_list">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DWithBiasAndRelu (TF_Output input, TF_Output filter, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, long[] padding_list = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DWithBiasAndRelu", MakeName ("QuantizedConv2DWithBiasAndRelu", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			if (padding_list != null)
				c_api.TF_SetAttrIntList (desc, "padding_list", ref padding_list[0], padding_list.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="summand">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DWithBiasSumAndRelu'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="padding_list">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DWithBiasSumAndRelu (TF_Output input, TF_Output filter, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, TF_Output summand, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, long[] padding_list = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DWithBiasSumAndRelu", MakeName ("QuantizedConv2DWithBiasSumAndRelu", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			c_api.TF_AddInput(desc, summand);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			if (padding_list != null)
				c_api.TF_SetAttrIntList (desc, "padding_list", ref padding_list[0], padding_list.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="min_freezed_output">
		/// </param>
		/// <param name="max_freezed_output">
		/// </param>
		/// <param name="summand">
		/// </param>
		/// <param name="min_summand">
		/// </param>
		/// <param name="max_summand">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DWithBiasSumAndReluAndRequantize'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="padding_list">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DWithBiasSumAndReluAndRequantize (TF_Output input, TF_Output filter, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, TF_Output min_freezed_output, TF_Output max_freezed_output, TF_Output summand, TF_Output min_summand, TF_Output max_summand, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, long[] padding_list = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DWithBiasSumAndReluAndRequantize", MakeName ("QuantizedConv2DWithBiasSumAndReluAndRequantize", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			c_api.TF_AddInput(desc, min_freezed_output);
			c_api.TF_AddInput(desc, max_freezed_output);
			c_api.TF_AddInput(desc, summand);
			c_api.TF_AddInput(desc, min_summand);
			c_api.TF_AddInput(desc, max_summand);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			if (padding_list != null)
				c_api.TF_SetAttrIntList (desc, "padding_list", ref padding_list[0], padding_list.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="min_freezed_output">
		/// </param>
		/// <param name="max_freezed_output">
		/// </param>
		/// <param name="summand">
		/// </param>
		/// <param name="min_summand">
		/// </param>
		/// <param name="max_summand">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DWithBiasSignedSumAndReluAndRequantize'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="padding_list">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DWithBiasSignedSumAndReluAndRequantize (TF_Output input, TF_Output filter, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, TF_Output min_freezed_output, TF_Output max_freezed_output, TF_Output summand, TF_Output min_summand, TF_Output max_summand, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, long[] padding_list = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DWithBiasSignedSumAndReluAndRequantize", MakeName ("QuantizedConv2DWithBiasSignedSumAndReluAndRequantize", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			c_api.TF_AddInput(desc, min_freezed_output);
			c_api.TF_AddInput(desc, max_freezed_output);
			c_api.TF_AddInput(desc, summand);
			c_api.TF_AddInput(desc, min_summand);
			c_api.TF_AddInput(desc, max_summand);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			if (padding_list != null)
				c_api.TF_SetAttrIntList (desc, "padding_list", ref padding_list[0], padding_list.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedDepthwiseConv2D'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedDepthwiseConv2D (TF_Output input, TF_Output filter, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedDepthwiseConv2D", MakeName ("QuantizedDepthwiseConv2D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="min_freezed_output">
		/// </param>
		/// <param name="max_freezed_output">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize (TF_Output input, TF_Output filter, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, TF_Output min_freezed_output, TF_Output max_freezed_output, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize", MakeName ("QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			c_api.TF_AddInput(desc, min_freezed_output);
			c_api.TF_AddInput(desc, max_freezed_output);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NoOp'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation NoOp (string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NoOp", MakeName ("NoOp", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterMul'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceScatterMul (TF_Output resource, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceScatterMul", MakeName ("ResourceScatterMul", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="bytes">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeRaw'.
		/// </param>
		/// <param name="little_endian">
		///   Optional argument
		/// </param>
		/// <param name="out_type">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DecodeRaw (TF_Output bytes, TF_DataType out_type, bool? little_endian = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodeRaw", MakeName ("DecodeRaw", operName));
			c_api.TF_AddInput(desc, bytes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "out_type", out_type);
			if (little_endian.HasValue)
				c_api.TF_SetAttrBool (desc, "little_endian", Convert.ToByte(little_endian.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="accum_update">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="rho">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdadelta'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceApplyAdadelta (TF_Output var, TF_Output accum, TF_Output accum_update, TF_Output lr, TF_Output rho, TF_Output epsilon, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyAdadelta", MakeName ("ResourceApplyAdadelta", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, accum_update);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_bytes">
		/// </param>
		/// <param name="fixed_length">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodePaddedRaw'.
		/// </param>
		/// <param name="little_endian">
		///   Optional argument
		/// </param>
		/// <param name="out_type">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DecodePaddedRaw (TF_Output input_bytes, TF_Output fixed_length, TF_DataType out_type, bool? little_endian = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodePaddedRaw", MakeName ("DecodePaddedRaw", operName));
			c_api.TF_AddInput(desc, input_bytes);
			c_api.TF_AddInput(desc, fixed_length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "out_type", out_type);
			if (little_endian.HasValue)
				c_api.TF_SetAttrBool (desc, "little_endian", Convert.ToByte(little_endian.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="bytes">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeCompressed'.
		/// </param>
		/// <param name="compression_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DecodeCompressed (TF_Output bytes, string compression_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodeCompressed", MakeName ("DecodeCompressed", operName));
			c_api.TF_AddInput(desc, bytes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (compression_type != null)
				c_api.TF_SetAttrString (desc, "compression_type", compression_type);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="string_tensor">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringToNumber'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StringToNumber (TF_Output string_tensor, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringToNumber", MakeName ("StringToNumber", operName));
			c_api.TF_AddInput(desc, string_tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="rt_nested_splits">
		/// </param>
		/// <param name="rt_dense_values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RaggedTensorToSparse'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sparse_indices:
		///   sparse_values:
		///   sparse_dense_shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output sparse_indices, TF_Output sparse_values, TF_Output sparse_dense_shape) RaggedTensorToSparse (TF_Output[] rt_nested_splits, TF_Output rt_dense_values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RaggedTensorToSparse", MakeName ("RaggedTensorToSparse", operName));
			c_api.TF_AddInputList(desc, rt_nested_splits[0], rt_nested_splits.Length);
			c_api.TF_AddInput(desc, rt_dense_values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var sparse_indices = new TF_Output (op, _idx++);
			var sparse_values = new TF_Output (op, _idx++);
			var sparse_dense_shape = new TF_Output (op, _idx++);
			return (sparse_indices, sparse_values, sparse_dense_shape);
		}

		/// <summary>
		/// </summary>
		/// <param name="rt_nested_splits">
		/// </param>
		/// <param name="rt_dense_values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RaggedTensorToVariant'.
		/// </param>
		/// <param name="batched_input">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RaggedTensorToVariant (TF_Output[] rt_nested_splits, TF_Output rt_dense_values, bool batched_input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RaggedTensorToVariant", MakeName ("RaggedTensorToVariant", operName));
			c_api.TF_AddInputList(desc, rt_nested_splits[0], rt_nested_splits.Length);
			c_api.TF_AddInput(desc, rt_dense_values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrBool (desc, "batched_input", Convert.ToByte(batched_input));
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var encoded_ragged = new TF_Output (op, _idx++);
			return encoded_ragged;
		}

		/// <summary>
		/// </summary>
		/// <param name="starts">
		/// </param>
		/// <param name="limits">
		/// </param>
		/// <param name="deltas">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RaggedRange'.
		/// </param>
		/// <param name="Tsplits">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   rt_nested_splits:
		///   rt_dense_values:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output rt_nested_splits, TF_Output rt_dense_values) RaggedRange (TF_Output starts, TF_Output limits, TF_Output deltas, TF_DataType? Tsplits = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RaggedRange", MakeName ("RaggedRange", operName));
			c_api.TF_AddInput(desc, starts);
			c_api.TF_AddInput(desc, limits);
			c_api.TF_AddInput(desc, deltas);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Tsplits.HasValue)
				c_api.TF_SetAttrType (desc, "Tsplits", Tsplits.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var rt_nested_splits = new TF_Output (op, _idx++);
			var rt_dense_values = new TF_Output (op, _idx++);
			return (rt_nested_splits, rt_dense_values);
		}

		/// <summary>
		/// </summary>
		/// <param name="mutex_lock">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ConsumeMutexLock'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ConsumeMutexLock (TF_Output mutex_lock, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ConsumeMutexLock", MakeName ("ConsumeMutexLock", operName));
			c_api.TF_AddInput(desc, mutex_lock);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="shape">
		/// </param>
		/// <param name="minval">
		/// </param>
		/// <param name="maxval">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomUniformInt'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RandomUniformInt (TF_Output shape, TF_Output minval, TF_Output maxval, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomUniformInt", MakeName ("RandomUniformInt", operName));
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, minval);
			c_api.TF_AddInput(desc, maxval);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="shape">
		/// </param>
		/// <param name="means">
		/// </param>
		/// <param name="stdevs">
		/// </param>
		/// <param name="minvals">
		/// </param>
		/// <param name="maxvals">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ParameterizedTruncatedNormal'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ParameterizedTruncatedNormal (TF_Output shape, TF_Output means, TF_Output stdevs, TF_Output minvals, TF_Output maxvals, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ParameterizedTruncatedNormal", MakeName ("ParameterizedTruncatedNormal", operName));
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, means);
			c_api.TF_AddInput(desc, stdevs);
			c_api.TF_AddInput(desc, minvals);
			c_api.TF_AddInput(desc, maxvals);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatefulStandardNormal'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StatefulStandardNormal (TF_Output resource, TF_Output shape, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatefulStandardNormal", MakeName ("StatefulStandardNormal", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TruncatedNormal'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TruncatedNormal (TF_Output shape, TF_DataType dtype, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TruncatedNormal", MakeName ("TruncatedNormal", operName));
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="alpha">
		/// </param>
		/// <param name="sample">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomGammaGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RandomGammaGrad (TF_Output alpha, TF_Output sample, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomGammaGrad", MakeName ("RandomGammaGrad", operName));
			c_api.TF_AddInput(desc, alpha);
			c_api.TF_AddInput(desc, sample);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="h_prev">
		/// </param>
		/// <param name="w_ru">
		/// </param>
		/// <param name="w_c">
		/// </param>
		/// <param name="b_ru">
		/// </param>
		/// <param name="b_c">
		/// </param>
		/// <param name="r">
		/// </param>
		/// <param name="u">
		/// </param>
		/// <param name="c">
		/// </param>
		/// <param name="d_h">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GRUBlockCellGrad'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   d_x:
		///   d_h_prev:
		///   d_c_bar:
		///   d_r_bar_u_bar:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output d_x, TF_Output d_h_prev, TF_Output d_c_bar, TF_Output d_r_bar_u_bar) GRUBlockCellGrad (TF_Output x, TF_Output h_prev, TF_Output w_ru, TF_Output w_c, TF_Output b_ru, TF_Output b_c, TF_Output r, TF_Output u, TF_Output c, TF_Output d_h, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GRUBlockCellGrad", MakeName ("GRUBlockCellGrad", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, h_prev);
			c_api.TF_AddInput(desc, w_ru);
			c_api.TF_AddInput(desc, w_c);
			c_api.TF_AddInput(desc, b_ru);
			c_api.TF_AddInput(desc, b_c);
			c_api.TF_AddInput(desc, r);
			c_api.TF_AddInput(desc, u);
			c_api.TF_AddInput(desc, c);
			c_api.TF_AddInput(desc, d_h);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var d_x = new TF_Output (op, _idx++);
			var d_h_prev = new TF_Output (op, _idx++);
			var d_c_bar = new TF_Output (op, _idx++);
			var d_r_bar_u_bar = new TF_Output (op, _idx++);
			return (d_x, d_h_prev, d_c_bar, d_r_bar_u_bar);
		}

		/// <summary>
		/// </summary>
		/// <param name="shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NonDeterministicInts'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output NonDeterministicInts (TF_Output shape, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NonDeterministicInts", MakeName ("NonDeterministicInts", operName));
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'VarHandleOp'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output VarHandleOp (TF_DataType dtype, long[] shape, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "VarHandleOp", MakeName ("VarHandleOp", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var resource = new TF_Output (op, _idx++);
			return resource;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DestroyResourceOp'.
		/// </param>
		/// <param name="ignore_lookup_error">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation DestroyResourceOp (TF_Output resource, bool? ignore_lookup_error = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DestroyResourceOp", MakeName ("DestroyResourceOp", operName));
			c_api.TF_AddInput(desc, resource);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (ignore_lookup_error.HasValue)
				c_api.TF_SetAttrBool (desc, "ignore_lookup_error", Convert.ToByte(ignore_lookup_error.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="delimiter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringSplit'.
		/// </param>
		/// <param name="skip_empty">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   indices:
		///   values:
		///   shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output indices, TF_Output values, TF_Output shape) StringSplit (TF_Output input, TF_Output delimiter, bool? skip_empty = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringSplit", MakeName ("StringSplit", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, delimiter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (skip_empty.HasValue)
				c_api.TF_SetAttrBool (desc, "skip_empty", Convert.ToByte(skip_empty.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var indices = new TF_Output (op, _idx++);
			var values = new TF_Output (op, _idx++);
			var shape = new TF_Output (op, _idx++);
			return (indices, values, shape);
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceGatherNd'.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ResourceGatherNd (TF_Output resource, TF_Output indices, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceGatherNd", MakeName ("ResourceGatherNd", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterMin'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceScatterMin (TF_Output resource, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceScatterMin", MakeName ("ResourceScatterMin", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterUpdate'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceScatterUpdate (TF_Output resource, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceScatterUpdate", MakeName ("ResourceScatterUpdate", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MutexV2'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MutexV2 (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MutexV2", MakeName ("MutexV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var resource = new TF_Output (op, _idx++);
			return resource;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SdcaFprint'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SdcaFprint (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SdcaFprint", MakeName ("SdcaFprint", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="set1">
		/// </param>
		/// <param name="set2_indices">
		/// </param>
		/// <param name="set2_values">
		/// </param>
		/// <param name="set2_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DenseToSparseSetOperation'.
		/// </param>
		/// <param name="validate_indices">
		///   Optional argument
		/// </param>
		/// <param name="set_operation">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   result_indices:
		///   result_values:
		///   result_shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output result_indices, TF_Output result_values, TF_Output result_shape) DenseToSparseSetOperation (TF_Output set1, TF_Output set2_indices, TF_Output set2_values, TF_Output set2_shape, string set_operation, bool? validate_indices = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DenseToSparseSetOperation", MakeName ("DenseToSparseSetOperation", operName));
			c_api.TF_AddInput(desc, set1);
			c_api.TF_AddInput(desc, set2_indices);
			c_api.TF_AddInput(desc, set2_values);
			c_api.TF_AddInput(desc, set2_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "set_operation", set_operation);
			if (validate_indices.HasValue)
				c_api.TF_SetAttrBool (desc, "validate_indices", Convert.ToByte(validate_indices.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var result_indices = new TF_Output (op, _idx++);
			var result_values = new TF_Output (op, _idx++);
			var result_shape = new TF_Output (op, _idx++);
			return (result_indices, result_values, result_shape);
		}

		/// <summary>
		/// </summary>
		/// <param name="backprop_val_grad">
		/// </param>
		/// <param name="a_indices">
		/// </param>
		/// <param name="b_indices">
		/// </param>
		/// <param name="sum_indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseAddGrad'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   a_val_grad:
		///   b_val_grad:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output a_val_grad, TF_Output b_val_grad) SparseAddGrad (TF_Output backprop_val_grad, TF_Output a_indices, TF_Output b_indices, TF_Output sum_indices, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseAddGrad", MakeName ("SparseAddGrad", operName));
			c_api.TF_AddInput(desc, backprop_val_grad);
			c_api.TF_AddInput(desc, a_indices);
			c_api.TF_AddInput(desc, b_indices);
			c_api.TF_AddInput(desc, sum_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var a_val_grad = new TF_Output (op, _idx++);
			var b_val_grad = new TF_Output (op, _idx++);
			return (a_val_grad, b_val_grad);
		}

		/// <summary>
		/// </summary>
		/// <param name="a_indices">
		/// </param>
		/// <param name="a_values">
		/// </param>
		/// <param name="a_shape">
		/// </param>
		/// <param name="b_indices">
		/// </param>
		/// <param name="b_values">
		/// </param>
		/// <param name="b_shape">
		/// </param>
		/// <param name="thresh">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseAdd'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sum_indices:
		///   sum_values:
		///   sum_shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output sum_indices, TF_Output sum_values, TF_Output sum_shape) SparseAdd (TF_Output a_indices, TF_Output a_values, TF_Output a_shape, TF_Output b_indices, TF_Output b_values, TF_Output b_shape, TF_Output thresh, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseAdd", MakeName ("SparseAdd", operName));
			c_api.TF_AddInput(desc, a_indices);
			c_api.TF_AddInput(desc, a_values);
			c_api.TF_AddInput(desc, a_shape);
			c_api.TF_AddInput(desc, b_indices);
			c_api.TF_AddInput(desc, b_values);
			c_api.TF_AddInput(desc, b_shape);
			c_api.TF_AddInput(desc, thresh);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var sum_indices = new TF_Output (op, _idx++);
			var sum_values = new TF_Output (op, _idx++);
			var sum_shape = new TF_Output (op, _idx++);
			return (sum_indices, sum_values, sum_shape);
		}

		/// <summary>
		/// </summary>
		/// <param name="a_indices">
		/// </param>
		/// <param name="a_values">
		/// </param>
		/// <param name="a_shape">
		/// </param>
		/// <param name="b">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseTensorDenseMatMul'.
		/// </param>
		/// <param name="adjoint_a">
		///   Optional argument
		/// </param>
		/// <param name="adjoint_b">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseTensorDenseMatMul (TF_Output a_indices, TF_Output a_values, TF_Output a_shape, TF_Output b, bool? adjoint_a = null, bool? adjoint_b = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseTensorDenseMatMul", MakeName ("SparseTensorDenseMatMul", operName));
			c_api.TF_AddInput(desc, a_indices);
			c_api.TF_AddInput(desc, a_values);
			c_api.TF_AddInput(desc, a_shape);
			c_api.TF_AddInput(desc, b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (adjoint_a.HasValue)
				c_api.TF_SetAttrBool (desc, "adjoint_a", Convert.ToByte(adjoint_a.Value));
			
			if (adjoint_b.HasValue)
				c_api.TF_SetAttrBool (desc, "adjoint_b", Convert.ToByte(adjoint_b.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var product = new TF_Output (op, _idx++);
			return product;
		}

		/// <summary>
		/// </summary>
		/// <param name="sparse_indices">
		/// </param>
		/// <param name="sparse_values">
		/// </param>
		/// <param name="sparse_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SerializeManySparse'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SerializeManySparse (TF_Output sparse_indices, TF_Output sparse_values, TF_Output sparse_shape, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SerializeManySparse", MakeName ("SerializeManySparse", operName));
			c_api.TF_AddInput(desc, sparse_indices);
			c_api.TF_AddInput(desc, sparse_values);
			c_api.TF_AddInput(desc, sparse_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var serialized_sparse = new TF_Output (op, _idx++);
			return serialized_sparse;
		}

		/// <summary>
		/// </summary>
		/// <param name="serialized_sparse">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DeserializeManySparse'.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sparse_indices:
		///   sparse_values:
		///   sparse_shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output sparse_indices, TF_Output sparse_values, TF_Output sparse_shape) DeserializeManySparse (TF_Output serialized_sparse, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DeserializeManySparse", MakeName ("DeserializeManySparse", operName));
			c_api.TF_AddInput(desc, serialized_sparse);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var sparse_indices = new TF_Output (op, _idx++);
			var sparse_values = new TF_Output (op, _idx++);
			var sparse_shape = new TF_Output (op, _idx++);
			return (sparse_indices, sparse_values, sparse_shape);
		}

		/// <summary>
		/// </summary>
		/// <param name="indices">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="shapes">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseConcat'.
		/// </param>
		/// <param name="concat_dim">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices:
		///   output_values:
		///   output_shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output_indices, TF_Output output_values, TF_Output output_shape) SparseConcat (TF_Output[] indices, TF_Output[] values, TF_Output[] shapes, long concat_dim, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseConcat", MakeName ("SparseConcat", operName));
			c_api.TF_AddInputList(desc, indices[0], indices.Length);
			c_api.TF_AddInputList(desc, values[0], values.Length);
			c_api.TF_AddInputList(desc, shapes[0], shapes.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "concat_dim", concat_dim);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_indices = new TF_Output (op, _idx++);
			var output_values = new TF_Output (op, _idx++);
			var output_shape = new TF_Output (op, _idx++);
			return (output_indices, output_values, output_shape);
		}

		/// <summary>
		/// </summary>
		/// <param name="indices">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <param name="start">
		/// </param>
		/// <param name="size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSlice'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices:
		///   output_values:
		///   output_shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output_indices, TF_Output output_values, TF_Output output_shape) SparseSlice (TF_Output indices, TF_Output values, TF_Output shape, TF_Output start, TF_Output size, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSlice", MakeName ("SparseSlice", operName));
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, values);
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, start);
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_indices = new TF_Output (op, _idx++);
			var output_values = new TF_Output (op, _idx++);
			var output_shape = new TF_Output (op, _idx++);
			return (output_indices, output_values, output_shape);
		}

		/// <summary>
		/// </summary>
		/// <param name="input_indices">
		/// </param>
		/// <param name="input_values">
		/// </param>
		/// <param name="input_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReorder'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices:
		///   output_values:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output_indices, TF_Output output_values) SparseReorder (TF_Output input_indices, TF_Output input_values, TF_Output input_shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseReorder", MakeName ("SparseReorder", operName));
			c_api.TF_AddInput(desc, input_indices);
			c_api.TF_AddInput(desc, input_values);
			c_api.TF_AddInput(desc, input_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_indices = new TF_Output (op, _idx++);
			var output_values = new TF_Output (op, _idx++);
			return (output_indices, output_values);
		}

		/// <summary>
		/// </summary>
		/// <param name="a_indices">
		/// </param>
		/// <param name="a_values">
		/// </param>
		/// <param name="a_shape">
		/// </param>
		/// <param name="b">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseTensorDenseAdd'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseTensorDenseAdd (TF_Output a_indices, TF_Output a_values, TF_Output a_shape, TF_Output b, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseTensorDenseAdd", MakeName ("SparseTensorDenseAdd", operName));
			c_api.TF_AddInput(desc, a_indices);
			c_api.TF_AddInput(desc, a_values);
			c_api.TF_AddInput(desc, a_shape);
			c_api.TF_AddInput(desc, b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_indices">
		/// </param>
		/// <param name="input_values">
		/// </param>
		/// <param name="input_shape">
		/// </param>
		/// <param name="reduction_axes">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReduceSum'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseReduceSum (TF_Output input_indices, TF_Output input_values, TF_Output input_shape, TF_Output reduction_axes, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseReduceSum", MakeName ("SparseReduceSum", operName));
			c_api.TF_AddInput(desc, input_indices);
			c_api.TF_AddInput(desc, input_values);
			c_api.TF_AddInput(desc, input_shape);
			c_api.TF_AddInput(desc, reduction_axes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="sp_indices">
		/// </param>
		/// <param name="sp_values">
		/// </param>
		/// <param name="sp_shape">
		/// </param>
		/// <param name="dense">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseDenseCwiseDiv'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseDenseCwiseDiv (TF_Output sp_indices, TF_Output sp_values, TF_Output sp_shape, TF_Output dense, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseDenseCwiseDiv", MakeName ("SparseDenseCwiseDiv", operName));
			c_api.TF_AddInput(desc, sp_indices);
			c_api.TF_AddInput(desc, sp_values);
			c_api.TF_AddInput(desc, sp_shape);
			c_api.TF_AddInput(desc, dense);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="a_indices">
		/// </param>
		/// <param name="a_values">
		/// </param>
		/// <param name="a_shape">
		/// </param>
		/// <param name="b_indices">
		/// </param>
		/// <param name="b_values">
		/// </param>
		/// <param name="b_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSparseMinimum'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices:
		///   output_values:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output_indices, TF_Output output_values) SparseSparseMinimum (TF_Output a_indices, TF_Output a_values, TF_Output a_shape, TF_Output b_indices, TF_Output b_values, TF_Output b_shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSparseMinimum", MakeName ("SparseSparseMinimum", operName));
			c_api.TF_AddInput(desc, a_indices);
			c_api.TF_AddInput(desc, a_values);
			c_api.TF_AddInput(desc, a_shape);
			c_api.TF_AddInput(desc, b_indices);
			c_api.TF_AddInput(desc, b_values);
			c_api.TF_AddInput(desc, b_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_indices = new TF_Output (op, _idx++);
			var output_values = new TF_Output (op, _idx++);
			return (output_indices, output_values);
		}

		/// <summary>
		/// </summary>
		/// <param name="sparse_indices">
		/// </param>
		/// <param name="sparse_values">
		/// </param>
		/// <param name="sparse_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AddManySparseToTensorsMap'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AddManySparseToTensorsMap (TF_Output sparse_indices, TF_Output sparse_values, TF_Output sparse_shape, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AddManySparseToTensorsMap", MakeName ("AddManySparseToTensorsMap", operName));
			c_api.TF_AddInput(desc, sparse_indices);
			c_api.TF_AddInput(desc, sparse_values);
			c_api.TF_AddInput(desc, sparse_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var sparse_handles = new TF_Output (op, _idx++);
			return sparse_handles;
		}

		/// <summary>
		/// </summary>
		/// <param name="indices">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="dense_shape">
		/// </param>
		/// <param name="default_value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseFillEmptyRows'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices:
		///   output_values:
		///   empty_row_indicator:
		///   reverse_index_map:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output_indices, TF_Output output_values, TF_Output empty_row_indicator, TF_Output reverse_index_map) SparseFillEmptyRows (TF_Output indices, TF_Output values, TF_Output dense_shape, TF_Output default_value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseFillEmptyRows", MakeName ("SparseFillEmptyRows", operName));
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, values);
			c_api.TF_AddInput(desc, dense_shape);
			c_api.TF_AddInput(desc, default_value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_indices = new TF_Output (op, _idx++);
			var output_values = new TF_Output (op, _idx++);
			var empty_row_indicator = new TF_Output (op, _idx++);
			var reverse_index_map = new TF_Output (op, _idx++);
			return (output_indices, output_values, empty_row_indicator, reverse_index_map);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SummaryWriter'.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SummaryWriter (string shared_name = null, string container = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SummaryWriter", MakeName ("SummaryWriter", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var writer = new TF_Output (op, _idx++);
			return writer;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FlushSummaryWriter'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation FlushSummaryWriter (TF_Output writer, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FlushSummaryWriter", MakeName ("FlushSummaryWriter", operName));
			c_api.TF_AddInput(desc, writer);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="step">
		/// </param>
		/// <param name="tensor">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="summary_metadata">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteSummary'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation WriteSummary (TF_Output writer, TF_Output step, TF_Output tensor, TF_Output tag, TF_Output summary_metadata, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WriteSummary", MakeName ("WriteSummary", operName));
			c_api.TF_AddInput(desc, writer);
			c_api.TF_AddInput(desc, step);
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, summary_metadata);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="step">
		/// </param>
		/// <param name="tensor">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteRawProtoSummary'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation WriteRawProtoSummary (TF_Output writer, TF_Output step, TF_Output tensor, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WriteRawProtoSummary", MakeName ("WriteRawProtoSummary", operName));
			c_api.TF_AddInput(desc, writer);
			c_api.TF_AddInput(desc, step);
			c_api.TF_AddInput(desc, tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="evnt">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ImportEvent'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ImportEvent (TF_Output writer, TF_Output evnt, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ImportEvent", MakeName ("ImportEvent", operName));
			c_api.TF_AddInput(desc, writer);
			c_api.TF_AddInput(desc, evnt);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="step">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteHistogramSummary'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation WriteHistogramSummary (TF_Output writer, TF_Output step, TF_Output tag, TF_Output values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WriteHistogramSummary", MakeName ("WriteHistogramSummary", operName));
			c_api.TF_AddInput(desc, writer);
			c_api.TF_AddInput(desc, step);
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="step">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="tensor">
		/// </param>
		/// <param name="bad_color">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteImageSummary'.
		/// </param>
		/// <param name="max_images">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation WriteImageSummary (TF_Output writer, TF_Output step, TF_Output tag, TF_Output tensor, TF_Output bad_color, long? max_images = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WriteImageSummary", MakeName ("WriteImageSummary", operName));
			c_api.TF_AddInput(desc, writer);
			c_api.TF_AddInput(desc, step);
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, bad_color);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (max_images.HasValue)
				c_api.TF_SetAttrInt (desc, "max_images", max_images.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="step">
		/// </param>
		/// <param name="tensor">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteGraphSummary'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation WriteGraphSummary (TF_Output writer, TF_Output step, TF_Output tensor, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WriteGraphSummary", MakeName ("WriteGraphSummary", operName));
			c_api.TF_AddInput(desc, writer);
			c_api.TF_AddInput(desc, step);
			c_api.TF_AddInput(desc, tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FFT'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FFT (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FFT", MakeName ("FFT", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IFFT'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IFFT (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IFFT", MakeName ("IFFT", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FFT2D'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FFT2D (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FFT2D", MakeName ("FFT2D", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IFFT2D'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IFFT2D (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IFFT2D", MakeName ("IFFT2D", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FFT3D'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FFT3D (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FFT3D", MakeName ("FFT3D", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="fft_length">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RFFT'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RFFT (TF_Output input, TF_Output fft_length, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RFFT", MakeName ("RFFT", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, fft_length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="fft_length">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IRFFT'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IRFFT (TF_Output input, TF_Output fft_length, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IRFFT", MakeName ("IRFFT", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, fft_length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="fft_length">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RFFT2D'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RFFT2D (TF_Output input, TF_Output fft_length, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RFFT2D", MakeName ("RFFT2D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, fft_length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="fft_length">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IRFFT2D'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IRFFT2D (TF_Output input, TF_Output fft_length, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IRFFT2D", MakeName ("IRFFT2D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, fft_length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="fft_length">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IRFFT3D'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IRFFT3D (TF_Output input, TF_Output fft_length, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IRFFT3D", MakeName ("IRFFT3D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, fft_length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchFFT'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchFFT (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchFFT", MakeName ("BatchFFT", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchIFFT'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchIFFT (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchIFFT", MakeName ("BatchIFFT", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchFFT2D'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchFFT2D (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchFFT2D", MakeName ("BatchFFT2D", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchIFFT2D'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchIFFT2D (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchIFFT2D", MakeName ("BatchIFFT2D", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchFFT3D'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchFFT3D (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchFFT3D", MakeName ("BatchFFT3D", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterMax'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ScatterMax (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterMax", MakeName ("ScatterMax", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchIFFT3D'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchIFFT3D (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchIFFT3D", MakeName ("BatchIFFT3D", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'VariableV2'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output VariableV2 (long[] shape, TF_DataType dtype, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "VariableV2", MakeName ("VariableV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var reference = new TF_Output (op, _idx++);
			return reference;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IsVariableInitialized'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IsVariableInitialized (TF_Output reference, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IsVariableInitialized", MakeName ("IsVariableInitialized", operName));
			c_api.TF_AddInput(desc, reference);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var is_initialized = new TF_Output (op, _idx++);
			return is_initialized;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TemporaryVariable'.
		/// </param>
		/// <param name="var_name">
		///   Optional argument
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TemporaryVariable (long[] shape, TF_DataType dtype, string var_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TemporaryVariable", MakeName ("TemporaryVariable", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (var_name != null)
				c_api.TF_SetAttrString (desc, "var_name", var_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var reference = new TF_Output (op, _idx++);
			return reference;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DestroyTemporaryVariable'.
		/// </param>
		/// <param name="var_name">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DestroyTemporaryVariable (TF_Output reference, string var_name, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DestroyTemporaryVariable", MakeName ("DestroyTemporaryVariable", operName));
			c_api.TF_AddInput(desc, reference);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "var_name", var_name);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			return value;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AssignSub'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AssignSub (TF_Output reference, TF_Output value, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AssignSub", MakeName ("AssignSub", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InfeedEnqueue'.
		/// </param>
		/// <param name="shape">
		///   Optional argument
		/// </param>
		/// <param name="layout">
		///   Optional argument
		/// </param>
		/// <param name="device_ordinal">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation InfeedEnqueue (TF_Output input, long[] shape = null, long[] layout = null, long? device_ordinal = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InfeedEnqueue", MakeName ("InfeedEnqueue", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (shape != null)
				c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			
			if (layout != null)
				c_api.TF_SetAttrIntList (desc, "layout", ref layout[0], layout.Length);
			
			if (device_ordinal.HasValue)
				c_api.TF_SetAttrInt (desc, "device_ordinal", device_ordinal.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterAdd'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ScatterAdd (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterAdd", MakeName ("ScatterAdd", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterSub'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ScatterSub (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterSub", MakeName ("ScatterSub", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterMin'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ScatterMin (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterMin", MakeName ("ScatterMin", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterNdUpdate'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceScatterNdUpdate (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceScatterNdUpdate", MakeName ("ResourceScatterNdUpdate", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterNdSub'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceScatterNdSub (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceScatterNdSub", MakeName ("ResourceScatterNdSub", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterNdAdd'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ScatterNdAdd (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterNdAdd", MakeName ("ScatterNdAdd", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		/// </summary>
		/// <param name="shape">
		/// </param>
		/// <param name="seed">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatelessRandomNormal'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StatelessRandomNormal (TF_Output shape, TF_Output seed, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatelessRandomNormal", MakeName ("StatelessRandomNormal", operName));
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, seed);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="shape">
		/// </param>
		/// <param name="seed">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatelessTruncatedNormal'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StatelessTruncatedNormal (TF_Output shape, TF_Output seed, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatelessTruncatedNormal", MakeName ("StatelessTruncatedNormal", operName));
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, seed);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="pattern">
		/// </param>
		/// <param name="rewrite">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RegexReplace'.
		/// </param>
		/// <param name="replace_global">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RegexReplace (TF_Output input, TF_Output pattern, TF_Output rewrite, bool? replace_global = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RegexReplace", MakeName ("RegexReplace", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, pattern);
			c_api.TF_AddInput(desc, rewrite);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (replace_global.HasValue)
				c_api.TF_SetAttrBool (desc, "replace_global", Convert.ToByte(replace_global.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StaticRegexReplace'.
		/// </param>
		/// <param name="replace_global">
		///   Optional argument
		/// </param>
		/// <param name="pattern">
		/// </param>
		/// <param name="rewrite">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StaticRegexReplace (TF_Output input, string pattern, string rewrite, bool? replace_global = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StaticRegexReplace", MakeName ("StaticRegexReplace", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "pattern", pattern);
			c_api.TF_SetAttrString (desc, "rewrite", rewrite);
			if (replace_global.HasValue)
				c_api.TF_SetAttrBool (desc, "replace_global", Convert.ToByte(replace_global.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="pattern">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RegexFullMatch'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RegexFullMatch (TF_Output input, TF_Output pattern, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RegexFullMatch", MakeName ("RegexFullMatch", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, pattern);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StaticRegexFullMatch'.
		/// </param>
		/// <param name="pattern">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StaticRegexFullMatch (TF_Output input, string pattern, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StaticRegexFullMatch", MakeName ("StaticRegexFullMatch", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "pattern", pattern);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringToHashBucketFast'.
		/// </param>
		/// <param name="num_buckets">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StringToHashBucketFast (TF_Output input, long num_buckets, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringToHashBucketFast", MakeName ("StringToHashBucketFast", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_buckets", num_buckets);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringToHashBucketStrong'.
		/// </param>
		/// <param name="num_buckets">
		/// </param>
		/// <param name="key">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StringToHashBucketStrong (TF_Output input, long num_buckets, long[] key, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringToHashBucketStrong", MakeName ("StringToHashBucketStrong", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_buckets", num_buckets);
			c_api.TF_SetAttrIntList (desc, "key", ref key[0], key.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="reduction_indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReduceJoin'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		/// </param>
		/// <param name="separator">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ReduceJoin (TF_Output inputs, TF_Output reduction_indices, bool? keep_dims = null, string separator = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReduceJoin", MakeName ("ReduceJoin", operName));
			c_api.TF_AddInput(desc, inputs);
			c_api.TF_AddInput(desc, reduction_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			if (separator != null)
				c_api.TF_SetAttrString (desc, "separator", separator);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="segment_ids">
		/// </param>
		/// <param name="num_segments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnsortedSegmentJoin'.
		/// </param>
		/// <param name="separator">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output UnsortedSegmentJoin (TF_Output inputs, TF_Output segment_ids, TF_Output num_segments, string separator = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnsortedSegmentJoin", MakeName ("UnsortedSegmentJoin", operName));
			c_api.TF_AddInput(desc, inputs);
			c_api.TF_AddInput(desc, segment_ids);
			c_api.TF_AddInput(desc, num_segments);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (separator != null)
				c_api.TF_SetAttrString (desc, "separator", separator);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AsString'.
		/// </param>
		/// <param name="precision">
		///   Optional argument
		/// </param>
		/// <param name="scientific">
		///   Optional argument
		/// </param>
		/// <param name="shortest">
		///   Optional argument
		/// </param>
		/// <param name="width">
		///   Optional argument
		/// </param>
		/// <param name="fill">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AsString (TF_Output input, long? precision = null, bool? scientific = null, bool? shortest = null, long? width = null, string fill = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AsString", MakeName ("AsString", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (precision.HasValue)
				c_api.TF_SetAttrInt (desc, "precision", precision.Value);
			
			if (scientific.HasValue)
				c_api.TF_SetAttrBool (desc, "scientific", Convert.ToByte(scientific.Value));
			
			if (shortest.HasValue)
				c_api.TF_SetAttrBool (desc, "shortest", Convert.ToByte(shortest.Value));
			
			if (width.HasValue)
				c_api.TF_SetAttrInt (desc, "width", width.Value);
			
			if (fill != null)
				c_api.TF_SetAttrString (desc, "fill", fill);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringJoin'.
		/// </param>
		/// <param name="separator">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StringJoin (TF_Output[] inputs, string separator = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringJoin", MakeName ("StringJoin", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (separator != null)
				c_api.TF_SetAttrString (desc, "separator", separator);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="sep">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringSplitV2'.
		/// </param>
		/// <param name="maxsplit">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   indices:
		///   values:
		///   shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output indices, TF_Output values, TF_Output shape) StringSplitV2 (TF_Output input, TF_Output sep, long? maxsplit = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringSplitV2", MakeName ("StringSplitV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, sep);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (maxsplit.HasValue)
				c_api.TF_SetAttrInt (desc, "maxsplit", maxsplit.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var indices = new TF_Output (op, _idx++);
			var values = new TF_Output (op, _idx++);
			var shape = new TF_Output (op, _idx++);
			return (indices, values, shape);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringLower'.
		/// </param>
		/// <param name="encoding">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StringLower (TF_Output input, string encoding = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringLower", MakeName ("StringLower", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (encoding != null)
				c_api.TF_SetAttrString (desc, "encoding", encoding);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringLength'.
		/// </param>
		/// <param name="unit">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StringLength (TF_Output input, string unit = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringLength", MakeName ("StringLength", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (unit != null)
				c_api.TF_SetAttrString (desc, "unit", unit);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodeBase64'.
		/// </param>
		/// <param name="pad">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output EncodeBase64 (TF_Output input, bool? pad = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EncodeBase64", MakeName ("EncodeBase64", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (pad.HasValue)
				c_api.TF_SetAttrBool (desc, "pad", Convert.ToByte(pad.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeBase64'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DecodeBase64 (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodeBase64", MakeName ("DecodeBase64", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="pos">
		/// </param>
		/// <param name="len">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Substr'.
		/// </param>
		/// <param name="unit">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Substr (TF_Output input, TF_Output pos, TF_Output len, string unit = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Substr", MakeName ("Substr", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, pos);
			c_api.TF_AddInput(desc, len);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (unit != null)
				c_api.TF_SetAttrString (desc, "unit", unit);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_values">
		/// </param>
		/// <param name="input_splits">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnicodeEncode'.
		/// </param>
		/// <param name="errors">
		///   Optional argument
		/// </param>
		/// <param name="replacement_char">
		///   Optional argument
		/// </param>
		/// <param name="output_encoding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output UnicodeEncode (TF_Output input_values, TF_Output input_splits, string output_encoding, string errors = null, long? replacement_char = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnicodeEncode", MakeName ("UnicodeEncode", operName));
			c_api.TF_AddInput(desc, input_values);
			c_api.TF_AddInput(desc, input_splits);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "output_encoding", output_encoding);
			if (errors != null)
				c_api.TF_SetAttrString (desc, "errors", errors);
			
			if (replacement_char.HasValue)
				c_api.TF_SetAttrInt (desc, "replacement_char", replacement_char.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnicodeTranscode'.
		/// </param>
		/// <param name="errors">
		///   Optional argument
		/// </param>
		/// <param name="replacement_char">
		///   Optional argument
		/// </param>
		/// <param name="replace_control_characters">
		///   Optional argument
		/// </param>
		/// <param name="input_encoding">
		/// </param>
		/// <param name="output_encoding">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output UnicodeTranscode (TF_Output input, string input_encoding, string output_encoding, string errors = null, long? replacement_char = null, bool? replace_control_characters = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnicodeTranscode", MakeName ("UnicodeTranscode", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "input_encoding", input_encoding);
			c_api.TF_SetAttrString (desc, "output_encoding", output_encoding);
			if (errors != null)
				c_api.TF_SetAttrString (desc, "errors", errors);
			
			if (replacement_char.HasValue)
				c_api.TF_SetAttrInt (desc, "replacement_char", replacement_char.Value);
			
			if (replace_control_characters.HasValue)
				c_api.TF_SetAttrBool (desc, "replace_control_characters", Convert.ToByte(replace_control_characters.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnicodeDecode'.
		/// </param>
		/// <param name="errors">
		///   Optional argument
		/// </param>
		/// <param name="replacement_char">
		///   Optional argument
		/// </param>
		/// <param name="replace_control_characters">
		///   Optional argument
		/// </param>
		/// <param name="Tsplits">
		///   Optional argument
		/// </param>
		/// <param name="input_encoding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   row_splits:
		///   char_values:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output row_splits, TF_Output char_values) UnicodeDecode (TF_Output input, string input_encoding, string errors = null, long? replacement_char = null, bool? replace_control_characters = null, TF_DataType? Tsplits = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnicodeDecode", MakeName ("UnicodeDecode", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "input_encoding", input_encoding);
			if (errors != null)
				c_api.TF_SetAttrString (desc, "errors", errors);
			
			if (replacement_char.HasValue)
				c_api.TF_SetAttrInt (desc, "replacement_char", replacement_char.Value);
			
			if (replace_control_characters.HasValue)
				c_api.TF_SetAttrBool (desc, "replace_control_characters", Convert.ToByte(replace_control_characters.Value));
			
			if (Tsplits.HasValue)
				c_api.TF_SetAttrType (desc, "Tsplits", Tsplits.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var row_splits = new TF_Output (op, _idx++);
			var char_values = new TF_Output (op, _idx++);
			return (row_splits, char_values);
		}

		/// <summary>
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="data_splits">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringNGrams'.
		/// </param>
		/// <param name="separator">
		/// </param>
		/// <param name="ngram_widths">
		/// </param>
		/// <param name="left_pad">
		/// </param>
		/// <param name="right_pad">
		/// </param>
		/// <param name="pad_width">
		/// </param>
		/// <param name="preserve_short_sequences">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   ngrams:
		///   ngrams_splits:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output ngrams, TF_Output ngrams_splits) StringNGrams (TF_Output data, TF_Output data_splits, string separator, long[] ngram_widths, string left_pad, string right_pad, long pad_width, bool preserve_short_sequences, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringNGrams", MakeName ("StringNGrams", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, data_splits);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "separator", separator);
			c_api.TF_SetAttrIntList (desc, "ngram_widths", ref ngram_widths[0], ngram_widths.Length);
			c_api.TF_SetAttrString (desc, "left_pad", left_pad);
			c_api.TF_SetAttrString (desc, "right_pad", right_pad);
			c_api.TF_SetAttrInt (desc, "pad_width", pad_width);
			c_api.TF_SetAttrBool (desc, "preserve_short_sequences", Convert.ToByte(preserve_short_sequences));
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var ngrams = new TF_Output (op, _idx++);
			var ngrams_splits = new TF_Output (op, _idx++);
			return (ngrams, ngrams_splits);
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyMomentum'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <param name="use_nesterov">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ApplyMomentum (TF_Output var, TF_Output accum, TF_Output lr, TF_Output grad, TF_Output momentum, bool? use_locking = null, bool? use_nesterov = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyMomentum", MakeName ("ApplyMomentum", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, momentum);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (use_nesterov.HasValue)
				c_api.TF_SetAttrBool (desc, "use_nesterov", Convert.ToByte(use_nesterov.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdagradV2'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <param name="update_slots">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ApplyAdagradV2 (TF_Output var, TF_Output accum, TF_Output lr, TF_Output epsilon, TF_Output grad, bool? use_locking = null, bool? update_slots = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyAdagradV2", MakeName ("ApplyAdagradV2", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (update_slots.HasValue)
				c_api.TF_SetAttrBool (desc, "update_slots", Convert.ToByte(update_slots.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ShutdownDistributedTPU'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ShutdownDistributedTPU (string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ShutdownDistributedTPU", MakeName ("ShutdownDistributedTPU", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="group_assignment">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AllToAll'.
		/// </param>
		/// <param name="concat_dimension">
		/// </param>
		/// <param name="split_dimension">
		/// </param>
		/// <param name="split_count">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AllToAll (TF_Output input, TF_Output group_assignment, long concat_dimension, long split_dimension, long split_count, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AllToAll", MakeName ("AllToAll", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, group_assignment);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "concat_dimension", concat_dimension);
			c_api.TF_SetAttrInt (desc, "split_dimension", split_dimension);
			c_api.TF_SetAttrInt (desc, "split_count", split_count);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="source_target_pairs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CollectivePermute'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CollectivePermute (TF_Output input, TF_Output source_target_pairs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CollectivePermute", MakeName ("CollectivePermute", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, source_target_pairs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="accumulators">
		/// </param>
		/// <param name="gradient_accumulators">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingAdagradParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LoadTPUEmbeddingAdagradParametersGradAccumDebug (TF_Output parameters, TF_Output accumulators, TF_Output gradient_accumulators, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingAdagradParametersGradAccumDebug", MakeName ("LoadTPUEmbeddingAdagradParametersGradAccumDebug", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, accumulators);
			c_api.TF_AddInput(desc, gradient_accumulators);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="ms">
		/// </param>
		/// <param name="mom">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="rho">
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyRMSProp'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceApplyRMSProp (TF_Output var, TF_Output ms, TF_Output mom, TF_Output lr, TF_Output rho, TF_Output momentum, TF_Output epsilon, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyRMSProp", MakeName ("ResourceApplyRMSProp", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, momentum);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingStochasticGradientDescentParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LoadTPUEmbeddingStochasticGradientDescentParameters (TF_Output parameters, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingStochasticGradientDescentParameters", MakeName ("LoadTPUEmbeddingStochasticGradientDescentParameters", operName));
			c_api.TF_AddInput(desc, parameters);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="accumulators">
		/// </param>
		/// <param name="linears">
		/// </param>
		/// <param name="gradient_accumulators">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingFTRLParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LoadTPUEmbeddingFTRLParametersGradAccumDebug (TF_Output parameters, TF_Output accumulators, TF_Output linears, TF_Output gradient_accumulators, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingFTRLParametersGradAccumDebug", MakeName ("LoadTPUEmbeddingFTRLParametersGradAccumDebug", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, accumulators);
			c_api.TF_AddInput(desc, linears);
			c_api.TF_AddInput(desc, gradient_accumulators);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="momenta">
		/// </param>
		/// <param name="velocities">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingADAMParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LoadTPUEmbeddingADAMParameters (TF_Output parameters, TF_Output momenta, TF_Output velocities, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingADAMParameters", MakeName ("LoadTPUEmbeddingADAMParameters", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, momenta);
			c_api.TF_AddInput(desc, velocities);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="momenta">
		/// </param>
		/// <param name="gradient_accumulators">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingMomentumParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LoadTPUEmbeddingMomentumParametersGradAccumDebug (TF_Output parameters, TF_Output momenta, TF_Output gradient_accumulators, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingMomentumParametersGradAccumDebug", MakeName ("LoadTPUEmbeddingMomentumParametersGradAccumDebug", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, momenta);
			c_api.TF_AddInput(desc, gradient_accumulators);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="ms">
		/// </param>
		/// <param name="mom">
		/// </param>
		/// <param name="gradient_accumulators">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingRMSPropParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LoadTPUEmbeddingRMSPropParametersGradAccumDebug (TF_Output parameters, TF_Output ms, TF_Output mom, TF_Output gradient_accumulators, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingRMSPropParametersGradAccumDebug", MakeName ("LoadTPUEmbeddingRMSPropParametersGradAccumDebug", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			c_api.TF_AddInput(desc, gradient_accumulators);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="accumulators">
		/// </param>
		/// <param name="weights">
		/// </param>
		/// <param name="benefits">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingMDLAdagradLightParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LoadTPUEmbeddingMDLAdagradLightParameters (TF_Output parameters, TF_Output accumulators, TF_Output weights, TF_Output benefits, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingMDLAdagradLightParameters", MakeName ("LoadTPUEmbeddingMDLAdagradLightParameters", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, accumulators);
			c_api.TF_AddInput(desc, weights);
			c_api.TF_AddInput(desc, benefits);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="accumulators">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingAdadeltaParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LoadTPUEmbeddingAdadeltaParameters (TF_Output parameters, TF_Output accumulators, TF_Output updates, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingAdadeltaParameters", MakeName ("LoadTPUEmbeddingAdadeltaParameters", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, accumulators);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="accumulators">
		/// </param>
		/// <param name="updates">
		/// </param>
		/// <param name="gradient_accumulators">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingAdadeltaParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation LoadTPUEmbeddingAdadeltaParametersGradAccumDebug (TF_Output parameters, TF_Output accumulators, TF_Output updates, TF_Output gradient_accumulators, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingAdadeltaParametersGradAccumDebug", MakeName ("LoadTPUEmbeddingAdadeltaParametersGradAccumDebug", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, accumulators);
			c_api.TF_AddInput(desc, updates);
			c_api.TF_AddInput(desc, gradient_accumulators);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingAdagradParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters:
		///   accumulators:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output parameters, TF_Output accumulators) RetrieveTPUEmbeddingAdagradParameters (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingAdagradParameters", MakeName ("RetrieveTPUEmbeddingAdagradParameters", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var accumulators = new TF_Output (op, _idx++);
			return (parameters, accumulators);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingAdagradParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters:
		///   accumulators:
		///   gradient_accumulators:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output parameters, TF_Output accumulators, TF_Output gradient_accumulators) RetrieveTPUEmbeddingAdagradParametersGradAccumDebug (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingAdagradParametersGradAccumDebug", MakeName ("RetrieveTPUEmbeddingAdagradParametersGradAccumDebug", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var accumulators = new TF_Output (op, _idx++);
			var gradient_accumulators = new TF_Output (op, _idx++);
			return (parameters, accumulators, gradient_accumulators);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingStochasticGradientDescentParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RetrieveTPUEmbeddingStochasticGradientDescentParameters (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingStochasticGradientDescentParameters", MakeName ("RetrieveTPUEmbeddingStochasticGradientDescentParameters", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			return parameters;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingADAMParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters:
		///   momenta:
		///   velocities:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output parameters, TF_Output momenta, TF_Output velocities) RetrieveTPUEmbeddingADAMParameters (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingADAMParameters", MakeName ("RetrieveTPUEmbeddingADAMParameters", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var momenta = new TF_Output (op, _idx++);
			var velocities = new TF_Output (op, _idx++);
			return (parameters, momenta, velocities);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingMomentumParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters:
		///   momenta:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output parameters, TF_Output momenta) RetrieveTPUEmbeddingMomentumParameters (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingMomentumParameters", MakeName ("RetrieveTPUEmbeddingMomentumParameters", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var momenta = new TF_Output (op, _idx++);
			return (parameters, momenta);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingRMSPropParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters:
		///   ms:
		///   mom:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output parameters, TF_Output ms, TF_Output mom) RetrieveTPUEmbeddingRMSPropParameters (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingRMSPropParameters", MakeName ("RetrieveTPUEmbeddingRMSPropParameters", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var ms = new TF_Output (op, _idx++);
			var mom = new TF_Output (op, _idx++);
			return (parameters, ms, mom);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingCenteredRMSPropParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters:
		///   ms:
		///   mom:
		///   mg:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output parameters, TF_Output ms, TF_Output mom, TF_Output mg) RetrieveTPUEmbeddingCenteredRMSPropParameters (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingCenteredRMSPropParameters", MakeName ("RetrieveTPUEmbeddingCenteredRMSPropParameters", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var ms = new TF_Output (op, _idx++);
			var mom = new TF_Output (op, _idx++);
			var mg = new TF_Output (op, _idx++);
			return (parameters, ms, mom, mg);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingMDLAdagradLightParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters:
		///   accumulators:
		///   weights:
		///   benefits:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output parameters, TF_Output accumulators, TF_Output weights, TF_Output benefits) RetrieveTPUEmbeddingMDLAdagradLightParameters (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingMDLAdagradLightParameters", MakeName ("RetrieveTPUEmbeddingMDLAdagradLightParameters", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var accumulators = new TF_Output (op, _idx++);
			var weights = new TF_Output (op, _idx++);
			var benefits = new TF_Output (op, _idx++);
			return (parameters, accumulators, weights, benefits);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingAdadeltaParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters:
		///   accumulators:
		///   updates:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output parameters, TF_Output accumulators, TF_Output updates) RetrieveTPUEmbeddingAdadeltaParameters (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingAdadeltaParameters", MakeName ("RetrieveTPUEmbeddingAdadeltaParameters", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var accumulators = new TF_Output (op, _idx++);
			var updates = new TF_Output (op, _idx++);
			return (parameters, accumulators, updates);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingProximalAdagradParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters:
		///   accumulators:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output parameters, TF_Output accumulators) RetrieveTPUEmbeddingProximalAdagradParameters (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingProximalAdagradParameters", MakeName ("RetrieveTPUEmbeddingProximalAdagradParameters", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var accumulators = new TF_Output (op, _idx++);
			return (parameters, accumulators);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters:
		///   accumulators:
		///   gradient_accumulators:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output parameters, TF_Output accumulators, TF_Output gradient_accumulators) RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug", MakeName ("RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var accumulators = new TF_Output (op, _idx++);
			var gradient_accumulators = new TF_Output (op, _idx++);
			return (parameters, accumulators, gradient_accumulators);
		}

		/// <summary>
		/// </summary>
		/// <param name="embedding_variable">
		/// </param>
		/// <param name="sliced_activations">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TPUEmbeddingActivations'.
		/// </param>
		/// <param name="table_id">
		/// </param>
		/// <param name="lookup_id">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TPUEmbeddingActivations (TF_Output embedding_variable, TF_Output sliced_activations, long table_id, long lookup_id, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TPUEmbeddingActivations", MakeName ("TPUEmbeddingActivations", operName));
			c_api.TF_AddInput(desc, embedding_variable);
			c_api.TF_AddInput(desc, sliced_activations);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "table_id", table_id);
			c_api.TF_SetAttrInt (desc, "lookup_id", lookup_id);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="learning_rates">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SendTPUEmbeddingGradients'.
		/// </param>
		/// <param name="config">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation SendTPUEmbeddingGradients (TF_Output[] inputs, TF_Output[] learning_rates, string config, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SendTPUEmbeddingGradients", MakeName ("SendTPUEmbeddingGradients", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			c_api.TF_AddInputList(desc, learning_rates[0], learning_rates.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "config", config);
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="batch">
		/// </param>
		/// <param name="mode_override">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EnqueueTPUEmbeddingIntegerBatch'.
		/// </param>
		/// <param name="device_ordinal">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation EnqueueTPUEmbeddingIntegerBatch (TF_Output[] batch, TF_Output mode_override, long? device_ordinal = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EnqueueTPUEmbeddingIntegerBatch", MakeName ("EnqueueTPUEmbeddingIntegerBatch", operName));
			c_api.TF_AddInputList(desc, batch[0], batch.Length);
			c_api.TF_AddInput(desc, mode_override);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (device_ordinal.HasValue)
				c_api.TF_SetAttrInt (desc, "device_ordinal", device_ordinal.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="sample_indices">
		/// </param>
		/// <param name="embedding_indices">
		/// </param>
		/// <param name="aggregation_weights">
		/// </param>
		/// <param name="mode_override">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EnqueueTPUEmbeddingSparseBatch'.
		/// </param>
		/// <param name="device_ordinal">
		///   Optional argument
		/// </param>
		/// <param name="combiners">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation EnqueueTPUEmbeddingSparseBatch (TF_Output[] sample_indices, TF_Output[] embedding_indices, TF_Output[] aggregation_weights, TF_Output mode_override, long? device_ordinal = null, string[] combiners = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EnqueueTPUEmbeddingSparseBatch", MakeName ("EnqueueTPUEmbeddingSparseBatch", operName));
			c_api.TF_AddInputList(desc, sample_indices[0], sample_indices.Length);
			c_api.TF_AddInputList(desc, embedding_indices[0], embedding_indices.Length);
			c_api.TF_AddInputList(desc, aggregation_weights[0], aggregation_weights.Length);
			c_api.TF_AddInput(desc, mode_override);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (device_ordinal.HasValue)
				c_api.TF_SetAttrInt (desc, "device_ordinal", device_ordinal.Value);
			
			if (combiners != null)
				c_api.TF_SetAttrStringList (desc, "combiners", combiners);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InfeedDequeue'.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output InfeedDequeue (TF_DataType dtype, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InfeedDequeue", MakeName ("InfeedDequeue", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InfeedEnqueueTuple'.
		/// </param>
		/// <param name="layouts">
		///   Optional argument
		/// </param>
		/// <param name="device_ordinal">
		///   Optional argument
		/// </param>
		/// <param name="shapes">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation InfeedEnqueueTuple (TF_Output[] inputs, long[][] shapes, long[] layouts = null, long? device_ordinal = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InfeedEnqueueTuple", MakeName ("InfeedEnqueueTuple", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			if (layouts != null)
				c_api.TF_SetAttrIntList (desc, "layouts", ref layouts[0], layouts.Length);
			
			if (device_ordinal.HasValue)
				c_api.TF_SetAttrInt (desc, "device_ordinal", device_ordinal.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Prelinearize'.
		/// </param>
		/// <param name="shape">
		///   Optional argument
		/// </param>
		/// <param name="layout">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Prelinearize (TF_Output input, long[] shape = null, long[] layout = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Prelinearize", MakeName ("Prelinearize", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (shape != null)
				c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			
			if (layout != null)
				c_api.TF_SetAttrIntList (desc, "layout", ref layout[0], layout.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OutfeedDequeue'.
		/// </param>
		/// <param name="device_ordinal">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output OutfeedDequeue (TF_DataType dtype, long[] shape, long? device_ordinal = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OutfeedDequeue", MakeName ("OutfeedDequeue", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			if (device_ordinal.HasValue)
				c_api.TF_SetAttrInt (desc, "device_ordinal", device_ordinal.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TPUReplicatedInput'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TPUReplicatedInput (TF_Output[] inputs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TPUReplicatedInput", MakeName ("TPUReplicatedInput", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TPUCompilationResult'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TPUCompilationResult (string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TPUCompilationResult", MakeName ("TPUCompilationResult", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="alpha">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyProximalGradientDescent'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseApplyProximalGradientDescent (TF_Output var, TF_Output alpha, TF_Output l1, TF_Output l2, TF_Output grad, TF_Output indices, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyProximalGradientDescent", MakeName ("SparseApplyProximalGradientDescent", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, alpha);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="alpha">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyProximalGradientDescent'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceSparseApplyProximalGradientDescent (TF_Output var, TF_Output alpha, TF_Output l1, TF_Output l2, TF_Output grad, TF_Output indices, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyProximalGradientDescent", MakeName ("ResourceSparseApplyProximalGradientDescent", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, alpha);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="accum_update">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="rho">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdadelta'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ApplyAdadelta (TF_Output var, TF_Output accum, TF_Output accum_update, TF_Output lr, TF_Output rho, TF_Output epsilon, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyAdadelta", MakeName ("ApplyAdadelta", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, accum_update);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="accum_update">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="rho">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyAdadelta'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceSparseApplyAdadelta (TF_Output var, TF_Output accum, TF_Output accum_update, TF_Output lr, TF_Output rho, TF_Output epsilon, TF_Output grad, TF_Output indices, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyAdadelta", MakeName ("ResourceSparseApplyAdadelta", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, accum_update);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdagrad'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <param name="update_slots">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ApplyAdagrad (TF_Output var, TF_Output accum, TF_Output lr, TF_Output grad, bool? use_locking = null, bool? update_slots = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyAdagrad", MakeName ("ApplyAdagrad", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (update_slots.HasValue)
				c_api.TF_SetAttrBool (desc, "update_slots", Convert.ToByte(update_slots.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdagrad'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <param name="update_slots">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceApplyAdagrad (TF_Output var, TF_Output accum, TF_Output lr, TF_Output grad, bool? use_locking = null, bool? update_slots = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyAdagrad", MakeName ("ResourceApplyAdagrad", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (update_slots.HasValue)
				c_api.TF_SetAttrBool (desc, "update_slots", Convert.ToByte(update_slots.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyProximalAdagrad'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceApplyProximalAdagrad (TF_Output var, TF_Output accum, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyProximalAdagrad", MakeName ("ResourceApplyProximalAdagrad", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyAdagradV2'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <param name="update_slots">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceSparseApplyAdagradV2 (TF_Output var, TF_Output accum, TF_Output lr, TF_Output epsilon, TF_Output grad, TF_Output indices, bool? use_locking = null, bool? update_slots = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyAdagradV2", MakeName ("ResourceSparseApplyAdagradV2", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (update_slots.HasValue)
				c_api.TF_SetAttrBool (desc, "update_slots", Convert.ToByte(update_slots.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="gradient_accumulator">
		/// </param>
		/// <param name="gradient_squared_accumulator">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="global_step">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdagradDA'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ApplyAdagradDA (TF_Output var, TF_Output gradient_accumulator, TF_Output gradient_squared_accumulator, TF_Output grad, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output global_step, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyAdagradDA", MakeName ("ApplyAdagradDA", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, gradient_accumulator);
			c_api.TF_AddInput(desc, gradient_squared_accumulator);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, global_step);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="mg">
		/// </param>
		/// <param name="ms">
		/// </param>
		/// <param name="mom">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="rho">
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyCenteredRMSProp'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseApplyCenteredRMSProp (TF_Output var, TF_Output mg, TF_Output ms, TF_Output mom, TF_Output lr, TF_Output rho, TF_Output momentum, TF_Output epsilon, TF_Output grad, TF_Output indices, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyCenteredRMSProp", MakeName ("SparseApplyCenteredRMSProp", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, mg);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, momentum);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="gradient_accumulator">
		/// </param>
		/// <param name="gradient_squared_accumulator">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="global_step">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyAdagradDA'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseApplyAdagradDA (TF_Output var, TF_Output gradient_accumulator, TF_Output gradient_squared_accumulator, TF_Output grad, TF_Output indices, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output global_step, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyAdagradDA", MakeName ("SparseApplyAdagradDA", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, gradient_accumulator);
			c_api.TF_AddInput(desc, gradient_squared_accumulator);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, global_step);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyProximalAdagrad'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceSparseApplyProximalAdagrad (TF_Output var, TF_Output accum, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output grad, TF_Output indices, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyProximalAdagrad", MakeName ("ResourceSparseApplyProximalAdagrad", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="linear">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="lr_power">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyFtrl'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseApplyFtrl (TF_Output var, TF_Output accum, TF_Output linear, TF_Output grad, TF_Output indices, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output lr_power, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyFtrl", MakeName ("SparseApplyFtrl", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, linear);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, lr_power);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="linear">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="lr_power">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyFtrl'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceApplyFtrl (TF_Output var, TF_Output accum, TF_Output linear, TF_Output grad, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output lr_power, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyFtrl", MakeName ("ResourceApplyFtrl", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, linear);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, lr_power);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="linear">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="lr_power">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyFtrl'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceSparseApplyFtrl (TF_Output var, TF_Output accum, TF_Output linear, TF_Output grad, TF_Output indices, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output lr_power, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyFtrl", MakeName ("ResourceSparseApplyFtrl", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, linear);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, lr_power);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="linear">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="l1">
		/// </param>
		/// <param name="l2">
		/// </param>
		/// <param name="l2_shrinkage">
		/// </param>
		/// <param name="lr_power">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyFtrlV2'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceApplyFtrlV2 (TF_Output var, TF_Output accum, TF_Output linear, TF_Output grad, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output l2_shrinkage, TF_Output lr_power, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyFtrlV2", MakeName ("ResourceApplyFtrlV2", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, linear);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, l2_shrinkage);
			c_api.TF_AddInput(desc, lr_power);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyMomentum'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <param name="use_nesterov">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseApplyMomentum (TF_Output var, TF_Output accum, TF_Output lr, TF_Output grad, TF_Output indices, TF_Output momentum, bool? use_locking = null, bool? use_nesterov = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyMomentum", MakeName ("SparseApplyMomentum", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, momentum);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (use_nesterov.HasValue)
				c_api.TF_SetAttrBool (desc, "use_nesterov", Convert.ToByte(use_nesterov.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyMomentum'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <param name="use_nesterov">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceApplyMomentum (TF_Output var, TF_Output accum, TF_Output lr, TF_Output grad, TF_Output momentum, bool? use_locking = null, bool? use_nesterov = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyMomentum", MakeName ("ResourceApplyMomentum", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, momentum);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (use_nesterov.HasValue)
				c_api.TF_SetAttrBool (desc, "use_nesterov", Convert.ToByte(use_nesterov.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyMomentum'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <param name="use_nesterov">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceSparseApplyMomentum (TF_Output var, TF_Output accum, TF_Output lr, TF_Output grad, TF_Output indices, TF_Output momentum, bool? use_locking = null, bool? use_nesterov = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyMomentum", MakeName ("ResourceSparseApplyMomentum", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, momentum);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (use_nesterov.HasValue)
				c_api.TF_SetAttrBool (desc, "use_nesterov", Convert.ToByte(use_nesterov.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyKerasMomentum'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <param name="use_nesterov">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceApplyKerasMomentum (TF_Output var, TF_Output accum, TF_Output lr, TF_Output grad, TF_Output momentum, bool? use_locking = null, bool? use_nesterov = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyKerasMomentum", MakeName ("ResourceApplyKerasMomentum", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, momentum);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (use_nesterov.HasValue)
				c_api.TF_SetAttrBool (desc, "use_nesterov", Convert.ToByte(use_nesterov.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="ms">
		/// </param>
		/// <param name="mom">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="rho">
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyRMSProp'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ApplyRMSProp (TF_Output var, TF_Output ms, TF_Output mom, TF_Output lr, TF_Output rho, TF_Output momentum, TF_Output epsilon, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyRMSProp", MakeName ("ApplyRMSProp", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, momentum);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="mg">
		/// </param>
		/// <param name="ms">
		/// </param>
		/// <param name="mom">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="rho">
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyCenteredRMSProp'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceApplyCenteredRMSProp (TF_Output var, TF_Output mg, TF_Output ms, TF_Output mom, TF_Output lr, TF_Output rho, TF_Output momentum, TF_Output epsilon, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyCenteredRMSProp", MakeName ("ResourceApplyCenteredRMSProp", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, mg);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, momentum);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="mg">
		/// </param>
		/// <param name="ms">
		/// </param>
		/// <param name="mom">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="rho">
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="epsilon">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyCenteredRMSProp'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceSparseApplyCenteredRMSProp (TF_Output var, TF_Output mg, TF_Output ms, TF_Output mom, TF_Output lr, TF_Output rho, TF_Output momentum, TF_Output epsilon, TF_Output grad, TF_Output indices, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyCenteredRMSProp", MakeName ("ResourceSparseApplyCenteredRMSProp", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, mg);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, momentum);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="m">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="alpha">
		/// </param>
		/// <param name="sign_decay">
		/// </param>
		/// <param name="beta">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAddSign'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceApplyAddSign (TF_Output var, TF_Output m, TF_Output lr, TF_Output alpha, TF_Output sign_decay, TF_Output beta, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyAddSign", MakeName ("ResourceApplyAddSign", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, alpha);
			c_api.TF_AddInput(desc, sign_decay);
			c_api.TF_AddInput(desc, beta);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="m">
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="logbase">
		/// </param>
		/// <param name="sign_decay">
		/// </param>
		/// <param name="beta">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyPowerSign'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceApplyPowerSign (TF_Output var, TF_Output m, TF_Output lr, TF_Output logbase, TF_Output sign_decay, TF_Output beta, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyPowerSign", MakeName ("ResourceApplyPowerSign", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, logbase);
			c_api.TF_AddInput(desc, sign_decay);
			c_api.TF_AddInput(desc, beta);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Fact'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Fact (string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Fact", MakeName ("Fact", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var fact = new TF_Output (op, _idx++);
			return fact;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Skipgram'.
		/// </param>
		/// <param name="window_size">
		///   Optional argument
		/// </param>
		/// <param name="min_count">
		///   Optional argument
		/// </param>
		/// <param name="subsample">
		///   Optional argument
		/// </param>
		/// <param name="filename">
		/// </param>
		/// <param name="batch_size">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   vocab_word:
		///   vocab_freq:
		///   words_per_epoch:
		///   current_epoch:
		///   total_words_processed:
		///   examples:
		///   labels:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output vocab_word, TF_Output vocab_freq, TF_Output words_per_epoch, TF_Output current_epoch, TF_Output total_words_processed, TF_Output examples, TF_Output labels) Skipgram (string filename, long batch_size, long? window_size = null, long? min_count = null, float? subsample = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Skipgram", MakeName ("Skipgram", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "filename", filename);
			c_api.TF_SetAttrInt (desc, "batch_size", batch_size);
			if (window_size.HasValue)
				c_api.TF_SetAttrInt (desc, "window_size", window_size.Value);
			
			if (min_count.HasValue)
				c_api.TF_SetAttrInt (desc, "min_count", min_count.Value);
			
			if (subsample.HasValue)
				c_api.TF_SetAttrFloat (desc, "subsample", subsample.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var vocab_word = new TF_Output (op, _idx++);
			var vocab_freq = new TF_Output (op, _idx++);
			var words_per_epoch = new TF_Output (op, _idx++);
			var current_epoch = new TF_Output (op, _idx++);
			var total_words_processed = new TF_Output (op, _idx++);
			var examples = new TF_Output (op, _idx++);
			var labels = new TF_Output (op, _idx++);
			return (vocab_word, vocab_freq, words_per_epoch, current_epoch, total_words_processed, examples, labels);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeParam'.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FakeParam (TF_DataType dtype, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FakeParam", MakeName ("FakeParam", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

	}
}
