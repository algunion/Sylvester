using System;

namespace TensorFlow {
	public partial class TF_Graph {
		/// <summary>
		///   Raise a exception to abort the process when called.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Abort'.
		/// </param>
		/// <param name="error_msg">
		///   Optional argument
		///   A string which is the message associated with the exception.
		/// </param>
		/// <param name="exit_without_error">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   If exit_without_error is true, the process will exit normally,
		///   otherwise it will exit with a SIGABORT signal.
		///   
		///   Returns nothing but an exception.
		/// </remarks>
		public TF_Operation Abort (string error_msg = null, bool? exit_without_error = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Abort", MakeName ("Abort", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (error_msg != null)
				c_api.TF_SetAttrString (desc, "error_msg", error_msg);
			
			if (exit_without_error.HasValue)
				c_api.TF_SetAttrBool (desc, "exit_without_error", Convert.ToByte(exit_without_error.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Computes the absolute value of a tensor.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Abs'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given a tensor <c>x</c>, this operation returns a tensor containing the absolute
		///   value of each element in <c>x</c>. For example, if x is an input element and y is
		///   an output element, this operation computes \\(y = |x|\\).
		/// </remarks>
		public TF_Output Abs (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Abs", MakeName ("Abs", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Returns the element-wise sum of a list of tensors.
		/// </summary>
		/// <param name="inputs">
		///   A list of <c>Tensor</c> objects, each with same shape and type.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AccumulateNV2'.
		/// </param>
		/// <param name="shape">
		///   Shape of elements of <c>inputs</c>.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   <c>tf.accumulate_n_v2</c> performs the same operation as <c>tf.add_n</c>, but does not
		///   wait for all of its inputs to be ready before beginning to sum. This can
		///   save memory if inputs are ready at different times, since minimum temporary
		///   storage is proportional to the output size rather than the inputs size.
		///   
		///   Unlike the original <c>accumulate_n</c>, <c>accumulate_n_v2</c> is differentiable.
		///   
		///   Returns a <c>Tensor</c> of same shape and type as the elements of <c>inputs</c>.
		/// </remarks>
		public TF_Output AccumulateNV2 (TF_Output[] inputs, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AccumulateNV2", MakeName ("AccumulateNV2", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var sum = new TF_Output (op, _idx++);
			return sum;
		}

		/// <summary>
		///   Applies a gradient to a given accumulator.
		/// </summary>
		/// <param name="handle">
		///   The handle to a accumulator.
		/// </param>
		/// <param name="local_step">
		///   The local_step value at which the gradient was computed.
		/// </param>
		/// <param name="gradient">
		///   A tensor of the gradient to be accumulated.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AccumulatorApplyGradient'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   Does not add if local_step is lesser than the accumulator's global_step.
		/// </remarks>
		public TF_Operation AccumulatorApplyGradient (TF_Output handle, TF_Output local_step, TF_Output gradient, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AccumulatorApplyGradient", MakeName ("AccumulatorApplyGradient", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, local_step);
			c_api.TF_AddInput(desc, gradient);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Returns the number of gradients aggregated in the given accumulators.
		/// </summary>
		/// <param name="handle">
		///   The handle to an accumulator.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AccumulatorNumAccumulated'.
		/// </param>
		/// <returns>
		///   The number of gradients aggregated in the given accumulator.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AccumulatorNumAccumulated (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AccumulatorNumAccumulated", MakeName ("AccumulatorNumAccumulated", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var num_accumulated = new TF_Output (op, _idx++);
			return num_accumulated;
		}

		/// <summary>
		///   Updates the accumulator with a new value for global_step.
		/// </summary>
		/// <param name="handle">
		///   The handle to an accumulator.
		/// </param>
		/// <param name="new_global_step">
		///   The new global_step value to set.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AccumulatorSetGlobalStep'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   Logs warning if the accumulator's value is already higher than
		///   new_global_step.
		/// </remarks>
		public TF_Operation AccumulatorSetGlobalStep (TF_Output handle, TF_Output new_global_step, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AccumulatorSetGlobalStep", MakeName ("AccumulatorSetGlobalStep", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, new_global_step);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Extracts the average gradient in the given ConditionalAccumulator.
		/// </summary>
		/// <param name="handle">
		///   The handle to an accumulator.
		/// </param>
		/// <param name="num_required">
		///   Number of gradients required before we return an aggregate.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AccumulatorTakeGradient'.
		/// </param>
		/// <param name="dtype">
		///   The data type of accumulated gradients. Needs to correspond to the type
		///   of the accumulator.
		/// </param>
		/// <returns>
		///   The average of the accumulated gradients.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The op blocks until sufficient (i.e., more than num_required)
		///   gradients have been accumulated.  If the accumulator has already
		///   aggregated more than num_required gradients, it returns the average of
		///   the accumulated gradients.  Also automatically increments the recorded
		///   global_step in the accumulator by 1, and resets the aggregate to 0.
		/// </remarks>
		public TF_Output AccumulatorTakeGradient (TF_Output handle, TF_Output num_required, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AccumulatorTakeGradient", MakeName ("AccumulatorTakeGradient", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, num_required);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var average = new TF_Output (op, _idx++);
			return average;
		}

		/// <summary>
		///   Computes acos of x element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Acos'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Acos (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Acos", MakeName ("Acos", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes inverse hyperbolic cosine of x element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Acosh'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given an input tensor, the function computes inverse hyperbolic cosine of every element.
		///   Input range is <c>[1, inf]</c>. It returns <c>nan</c> if the input lies outside the range.
		///   
		///    <code>
		///   x = tf.constant([-2, -0.5, 1, 1.2, 200, 10000, float("inf")])
		///   tf.math.acosh(x) ==&amp;gt; [nan nan 0. 0.62236255 5.9914584 9.903487 inf]
		///    </code>
		/// </remarks>
		public TF_Output Acosh (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Acosh", MakeName ("Acosh", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Returns x + y element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Add'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   *NOTE*: <c>Add</c> supports broadcasting. <c>AddN</c> does not. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output Add (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Add", MakeName ("Add", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Add an <c>N</c>-minibatch <c>SparseTensor</c> to a <c>SparseTensorsMap</c>, return <c>N</c> handles.
		/// </summary>
		/// <param name="sparse_indices">
		///   2-D.  The <c>indices</c> of the minibatch <c>SparseTensor</c>.
		///   <c>sparse_indices[:, 0]</c> must be ordered values in <c>[0, N)</c>.
		/// </param>
		/// <param name="sparse_values">
		///   1-D.  The <c>values</c> of the minibatch <c>SparseTensor</c>.
		/// </param>
		/// <param name="sparse_shape">
		///   1-D.  The <c>shape</c> of the minibatch <c>SparseTensor</c>.
		///   The minibatch size <c>N == sparse_shape[0]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AddManySparseToTensorsMap'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   The container name for the <c>SparseTensorsMap</c> created by this op.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   The shared name for the <c>SparseTensorsMap</c> created by this op.
		///   If blank, the new Operation's unique name is used.
		/// </param>
		/// <returns>
		///   1-D.  The handles of the <c>SparseTensor</c> now stored in the
		///   <c>SparseTensorsMap</c>.  Shape: <c>[N]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   A <c>SparseTensor</c> of rank <c>R</c> is represented by three tensors: <c>sparse_indices</c>,
		///   <c>sparse_values</c>, and <c>sparse_shape</c>, where
		///   
		///    <code>
		///    sparse_indices.shape[1] == sparse_shape.shape[0] == R
		///    </code>
		///   
		///   An <c>N</c>-minibatch of <c>SparseTensor</c> objects is represented as a <c>SparseTensor</c>
		///   having a first <c>sparse_indices</c> column taking values between <c>[0, N)</c>, where
		///   the minibatch size <c>N == sparse_shape[0]</c>.
		///   
		///   The input <c>SparseTensor</c> must have rank <c>R</c> greater than 1, and the first
		///   dimension is treated as the minibatch dimension.  Elements of the <c>SparseTensor</c>
		///   must be sorted in increasing order of this first dimension.  The stored
		///   <c>SparseTensor</c> objects pointed to by each row of the output <c>sparse_handles</c>
		///   will have rank <c>R-1</c>.
		///   
		///   The <c>SparseTensor</c> values can then be read out as part of a minibatch by passing
		///   the given keys as vector elements to <c>TakeManySparseFromTensorsMap</c>.  To ensure
		///   the correct <c>SparseTensorsMap</c> is accessed, ensure that the same
		///   <c>container</c> and <c>shared_name</c> are passed to that Op.  If no <c>shared_name</c>
		///   is provided here, instead use the *name* of the Operation created by calling
		///   <c>AddManySparseToTensorsMap</c> as the <c>shared_name</c> passed to
		///   <c>TakeManySparseFromTensorsMap</c>.  Ensure the Operations are colocated.
		/// </remarks>
		public TF_Output AddManySparseToTensorsMap (TF_Output sparse_indices, TF_Output sparse_values, TF_Output sparse_shape, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AddManySparseToTensorsMap", MakeName ("AddManySparseToTensorsMap", operName));
			c_api.TF_AddInput(desc, sparse_indices);
			c_api.TF_AddInput(desc, sparse_values);
			c_api.TF_AddInput(desc, sparse_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var sparse_handles = new TF_Output (op, _idx++);
			return sparse_handles;
		}

		/// <summary>
		///   Add all input tensors element wise.
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AddN'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Inputs must be of same size and shape.
		///   
		///    <code>
		///   x = [9, 7, 10]
		///   tf.math.add_n(x) ==&amp;gt; 26
		///    </code>
		/// </remarks>
		public TF_Output AddN (TF_Output[] inputs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AddN", MakeName ("AddN", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var sum = new TF_Output (op, _idx++);
			return sum;
		}

		/// <summary>
		///   Add a <c>SparseTensor</c> to a <c>SparseTensorsMap</c> return its handle.
		/// </summary>
		/// <param name="sparse_indices">
		///   2-D.  The <c>indices</c> of the <c>SparseTensor</c>.
		/// </param>
		/// <param name="sparse_values">
		///   1-D.  The <c>values</c> of the <c>SparseTensor</c>.
		/// </param>
		/// <param name="sparse_shape">
		///   1-D.  The <c>shape</c> of the <c>SparseTensor</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AddSparseToTensorsMap'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   The container name for the <c>SparseTensorsMap</c> created by this op.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   The shared name for the <c>SparseTensorsMap</c> created by this op.
		///   If blank, the new Operation's unique name is used.
		/// </param>
		/// <returns>
		///   0-D.  The handle of the <c>SparseTensor</c> now stored in the
		///   <c>SparseTensorsMap</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   A <c>SparseTensor</c> is represented by three tensors: <c>sparse_indices</c>,
		///   <c>sparse_values</c>, and <c>sparse_shape</c>.
		///   
		///   This operator takes the given <c>SparseTensor</c> and adds it to a container
		///   object (a <c>SparseTensorsMap</c>).  A unique key within this container is generated
		///   in the form of an <c>int64</c>, and this is the value that is returned.
		///   
		///   The <c>SparseTensor</c> can then be read out as part of a minibatch by passing
		///   the key as a vector element to <c>TakeManySparseFromTensorsMap</c>.  To ensure
		///   the correct <c>SparseTensorsMap</c> is accessed, ensure that the same
		///   <c>container</c> and <c>shared_name</c> are passed to that Op.  If no <c>shared_name</c>
		///   is provided here, instead use the *name* of the Operation created by calling
		///   <c>AddSparseToTensorsMap</c> as the <c>shared_name</c> passed to
		///   <c>TakeManySparseFromTensorsMap</c>.  Ensure the Operations are colocated.
		/// </remarks>
		public TF_Output AddSparseToTensorsMap (TF_Output sparse_indices, TF_Output sparse_values, TF_Output sparse_shape, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AddSparseToTensorsMap", MakeName ("AddSparseToTensorsMap", operName));
			c_api.TF_AddInput(desc, sparse_indices);
			c_api.TF_AddInput(desc, sparse_values);
			c_api.TF_AddInput(desc, sparse_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var sparse_handle = new TF_Output (op, _idx++);
			return sparse_handle;
		}

		/// <summary>
		///   Returns x + y element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AddV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   *NOTE*: <c>Add</c> supports broadcasting. <c>AddN</c> does not. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output AddV2 (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AddV2", MakeName ("AddV2", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Deprecated. Disallowed in GraphDef version &amp;gt;= 2.
		/// </summary>
		/// <param name="images">
		/// </param>
		/// <param name="contrast_factor">
		/// </param>
		/// <param name="min_value">
		/// </param>
		/// <param name="max_value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AdjustContrast'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AdjustContrast (TF_Output images, TF_Output contrast_factor, TF_Output min_value, TF_Output max_value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AdjustContrast", MakeName ("AdjustContrast", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, contrast_factor);
			c_api.TF_AddInput(desc, min_value);
			c_api.TF_AddInput(desc, max_value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Adjust the contrast of one or more images.
		/// </summary>
		/// <param name="images">
		///   Images to adjust.  At least 3-D.
		/// </param>
		/// <param name="contrast_factor">
		///   A float multiplier for adjusting contrast.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AdjustContrastv2'.
		/// </param>
		/// <returns>
		///   The contrast-adjusted image or images.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   <c>images</c> is a tensor of at least 3 dimensions.  The last 3 dimensions are
		///   interpreted as <c>[height, width, channels]</c>.  The other dimensions only
		///   represent a collection of images, such as <c>[batch, height, width, channels].</c>
		///   
		///   Contrast is adjusted independently for each channel of each image.
		///   
		///   For each channel, the Op first computes the mean of the image pixels in the
		///   channel and then adjusts each component of each pixel to
		///   <c>(x - mean) * contrast_factor + mean</c>.
		/// </remarks>
		public TF_Output AdjustContrastv2 (TF_Output images, TF_Output contrast_factor, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AdjustContrastv2", MakeName ("AdjustContrastv2", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, contrast_factor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Adjust the hue of one or more images.
		/// </summary>
		/// <param name="images">
		///   Images to adjust.  At least 3-D.
		/// </param>
		/// <param name="delta">
		///   A float delta to add to the hue.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AdjustHue'.
		/// </param>
		/// <returns>
		///   The hue-adjusted image or images.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   <c>images</c> is a tensor of at least 3 dimensions.  The last dimension is
		///   interpretted as channels, and must be three.
		///   
		///   The input image is considered in the RGB colorspace. Conceptually, the RGB
		///   colors are first mapped into HSV. A delta is then applied all the hue values,
		///   and then remapped back to RGB colorspace.
		/// </remarks>
		public TF_Output AdjustHue (TF_Output images, TF_Output delta, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AdjustHue", MakeName ("AdjustHue", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, delta);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Adjust the saturation of one or more images.
		/// </summary>
		/// <param name="images">
		///   Images to adjust.  At least 3-D.
		/// </param>
		/// <param name="scale">
		///   A float scale to add to the saturation.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AdjustSaturation'.
		/// </param>
		/// <returns>
		///   The hue-adjusted image or images.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   <c>images</c> is a tensor of at least 3 dimensions.  The last dimension is
		///   interpretted as channels, and must be three.
		///   
		///   The input image is considered in the RGB colorspace. Conceptually, the RGB
		///   colors are first mapped into HSV. A scale is then applied all the saturation
		///   values, and then remapped back to RGB colorspace.
		/// </remarks>
		public TF_Output AdjustSaturation (TF_Output images, TF_Output scale, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AdjustSaturation", MakeName ("AdjustSaturation", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, scale);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the "logical and" of elements across dimensions of a tensor.
		/// </summary>
		/// <param name="input">
		///   The tensor to reduce.
		/// </param>
		/// <param name="reduction_indices">
		///   The dimensions to reduce. Must be in the range
		///   <c>[-rank(input), rank(input))</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'All'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		///   If true, retain reduced dimensions with length 1.
		/// </param>
		/// <returns>
		///   The reduced tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Reduces <c>input</c> along the dimensions given in <c>axis</c>. Unless
		///   <c>keep_dims</c> is true, the rank of the tensor is reduced by 1 for each entry in
		///   <c>axis</c>. If <c>keep_dims</c> is true, the reduced dimensions are
		///   retained with length 1.
		/// </remarks>
		public TF_Output All (TF_Output input, TF_Output reduction_indices, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "All", MakeName ("All", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, reduction_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Generates labels for candidate sampling with a learned unigram distribution.
		/// </summary>
		/// <param name="true_classes">
		///   A batch_size * num_true matrix, in which each row contains the
		///   IDs of the num_true target_classes in the corresponding original label.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AllCandidateSampler'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either seed or seed2 are set to be non-zero, the random number
		///   generator is seeded by the given seed.  Otherwise, it is seeded by a
		///   random seed.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   An second seed to avoid seed collision.
		/// </param>
		/// <param name="num_true">
		///   Number of true labels per context.
		/// </param>
		/// <param name="num_sampled">
		///   Number of candidates to produce.
		/// </param>
		/// <param name="unique">
		///   If unique is true, we sample with rejection, so that all sampled
		///   candidates in a batch are unique. This requires some approximation to
		///   estimate the post-rejection sampling probabilities.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sampled_candidates: A vector of length num_sampled, in which each element is
		///   the ID of a sampled candidate.
		///   true_expected_count: A batch_size * num_true matrix, representing
		///   the number of times each candidate is expected to occur in a batch
		///   of sampled candidates. If unique=true, then this is a probability.
		///   sampled_expected_count: A vector of length num_sampled, for each sampled
		///   candidate representing the number of times the candidate is expected
		///   to occur in a batch of sampled candidates.  If unique=true, then this is a
		///   probability.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   See explanations of candidate sampling and the data formats at
		///   go/candidate-sampling.
		///   
		///   For each batch, this op picks a single set of sampled candidate labels.
		///   
		///   The advantages of sampling candidates per-batch are simplicity and the
		///   possibility of efficient dense matrix multiplication. The disadvantage is that
		///   the sampled candidates must be chosen independently of the context and of the
		///   true labels.
		/// </remarks>
		public (TF_Output sampled_candidates, TF_Output true_expected_count, TF_Output sampled_expected_count) AllCandidateSampler (TF_Output true_classes, long num_true, long num_sampled, bool unique, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AllCandidateSampler", MakeName ("AllCandidateSampler", operName));
			c_api.TF_AddInput(desc, true_classes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_true", num_true);
			c_api.TF_SetAttrInt (desc, "num_sampled", num_sampled);
			c_api.TF_SetAttrBool (desc, "unique", Convert.ToByte(unique));
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var sampled_candidates = new TF_Output (op, _idx++);
			var true_expected_count = new TF_Output (op, _idx++);
			var sampled_expected_count = new TF_Output (op, _idx++);
			return (sampled_candidates, true_expected_count, sampled_expected_count);
		}

		/// <summary>
		///   An Op to exchange data across TPU replicas.
		/// </summary>
		/// <param name="input">
		///   The local input to the sum.
		/// </param>
		/// <param name="group_assignment">
		///   An int32 tensor with shape
		///   [num_groups, num_replicas_per_group]. <c>group_assignment[i]</c> represents the
		///   replica ids in the ith subgroup.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AllToAll'.
		/// </param>
		/// <param name="concat_dimension">
		///   The dimension number to concatenate.
		/// </param>
		/// <param name="split_dimension">
		///   The dimension number to split.
		/// </param>
		/// <param name="split_count">
		///   The number of splits, this number must equal to the sub-group
		///   size(group_assignment.get_shape()[1])
		/// </param>
		/// <returns>
		///   The exchanged result.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   On each replica, the input is split into <c>split_count</c> blocks along
		///   <c>split_dimension</c> and send to the other replicas given group_assignment. After
		///   receiving <c>split_count</c> - 1 blocks from other replicas, we concatenate the
		///   blocks along <c>concat_dimension</c> as the output.
		///   
		///   For example, suppose there are 2 TPU replicas:
		///   replica 0 receives input: <c>[[A, B]]</c>
		///   replica 1 receives input: <c>[[C, D]]</c>
		///   
		///   group_assignment=<c>[[0, 1]]</c>
		///   concat_dimension=0
		///   split_dimension=1
		///   split_count=2
		///   
		///   replica 0's output: <c>[[A], [C]]</c>
		///   replica 1's output: <c>[[B], [D]]</c>
		/// </remarks>
		public TF_Output AllToAll (TF_Output input, TF_Output group_assignment, long concat_dimension, long split_dimension, long split_count, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AllToAll", MakeName ("AllToAll", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, group_assignment);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "concat_dimension", concat_dimension);
			c_api.TF_SetAttrInt (desc, "split_dimension", split_dimension);
			c_api.TF_SetAttrInt (desc, "split_count", split_count);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns the argument of a complex number.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Angle'.
		/// </param>
		/// <param name="Tout">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given a tensor <c>input</c> of complex numbers, this operation returns a tensor of
		///   type <c>float</c> that is the argument of each element in <c>input</c>. All elements in
		///   <c>input</c> must be complex numbers of the form \\(a + bj\\), where *a*
		///   is the real part and *b* is the imaginary part.
		///   
		///   The argument returned by this operation is of the form \\(atan2(b, a)\\).
		///   
		///   For example:
		///   
		///    <code>
		///   # tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]
		///   tf.angle(input) ==&amp;gt; [2.0132, 1.056]
		///    </code>
		///   
		///   @compatibility(numpy)
		///   Equivalent to np.angle.
		///   @end_compatibility
		/// </remarks>
		public TF_Output Angle (TF_Output input, TF_DataType? Tout = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Angle", MakeName ("Angle", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Tout.HasValue)
				c_api.TF_SetAttrType (desc, "Tout", Tout.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   A container for an iterator resource.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AnonymousIterator'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   A handle to the iterator that can be passed to a "MakeIterator" or
		///   "IteratorGetNext" op. In contrast to Iterator, AnonymousIterator prevents
		///   resource sharing by name, and does not keep a reference to the resource
		///   container.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AnonymousIterator (TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AnonymousIterator", MakeName ("AnonymousIterator", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   A container for an iterator resource.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AnonymousIteratorV2'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   handle: A handle to the iterator that can be passed to a "MakeIterator" or
		///   "IteratorGetNext" op. In contrast to Iterator, AnonymousIterator prevents
		///   resource sharing by name, and does not keep a reference to the resource
		///   container.
		///   deleter: A variant deleter that should be passed into the op that deletes the iterator.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output handle, TF_Output deleter) AnonymousIteratorV2 (TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AnonymousIteratorV2", MakeName ("AnonymousIteratorV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			var deleter = new TF_Output (op, _idx++);
			return (handle, deleter);
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AnonymousMemoryCache'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   handle:
		///   deleter:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output handle, TF_Output deleter) AnonymousMemoryCache (string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AnonymousMemoryCache", MakeName ("AnonymousMemoryCache", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			var deleter = new TF_Output (op, _idx++);
			return (handle, deleter);
		}

		/// <summary>
		///   A container for a multi device iterator resource.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AnonymousMultiDeviceIterator'.
		/// </param>
		/// <param name="devices">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   handle: A handle to a multi device iterator that can be passed to a
		///   "MultiDeviceIteratorGetNextFromShard" op. In contrast to MultiDeviceIterator,
		///   AnonymousIterator prevents resource sharing by name, and does not keep a
		///   reference to the resource container.
		///   deleter: A variant deleter that should be passed into the op that deletes the iterator.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output handle, TF_Output deleter) AnonymousMultiDeviceIterator (string[] devices, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AnonymousMultiDeviceIterator", MakeName ("AnonymousMultiDeviceIterator", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrStringList (desc, "devices", devices);
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			var deleter = new TF_Output (op, _idx++);
			return (handle, deleter);
		}

		/// <summary>
		/// </summary>
		/// <param name="seed">
		/// </param>
		/// <param name="seed2">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AnonymousRandomSeedGenerator'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   handle:
		///   deleter:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output handle, TF_Output deleter) AnonymousRandomSeedGenerator (TF_Output seed, TF_Output seed2, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AnonymousRandomSeedGenerator", MakeName ("AnonymousRandomSeedGenerator", operName));
			c_api.TF_AddInput(desc, seed);
			c_api.TF_AddInput(desc, seed2);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			var deleter = new TF_Output (op, _idx++);
			return (handle, deleter);
		}

		/// <summary>
		///   Computes the "logical or" of elements across dimensions of a tensor.
		/// </summary>
		/// <param name="input">
		///   The tensor to reduce.
		/// </param>
		/// <param name="reduction_indices">
		///   The dimensions to reduce. Must be in the range
		///   <c>[-rank(input), rank(input))</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Any'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		///   If true, retain reduced dimensions with length 1.
		/// </param>
		/// <returns>
		///   The reduced tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Reduces <c>input</c> along the dimensions given in <c>axis</c>. Unless
		///   <c>keep_dims</c> is true, the rank of the tensor is reduced by 1 for each entry in
		///   <c>axis</c>. If <c>keep_dims</c> is true, the reduced dimensions are
		///   retained with length 1.
		/// </remarks>
		public TF_Output Any (TF_Output input, TF_Output reduction_indices, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Any", MakeName ("Any", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, reduction_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update '*var' according to the adadelta scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum_update">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="rho">
		///   Decay factor. Must be a scalar.
		/// </param>
		/// <param name="epsilon">
		///   Constant factor. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdadelta'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, updating of the var, accum and update_accum tensors will be protected by
		///   a lock; otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   accum = rho() * accum + (1 - rho()) * grad.square();
		///   update = (update_accum + epsilon).sqrt() * (accum + epsilon()).rsqrt() * grad;
		///   update_accum = rho() * update_accum + (1 - rho()) * update.square();
		///   var -= update;
		/// </remarks>
		public TF_Output ApplyAdadelta (TF_Output var, TF_Output accum, TF_Output accum_update, TF_Output lr, TF_Output rho, TF_Output epsilon, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyAdadelta", MakeName ("ApplyAdadelta", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, accum_update);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update '*var' according to the adagrad scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdagrad'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <param name="update_slots">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   accum += grad * grad
		///   var -= lr * grad * (1 / sqrt(accum))
		/// </remarks>
		public TF_Output ApplyAdagrad (TF_Output var, TF_Output accum, TF_Output lr, TF_Output grad, bool? use_locking = null, bool? update_slots = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyAdagrad", MakeName ("ApplyAdagrad", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (update_slots.HasValue)
				c_api.TF_SetAttrBool (desc, "update_slots", Convert.ToByte(update_slots.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update '*var' according to the proximal adagrad scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="gradient_accumulator">
		///   Should be from a Variable().
		/// </param>
		/// <param name="gradient_squared_accumulator">
		///   Should be from a Variable().
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="l1">
		///   L1 regularization. Must be a scalar.
		/// </param>
		/// <param name="l2">
		///   L2 regularization. Must be a scalar.
		/// </param>
		/// <param name="global_step">
		///   Training step number. Must be a scalar.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdagradDA'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, updating of the var and accum tensors will be protected by
		///   a lock; otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ApplyAdagradDA (TF_Output var, TF_Output gradient_accumulator, TF_Output gradient_squared_accumulator, TF_Output grad, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output global_step, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyAdagradDA", MakeName ("ApplyAdagradDA", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, gradient_accumulator);
			c_api.TF_AddInput(desc, gradient_squared_accumulator);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, global_step);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update '*var' according to the adagrad scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="epsilon">
		///   Constant factor. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdagradV2'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <param name="update_slots">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   accum += grad * grad
		///   var -= lr * grad * (1 / sqrt(accum))
		/// </remarks>
		public TF_Output ApplyAdagradV2 (TF_Output var, TF_Output accum, TF_Output lr, TF_Output epsilon, TF_Output grad, bool? use_locking = null, bool? update_slots = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyAdagradV2", MakeName ("ApplyAdagradV2", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (update_slots.HasValue)
				c_api.TF_SetAttrBool (desc, "update_slots", Convert.ToByte(update_slots.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update '*var' according to the Adam algorithm.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="m">
		///   Should be from a Variable().
		/// </param>
		/// <param name="v">
		///   Should be from a Variable().
		/// </param>
		/// <param name="beta1_power">
		///   Must be a scalar.
		/// </param>
		/// <param name="beta2_power">
		///   Must be a scalar.
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="beta1">
		///   Momentum factor. Must be a scalar.
		/// </param>
		/// <param name="beta2">
		///   Momentum factor. Must be a scalar.
		/// </param>
		/// <param name="epsilon">
		///   Ridge term. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdam'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var, m, and v tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <param name="use_nesterov">
		///   Optional argument
		///   If <c>True</c>, uses the nesterov update.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   $$lr_t := \text{learning\_rate} * \sqrt{1 - beta_2^t} / (1 - beta_1^t)$$
		///   $$m_t := beta_1 * m_{t-1} + (1 - beta_1) * g$$
		///   $$v_t := beta_2 * v_{t-1} + (1 - beta_2) * g * g$$
		///   $$variable := variable - lr_t * m_t / (\sqrt{v_t} + \epsilon)$$
		/// </remarks>
		public TF_Output ApplyAdam (TF_Output var, TF_Output m, TF_Output v, TF_Output beta1_power, TF_Output beta2_power, TF_Output lr, TF_Output beta1, TF_Output beta2, TF_Output epsilon, TF_Output grad, bool? use_locking = null, bool? use_nesterov = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyAdam", MakeName ("ApplyAdam", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, v);
			c_api.TF_AddInput(desc, beta1_power);
			c_api.TF_AddInput(desc, beta2_power);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, beta1);
			c_api.TF_AddInput(desc, beta2);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (use_nesterov.HasValue)
				c_api.TF_SetAttrBool (desc, "use_nesterov", Convert.ToByte(use_nesterov.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update '*var' according to the AdaMax algorithm.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="m">
		///   Should be from a Variable().
		/// </param>
		/// <param name="v">
		///   Should be from a Variable().
		/// </param>
		/// <param name="beta1_power">
		///   Must be a scalar.
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="beta1">
		///   Momentum factor. Must be a scalar.
		/// </param>
		/// <param name="beta2">
		///   Momentum factor. Must be a scalar.
		/// </param>
		/// <param name="epsilon">
		///   Ridge term. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdaMax'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var, m, and v tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   m_t &amp;lt;- beta1 * m_{t-1} + (1 - beta1) * g
		///   v_t &amp;lt;- max(beta2 * v_{t-1}, abs(g))
		///   variable &amp;lt;- variable - learning_rate / (1 - beta1^t) * m_t / (v_t + epsilon)
		/// </remarks>
		public TF_Output ApplyAdaMax (TF_Output var, TF_Output m, TF_Output v, TF_Output beta1_power, TF_Output lr, TF_Output beta1, TF_Output beta2, TF_Output epsilon, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyAdaMax", MakeName ("ApplyAdaMax", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, v);
			c_api.TF_AddInput(desc, beta1_power);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, beta1);
			c_api.TF_AddInput(desc, beta2);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update '*var' according to the AddSign update.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="m">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="alpha">
		///   Must be a scalar.
		/// </param>
		/// <param name="sign_decay">
		///   Must be a scalar.
		/// </param>
		/// <param name="beta">
		///   Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAddSign'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and m tensors is
		///   protected by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   m_t &amp;lt;- beta1 * m_{t-1} + (1 - beta1) * g
		///   update &amp;lt;- (alpha + sign_decay * sign(g) *sign(m)) * g
		///   variable &amp;lt;- variable - lr_t * update
		/// </remarks>
		public TF_Output ApplyAddSign (TF_Output var, TF_Output m, TF_Output lr, TF_Output alpha, TF_Output sign_decay, TF_Output beta, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyAddSign", MakeName ("ApplyAddSign", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, alpha);
			c_api.TF_AddInput(desc, sign_decay);
			c_api.TF_AddInput(desc, beta);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update '*var' according to the centered RMSProp algorithm.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="mg">
		///   Should be from a Variable().
		/// </param>
		/// <param name="ms">
		///   Should be from a Variable().
		/// </param>
		/// <param name="mom">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="rho">
		///   Decay rate. Must be a scalar.
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="epsilon">
		///   Ridge term. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyCenteredRMSProp'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var, mg, ms, and mom tensors is
		///   protected by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The centered RMSProp algorithm uses an estimate of the centered second moment
		///   (i.e., the variance) for normalization, as opposed to regular RMSProp, which
		///   uses the (uncentered) second moment. This often helps with training, but is
		///   slightly more expensive in terms of computation and memory.
		///   
		///   Note that in dense implementation of this algorithm, mg, ms, and mom will
		///   update even if the grad is zero, but in this sparse implementation, mg, ms,
		///   and mom will not update in iterations during which the grad is zero.
		///   
		///   mean_square = decay * mean_square + (1-decay) * gradient ** 2
		///   mean_grad = decay * mean_grad + (1-decay) * gradient
		///   
		///   Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)
		///   
		///   mg &amp;lt;- rho * mg_{t-1} + (1-rho) * grad
		///   ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad
		///   mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms - mg * mg + epsilon)
		///   var &amp;lt;- var - mom
		/// </remarks>
		public TF_Output ApplyCenteredRMSProp (TF_Output var, TF_Output mg, TF_Output ms, TF_Output mom, TF_Output lr, TF_Output rho, TF_Output momentum, TF_Output epsilon, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyCenteredRMSProp", MakeName ("ApplyCenteredRMSProp", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, mg);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, momentum);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update '*var' according to the Ftrl-proximal scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="linear">
		///   Should be from a Variable().
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="l1">
		///   L1 regulariation. Must be a scalar.
		/// </param>
		/// <param name="l2">
		///   L2 regulariation. Must be a scalar.
		/// </param>
		/// <param name="lr_power">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyFtrl'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   accum_new = accum + grad * grad
		///   linear += grad + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
		///   quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
		///   var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0
		///   accum = accum_new
		/// </remarks>
		public TF_Output ApplyFtrl (TF_Output var, TF_Output accum, TF_Output linear, TF_Output grad, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output lr_power, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyFtrl", MakeName ("ApplyFtrl", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, linear);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, lr_power);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update '*var' according to the Ftrl-proximal scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="linear">
		///   Should be from a Variable().
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="l1">
		///   L1 regulariation. Must be a scalar.
		/// </param>
		/// <param name="l2">
		///   L2 shrinkage regulariation. Must be a scalar.
		/// </param>
		/// <param name="l2_shrinkage">
		/// </param>
		/// <param name="lr_power">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyFtrlV2'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   grad_with_shrinkage = grad + 2 * l2_shrinkage * var
		///   accum_new = accum + grad_with_shrinkage * grad_with_shrinkage
		///   linear += grad_with_shrinkage +
		///   (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
		///   quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
		///   var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0
		///   accum = accum_new
		/// </remarks>
		public TF_Output ApplyFtrlV2 (TF_Output var, TF_Output accum, TF_Output linear, TF_Output grad, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output l2_shrinkage, TF_Output lr_power, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyFtrlV2", MakeName ("ApplyFtrlV2", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, linear);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, l2_shrinkage);
			c_api.TF_AddInput(desc, lr_power);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update '*var' by subtracting 'alpha' * 'delta' from it.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="alpha">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="delta">
		///   The change.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyGradientDescent'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, the subtraction will be protected by a lock;
		///   otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ApplyGradientDescent (TF_Output var, TF_Output alpha, TF_Output delta, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyGradientDescent", MakeName ("ApplyGradientDescent", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, alpha);
			c_api.TF_AddInput(desc, delta);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update '*var' according to the momentum scheme. Set use_nesterov = True if you
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="momentum">
		///   Momentum. Must be a scalar.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyMomentum'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <param name="use_nesterov">
		///   Optional argument
		///   If <c>True</c>, the tensor passed to compute grad will be
		///   var - lr * momentum * accum, so in the end, the var you get is actually
		///   var - lr * momentum * accum.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   want to use Nesterov momentum.
		///   
		///   accum = accum * momentum + grad
		///   var -= lr * accum
		/// </remarks>
		public TF_Output ApplyMomentum (TF_Output var, TF_Output accum, TF_Output lr, TF_Output grad, TF_Output momentum, bool? use_locking = null, bool? use_nesterov = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyMomentum", MakeName ("ApplyMomentum", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, momentum);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (use_nesterov.HasValue)
				c_api.TF_SetAttrBool (desc, "use_nesterov", Convert.ToByte(use_nesterov.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update '*var' according to the AddSign update.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="m">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="logbase">
		///   Must be a scalar.
		/// </param>
		/// <param name="sign_decay">
		///   Must be a scalar.
		/// </param>
		/// <param name="beta">
		///   Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyPowerSign'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and m tensors is
		///   protected by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   m_t &amp;lt;- beta1 * m_{t-1} + (1 - beta1) * g
		///   update &amp;lt;- exp(logbase * sign_decay * sign(g) * sign(m_t)) * g
		///   variable &amp;lt;- variable - lr_t * update
		/// </remarks>
		public TF_Output ApplyPowerSign (TF_Output var, TF_Output m, TF_Output lr, TF_Output logbase, TF_Output sign_decay, TF_Output beta, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyPowerSign", MakeName ("ApplyPowerSign", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, logbase);
			c_api.TF_AddInput(desc, sign_decay);
			c_api.TF_AddInput(desc, beta);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update '*var' and '*accum' according to FOBOS with Adagrad learning rate.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="l1">
		///   L1 regularization. Must be a scalar.
		/// </param>
		/// <param name="l2">
		///   L2 regularization. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyProximalAdagrad'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, updating of the var and accum tensors will be protected by
		///   a lock; otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   accum += grad * grad
		///   prox_v = var - lr * grad * (1 / sqrt(accum))
		///   var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}
		/// </remarks>
		public TF_Output ApplyProximalAdagrad (TF_Output var, TF_Output accum, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyProximalAdagrad", MakeName ("ApplyProximalAdagrad", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update '*var' as FOBOS algorithm with fixed learning rate.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="alpha">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="l1">
		///   L1 regularization. Must be a scalar.
		/// </param>
		/// <param name="l2">
		///   L2 regularization. Must be a scalar.
		/// </param>
		/// <param name="delta">
		///   The change.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyProximalGradientDescent'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, the subtraction will be protected by a lock;
		///   otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   prox_v = var - alpha * delta
		///   var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}
		/// </remarks>
		public TF_Output ApplyProximalGradientDescent (TF_Output var, TF_Output alpha, TF_Output l1, TF_Output l2, TF_Output delta, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyProximalGradientDescent", MakeName ("ApplyProximalGradientDescent", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, alpha);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, delta);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update '*var' according to the RMSProp algorithm.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="ms">
		///   Should be from a Variable().
		/// </param>
		/// <param name="mom">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="rho">
		///   Decay rate. Must be a scalar.
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="epsilon">
		///   Ridge term. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyRMSProp'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var, ms, and mom tensors is protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Note that in dense implementation of this algorithm, ms and mom will
		///   update even if the grad is zero, but in this sparse implementation, ms
		///   and mom will not update in iterations during which the grad is zero.
		///   
		///   mean_square = decay * mean_square + (1-decay) * gradient ** 2
		///   Delta = learning_rate * gradient / sqrt(mean_square + epsilon)
		///   
		///   ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad
		///   mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
		///   var &amp;lt;- var - mom
		/// </remarks>
		public TF_Output ApplyRMSProp (TF_Output var, TF_Output ms, TF_Output mom, TF_Output lr, TF_Output rho, TF_Output momentum, TF_Output epsilon, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApplyRMSProp", MakeName ("ApplyRMSProp", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, momentum);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns the truth value of abs(x-y) &amp;lt; tolerance element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ApproximateEqual'.
		/// </param>
		/// <param name="tolerance">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ApproximateEqual (TF_Output x, TF_Output y, float? tolerance = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ApproximateEqual", MakeName ("ApproximateEqual", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (tolerance.HasValue)
				c_api.TF_SetAttrFloat (desc, "tolerance", tolerance.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Returns the index with the largest value across dimensions of a tensor.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="dimension">
		///   int32 or int64, must be in the range <c>[-rank(input), rank(input))</c>.
		///   Describes which dimension of the input Tensor to reduce across. For vectors,
		///   use dimension = 0.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ArgMax'.
		/// </param>
		/// <param name="output_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Note that in case of ties the identity of the return value is not guaranteed.
		///   
		///   Usage:
		///    <code>
		///   import tensorflow as tf
		///   a = [1, 10, 26.9, 2.8, 166.32, 62.3]
		///   b = tf.math.argmax(input = a)
		///   c = tf.keras.backend.eval(b)
		///   # c = 4
		///   # here a[4] = 166.32 which is the largest element of a across axis 0
		///    </code>
		/// </remarks>
		public TF_Output ArgMax (TF_Output input, TF_Output dimension, TF_DataType? output_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ArgMax", MakeName ("ArgMax", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, dimension);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (output_type.HasValue)
				c_api.TF_SetAttrType (desc, "output_type", output_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns the index with the smallest value across dimensions of a tensor.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="dimension">
		///   int32 or int64, must be in the range <c>[-rank(input), rank(input))</c>.
		///   Describes which dimension of the input Tensor to reduce across. For vectors,
		///   use dimension = 0.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ArgMin'.
		/// </param>
		/// <param name="output_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Note that in case of ties the identity of the return value is not guaranteed.
		///   
		///   Usage:
		///    <code>
		///   import tensorflow as tf
		///   a = [1, 10, 26.9, 2.8, 166.32, 62.3]
		///   b = tf.math.argmin(input = a)
		///   c = tf.keras.backend.eval(b)
		///   # c = 0
		///   # here a[0] = 1 which is the smallest element of a across axis 0
		///    </code>
		/// </remarks>
		public TF_Output ArgMin (TF_Output input, TF_Output dimension, TF_DataType? output_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ArgMin", MakeName ("ArgMin", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, dimension);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (output_type.HasValue)
				c_api.TF_SetAttrType (desc, "output_type", output_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the trignometric inverse sine of x element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Asin'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The <c>tf.math.asin</c> operation returns the inverse of <c>tf.math.sin</c>, such that
		///   if <c>y = tf.math.sin(x)</c> then, <c>x = tf.math.asin(y)</c>.
		///   
		///   **Note**: The output of <c>tf.math.asin</c> will lie within the invertible range
		///   of sine, i.e [-pi/2, pi/2].
		///   
		///   For example:
		///   
		///    <code>
		///   # Note: [1.047, 0.785] ~= [(pi/3), (pi/4)]
		///   x = tf.constant([1.047, 0.785])
		///   y = tf.math.sin(x) # [0.8659266, 0.7068252]
		///   
		///   tf.math.asin(y) # [1.047, 0.785] = x
		///    </code>
		///   
		/// </remarks>
		public TF_Output Asin (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Asin", MakeName ("Asin", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes inverse hyperbolic sine of x element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Asinh'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given an input tensor, this function computes inverse hyperbolic sine
		///   for every element in the tensor. Both input and output has a range of
		///   <c>[-inf, inf]</c>.
		///   
		///    <code>
		///   x = tf.constant([-float("inf"), -2, -0.5, 1, 1.2, 200, 10000, float("inf")])
		///   tf.math.asinh(x) ==&amp;gt; [-inf -1.4436355 -0.4812118 0.8813736 1.0159732 5.991471 9.903487 inf]
		///    </code>
		/// </remarks>
		public TF_Output Asinh (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Asinh", MakeName ("Asinh", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Asserts that the given condition is true.
		/// </summary>
		/// <param name="condition">
		///   The condition to evaluate.
		/// </param>
		/// <param name="data">
		///   The tensors to print out when condition is false.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Assert'.
		/// </param>
		/// <param name="summarize">
		///   Optional argument
		///   Print this many entries of each tensor.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   If <c>condition</c> evaluates to false, print the list of tensors in <c>data</c>.
		///   <c>summarize</c> determines how many entries of the tensors to print.
		/// </remarks>
		public TF_Operation Assert (TF_Output condition, TF_Output[] data, long? summarize = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Assert", MakeName ("Assert", operName));
			c_api.TF_AddInput(desc, condition);
			c_api.TF_AddInputList(desc, data[0], data.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (summarize.HasValue)
				c_api.TF_SetAttrInt (desc, "summarize", summarize.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="transformations">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AssertNextDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AssertNextDataset (TF_Output input_dataset, TF_Output transformations, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AssertNextDataset", MakeName ("AssertNextDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, transformations);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Update 'ref' by assigning 'value' to it.
		/// </summary>
		/// <param name="reference">
		///   Should be from a <c>Variable</c> node. May be uninitialized.
		/// </param>
		/// <param name="value">
		///   The value to be assigned to the variable.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Assign'.
		/// </param>
		/// <param name="validate_shape">
		///   Optional argument
		///   If true, the operation will validate that the shape
		///   of 'value' matches the shape of the Tensor being assigned to.  If false,
		///   'ref' will take on the shape of 'value'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, the assignment will be protected by a lock;
		///   otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   = Same as "ref".  Returned as a convenience for operations that want
		///   to use the new value after the variable has been reset.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation outputs "ref" after the assignment is done.
		///   This makes it easier to chain operations that need to use the reset value.
		/// </remarks>
		public TF_Output Assign (TF_Output reference, TF_Output value, bool? validate_shape = null, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Assign", MakeName ("Assign", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (validate_shape.HasValue)
				c_api.TF_SetAttrBool (desc, "validate_shape", Convert.ToByte(validate_shape.Value));
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		///   Update 'ref' by adding 'value' to it.
		/// </summary>
		/// <param name="reference">
		///   Should be from a <c>Variable</c> node.
		/// </param>
		/// <param name="value">
		///   The value to be added to the variable.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AssignAdd'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, the addition will be protected by a lock;
		///   otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   = Same as "ref".  Returned as a convenience for operations that want
		///   to use the new value after the variable has been updated.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation outputs "ref" after the update is done.
		///   This makes it easier to chain operations that need to use the reset value.
		/// </remarks>
		public TF_Output AssignAdd (TF_Output reference, TF_Output value, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AssignAdd", MakeName ("AssignAdd", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		///   Adds a value to the current value of a variable.
		/// </summary>
		/// <param name="resource">
		///   handle to the resource in which to store the variable.
		/// </param>
		/// <param name="value">
		///   the value by which the variable will be incremented.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AssignAddVariableOp'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   Any ReadVariableOp with a control dependency on this op is guaranteed to
		///   see the incremented value or a subsequent newer one.
		/// </remarks>
		public TF_Operation AssignAddVariableOp (TF_Output resource, TF_Output value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AssignAddVariableOp", MakeName ("AssignAddVariableOp", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update 'ref' by subtracting 'value' from it.
		/// </summary>
		/// <param name="reference">
		///   Should be from a <c>Variable</c> node.
		/// </param>
		/// <param name="value">
		///   The value to be subtracted to the variable.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AssignSub'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, the subtraction will be protected by a lock;
		///   otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   = Same as "ref".  Returned as a convenience for operations that want
		///   to use the new value after the variable has been updated.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation outputs "ref" after the update is done.
		///   This makes it easier to chain operations that need to use the reset value.
		/// </remarks>
		public TF_Output AssignSub (TF_Output reference, TF_Output value, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AssignSub", MakeName ("AssignSub", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		///   Subtracts a value from the current value of a variable.
		/// </summary>
		/// <param name="resource">
		///   handle to the resource in which to store the variable.
		/// </param>
		/// <param name="value">
		///   the value by which the variable will be incremented.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AssignSubVariableOp'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   Any ReadVariableOp with a control dependency on this op is guaranteed to
		///   see the decremented value or a subsequent newer one.
		/// </remarks>
		public TF_Operation AssignSubVariableOp (TF_Output resource, TF_Output value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AssignSubVariableOp", MakeName ("AssignSubVariableOp", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Assigns a new value to a variable.
		/// </summary>
		/// <param name="resource">
		///   handle to the resource in which to store the variable.
		/// </param>
		/// <param name="value">
		///   the value to set the new tensor to use.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AssignVariableOp'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   Any ReadVariableOp with a control dependency on this op is guaranteed to return
		///   this value or a subsequent newer value of the variable.
		/// </remarks>
		public TF_Operation AssignVariableOp (TF_Output resource, TF_Output value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AssignVariableOp", MakeName ("AssignVariableOp", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Converts each entry in the given tensor to strings.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AsString'.
		/// </param>
		/// <param name="precision">
		///   Optional argument
		///   The post-decimal precision to use for floating point numbers.
		///   Only used if precision &amp;gt; -1.
		/// </param>
		/// <param name="scientific">
		///   Optional argument
		///   Use scientific notation for floating point numbers.
		/// </param>
		/// <param name="shortest">
		///   Optional argument
		///   Use shortest representation (either scientific or standard) for
		///   floating point numbers.
		/// </param>
		/// <param name="width">
		///   Optional argument
		///   Pad pre-decimal numbers to this width.
		///   Applies to both floating point and integer numbers.
		///   Only used if width &amp;gt; -1.
		/// </param>
		/// <param name="fill">
		///   Optional argument
		///   The value to pad if width &amp;gt; -1.  If empty, pads with spaces.
		///   Another typical value is '0'.  String cannot be longer than 1 character.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Supports many numeric types and boolean.
		///   
		///   For Unicode, see the
		///   [https://www.tensorflow.org/tutorials/representation/unicode](Working with Unicode text)
		///   tutorial.
		/// </remarks>
		public TF_Output AsString (TF_Output input, long? precision = null, bool? scientific = null, bool? shortest = null, long? width = null, string fill = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AsString", MakeName ("AsString", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (precision.HasValue)
				c_api.TF_SetAttrInt (desc, "precision", precision.Value);
			
			if (scientific.HasValue)
				c_api.TF_SetAttrBool (desc, "scientific", Convert.ToByte(scientific.Value));
			
			if (shortest.HasValue)
				c_api.TF_SetAttrBool (desc, "shortest", Convert.ToByte(shortest.Value));
			
			if (width.HasValue)
				c_api.TF_SetAttrInt (desc, "width", width.Value);
			
			if (fill != null)
				c_api.TF_SetAttrString (desc, "fill", fill);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the trignometric inverse tangent of x element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Atan'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The <c>tf.math.atan</c> operation returns the inverse of <c>tf.math.tan</c>, such that
		///   if <c>y = tf.math.tan(x)</c> then, <c>x = tf.math.atan(y)</c>.
		///   
		///   **Note**: The output of <c>tf.math.atan</c> will lie within the invertible range
		///   of tan, i.e (-pi/2, pi/2).
		///   
		///   For example:
		///   
		///    <code>
		///   # Note: [1.047, 0.785] ~= [(pi/3), (pi/4)]
		///   x = tf.constant([1.047, 0.785])
		///   y = tf.math.tan(x) # [1.731261, 0.99920404]
		///   
		///   tf.math.atan(y) # [1.047, 0.785] = x
		///    </code>
		///   
		/// </remarks>
		public TF_Output Atan (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Atan", MakeName ("Atan", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes arctangent of <c>y/x</c> element-wise, respecting signs of the arguments.
		/// </summary>
		/// <param name="y">
		/// </param>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Atan2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This is the angle \( \theta \in [-\pi, \pi] \) such that
		///   \[ x = r \cos(\theta) \]
		///   and
		///   \[ y = r \sin(\theta) \]
		///   where \(r = \sqrt(x^2 + y^2) \).
		/// </remarks>
		public TF_Output Atan2 (TF_Output y, TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Atan2", MakeName ("Atan2", operName));
			c_api.TF_AddInput(desc, y);
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Computes inverse hyperbolic tangent of x element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Atanh'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given an input tensor, this function computes inverse hyperbolic tangent
		///   for every element in the tensor. Input range is <c>[-1,1]</c> and output range is
		///   <c>[-inf, inf]</c>. If input is <c>-1</c>, output will be <c>-inf</c> and if the
		///   input is <c>1</c>, output will be <c>inf</c>. Values outside the range will have
		///   <c>nan</c> as output.
		///   
		///    <code>
		///   x = tf.constant([-float("inf"), -1, -0.5, 1, 0, 0.5, 10, float("inf")])
		///   tf.math.atanh(x) ==&amp;gt; [nan -inf -0.54930615 inf  0. 0.54930615 nan nan]
		///    </code>
		/// </remarks>
		public TF_Output Atanh (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Atanh", MakeName ("Atanh", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Produces a visualization of audio data over time.
		/// </summary>
		/// <param name="input">
		///   Float representation of audio data.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AudioSpectrogram'.
		/// </param>
		/// <param name="magnitude_squared">
		///   Optional argument
		///   Whether to return the squared magnitude or just the
		///   magnitude. Using squared magnitude can avoid extra calculations.
		/// </param>
		/// <param name="window_size">
		///   How wide the input window is in samples. For the highest efficiency
		///   this should be a power of two, but other values are accepted.
		/// </param>
		/// <param name="stride">
		///   How widely apart the center of adjacent sample windows should be.
		/// </param>
		/// <returns>
		///   3D representation of the audio frequencies as an image.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Spectrograms are a standard way of representing audio information as a series of
		///   slices of frequency information, one slice for each window of time. By joining
		///   these together into a sequence, they form a distinctive fingerprint of the sound
		///   over time.
		///   
		///   This op expects to receive audio data as an input, stored as floats in the range
		///   -1 to 1, together with a window width in samples, and a stride specifying how
		///   far to move the window between slices. From this it generates a three
		///   dimensional output. The first dimension is for the channels in the input, so a
		///   stereo audio input would have two here for example. The second dimension is time,
		///   with successive frequency slices. The third dimension has an amplitude value for
		///   each frequency during that time slice.
		///   
		///   This means the layout when converted and saved as an image is rotated 90 degrees
		///   clockwise from a typical spectrogram. Time is descending down the Y axis, and
		///   the frequency decreases from left to right.
		///   
		///   Each value in the result represents the square root of the sum of the real and
		///   imaginary parts of an FFT on the current window of samples. In this way, the
		///   lowest dimension represents the power of each frequency in the current window,
		///   and adjacent windows are concatenated in the next dimension.
		///   
		///   To get a more intuitive and visual look at what this operation does, you can run
		///   tensorflow/examples/wav_to_spectrogram to read in an audio file and save out the
		///   resulting spectrogram as a PNG image.
		/// </remarks>
		public TF_Output AudioSpectrogram (TF_Output input, long window_size, long stride, bool? magnitude_squared = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AudioSpectrogram", MakeName ("AudioSpectrogram", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "window_size", window_size);
			c_api.TF_SetAttrInt (desc, "stride", stride);
			if (magnitude_squared.HasValue)
				c_api.TF_SetAttrBool (desc, "magnitude_squared", Convert.ToByte(magnitude_squared.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var spectrogram = new TF_Output (op, _idx++);
			return spectrogram;
		}

		/// <summary>
		///   Outputs a <c>Summary</c> protocol buffer with audio.
		/// </summary>
		/// <param name="tag">
		///   Scalar. Used to build the <c>tag</c> attribute of the summary values.
		/// </param>
		/// <param name="tensor">
		///   2-D of shape <c>[batch_size, frames]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AudioSummary'.
		/// </param>
		/// <param name="max_outputs">
		///   Optional argument
		///   Max number of batch elements to generate audio for.
		/// </param>
		/// <param name="sample_rate">
		///   The sample rate of the signal in hertz.
		/// </param>
		/// <returns>
		///   Scalar. Serialized <c>Summary</c> protocol buffer.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The summary has up to <c>max_outputs</c> summary values containing audio. The
		///   audio is built from <c>tensor</c> which must be 3-D with shape <c>[batch_size,
		///   frames, channels]</c> or 2-D with shape <c>[batch_size, frames]</c>. The values are
		///   assumed to be in the range of <c>[-1.0, 1.0]</c> with a sample rate of <c>sample_rate</c>.
		///   
		///   The <c>tag</c> argument is a scalar <c>Tensor</c> of type <c>string</c>.  It is used to
		///   build the <c>tag</c> of the summary values:
		///   
		///   *  If <c>max_outputs</c> is 1, the summary value tag is '*tag*/audio'.
		///   *  If <c>max_outputs</c> is greater than 1, the summary value tags are
		///   generated sequentially as '*tag*/audio/0', '*tag*/audio/1', etc.
		/// </remarks>
		public TF_Output AudioSummary (TF_Output tag, TF_Output tensor, float sample_rate, long? max_outputs = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AudioSummary", MakeName ("AudioSummary", operName));
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFloat (desc, "sample_rate", sample_rate);
			if (max_outputs.HasValue)
				c_api.TF_SetAttrInt (desc, "max_outputs", max_outputs.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var summary = new TF_Output (op, _idx++);
			return summary;
		}

		/// <summary>
		///   Outputs a <c>Summary</c> protocol buffer with audio.
		/// </summary>
		/// <param name="tag">
		///   Scalar. Used to build the <c>tag</c> attribute of the summary values.
		/// </param>
		/// <param name="tensor">
		///   2-D of shape <c>[batch_size, frames]</c>.
		/// </param>
		/// <param name="sample_rate">
		///   The sample rate of the signal in hertz.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AudioSummaryV2'.
		/// </param>
		/// <param name="max_outputs">
		///   Optional argument
		///   Max number of batch elements to generate audio for.
		/// </param>
		/// <returns>
		///   Scalar. Serialized <c>Summary</c> protocol buffer.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The summary has up to <c>max_outputs</c> summary values containing audio. The
		///   audio is built from <c>tensor</c> which must be 3-D with shape <c>[batch_size,
		///   frames, channels]</c> or 2-D with shape <c>[batch_size, frames]</c>. The values are
		///   assumed to be in the range of <c>[-1.0, 1.0]</c> with a sample rate of <c>sample_rate</c>.
		///   
		///   The <c>tag</c> argument is a scalar <c>Tensor</c> of type <c>string</c>.  It is used to
		///   build the <c>tag</c> of the summary values:
		///   
		///   *  If <c>max_outputs</c> is 1, the summary value tag is '*tag*/audio'.
		///   *  If <c>max_outputs</c> is greater than 1, the summary value tags are
		///   generated sequentially as '*tag*/audio/0', '*tag*/audio/1', etc.
		/// </remarks>
		public TF_Output AudioSummaryV2 (TF_Output tag, TF_Output tensor, TF_Output sample_rate, long? max_outputs = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AudioSummaryV2", MakeName ("AudioSummaryV2", operName));
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, sample_rate);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (max_outputs.HasValue)
				c_api.TF_SetAttrInt (desc, "max_outputs", max_outputs.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var summary = new TF_Output (op, _idx++);
			return summary;
		}

		/// <summary>
		///   Creates a dataset that shards the input dataset.
		/// </summary>
		/// <param name="input_dataset">
		///   A variant tensor representing the input dataset.
		/// </param>
		/// <param name="num_workers">
		///   A scalar representing the number of workers to distribute this dataset across.
		/// </param>
		/// <param name="index">
		///   A scalar representing the index of the current worker out of num_workers.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AutoShardDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Creates a dataset that shards the input dataset by num_workers, returning a
		///   sharded dataset for the index-th worker. This attempts to automatically shard
		///   a dataset by examining the Dataset graph and inserting a shard op before the
		///   inputs to a reader Dataset (e.g. CSVDataset, TFRecordDataset).
		///   
		///   This dataset will throw a NotFound error if we cannot shard the dataset
		///   automatically.
		/// </remarks>
		public TF_Output AutoShardDataset (TF_Output input_dataset, TF_Output num_workers, TF_Output index, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AutoShardDataset", MakeName ("AutoShardDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, num_workers);
			c_api.TF_AddInput(desc, index);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Performs average pooling on the input.
		/// </summary>
		/// <param name="value">
		///   4-D with shape <c>[batch, height, width, channels]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AvgPool'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   Specify the data format of the input and output data. With the
		///   default format "NHWC", the data is stored in the order of:
		///   [batch, in_height, in_width, in_channels].
		///   Alternatively, the format could be "NCHW", the data storage order of:
		///   [batch, in_channels, in_height, in_width].
		/// </param>
		/// <param name="ksize">
		///   The size of the sliding window for each dimension of <c>value</c>.
		/// </param>
		/// <param name="strides">
		///   The stride of the sliding window for each dimension of <c>value</c>.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   The average pooled output tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Each entry in <c>output</c> is the mean of the corresponding size <c>ksize</c>
		///   window in <c>value</c>.
		/// </remarks>
		public TF_Output AvgPool (TF_Output value, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AvgPool", MakeName ("AvgPool", operName));
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Performs 3D average pooling on the input.
		/// </summary>
		/// <param name="input">
		///   Shape <c>[batch, depth, rows, cols, channels]</c> tensor to pool over.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AvgPool3D'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   The data format of the input and output data. With the
		///   default format "NDHWC", the data is stored in the order of:
		///   [batch, in_depth, in_height, in_width, in_channels].
		///   Alternatively, the format could be "NCDHW", the data storage order is:
		///   [batch, in_channels, in_depth, in_height, in_width].
		/// </param>
		/// <param name="ksize">
		///   1-D tensor of length 5. The size of the window for each dimension of
		///   the input tensor. Must have <c>ksize[0] = ksize[4] = 1</c>.
		/// </param>
		/// <param name="strides">
		///   1-D tensor of length 5. The stride of the sliding window for each
		///   dimension of <c>input</c>. Must have <c>strides[0] = strides[4] = 1</c>.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   The average pooled output tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AvgPool3D (TF_Output input, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AvgPool3D", MakeName ("AvgPool3D", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes gradients of average pooling function.
		/// </summary>
		/// <param name="orig_input_shape">
		///   The original input dimensions.
		/// </param>
		/// <param name="grad">
		///   Output backprop of shape <c>[batch, depth, rows, cols, channels]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AvgPool3DGrad'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   The data format of the input and output data. With the
		///   default format "NDHWC", the data is stored in the order of:
		///   [batch, in_depth, in_height, in_width, in_channels].
		///   Alternatively, the format could be "NCDHW", the data storage order is:
		///   [batch, in_channels, in_depth, in_height, in_width].
		/// </param>
		/// <param name="ksize">
		///   1-D tensor of length 5. The size of the window for each dimension of
		///   the input tensor. Must have <c>ksize[0] = ksize[4] = 1</c>.
		/// </param>
		/// <param name="strides">
		///   1-D tensor of length 5. The stride of the sliding window for each
		///   dimension of <c>input</c>. Must have <c>strides[0] = strides[4] = 1</c>.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   The backprop for input.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AvgPool3DGrad (TF_Output orig_input_shape, TF_Output grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AvgPool3DGrad", MakeName ("AvgPool3DGrad", operName));
			c_api.TF_AddInput(desc, orig_input_shape);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes gradients of the average pooling function.
		/// </summary>
		/// <param name="orig_input_shape">
		///   1-D.  Shape of the original input to <c>avg_pool</c>.
		/// </param>
		/// <param name="grad">
		///   4-D with shape <c>[batch, height, width, channels]</c>.  Gradients w.r.t.
		///   the output of <c>avg_pool</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'AvgPoolGrad'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   Specify the data format of the input and output data. With the
		///   default format "NHWC", the data is stored in the order of:
		///   [batch, in_height, in_width, in_channels].
		///   Alternatively, the format could be "NCHW", the data storage order of:
		///   [batch, in_channels, in_height, in_width].
		/// </param>
		/// <param name="ksize">
		///   The size of the sliding window for each dimension of the input.
		/// </param>
		/// <param name="strides">
		///   The stride of the sliding window for each dimension of the input.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   4-D.  Gradients w.r.t. the input of <c>avg_pool</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output AvgPoolGrad (TF_Output orig_input_shape, TF_Output grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "AvgPoolGrad", MakeName ("AvgPoolGrad", operName));
			c_api.TF_AddInput(desc, orig_input_shape);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Defines a barrier that persists across different graph executions.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Barrier'.
		/// </param>
		/// <param name="shapes">
		///   Optional argument
		///   The shape of each component in a value. Each shape must be 1 in the
		///   first dimension. The length of this attr must be the same as the length of
		///   component_types.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		///   The capacity of the barrier.  The default capacity is MAX_INT32,
		///   which is the largest capacity of the underlying queue.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this barrier is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this barrier will be shared under the given name
		///   across multiple sessions.
		/// </param>
		/// <param name="component_types">
		///   The type of each component in a value.
		/// </param>
		/// <returns>
		///   The handle to the barrier.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   A barrier represents a key-value map, where each key is a string, and
		///   each value is a tuple of tensors.
		///   
		///   At runtime, the barrier contains 'complete' and 'incomplete'
		///   elements. A complete element has defined tensors for all components of
		///   its value tuple, and may be accessed using BarrierTakeMany. An
		///   incomplete element has some undefined components in its value tuple,
		///   and may be updated using BarrierInsertMany.
		/// </remarks>
		public TF_Output Barrier (TF_DataType[] component_types, long[][] shapes = null, long? capacity = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Barrier", MakeName ("Barrier", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (shapes != null)
				c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Closes the given barrier.
		/// </summary>
		/// <param name="handle">
		///   The handle to a barrier.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BarrierClose'.
		/// </param>
		/// <param name="cancel_pending_enqueues">
		///   Optional argument
		///   If true, all pending enqueue requests that are
		///   blocked on the barrier's queue will be canceled. InsertMany will fail, even
		///   if no new key is introduced.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   This operation signals that no more new elements will be inserted in the
		///   given barrier. Subsequent InsertMany that try to introduce a new key will fail.
		///   Subsequent InsertMany operations that just add missing components to already
		///   existing elements will continue to succeed. Subsequent TakeMany operations will
		///   continue to succeed if sufficient completed elements remain in the barrier.
		///   Subsequent TakeMany operations that would block will fail immediately.
		/// </remarks>
		public TF_Operation BarrierClose (TF_Output handle, bool? cancel_pending_enqueues = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BarrierClose", MakeName ("BarrierClose", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (cancel_pending_enqueues.HasValue)
				c_api.TF_SetAttrBool (desc, "cancel_pending_enqueues", Convert.ToByte(cancel_pending_enqueues.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Computes the number of incomplete elements in the given barrier.
		/// </summary>
		/// <param name="handle">
		///   The handle to a barrier.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BarrierIncompleteSize'.
		/// </param>
		/// <returns>
		///   The number of incomplete elements (i.e. those with some of their value
		///   components not set) in the barrier.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BarrierIncompleteSize (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BarrierIncompleteSize", MakeName ("BarrierIncompleteSize", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		///   For each key, assigns the respective value to the specified component.
		/// </summary>
		/// <param name="handle">
		///   The handle to a barrier.
		/// </param>
		/// <param name="keys">
		///   A one-dimensional tensor of keys, with length n.
		/// </param>
		/// <param name="values">
		///   An any-dimensional tensor of values, which are associated with the
		///   respective keys. The 0th dimension must have length n.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BarrierInsertMany'.
		/// </param>
		/// <param name="component_index">
		///   The component of the barrier elements that is being assigned.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   If a key is not found in the barrier, this operation will create a new
		///   incomplete element. If a key is found in the barrier, and the element
		///   already has a value at component_index, this operation will fail with
		///   INVALID_ARGUMENT, and leave the barrier in an undefined state.
		/// </remarks>
		public TF_Operation BarrierInsertMany (TF_Output handle, TF_Output keys, TF_Output values, long component_index, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BarrierInsertMany", MakeName ("BarrierInsertMany", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, keys);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "component_index", component_index);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Computes the number of complete elements in the given barrier.
		/// </summary>
		/// <param name="handle">
		///   The handle to a barrier.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BarrierReadySize'.
		/// </param>
		/// <returns>
		///   The number of complete elements (i.e. those with all of their value
		///   components set) in the barrier.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BarrierReadySize (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BarrierReadySize", MakeName ("BarrierReadySize", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		///   Takes the given number of completed elements from a barrier.
		/// </summary>
		/// <param name="handle">
		///   The handle to a barrier.
		/// </param>
		/// <param name="num_elements">
		///   A single-element tensor containing the number of elements to
		///   take.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BarrierTakeMany'.
		/// </param>
		/// <param name="allow_small_batch">
		///   Optional argument
		///   Allow to return less than num_elements items if barrier is
		///   already closed.
		/// </param>
		/// <param name="wait_for_incomplete">
		///   Optional argument
		/// </param>
		/// <param name="timeout_ms">
		///   Optional argument
		///   If the queue is empty, this operation will block for up to
		///   timeout_ms milliseconds.
		///   Note: This option is not supported yet.
		/// </param>
		/// <param name="component_types">
		///   The type of each component in a value.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   indices: A one-dimensional tensor of indices, with length num_elems.
		///   These indices refer to the batch in which the values were placed into the
		///   barrier (starting with MIN_LONG and increasing with each BarrierInsertMany).
		///   keys: A one-dimensional tensor of keys, with length num_elements.
		///   values: One any-dimensional tensor per component in a barrier element. All
		///   values have length num_elements in the 0th dimension.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   This operation concatenates completed-element component tensors along
		///   the 0th dimension to make a single component tensor.
		///   
		///   Elements come out of the barrier when they are complete, and in the order
		///   in which they were placed into the barrier.  The indices output provides
		///   information about the batch in which each element was originally inserted
		///   into the barrier.
		/// </remarks>
		public (TF_Output indices, TF_Output keys, TF_Output[] values) BarrierTakeMany (TF_Output handle, TF_Output num_elements, TF_DataType[] component_types, bool? allow_small_batch = null, bool? wait_for_incomplete = null, long? timeout_ms = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BarrierTakeMany", MakeName ("BarrierTakeMany", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, num_elements);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (allow_small_batch.HasValue)
				c_api.TF_SetAttrBool (desc, "allow_small_batch", Convert.ToByte(allow_small_batch.Value));
			
			if (wait_for_incomplete.HasValue)
				c_api.TF_SetAttrBool (desc, "wait_for_incomplete", Convert.ToByte(wait_for_incomplete.Value));
			
			if (timeout_ms.HasValue)
				c_api.TF_SetAttrInt (desc, "timeout_ms", timeout_ms.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			var indices = new TF_Output (op, _idx++);
			var keys = new TF_Output (op, _idx++);
			_n = c_api.TF_OperationOutputListLength(op, "values", status);
			var values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				values [i] = new TF_Output (op, _idx++);
			
			return (indices, keys, values);
		}

		/// <summary>
		///   Batches all input tensors nondeterministically.
		/// </summary>
		/// <param name="in_tensors">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Batch'.
		/// </param>
		/// <param name="max_enqueued_batches">
		///   Optional argument
		/// </param>
		/// <param name="allowed_batch_sizes">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="batching_queue">
		///   Optional argument
		/// </param>
		/// <param name="num_batch_threads">
		/// </param>
		/// <param name="max_batch_size">
		/// </param>
		/// <param name="batch_timeout_micros">
		/// </param>
		/// <param name="grad_timeout_micros">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   batched_tensors:
		///   batch_index:
		///   id:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   When many instances of this Op are being run concurrently with the same
		///   container/shared_name in the same device, some will output zero-shaped Tensors
		///   and others will output Tensors of size up to max_batch_size.
		///   
		///   All Tensors in in_tensors are batched together (so, for example, labels and
		///   features should be batched with a single instance of this operation.
		///   
		///   Each invocation of batch emits an <c>id</c> scalar which will be used to identify
		///   this particular invocation when doing unbatch or its gradient.
		///   
		///   Each op which emits a non-empty batch will also emit a non-empty batch_index
		///   Tensor, which, is a [K, 3] matrix where each row contains the invocation's id,
		///   start, and length of elements of each set of Tensors present in batched_tensors.
		///   
		///   Batched tensors are concatenated along the first dimension, and all tensors in
		///   in_tensors must have the first dimension of the same size.
		///   
		///   in_tensors: The tensors to be batched.
		///   num_batch_threads: Number of scheduling threads for processing batches of work.
		///   Determines the number of batches processed in parallel.
		///   max_batch_size: Batch sizes will never be bigger than this.
		///   batch_timeout_micros: Maximum number of microseconds to wait before outputting
		///   an incomplete batch.
		///   allowed_batch_sizes: Optional list of allowed batch sizes. If left empty, does
		///   nothing. Otherwise, supplies a list of batch sizes, causing the op to pad
		///   batches up to one of those sizes. The entries must increase monotonically, and
		///   the final entry must equal max_batch_size.
		///   grad_timeout_micros: The timeout to use for the gradient. See Unbatch.
		///   batched_tensors: Either empty tensors or a batch of concatenated Tensors.
		///   batch_index: If out_tensors is non-empty, has information to invert it.
		///   container: Controls the scope of sharing of this batch.
		///   id: always contains a scalar with a unique ID for this invocation of Batch.
		///   shared_name: Concurrently running instances of batch in the same device with the
		///   same container and shared_name will batch their elements together. If left
		///   empty, the op name will be used as the shared name.
		///   T: the types of tensors to be batched.
		/// </remarks>
		public (TF_Output[] batched_tensors, TF_Output batch_index, TF_Output id) Batch (TF_Output[] in_tensors, long num_batch_threads, long max_batch_size, long batch_timeout_micros, long grad_timeout_micros, long? max_enqueued_batches = null, long[] allowed_batch_sizes = null, string container = null, string shared_name = null, string batching_queue = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Batch", MakeName ("Batch", operName));
			c_api.TF_AddInputList(desc, in_tensors[0], in_tensors.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_batch_threads", num_batch_threads);
			c_api.TF_SetAttrInt (desc, "max_batch_size", max_batch_size);
			c_api.TF_SetAttrInt (desc, "batch_timeout_micros", batch_timeout_micros);
			c_api.TF_SetAttrInt (desc, "grad_timeout_micros", grad_timeout_micros);
			if (max_enqueued_batches.HasValue)
				c_api.TF_SetAttrInt (desc, "max_enqueued_batches", max_enqueued_batches.Value);
			
			if (allowed_batch_sizes != null)
				c_api.TF_SetAttrIntList (desc, "allowed_batch_sizes", ref allowed_batch_sizes[0], allowed_batch_sizes.Length);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (batching_queue != null)
				c_api.TF_SetAttrString (desc, "batching_queue", batching_queue);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "batched_tensors", status);
			var batched_tensors = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				batched_tensors [i] = new TF_Output (op, _idx++);
			
			var batch_index = new TF_Output (op, _idx++);
			var id = new TF_Output (op, _idx++);
			return (batched_tensors, batch_index, id);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchCholesky'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchCholesky (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchCholesky", MakeName ("BatchCholesky", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="l">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchCholeskyGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchCholeskyGrad (TF_Output l, TF_Output grad, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchCholeskyGrad", MakeName ("BatchCholeskyGrad", operName));
			c_api.TF_AddInput(desc, l);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates a dataset that batches <c>batch_size</c> elements from <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="batch_size">
		///   A scalar representing the number of elements to accumulate in a
		///   batch.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchDataset (TF_Output input_dataset, TF_Output batch_size, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchDataset", MakeName ("BatchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, batch_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that batches <c>batch_size</c> elements from <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="batch_size">
		///   A scalar representing the number of elements to accumulate in a batch.
		/// </param>
		/// <param name="drop_remainder">
		///   A scalar representing whether the last batch should be dropped in case its size
		///   is smaller than desired.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchDatasetV2'.
		/// </param>
		/// <param name="parallel_copy">
		///   Optional argument
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchDatasetV2 (TF_Output input_dataset, TF_Output batch_size, TF_Output drop_remainder, TF_DataType[] output_types, long[][] output_shapes, bool? parallel_copy = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchDatasetV2", MakeName ("BatchDatasetV2", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, batch_size);
			c_api.TF_AddInput(desc, drop_remainder);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (parallel_copy.HasValue)
				c_api.TF_SetAttrBool (desc, "parallel_copy", Convert.ToByte(parallel_copy.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchFFT'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchFFT (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchFFT", MakeName ("BatchFFT", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchFFT2D'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchFFT2D (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchFFT2D", MakeName ("BatchFFT2D", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchFFT3D'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchFFT3D (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchFFT3D", MakeName ("BatchFFT3D", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Batches all the inputs tensors to the computation done by the function.
		/// </summary>
		/// <param name="in_tensors">
		///   The tensors to be batched.
		/// </param>
		/// <param name="captured_tensors">
		///   The tensors which are captured in the function, and don't need
		///   to be batched.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchFunction'.
		/// </param>
		/// <param name="max_enqueued_batches">
		///   Optional argument
		///   Maximum number of batches enqueued. Default: 10.
		/// </param>
		/// <param name="allowed_batch_sizes">
		///   Optional argument
		///   Optional list of allowed batch sizes. If left empty, does
		///   nothing. Otherwise, supplies a list of batch sizes, causing the op to pad
		///   batches up to one of those sizes. The entries must increase monotonically, and
		///   the final entry must equal max_batch_size.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   Controls the scope of sharing of this batch.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   Concurrently running instances of batch in the same device with the
		///   same container and shared_name will batch their elements together. If left
		///   empty, the op name will be used as the shared name.
		/// </param>
		/// <param name="batching_queue">
		///   Optional argument
		/// </param>
		/// <param name="f">
		/// </param>
		/// <param name="num_batch_threads">
		///   Number of scheduling threads for processing batches of work.
		///   Determines the number of batches processed in parallel.
		/// </param>
		/// <param name="max_batch_size">
		///   Batch sizes will never be bigger than this.
		/// </param>
		/// <param name="batch_timeout_micros">
		///   Maximum number of microseconds to wait before outputting
		///   an incomplete batch.
		/// </param>
		/// <param name="Tout">
		///   the types of the output tensors.
		/// </param>
		/// <returns>
		///   The output tensors.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   So, for example, in the following code
		///   
		///    <code>
		///   
		///   # This input will be captured.
		///   y = tf.placeholder_with_default(1.0, shape=[])
		///   
		///   @tf.Defun(tf.float32)
		///   def computation(a):
		///   return tf.matmul(a, a) + y
		///   
		///   b = gen_batch_ops.batch_function(
		///   f=computation
		///   in_tensors=[a],
		///   captured_tensors=computation.captured_inputs,
		///   Tout=[o.type for o in computation.definition.signature.output_arg],
		///   num_batch_threads=1,
		///   max_batch_size=10,
		///   batch_timeout_micros=100000,  # 100ms
		///   allowed_batch_sizes=[3, 10],
		///   batching_queue="")
		///   
		///   If more than one session.run call is simultaneously trying to compute <c>b</c>
		///   the values of <c>a</c> will be gathered, non-deterministically concatenated
		///   along the first axis, and only one thread will run the computation.
		///   
		///   Assumes that all arguments of the function are Tensors which will be batched
		///   along their first dimension.
		///   
		///   Arguments that are captured, are not batched. The session.run call which does
		///   the concatenation, will use the values of the captured tensors available to it.
		///   Therefore, typical uses of captured tensors should involve values which remain
		///   unchanged across session.run calls. Inference is a good example of this.
		///   
		///   SparseTensor is not supported. The return value of the decorated function
		///   must be a Tensor or a list/tuple of Tensors.
		/// </remarks>
		public TF_Output[] BatchFunction (TF_Output[] in_tensors, TF_Output[] captured_tensors, TF_Function f, long num_batch_threads, long max_batch_size, long batch_timeout_micros, TF_DataType[] Tout, long? max_enqueued_batches = null, long[] allowed_batch_sizes = null, string container = null, string shared_name = null, string batching_queue = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchFunction", MakeName ("BatchFunction", operName));
			c_api.TF_AddInputList(desc, in_tensors[0], in_tensors.Length);
			c_api.TF_AddInputList(desc, captured_tensors[0], captured_tensors.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "f", c_api.TF_FunctionName(f));
			c_api.TF_SetAttrInt (desc, "num_batch_threads", num_batch_threads);
			c_api.TF_SetAttrInt (desc, "max_batch_size", max_batch_size);
			c_api.TF_SetAttrInt (desc, "batch_timeout_micros", batch_timeout_micros);
			c_api.TF_SetAttrTypeList (desc, "Tout", Tout);
			if (max_enqueued_batches.HasValue)
				c_api.TF_SetAttrInt (desc, "max_enqueued_batches", max_enqueued_batches.Value);
			
			if (allowed_batch_sizes != null)
				c_api.TF_SetAttrIntList (desc, "allowed_batch_sizes", ref allowed_batch_sizes[0], allowed_batch_sizes.Length);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (batching_queue != null)
				c_api.TF_SetAttrString (desc, "batching_queue", batching_queue);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "out_tensors", status);
			var out_tensors = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				out_tensors [i] = new TF_Output (op, _idx++);
			
			return out_tensors;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchIFFT'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchIFFT (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchIFFT", MakeName ("BatchIFFT", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchIFFT2D'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchIFFT2D (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchIFFT2D", MakeName ("BatchIFFT2D", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchIFFT3D'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchIFFT3D (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchIFFT3D", MakeName ("BatchIFFT3D", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Multiplies slices of two tensors in batches.
		/// </summary>
		/// <param name="x">
		///   2-D or higher with shape <c>[..., r_x, c_x]</c>.
		/// </param>
		/// <param name="y">
		///   2-D or higher with shape <c>[..., r_y, c_y]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatMul'.
		/// </param>
		/// <param name="adj_x">
		///   Optional argument
		///   If <c>True</c>, adjoint the slices of <c>x</c>. Defaults to <c>False</c>.
		/// </param>
		/// <param name="adj_y">
		///   Optional argument
		///   If <c>True</c>, adjoint the slices of <c>y</c>. Defaults to <c>False</c>.
		/// </param>
		/// <returns>
		///   3-D or higher with shape <c>[..., r_o, c_o]</c>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Multiplies all slices of <c>Tensor</c> <c>x</c> and <c>y</c> (each slice can be
		///   viewed as an element of a batch), and arranges the individual results
		///   in a single output tensor of the same batch size. Each of the
		///   individual slices can optionally be adjointed (to adjoint a matrix
		///   means to transpose and conjugate it) before multiplication by setting
		///   the <c>adj_x</c> or <c>adj_y</c> flag to <c>True</c>, which are by default <c>False</c>.
		///   
		///   The input tensors <c>x</c> and <c>y</c> are 2-D or higher with shape <c>[..., r_x, c_x]</c>
		///   and <c>[..., r_y, c_y]</c>.
		///   
		///   The output tensor is 2-D or higher with shape <c>[..., r_o, c_o]</c>, where:
		///   
		///   r_o = c_x if adj_x else r_x
		///   c_o = r_y if adj_y else c_y
		///   
		///   It is computed as:
		///   
		///   output[..., :, :] = matrix(x[..., :, :]) * matrix(y[..., :, :])
		/// </remarks>
		public TF_Output BatchMatMul (TF_Output x, TF_Output y, bool? adj_x = null, bool? adj_y = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatMul", MakeName ("BatchMatMul", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (adj_x.HasValue)
				c_api.TF_SetAttrBool (desc, "adj_x", Convert.ToByte(adj_x.Value));
			
			if (adj_y.HasValue)
				c_api.TF_SetAttrBool (desc, "adj_y", Convert.ToByte(adj_y.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Multiplies slices of two tensors in batches.
		/// </summary>
		/// <param name="x">
		///   2-D or higher with shape <c>[..., r_x, c_x]</c>.
		/// </param>
		/// <param name="y">
		///   2-D or higher with shape <c>[..., r_y, c_y]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatMulV2'.
		/// </param>
		/// <param name="adj_x">
		///   Optional argument
		///   If <c>True</c>, adjoint the slices of <c>x</c>. Defaults to <c>False</c>.
		/// </param>
		/// <param name="adj_y">
		///   Optional argument
		///   If <c>True</c>, adjoint the slices of <c>y</c>. Defaults to <c>False</c>.
		/// </param>
		/// <returns>
		///   3-D or higher with shape <c>[..., r_o, c_o]</c>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Multiplies all slices of <c>Tensor</c> <c>x</c> and <c>y</c> (each slice can be
		///   viewed as an element of a batch), and arranges the individual results
		///   in a single output tensor of the same batch size. Each of the
		///   individual slices can optionally be adjointed (to adjoint a matrix
		///   means to transpose and conjugate it) before multiplication by setting
		///   the <c>adj_x</c> or <c>adj_y</c> flag to <c>True</c>, which are by default <c>False</c>.
		///   
		///   The input tensors <c>x</c> and <c>y</c> are 2-D or higher with shape <c>[..., r_x, c_x]</c>
		///   and <c>[..., r_y, c_y]</c>.
		///   
		///   The output tensor is 2-D or higher with shape <c>[..., r_o, c_o]</c>, where:
		///   
		///   r_o = c_x if adj_x else r_x
		///   c_o = r_y if adj_y else c_y
		///   
		///   It is computed as:
		///   
		///   output[..., :, :] = matrix(x[..., :, :]) * matrix(y[..., :, :])
		///   
		///   *NOTE*: <c>BatchMatMulV2</c> supports broadcasting in the batch dimensions. More
		///   about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html).
		///   
		/// </remarks>
		public TF_Output BatchMatMulV2 (TF_Output x, TF_Output y, bool? adj_x = null, bool? adj_y = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatMulV2", MakeName ("BatchMatMulV2", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (adj_x.HasValue)
				c_api.TF_SetAttrBool (desc, "adj_x", Convert.ToByte(adj_x.Value));
			
			if (adj_y.HasValue)
				c_api.TF_SetAttrBool (desc, "adj_y", Convert.ToByte(adj_y.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="num_lower">
		/// </param>
		/// <param name="num_upper">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatrixBandPart'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchMatrixBandPart (TF_Output input, TF_Output num_lower, TF_Output num_upper, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatrixBandPart", MakeName ("BatchMatrixBandPart", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, num_lower);
			c_api.TF_AddInput(desc, num_upper);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var band = new TF_Output (op, _idx++);
			return band;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatrixDeterminant'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchMatrixDeterminant (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatrixDeterminant", MakeName ("BatchMatrixDeterminant", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="diagonal">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatrixDiag'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchMatrixDiag (TF_Output diagonal, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatrixDiag", MakeName ("BatchMatrixDiag", operName));
			c_api.TF_AddInput(desc, diagonal);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatrixDiagPart'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchMatrixDiagPart (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatrixDiagPart", MakeName ("BatchMatrixDiagPart", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var diagonal = new TF_Output (op, _idx++);
			return diagonal;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatrixInverse'.
		/// </param>
		/// <param name="adjoint">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchMatrixInverse (TF_Output input, bool? adjoint = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatrixInverse", MakeName ("BatchMatrixInverse", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (adjoint.HasValue)
				c_api.TF_SetAttrBool (desc, "adjoint", Convert.ToByte(adjoint.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="diagonal">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatrixSetDiag'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchMatrixSetDiag (TF_Output input, TF_Output diagonal, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatrixSetDiag", MakeName ("BatchMatrixSetDiag", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, diagonal);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="matrix">
		/// </param>
		/// <param name="rhs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatrixSolve'.
		/// </param>
		/// <param name="adjoint">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchMatrixSolve (TF_Output matrix, TF_Output rhs, bool? adjoint = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatrixSolve", MakeName ("BatchMatrixSolve", operName));
			c_api.TF_AddInput(desc, matrix);
			c_api.TF_AddInput(desc, rhs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (adjoint.HasValue)
				c_api.TF_SetAttrBool (desc, "adjoint", Convert.ToByte(adjoint.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="matrix">
		/// </param>
		/// <param name="rhs">
		/// </param>
		/// <param name="l2_regularizer">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatrixSolveLs'.
		/// </param>
		/// <param name="fast">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchMatrixSolveLs (TF_Output matrix, TF_Output rhs, TF_Output l2_regularizer, bool? fast = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatrixSolveLs", MakeName ("BatchMatrixSolveLs", operName));
			c_api.TF_AddInput(desc, matrix);
			c_api.TF_AddInput(desc, rhs);
			c_api.TF_AddInput(desc, l2_regularizer);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (fast.HasValue)
				c_api.TF_SetAttrBool (desc, "fast", Convert.ToByte(fast.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="matrix">
		/// </param>
		/// <param name="rhs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatrixTriangularSolve'.
		/// </param>
		/// <param name="lower">
		///   Optional argument
		/// </param>
		/// <param name="adjoint">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchMatrixTriangularSolve (TF_Output matrix, TF_Output rhs, bool? lower = null, bool? adjoint = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchMatrixTriangularSolve", MakeName ("BatchMatrixTriangularSolve", operName));
			c_api.TF_AddInput(desc, matrix);
			c_api.TF_AddInput(desc, rhs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (lower.HasValue)
				c_api.TF_SetAttrBool (desc, "lower", Convert.ToByte(lower.Value));
			
			if (adjoint.HasValue)
				c_api.TF_SetAttrBool (desc, "adjoint", Convert.ToByte(adjoint.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Batch normalization.
		/// </summary>
		/// <param name="t">
		///   A 4D input Tensor.
		/// </param>
		/// <param name="m">
		///   A 1D mean Tensor with size matching the last dimension of t.
		///   This is the first output from tf.nn.moments,
		///   or a saved moving average thereof.
		/// </param>
		/// <param name="v">
		///   A 1D variance Tensor with size matching the last dimension of t.
		///   This is the second output from tf.nn.moments,
		///   or a saved moving average thereof.
		/// </param>
		/// <param name="beta">
		///   A 1D beta Tensor with size matching the last dimension of t.
		///   An offset to be added to the normalized tensor.
		/// </param>
		/// <param name="gamma">
		///   A 1D gamma Tensor with size matching the last dimension of t.
		///   If "scale_after_normalization" is true, this tensor will be multiplied
		///   with the normalized tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchNormWithGlobalNormalization'.
		/// </param>
		/// <param name="variance_epsilon">
		///   A small float number to avoid dividing by 0.
		/// </param>
		/// <param name="scale_after_normalization">
		///   A bool indicating whether the resulted tensor
		///   needs to be multiplied with gamma.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op is deprecated. Prefer <c>tf.nn.batch_normalization</c>.
		/// </remarks>
		public TF_Output BatchNormWithGlobalNormalization (TF_Output t, TF_Output m, TF_Output v, TF_Output beta, TF_Output gamma, float variance_epsilon, bool scale_after_normalization, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchNormWithGlobalNormalization", MakeName ("BatchNormWithGlobalNormalization", operName));
			c_api.TF_AddInput(desc, t);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, v);
			c_api.TF_AddInput(desc, beta);
			c_api.TF_AddInput(desc, gamma);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFloat (desc, "variance_epsilon", variance_epsilon);
			c_api.TF_SetAttrBool (desc, "scale_after_normalization", Convert.ToByte(scale_after_normalization));
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var result = new TF_Output (op, _idx++);
			return result;
		}

		/// <summary>
		///   Gradients for batch normalization.
		/// </summary>
		/// <param name="t">
		///   A 4D input Tensor.
		/// </param>
		/// <param name="m">
		///   A 1D mean Tensor with size matching the last dimension of t.
		///   This is the first output from tf.nn.moments,
		///   or a saved moving average thereof.
		/// </param>
		/// <param name="v">
		///   A 1D variance Tensor with size matching the last dimension of t.
		///   This is the second output from tf.nn.moments,
		///   or a saved moving average thereof.
		/// </param>
		/// <param name="gamma">
		///   A 1D gamma Tensor with size matching the last dimension of t.
		///   If "scale_after_normalization" is true, this Tensor will be multiplied
		///   with the normalized Tensor.
		/// </param>
		/// <param name="backprop">
		///   4D backprop Tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchNormWithGlobalNormalizationGrad'.
		/// </param>
		/// <param name="variance_epsilon">
		///   A small float number to avoid dividing by 0.
		/// </param>
		/// <param name="scale_after_normalization">
		///   A bool indicating whether the resulted tensor
		///   needs to be multiplied with gamma.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   dx: 4D backprop tensor for input.
		///   dm: 1D backprop tensor for mean.
		///   dv: 1D backprop tensor for variance.
		///   db: 1D backprop tensor for beta.
		///   dg: 1D backprop tensor for gamma.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   This op is deprecated. See <c>tf.nn.batch_normalization</c>.
		/// </remarks>
		public (TF_Output dx, TF_Output dm, TF_Output dv, TF_Output db, TF_Output dg) BatchNormWithGlobalNormalizationGrad (TF_Output t, TF_Output m, TF_Output v, TF_Output gamma, TF_Output backprop, float variance_epsilon, bool scale_after_normalization, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchNormWithGlobalNormalizationGrad", MakeName ("BatchNormWithGlobalNormalizationGrad", operName));
			c_api.TF_AddInput(desc, t);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, v);
			c_api.TF_AddInput(desc, gamma);
			c_api.TF_AddInput(desc, backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFloat (desc, "variance_epsilon", variance_epsilon);
			c_api.TF_SetAttrBool (desc, "scale_after_normalization", Convert.ToByte(scale_after_normalization));
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var dx = new TF_Output (op, _idx++);
			var dm = new TF_Output (op, _idx++);
			var dv = new TF_Output (op, _idx++);
			var db = new TF_Output (op, _idx++);
			var dg = new TF_Output (op, _idx++);
			return (dx, dm, dv, db, dg);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchSelfAdjointEig'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BatchSelfAdjointEig (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchSelfAdjointEig", MakeName ("BatchSelfAdjointEig", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchSelfAdjointEigV2'.
		/// </param>
		/// <param name="compute_v">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   e:
		///   v:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output e, TF_Output v) BatchSelfAdjointEigV2 (TF_Output input, bool? compute_v = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchSelfAdjointEigV2", MakeName ("BatchSelfAdjointEigV2", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (compute_v.HasValue)
				c_api.TF_SetAttrBool (desc, "compute_v", Convert.ToByte(compute_v.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var e = new TF_Output (op, _idx++);
			var v = new TF_Output (op, _idx++);
			return (e, v);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchSvd'.
		/// </param>
		/// <param name="compute_uv">
		///   Optional argument
		/// </param>
		/// <param name="full_matrices">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   s:
		///   u:
		///   v:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output s, TF_Output u, TF_Output v) BatchSvd (TF_Output input, bool? compute_uv = null, bool? full_matrices = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchSvd", MakeName ("BatchSvd", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (compute_uv.HasValue)
				c_api.TF_SetAttrBool (desc, "compute_uv", Convert.ToByte(compute_uv.Value));
			
			if (full_matrices.HasValue)
				c_api.TF_SetAttrBool (desc, "full_matrices", Convert.ToByte(full_matrices.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var s = new TF_Output (op, _idx++);
			var u = new TF_Output (op, _idx++);
			var v = new TF_Output (op, _idx++);
			return (s, u, v);
		}

		/// <summary>
		///   BatchToSpace for 4-D tensors of type T.
		/// </summary>
		/// <param name="input">
		///   4-D tensor with shape
		///   <c>[batch*block_size*block_size, height_pad/block_size, width_pad/block_size,
		///   depth]</c>. Note that the batch size of the input tensor must be divisible by
		///   <c>block_size * block_size</c>.
		/// </param>
		/// <param name="crops">
		///   2-D tensor of non-negative integers with shape <c>[2, 2]</c>. It specifies
		///   how many elements to crop from the intermediate result across the spatial
		///   dimensions as follows:
		///   
		///   crops = [[crop_top, crop_bottom], [crop_left, crop_right]]
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchToSpace'.
		/// </param>
		/// <param name="block_size">
		/// </param>
		/// <returns>
		///   4-D with shape <c>[batch, height, width, depth]</c>, where:
		///   
		///   height = height_pad - crop_top - crop_bottom
		///   width = width_pad - crop_left - crop_right
		///   
		///   The attr <c>block_size</c> must be greater than one. It indicates the block size.
		///   
		///   Some examples:
		///   
		///   (1) For the following input of shape <c>[4, 1, 1, 1]</c> and block_size of 2:
		///   
		///    <code>
		///   [[[[1]]], [[[2]]], [[[3]]], [[[4]]]]
		///    </code>
		///   
		///   The output tensor has shape <c>[1, 2, 2, 1]</c> and value:
		///   
		///    <code>
		///   x = [[[[1], [2]], [[3], [4]]]]
		///    </code>
		///   
		///   (2) For the following input of shape <c>[4, 1, 1, 3]</c> and block_size of 2:
		///   
		///    <code>
		///   [[[[1, 2, 3]]], [[[4, 5, 6]]], [[[7, 8, 9]]], [[[10, 11, 12]]]]
		///    </code>
		///   
		///   The output tensor has shape <c>[1, 2, 2, 3]</c> and value:
		///   
		///    <code>
		///   x = [[[[1, 2, 3], [4, 5, 6]],
		///   [[7, 8, 9], [10, 11, 12]]]]
		///    </code>
		///   
		///   (3) For the following input of shape <c>[4, 2, 2, 1]</c> and block_size of 2:
		///   
		///    <code>
		///   x = [[[[1], [3]], [[9], [11]]],
		///   [[[2], [4]], [[10], [12]]],
		///   [[[5], [7]], [[13], [15]]],
		///   [[[6], [8]], [[14], [16]]]]
		///    </code>
		///   
		///   The output tensor has shape <c>[1, 4, 4, 1]</c> and value:
		///   
		///    <code>
		///   x = [[[[1],   [2],  [3],  [4]],
		///   [[5],   [6],  [7],  [8]],
		///   [[9],  [10], [11],  [12]],
		///   [[13], [14], [15],  [16]]]]
		///    </code>
		///   
		///   (4) For the following input of shape <c>[8, 1, 2, 1]</c> and block_size of 2:
		///   
		///    <code>
		///   x = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],
		///   [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]
		///    </code>
		///   
		///   The output tensor has shape <c>[2, 2, 4, 1]</c> and value:
		///   
		///    <code>
		///   x = [[[[1], [3]], [[5], [7]]],
		///   [[[2], [4]], [[10], [12]]],
		///   [[[5], [7]], [[13], [15]]],
		///   [[[6], [8]], [[14], [16]]]]
		///    </code>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This is a legacy version of the more general BatchToSpaceND.
		///   
		///   Rearranges (permutes) data from batch into blocks of spatial data, followed by
		///   cropping. This is the reverse transformation of SpaceToBatch. More specifically,
		///   this op outputs a copy of the input tensor where values from the <c>batch</c>
		///   dimension are moved in spatial blocks to the <c>height</c> and <c>width</c> dimensions,
		///   followed by cropping along the <c>height</c> and <c>width</c> dimensions.
		/// </remarks>
		public TF_Output BatchToSpace (TF_Output input, TF_Output crops, long block_size, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchToSpace", MakeName ("BatchToSpace", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, crops);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "block_size", block_size);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   BatchToSpace for N-D tensors of type T.
		/// </summary>
		/// <param name="input">
		///   N-D with shape <c>input_shape = [batch] + spatial_shape + remaining_shape</c>,
		///   where spatial_shape has M dimensions.
		/// </param>
		/// <param name="block_shape">
		///   1-D with shape <c>[M]</c>, all values must be &amp;gt;= 1.
		/// </param>
		/// <param name="crops">
		///   2-D with shape <c>[M, 2]</c>, all values must be &amp;gt;= 0.
		///   <c>crops[i] = [crop_start, crop_end]</c> specifies the amount to crop from input
		///   dimension <c>i + 1</c>, which corresponds to spatial dimension <c>i</c>.  It is
		///   required that
		///   <c>crop_start[i] + crop_end[i] &amp;lt;= block_shape[i] * input_shape[i + 1]</c>.
		///   
		///   This operation is equivalent to the following steps:
		///   
		///   1. Reshape <c>input</c> to <c>reshaped</c> of shape:
		///   [block_shape[0], ..., block_shape[M-1],
		///   batch / prod(block_shape),
		///   input_shape[1], ..., input_shape[N-1]]
		///   
		///   2. Permute dimensions of <c>reshaped</c> to produce <c>permuted</c> of shape
		///   [batch / prod(block_shape),
		///   
		///   input_shape[1], block_shape[0],
		///   ...,
		///   input_shape[M], block_shape[M-1],
		///   
		///   input_shape[M+1], ..., input_shape[N-1]]
		///   
		///   3. Reshape <c>permuted</c> to produce <c>reshaped_permuted</c> of shape
		///   [batch / prod(block_shape),
		///   
		///   input_shape[1] * block_shape[0],
		///   ...,
		///   input_shape[M] * block_shape[M-1],
		///   
		///   input_shape[M+1],
		///   ...,
		///   input_shape[N-1]]
		///   
		///   4. Crop the start and end of dimensions <c>[1, ..., M]</c> of
		///   <c>reshaped_permuted</c> according to <c>crops</c> to produce the output of shape:
		///   [batch / prod(block_shape),
		///   
		///   input_shape[1] * block_shape[0] - crops[0,0] - crops[0,1],
		///   ...,
		///   input_shape[M] * block_shape[M-1] - crops[M-1,0] - crops[M-1,1],
		///   
		///   input_shape[M+1], ..., input_shape[N-1]]
		///   
		///   Some examples:
		///   
		///   (1) For the following input of shape <c>[4, 1, 1, 1]</c>, <c>block_shape = [2, 2]</c>, and
		///   <c>crops = [[0, 0], [0, 0]]</c>:
		///   
		///    <code>
		///   [[[[1]]], [[[2]]], [[[3]]], [[[4]]]]
		///    </code>
		///   
		///   The output tensor has shape <c>[1, 2, 2, 1]</c> and value:
		///   
		///    <code>
		///   x = [[[[1], [2]], [[3], [4]]]]
		///    </code>
		///   
		///   (2) For the following input of shape <c>[4, 1, 1, 3]</c>, <c>block_shape = [2, 2]</c>, and
		///   <c>crops = [[0, 0], [0, 0]]</c>:
		///   
		///    <code>
		///   [[[[1, 2, 3]]], [[[4, 5, 6]]], [[[7, 8, 9]]], [[[10, 11, 12]]]]
		///    </code>
		///   
		///   The output tensor has shape <c>[1, 2, 2, 3]</c> and value:
		///   
		///    <code>
		///   x = [[[[1, 2, 3], [4, 5, 6]],
		///   [[7, 8, 9], [10, 11, 12]]]]
		///    </code>
		///   
		///   (3) For the following input of shape <c>[4, 2, 2, 1]</c>, <c>block_shape = [2, 2]</c>, and
		///   <c>crops = [[0, 0], [0, 0]]</c>:
		///   
		///    <code>
		///   x = [[[[1], [3]], [[9], [11]]],
		///   [[[2], [4]], [[10], [12]]],
		///   [[[5], [7]], [[13], [15]]],
		///   [[[6], [8]], [[14], [16]]]]
		///    </code>
		///   
		///   The output tensor has shape <c>[1, 4, 4, 1]</c> and value:
		///   
		///    <code>
		///   x = [[[[1],   [2],  [3],  [4]],
		///   [[5],   [6],  [7],  [8]],
		///   [[9],  [10], [11],  [12]],
		///   [[13], [14], [15],  [16]]]]
		///    </code>
		///   
		///   (4) For the following input of shape <c>[8, 1, 3, 1]</c>, <c>block_shape = [2, 2]</c>, and
		///   <c>crops = [[0, 0], [2, 0]]</c>:
		///   
		///    <code>
		///   x = [[[[0], [1], [3]]], [[[0], [9], [11]]],
		///   [[[0], [2], [4]]], [[[0], [10], [12]]],
		///   [[[0], [5], [7]]], [[[0], [13], [15]]],
		///   [[[0], [6], [8]]], [[[0], [14], [16]]]]
		///    </code>
		///   
		///   The output tensor has shape <c>[2, 2, 4, 1]</c> and value:
		///   
		///    <code>
		///   x = [[[[1],   [2],  [3],  [4]],
		///   [[5],   [6],  [7],  [8]]],
		///   [[[9],  [10], [11],  [12]],
		///   [[13], [14], [15],  [16]]]]
		///    </code>
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchToSpaceND'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation reshapes the "batch" dimension 0 into <c>M + 1</c> dimensions of shape
		///   <c>block_shape + [batch]</c>, interleaves these blocks back into the grid defined by
		///   the spatial dimensions <c>[1, ..., M]</c>, to obtain a result with the same rank as
		///   the input.  The spatial dimensions of this intermediate result are then
		///   optionally cropped according to <c>crops</c> to produce the output.  This is the
		///   reverse of SpaceToBatch.  See below for a precise description.
		/// </remarks>
		public TF_Output BatchToSpaceND (TF_Output input, TF_Output block_shape, TF_Output crops, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BatchToSpaceND", MakeName ("BatchToSpaceND", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, block_shape);
			c_api.TF_AddInput(desc, crops);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the Bessel i0e function of <c>x</c> element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BesselI0e'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Exponentially scaled modified Bessel function of order 0 defined as
		///   <c>bessel_i0e(x) = exp(-abs(x)) bessel_i0(x)</c>.
		///   
		///   This function is faster and numerically stabler than <c>bessel_i0(x)</c>.
		/// </remarks>
		public TF_Output BesselI0e (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BesselI0e", MakeName ("BesselI0e", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes the Bessel i1e function of <c>x</c> element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BesselI1e'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Exponentially scaled modified Bessel function of order 0 defined as
		///   <c>bessel_i1e(x) = exp(-abs(x)) bessel_i1(x)</c>.
		///   
		///   This function is faster and numerically stabler than <c>bessel_i1(x)</c>.
		/// </remarks>
		public TF_Output BesselI1e (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BesselI1e", MakeName ("BesselI1e", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Compute the regularized incomplete beta integral \\(I_x(a, b)\\).
		/// </summary>
		/// <param name="a">
		/// </param>
		/// <param name="b">
		/// </param>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Betainc'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The regularized incomplete beta integral is defined as:
		///   
		///   
		///   \\(I_x(a, b) = \frac{B(x; a, b)}{B(a, b)}\\)
		///   
		///   where
		///   
		///   
		///   \\(B(x; a, b) = \int_0^x t^{a-1} (1 - t)^{b-1} dt\\)
		///   
		///   
		///   is the incomplete beta function and \\(B(a, b)\\) is the *complete*
		///   beta function.
		/// </remarks>
		public TF_Output Betainc (TF_Output a, TF_Output b, TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Betainc", MakeName ("Betainc", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, b);
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Adds <c>bias</c> to <c>value</c>.
		/// </summary>
		/// <param name="value">
		///   Any number of dimensions.
		/// </param>
		/// <param name="bias">
		///   1-D with size the last dimension of <c>value</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BiasAdd'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   Specify the data format of the input and output data. With the
		///   default format "NHWC", the bias tensor will be added to the last dimension
		///   of the value tensor.
		///   Alternatively, the format could be "NCHW", the data storage order of:
		///   [batch, in_channels, in_height, in_width].
		///   The tensor will be added to "in_channels", the third-to-the-last
		///   dimension.
		/// </param>
		/// <returns>
		///   Broadcasted sum of <c>value</c> and <c>bias</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This is a special case of <c>tf.add</c> where <c>bias</c> is restricted to be 1-D.
		///   Broadcasting is supported, so <c>value</c> may have any number of dimensions.
		/// </remarks>
		public TF_Output BiasAdd (TF_Output value, TF_Output bias, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BiasAdd", MakeName ("BiasAdd", operName));
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, bias);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   The backward operation for "BiasAdd" on the "bias" tensor.
		/// </summary>
		/// <param name="out_backprop">
		///   Any number of dimensions.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BiasAddGrad'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   Specify the data format of the input and output data. With the
		///   default format "NHWC", the bias tensor will be added to the last dimension
		///   of the value tensor.
		///   Alternatively, the format could be "NCHW", the data storage order of:
		///   [batch, in_channels, in_height, in_width].
		///   The tensor will be added to "in_channels", the third-to-the-last
		///   dimension.
		/// </param>
		/// <returns>
		///   1-D with size the feature dimension of <c>out_backprop</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   It accumulates all the values from out_backprop into the feature dimension.
		///   For NHWC data format, the feature dimension is the last. For NCHW data format,
		///   the feature dimension is the third-to-last.
		/// </remarks>
		public TF_Output BiasAddGrad (TF_Output out_backprop, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BiasAddGrad", MakeName ("BiasAddGrad", operName));
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Adds <c>bias</c> to <c>value</c>.
		/// </summary>
		/// <param name="value">
		///   Any number of dimensions.
		/// </param>
		/// <param name="bias">
		///   1-D with size the last dimension of <c>value</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BiasAddV1'.
		/// </param>
		/// <returns>
		///   Broadcasted sum of <c>value</c> and <c>bias</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This is a deprecated version of BiasAdd and will be soon removed.
		///   
		///   This is a special case of <c>tf.add</c> where <c>bias</c> is restricted to be 1-D.
		///   Broadcasting is supported, so <c>value</c> may have any number of dimensions.
		/// </remarks>
		public TF_Output BiasAddV1 (TF_Output value, TF_Output bias, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BiasAddV1", MakeName ("BiasAddV1", operName));
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, bias);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Counts the number of occurrences of each value in an integer array.
		/// </summary>
		/// <param name="arr">
		///   int32 <c>Tensor</c>.
		/// </param>
		/// <param name="size">
		///   non-negative int32 scalar <c>Tensor</c>.
		/// </param>
		/// <param name="weights">
		///   is an int32, int64, float32, or float64 <c>Tensor</c> with the same
		///   shape as <c>arr</c>, or a length-0 <c>Tensor</c>, in which case it acts as all weights
		///   equal to 1.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Bincount'.
		/// </param>
		/// <returns>
		///   1D <c>Tensor</c> with length equal to <c>size</c>. The counts or summed weights for
		///   each value in the range [0, size).
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Outputs a vector with length <c>size</c> and the same dtype as <c>weights</c>. If
		///   <c>weights</c> are empty, then index <c>i</c> stores the number of times the value <c>i</c> is
		///   counted in <c>arr</c>. If <c>weights</c> are non-empty, then index <c>i</c> stores the sum of
		///   the value in <c>weights</c> at each index where the corresponding value in <c>arr</c> is
		///   <c>i</c>.
		///   
		///   Values in <c>arr</c> outside of the range [0, size) are ignored.
		/// </remarks>
		public TF_Output Bincount (TF_Output arr, TF_Output size, TF_Output weights, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Bincount", MakeName ("Bincount", operName));
			c_api.TF_AddInput(desc, arr);
			c_api.TF_AddInput(desc, size);
			c_api.TF_AddInput(desc, weights);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var bins = new TF_Output (op, _idx++);
			return bins;
		}

		/// <summary>
		///   Bitcasts a tensor from one type to another without copying data.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Bitcast'.
		/// </param>
		/// <param name="type">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given a tensor <c>input</c>, this operation returns a tensor that has the same buffer
		///   data as <c>input</c> with datatype <c>type</c>.
		///   
		///   If the input datatype <c>T</c> is larger than the output datatype <c>type</c> then the
		///   shape changes from [...] to [..., sizeof(<c>T</c>)/sizeof(<c>type</c>)].
		///   
		///   If <c>T</c> is smaller than <c>type</c>, the operator requires that the rightmost
		///   dimension be equal to sizeof(<c>type</c>)/sizeof(<c>T</c>). The shape then goes from
		///   [..., sizeof(<c>type</c>)/sizeof(<c>T</c>)] to [...].
		///   
		///   tf.bitcast() and tf.cast() work differently when real dtype is casted as a complex dtype
		///   (e.g. tf.complex64 or tf.complex128) as tf.cast() make imaginary part 0 while tf.bitcast()
		///   gives module error.
		///   For example,
		///   
		///   Example 1:
		///    <code>
		///   &amp;gt;&amp;gt;&amp;gt; a = [1., 2., 3.]
		///   &amp;gt;&amp;gt;&amp;gt; equality_bitcast = tf.bitcast(a,tf.complex128)
		///   tensorflow.python.framework.errors_impl.InvalidArgumentError: Cannot bitcast from float to complex128: shape [3] [Op:Bitcast]
		///   &amp;gt;&amp;gt;&amp;gt; equality_cast = tf.cast(a,tf.complex128)
		///   &amp;gt;&amp;gt;&amp;gt; print(equality_cast)
		///   tf.Tensor([1.+0.j 2.+0.j 3.+0.j], shape=(3,), dtype=complex128)
		///    </code>
		///   Example 2:
		///    <code>
		///   &amp;gt;&amp;gt;&amp;gt; tf.bitcast(tf.constant(0xffffffff, dtype=tf.uint32), tf.uint8)
		///   &amp;lt;tf.Tensor: ... shape=(4,), dtype=uint8, numpy=array([255, 255, 255, 255], dtype=uint8)&amp;gt;
		///    </code>
		///   Example 3:
		///    <code>
		///   &amp;gt;&amp;gt;&amp;gt; x = [1., 2., 3.]
		///   &amp;gt;&amp;gt;&amp;gt; y = [0., 2., 3.]
		///   &amp;gt;&amp;gt;&amp;gt; equality= tf.equal(x,y)
		///   &amp;gt;&amp;gt;&amp;gt; equality_cast = tf.cast(equality,tf.float32)
		///   &amp;gt;&amp;gt;&amp;gt; equality_bitcast = tf.bitcast(equality_cast,tf.uint8)
		///   &amp;gt;&amp;gt;&amp;gt; print(equality)
		///   tf.Tensor([False True True], shape=(3,), dtype=bool)
		///   &amp;gt;&amp;gt;&amp;gt; print(equality_cast)
		///   tf.Tensor([0. 1. 1.], shape=(3,), dtype=float32)
		///   &amp;gt;&amp;gt;&amp;gt; print(equality_bitcast)
		///   tf.Tensor(
		///   [[ 0 0 0 0]
		///   [ 0 0 128 63]
		///   [ 0 0 128 63]], shape=(3, 4), dtype=uint8)
		///    </code>
		///   
		///   *NOTE*: Bitcast is implemented as a low-level cast, so machines with different
		///   endian orderings will give different results.
		/// </remarks>
		public TF_Output Bitcast (TF_Output input, TF_DataType type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Bitcast", MakeName ("Bitcast", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "type", type);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Elementwise computes the bitwise AND of <c>x</c> and <c>y</c>.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BitwiseAnd'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The result will have those bits set, that are set in both <c>x</c> and <c>y</c>. The
		///   computation is performed on the underlying representations of <c>x</c> and <c>y</c>.
		///   
		///   For example:
		///   
		///    <code>
		///   import tensorflow as tf
		///   from tensorflow.python.ops import bitwise_ops
		///   dtype_list = [tf.int8, tf.int16, tf.int32, tf.int64,
		///   tf.uint8, tf.uint16, tf.uint32, tf.uint64]
		///   
		///   for dtype in dtype_list:
		///   lhs = tf.constant([0, 5, 3, 14], dtype=dtype)
		///   rhs = tf.constant([5, 0, 7, 11], dtype=dtype)
		///   exp = tf.constant([0, 0, 3, 10], dtype=tf.float32)
		///   
		///   res = bitwise_ops.bitwise_and(lhs, rhs)
		///   tf.assert_equal(tf.cast(res, tf.float32), exp) # TRUE
		///    </code>
		///   
		/// </remarks>
		public TF_Output BitwiseAnd (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BitwiseAnd", MakeName ("BitwiseAnd", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Elementwise computes the bitwise OR of <c>x</c> and <c>y</c>.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BitwiseOr'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The result will have those bits set, that are set in <c>x</c>, <c>y</c> or both. The
		///   computation is performed on the underlying representations of <c>x</c> and <c>y</c>.
		///   
		///   For example:
		///   
		///    <code>
		///   import tensorflow as tf
		///   from tensorflow.python.ops import bitwise_ops
		///   dtype_list = [tf.int8, tf.int16, tf.int32, tf.int64,
		///   tf.uint8, tf.uint16, tf.uint32, tf.uint64]
		///   
		///   for dtype in dtype_list:
		///   lhs = tf.constant([0, 5, 3, 14], dtype=dtype)
		///   rhs = tf.constant([5, 0, 7, 11], dtype=dtype)
		///   exp = tf.constant([5, 5, 7, 15], dtype=tf.float32)
		///   
		///   res = bitwise_ops.bitwise_or(lhs, rhs)
		///   tf.assert_equal(tf.cast(res,  tf.float32), exp)  # TRUE
		///    </code>
		///   
		/// </remarks>
		public TF_Output BitwiseOr (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BitwiseOr", MakeName ("BitwiseOr", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Elementwise computes the bitwise XOR of <c>x</c> and <c>y</c>.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BitwiseXor'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The result will have those bits set, that are different in <c>x</c> and <c>y</c>. The
		///   computation is performed on the underlying representations of <c>x</c> and <c>y</c>.
		///   
		///   For example:
		///   
		///    <code>
		///   import tensorflow as tf
		///   from tensorflow.python.ops import bitwise_ops
		///   dtype_list = [tf.int8, tf.int16, tf.int32, tf.int64,
		///   tf.uint8, tf.uint16, tf.uint32, tf.uint64]
		///   
		///   for dtype in dtype_list:
		///   lhs = tf.constant([0, 5, 3, 14], dtype=dtype)
		///   rhs = tf.constant([5, 0, 7, 11], dtype=dtype)
		///   exp = tf.constant([5, 5, 4, 5],  dtype=tf.float32)
		///   
		///   res = bitwise_ops.bitwise_xor(lhs, rhs)
		///   tf.assert_equal(tf.cast(res, tf.float32), exp) # TRUE
		///    </code>
		///   
		/// </remarks>
		public TF_Output BitwiseXor (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BitwiseXor", MakeName ("BitwiseXor", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Computes the LSTM cell forward propagation for all the time steps.
		/// </summary>
		/// <param name="seq_len_max">
		///   Maximum time length actually used by this input. Outputs are padded
		///   with zeros beyond this length.
		/// </param>
		/// <param name="x">
		///   The sequence input to the LSTM, shape (timelen, batch_size, num_inputs).
		/// </param>
		/// <param name="cs_prev">
		///   Value of the initial cell state.
		/// </param>
		/// <param name="h_prev">
		///   Initial output of cell (to be used for peephole).
		/// </param>
		/// <param name="w">
		///   The weight matrix.
		/// </param>
		/// <param name="wci">
		///   The weight matrix for input gate peephole connection.
		/// </param>
		/// <param name="wcf">
		///   The weight matrix for forget gate peephole connection.
		/// </param>
		/// <param name="wco">
		///   The weight matrix for output gate peephole connection.
		/// </param>
		/// <param name="b">
		///   The bias vector.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BlockLSTM'.
		/// </param>
		/// <param name="forget_bias">
		///   Optional argument
		///   The forget gate bias.
		/// </param>
		/// <param name="cell_clip">
		///   Optional argument
		///   Value to clip the 'cs' value to.
		/// </param>
		/// <param name="use_peephole">
		///   Optional argument
		///   Whether to use peephole weights.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   i: The input gate over the whole time sequence.
		///   cs: The cell state before the tanh over the whole time sequence.
		///   f: The forget gate over the whole time sequence.
		///   o: The output gate over the whole time sequence.
		///   ci: The cell input over the whole time sequence.
		///   co: The cell after the tanh over the whole time sequence.
		///   h: The output h vector over the whole time sequence.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   This is equivalent to applying LSTMBlockCell in a loop, like so:
		///   
		///    <code>
		///   for x1 in unpack(x):
		///   i1, cs1, f1, o1, ci1, co1, h1 = LSTMBlock(
		///   x1, cs_prev, h_prev, w, wci, wcf, wco, b)
		///   cs_prev = cs1
		///   h_prev = h1
		///   i.append(i1)
		///   cs.append(cs1)
		///   f.append(f1)
		///   o.append(o1)
		///   ci.append(ci1)
		///   co.append(co1)
		///   h.append(h1)
		///   return pack(i), pack(cs), pack(f), pack(o), pack(ci), pack(ch), pack(h)
		///    </code>
		/// </remarks>
		public (TF_Output i, TF_Output cs, TF_Output f, TF_Output o, TF_Output ci, TF_Output co, TF_Output h) BlockLSTM (TF_Output seq_len_max, TF_Output x, TF_Output cs_prev, TF_Output h_prev, TF_Output w, TF_Output wci, TF_Output wcf, TF_Output wco, TF_Output b, float? forget_bias = null, float? cell_clip = null, bool? use_peephole = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BlockLSTM", MakeName ("BlockLSTM", operName));
			c_api.TF_AddInput(desc, seq_len_max);
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, cs_prev);
			c_api.TF_AddInput(desc, h_prev);
			c_api.TF_AddInput(desc, w);
			c_api.TF_AddInput(desc, wci);
			c_api.TF_AddInput(desc, wcf);
			c_api.TF_AddInput(desc, wco);
			c_api.TF_AddInput(desc, b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (forget_bias.HasValue)
				c_api.TF_SetAttrFloat (desc, "forget_bias", forget_bias.Value);
			
			if (cell_clip.HasValue)
				c_api.TF_SetAttrFloat (desc, "cell_clip", cell_clip.Value);
			
			if (use_peephole.HasValue)
				c_api.TF_SetAttrBool (desc, "use_peephole", Convert.ToByte(use_peephole.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var i = new TF_Output (op, _idx++);
			var cs = new TF_Output (op, _idx++);
			var f = new TF_Output (op, _idx++);
			var o = new TF_Output (op, _idx++);
			var ci = new TF_Output (op, _idx++);
			var co = new TF_Output (op, _idx++);
			var h = new TF_Output (op, _idx++);
			return (i, cs, f, o, ci, co, h);
		}

		/// <summary>
		///   Computes the LSTM cell backward propagation for the entire time sequence.
		/// </summary>
		/// <param name="seq_len_max">
		///   Maximum time length actually used by this input. Outputs are padded
		///   with zeros beyond this length.
		/// </param>
		/// <param name="x">
		///   The sequence input to the LSTM, shape (timelen, batch_size, num_inputs).
		/// </param>
		/// <param name="cs_prev">
		///   Value of the initial cell state.
		/// </param>
		/// <param name="h_prev">
		///   Initial output of cell (to be used for peephole).
		/// </param>
		/// <param name="w">
		///   The weight matrix.
		/// </param>
		/// <param name="wci">
		///   The weight matrix for input gate peephole connection.
		/// </param>
		/// <param name="wcf">
		///   The weight matrix for forget gate peephole connection.
		/// </param>
		/// <param name="wco">
		///   The weight matrix for output gate peephole connection.
		/// </param>
		/// <param name="b">
		///   The bias vector.
		/// </param>
		/// <param name="i">
		///   The input gate over the whole time sequence.
		/// </param>
		/// <param name="cs">
		///   The cell state before the tanh over the whole time sequence.
		/// </param>
		/// <param name="f">
		///   The forget gate over the whole time sequence.
		/// </param>
		/// <param name="o">
		///   The output gate over the whole time sequence.
		/// </param>
		/// <param name="ci">
		///   The cell input over the whole time sequence.
		/// </param>
		/// <param name="co">
		///   The cell after the tanh over the whole time sequence.
		/// </param>
		/// <param name="h">
		///   The output h vector over the whole time sequence.
		/// </param>
		/// <param name="cs_grad">
		///   The current gradient of cs.
		/// </param>
		/// <param name="h_grad">
		///   The gradient of h vector.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BlockLSTMGrad'.
		/// </param>
		/// <param name="use_peephole">
		///   Whether to use peephole weights.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   x_grad: The gradient of x to be back-propped.
		///   cs_prev_grad: The gradient of cs_prev to be back-propped.
		///   h_prev_grad: The gradient of h_prev to be back-propped.
		///   w_grad: The gradient for w to be back-propped.
		///   wci_grad: The gradient for wci to be back-propped.
		///   wcf_grad: The gradient for wcf to be back-propped.
		///   wco_grad: The gradient for wco to be back-propped.
		///   b_grad: The gradient for w to be back-propped.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   This implementation is to be used in conjunction of LSTMBlock.
		/// </remarks>
		public (TF_Output x_grad, TF_Output cs_prev_grad, TF_Output h_prev_grad, TF_Output w_grad, TF_Output wci_grad, TF_Output wcf_grad, TF_Output wco_grad, TF_Output b_grad) BlockLSTMGrad (TF_Output seq_len_max, TF_Output x, TF_Output cs_prev, TF_Output h_prev, TF_Output w, TF_Output wci, TF_Output wcf, TF_Output wco, TF_Output b, TF_Output i, TF_Output cs, TF_Output f, TF_Output o, TF_Output ci, TF_Output co, TF_Output h, TF_Output cs_grad, TF_Output h_grad, bool use_peephole, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BlockLSTMGrad", MakeName ("BlockLSTMGrad", operName));
			c_api.TF_AddInput(desc, seq_len_max);
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, cs_prev);
			c_api.TF_AddInput(desc, h_prev);
			c_api.TF_AddInput(desc, w);
			c_api.TF_AddInput(desc, wci);
			c_api.TF_AddInput(desc, wcf);
			c_api.TF_AddInput(desc, wco);
			c_api.TF_AddInput(desc, b);
			c_api.TF_AddInput(desc, i);
			c_api.TF_AddInput(desc, cs);
			c_api.TF_AddInput(desc, f);
			c_api.TF_AddInput(desc, o);
			c_api.TF_AddInput(desc, ci);
			c_api.TF_AddInput(desc, co);
			c_api.TF_AddInput(desc, h);
			c_api.TF_AddInput(desc, cs_grad);
			c_api.TF_AddInput(desc, h_grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrBool (desc, "use_peephole", Convert.ToByte(use_peephole));
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var x_grad = new TF_Output (op, _idx++);
			var cs_prev_grad = new TF_Output (op, _idx++);
			var h_prev_grad = new TF_Output (op, _idx++);
			var w_grad = new TF_Output (op, _idx++);
			var wci_grad = new TF_Output (op, _idx++);
			var wcf_grad = new TF_Output (op, _idx++);
			var wco_grad = new TF_Output (op, _idx++);
			var b_grad = new TF_Output (op, _idx++);
			return (x_grad, cs_prev_grad, h_prev_grad, w_grad, wci_grad, wcf_grad, wco_grad, b_grad);
		}

		/// <summary>
		///   Aggregates the summary of accumulated stats for the batch.
		/// </summary>
		/// <param name="node_ids">
		///   int32; Rank 1 Tensor containing node ids for each example, shape [batch_size].
		/// </param>
		/// <param name="gradients">
		///   float32; Rank 2 Tensor (shape=[batch_size, logits_dimension]) with gradients for each example.
		/// </param>
		/// <param name="hessians">
		///   float32; Rank 2 Tensor (shape=[batch_size, hessian_dimension]) with hessians for each example.
		/// </param>
		/// <param name="feature">
		///   int32; Rank 2 feature Tensors (shape=[batch_size, feature_dimension]).
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesAggregateStats'.
		/// </param>
		/// <param name="max_splits">
		///   int; the maximum number of splits possible in the whole tree.
		/// </param>
		/// <param name="num_buckets">
		///   int; equals to the maximum possible value of bucketized feature.
		/// </param>
		/// <returns>
		///   output Rank 4 Tensor (shape=[splits, feature_dimension, buckets, logits_dimension + hessian_dimension])
		///   containing accumulated stats for each node, feature dimension and bucket.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The summary stats contains gradients and hessians accumulated for each node, feature dimension id and bucket.
		/// </remarks>
		public TF_Output BoostedTreesAggregateStats (TF_Output node_ids, TF_Output gradients, TF_Output hessians, TF_Output feature, long max_splits, long num_buckets, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesAggregateStats", MakeName ("BoostedTreesAggregateStats", operName));
			c_api.TF_AddInput(desc, node_ids);
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, hessians);
			c_api.TF_AddInput(desc, feature);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "max_splits", max_splits);
			c_api.TF_SetAttrInt (desc, "num_buckets", num_buckets);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var stats_summary = new TF_Output (op, _idx++);
			return stats_summary;
		}

		/// <summary>
		///   Bucketize each feature based on bucket boundaries.
		/// </summary>
		/// <param name="float_values">
		///   float; List of Rank 1 Tensor each containing float values for a single feature.
		/// </param>
		/// <param name="bucket_boundaries">
		///   float; List of Rank 1 Tensors each containing the bucket boundaries for a single
		///   feature.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesBucketize'.
		/// </param>
		/// <returns>
		///   int; List of Rank 1 Tensors each containing the bucketized values for a single feature.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   An op that returns a list of float tensors, where each tensor represents the
		///   bucketized values for a single feature.
		/// </remarks>
		public TF_Output[] BoostedTreesBucketize (TF_Output[] float_values, TF_Output[] bucket_boundaries, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesBucketize", MakeName ("BoostedTreesBucketize", operName));
			c_api.TF_AddInputList(desc, float_values[0], float_values.Length);
			c_api.TF_AddInputList(desc, bucket_boundaries[0], bucket_boundaries.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "buckets", status);
			var buckets = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				buckets [i] = new TF_Output (op, _idx++);
			
			return buckets;
		}

		/// <summary>
		///   Calculates gains for each feature and returns the best possible split information for the feature.
		/// </summary>
		/// <param name="node_id_range">
		///   A Rank 1 tensor (shape=[2]) to specify the range [first, last) of node ids to process within <c>stats_summary_list</c>. The nodes are iterated between the two nodes specified by the tensor, as like <c>for node_id in range(node_id_range[0], node_id_range[1])</c> (Note that the last index node_id_range[1] is exclusive).
		/// </param>
		/// <param name="stats_summary">
		///   A Rank 4 tensor (#shape=[max_splits, feature_dims, bucket, stats_dims]) for accumulated stats summary (gradient/hessian) per node, per dimension, per buckets for each feature.
		///   The first dimension of the tensor is the maximum number of splits, and thus not all elements of it will be used, but only the indexes specified by node_ids will be used.
		/// </param>
		/// <param name="l1">
		///   l1 regularization factor on leaf weights, per instance based.
		/// </param>
		/// <param name="l2">
		///   l2 regularization factor on leaf weights, per instance based.
		/// </param>
		/// <param name="tree_complexity">
		///   adjustment to the gain, per leaf based.
		/// </param>
		/// <param name="min_node_weight">
		///   mininum avg of hessians in a node before required for the node to be considered for splitting.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesCalculateBestFeatureSplit'.
		/// </param>
		/// <param name="split_type">
		///   Optional argument
		///   A string indicating if this Op should perform inequality split or equality split.
		/// </param>
		/// <param name="logits_dimension">
		///   The dimension of logit, i.e., number of classes.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   node_ids: A Rank 1 tensors indicating possible split node ids for each feature. The length of the list is num_features, but each tensor has different size as each feature provides different possible nodes. See above for details like shapes and sizes.
		///   gains: A Rank 1 tensors indicating the best gains for each feature to split for certain nodes. See above for details like shapes and sizes.
		///   feature_dimensions: A Rank 1 tensors indicating the best feature dimension for each feature to split for certain nodes if the feature is multi-dimension. See above for details like shapes and sizes.
		///   thresholds: A Rank 1 tensors indicating the bucket id to compare with (as a threshold) for split in each node. See above for details like shapes and sizes.
		///   left_node_contribs: A Rank 2 tensors indicating the contribution of the left nodes when branching from parent nodes (given by the tensor element in the output node_ids_list) to the left direction by the given threshold for each feature. This value will be used to make the left node value by adding to the parent node value. Second dimension size is 1 for 1-dimensional logits, but would be larger for multi-class problems. See above for details like shapes and sizes.
		///   right_node_contribs: A Rank 2 tensors, with the same shape/conditions as left_node_contribs_list, but just that the value is for the right node.
		///   split_with_default_directions: A Rank 1 tensors indicating the which direction to go if data is missing. See above for details like shapes and sizes.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The split information is the best threshold (bucket id), gains and left/right node contributions per node for each feature.
		///   
		///   It is possible that not all nodes can be split on each feature. Hence, the list of possible nodes can differ between the features. Therefore, we return <c>node_ids_list</c> for each feature, containing the list of nodes that this feature can be used to split.
		///   
		///   In this manner, the output is the best split per features and per node, so that it needs to be combined later to produce the best split for each node (among all possible features).
		///   
		///   The output shapes are compatible in a way that the first dimension of all tensors are the same and equal to the number of possible split nodes for each feature.
		/// </remarks>
		public (TF_Output node_ids, TF_Output gains, TF_Output feature_dimensions, TF_Output thresholds, TF_Output left_node_contribs, TF_Output right_node_contribs, TF_Output split_with_default_directions) BoostedTreesCalculateBestFeatureSplit (TF_Output node_id_range, TF_Output stats_summary, TF_Output l1, TF_Output l2, TF_Output tree_complexity, TF_Output min_node_weight, long logits_dimension, string split_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesCalculateBestFeatureSplit", MakeName ("BoostedTreesCalculateBestFeatureSplit", operName));
			c_api.TF_AddInput(desc, node_id_range);
			c_api.TF_AddInput(desc, stats_summary);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, tree_complexity);
			c_api.TF_AddInput(desc, min_node_weight);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "logits_dimension", logits_dimension);
			if (split_type != null)
				c_api.TF_SetAttrString (desc, "split_type", split_type);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var node_ids = new TF_Output (op, _idx++);
			var gains = new TF_Output (op, _idx++);
			var feature_dimensions = new TF_Output (op, _idx++);
			var thresholds = new TF_Output (op, _idx++);
			var left_node_contribs = new TF_Output (op, _idx++);
			var right_node_contribs = new TF_Output (op, _idx++);
			var split_with_default_directions = new TF_Output (op, _idx++);
			return (node_ids, gains, feature_dimensions, thresholds, left_node_contribs, right_node_contribs, split_with_default_directions);
		}

		/// <summary>
		///   Calculates gains for each feature and returns the best possible split information for the feature.
		/// </summary>
		/// <param name="node_id_range">
		///   A Rank 1 tensor (shape=[2]) to specify the range [first, last) of node ids to process within <c>stats_summary_list</c>. The nodes are iterated between the two nodes specified by the tensor, as like <c>for node_id in range(node_id_range[0], node_id_range[1])</c> (Note that the last index node_id_range[1] is exclusive).
		/// </param>
		/// <param name="stats_summary_list">
		///   A list of Rank 3 tensor (#shape=[max_splits, bucket, 2]) for accumulated stats summary (gradient/hessian) per node per buckets for each feature. The first dimension of the tensor is the maximum number of splits, and thus not all elements of it will be used, but only the indexes specified by node_ids will be used.
		/// </param>
		/// <param name="l1">
		///   l1 regularization factor on leaf weights, per instance based.
		/// </param>
		/// <param name="l2">
		///   l2 regularization factor on leaf weights, per instance based.
		/// </param>
		/// <param name="tree_complexity">
		///   adjustment to the gain, per leaf based.
		/// </param>
		/// <param name="min_node_weight">
		///   mininum avg of hessians in a node before required for the node to be considered for splitting.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesCalculateBestGainsPerFeature'.
		/// </param>
		/// <param name="max_splits">
		///   the number of nodes that can be split in the whole tree. Used as a dimension of output tensors.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   node_ids_list: An output list of Rank 1 tensors indicating possible split node ids for each feature. The length of the list is num_features, but each tensor has different size as each feature provides different possible nodes. See above for details like shapes and sizes.
		///   gains_list: An output list of Rank 1 tensors indicating the best gains for each feature to split for certain nodes. See above for details like shapes and sizes.
		///   thresholds_list: An output list of Rank 1 tensors indicating the bucket id to compare with (as a threshold) for split in each node. See above for details like shapes and sizes.
		///   left_node_contribs_list: A list of Rank 2 tensors indicating the contribution of the left nodes when branching from parent nodes (given by the tensor element in the output node_ids_list) to the left direction by the given threshold for each feature. This value will be used to make the left node value by adding to the parent node value. Second dimension size is 1 for 1-dimensional logits, but would be larger for multi-class problems. See above for details like shapes and sizes.
		///   right_node_contribs_list: A list of Rank 2 tensors, with the same shape/conditions as left_node_contribs_list, but just that the value is for the right node.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The split information is the best threshold (bucket id), gains and left/right node contributions per node for each feature.
		///   
		///   It is possible that not all nodes can be split on each feature. Hence, the list of possible nodes can differ between the features. Therefore, we return <c>node_ids_list</c> for each feature, containing the list of nodes that this feature can be used to split.
		///   
		///   In this manner, the output is the best split per features and per node, so that it needs to be combined later to produce the best split for each node (among all possible features).
		///   
		///   The length of output lists are all of the same length, <c>num_features</c>.
		///   The output shapes are compatible in a way that the first dimension of all tensors of all lists are the same and equal to the number of possible split nodes for each feature.
		/// </remarks>
		public (TF_Output[] node_ids_list, TF_Output[] gains_list, TF_Output[] thresholds_list, TF_Output[] left_node_contribs_list, TF_Output[] right_node_contribs_list) BoostedTreesCalculateBestGainsPerFeature (TF_Output node_id_range, TF_Output[] stats_summary_list, TF_Output l1, TF_Output l2, TF_Output tree_complexity, TF_Output min_node_weight, long max_splits, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesCalculateBestGainsPerFeature", MakeName ("BoostedTreesCalculateBestGainsPerFeature", operName));
			c_api.TF_AddInput(desc, node_id_range);
			c_api.TF_AddInputList(desc, stats_summary_list[0], stats_summary_list.Length);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, tree_complexity);
			c_api.TF_AddInput(desc, min_node_weight);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "max_splits", max_splits);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "node_ids_list", status);
			var node_ids_list = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				node_ids_list [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "gains_list", status);
			var gains_list = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				gains_list [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "thresholds_list", status);
			var thresholds_list = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				thresholds_list [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "left_node_contribs_list", status);
			var left_node_contribs_list = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				left_node_contribs_list [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "right_node_contribs_list", status);
			var right_node_contribs_list = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				right_node_contribs_list [i] = new TF_Output (op, _idx++);
			
			return (node_ids_list, gains_list, thresholds_list, left_node_contribs_list, right_node_contribs_list);
		}

		/// <summary>
		///   Calculates the prior from the training data (the bias) and fills in the first node with the logits' prior. Returns a boolean indicating whether to continue centering.
		/// </summary>
		/// <param name="tree_ensemble_handle">
		///   Handle to the tree ensemble.
		/// </param>
		/// <param name="mean_gradients">
		///   A tensor with shape=[logits_dimension] with mean of gradients for a first node.
		/// </param>
		/// <param name="mean_hessians">
		///   A tensor with shape=[logits_dimension] mean of hessians for a first node.
		/// </param>
		/// <param name="l1">
		///   l1 regularization factor on leaf weights, per instance based.
		/// </param>
		/// <param name="l2">
		///   l2 regularization factor on leaf weights, per instance based.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesCenterBias'.
		/// </param>
		/// <returns>
		///   Bool, whether to continue bias centering.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BoostedTreesCenterBias (TF_Output tree_ensemble_handle, TF_Output mean_gradients, TF_Output mean_hessians, TF_Output l1, TF_Output l2, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesCenterBias", MakeName ("BoostedTreesCenterBias", operName));
			c_api.TF_AddInput(desc, tree_ensemble_handle);
			c_api.TF_AddInput(desc, mean_gradients);
			c_api.TF_AddInput(desc, mean_hessians);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var continue_centering = new TF_Output (op, _idx++);
			return continue_centering;
		}

		/// <summary>
		///   Creates a tree ensemble model and returns a handle to it.
		/// </summary>
		/// <param name="tree_ensemble_handle">
		///   Handle to the tree ensemble resource to be created.
		/// </param>
		/// <param name="stamp_token">
		///   Token to use as the initial value of the resource stamp.
		/// </param>
		/// <param name="tree_ensemble_serialized">
		///   Serialized proto of the tree ensemble.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesCreateEnsemble'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation BoostedTreesCreateEnsemble (TF_Output tree_ensemble_handle, TF_Output stamp_token, TF_Output tree_ensemble_serialized, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesCreateEnsemble", MakeName ("BoostedTreesCreateEnsemble", operName));
			c_api.TF_AddInput(desc, tree_ensemble_handle);
			c_api.TF_AddInput(desc, stamp_token);
			c_api.TF_AddInput(desc, tree_ensemble_serialized);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Create the Resource for Quantile Streams.
		/// </summary>
		/// <param name="quantile_stream_resource_handle">
		///   resource; Handle to quantile stream resource.
		/// </param>
		/// <param name="epsilon">
		///   float; The required approximation error of the stream resource.
		/// </param>
		/// <param name="num_streams">
		///   int; The number of streams managed by the resource that shares the same epsilon.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesCreateQuantileStreamResource'.
		/// </param>
		/// <param name="max_elements">
		///   Optional argument
		///   int; The maximum number of data points that can be fed to the stream.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation BoostedTreesCreateQuantileStreamResource (TF_Output quantile_stream_resource_handle, TF_Output epsilon, TF_Output num_streams, long? max_elements = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesCreateQuantileStreamResource", MakeName ("BoostedTreesCreateQuantileStreamResource", operName));
			c_api.TF_AddInput(desc, quantile_stream_resource_handle);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, num_streams);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (max_elements.HasValue)
				c_api.TF_SetAttrInt (desc, "max_elements", max_elements.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Deserializes a serialized tree ensemble config and replaces current tree
		/// </summary>
		/// <param name="tree_ensemble_handle">
		///   Handle to the tree ensemble.
		/// </param>
		/// <param name="stamp_token">
		///   Token to use as the new value of the resource stamp.
		/// </param>
		/// <param name="tree_ensemble_serialized">
		///   Serialized proto of the ensemble.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesDeserializeEnsemble'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   ensemble.
		/// </remarks>
		public TF_Operation BoostedTreesDeserializeEnsemble (TF_Output tree_ensemble_handle, TF_Output stamp_token, TF_Output tree_ensemble_serialized, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesDeserializeEnsemble", MakeName ("BoostedTreesDeserializeEnsemble", operName));
			c_api.TF_AddInput(desc, tree_ensemble_handle);
			c_api.TF_AddInput(desc, stamp_token);
			c_api.TF_AddInput(desc, tree_ensemble_serialized);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Creates a handle to a BoostedTreesEnsembleResource
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesEnsembleResourceHandleOp'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BoostedTreesEnsembleResourceHandleOp (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesEnsembleResourceHandleOp", MakeName ("BoostedTreesEnsembleResourceHandleOp", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var resource = new TF_Output (op, _idx++);
			return resource;
		}

		/// <summary>
		///   Debugging/model interpretability outputs for each example.
		/// </summary>
		/// <param name="tree_ensemble_handle">
		/// </param>
		/// <param name="bucketized_features">
		///   A list of rank 1 Tensors containing bucket id for each
		///   feature.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesExampleDebugOutputs'.
		/// </param>
		/// <param name="logits_dimension">
		///   scalar, dimension of the logits, to be used for constructing the protos in
		///   examples_debug_outputs_serialized.
		/// </param>
		/// <returns>
		///   Output rank 1 Tensor containing a proto serialized as a string for each example.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   It traverses all the trees and computes debug metrics for individual examples,
		///   such as getting split feature ids and logits after each split along the decision
		///   path used to compute directional feature contributions.
		/// </remarks>
		public TF_Output BoostedTreesExampleDebugOutputs (TF_Output tree_ensemble_handle, TF_Output[] bucketized_features, long logits_dimension, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesExampleDebugOutputs", MakeName ("BoostedTreesExampleDebugOutputs", operName));
			c_api.TF_AddInput(desc, tree_ensemble_handle);
			c_api.TF_AddInputList(desc, bucketized_features[0], bucketized_features.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "logits_dimension", logits_dimension);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var examples_debug_outputs_serialized = new TF_Output (op, _idx++);
			return examples_debug_outputs_serialized;
		}

		/// <summary>
		///   Flush the quantile summaries from each quantile stream resource.
		/// </summary>
		/// <param name="quantile_stream_resource_handle">
		///   resource handle referring to a QuantileStreamResource.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesFlushQuantileSummaries'.
		/// </param>
		/// <param name="num_features">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   An op that outputs a list of quantile summaries of a quantile stream resource.
		///   Each summary Tensor is rank 2, containing summaries (value, weight, min_rank,
		///   max_rank) for a single feature.
		/// </remarks>
		public TF_Output[] BoostedTreesFlushQuantileSummaries (TF_Output quantile_stream_resource_handle, long num_features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesFlushQuantileSummaries", MakeName ("BoostedTreesFlushQuantileSummaries", operName));
			c_api.TF_AddInput(desc, quantile_stream_resource_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_features", num_features);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "summaries", status);
			var summaries = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				summaries [i] = new TF_Output (op, _idx++);
			
			return summaries;
		}

		/// <summary>
		///   Retrieves the tree ensemble resource stamp token, number of trees and growing statistics.
		/// </summary>
		/// <param name="tree_ensemble_handle">
		///   Handle to the tree ensemble.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesGetEnsembleStates'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   stamp_token: Stamp token of the tree ensemble resource.
		///   num_trees: The number of trees in the tree ensemble resource.
		///   num_finalized_trees: The number of trees that were finished successfully.
		///   num_attempted_layers: The number of layers we attempted to build (but not necessarily succeeded).
		///   last_layer_nodes_range: Rank size 2 tensor that contains start and end ids of the nodes in the latest
		///   layer.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output stamp_token, TF_Output num_trees, TF_Output num_finalized_trees, TF_Output num_attempted_layers, TF_Output last_layer_nodes_range) BoostedTreesGetEnsembleStates (TF_Output tree_ensemble_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesGetEnsembleStates", MakeName ("BoostedTreesGetEnsembleStates", operName));
			c_api.TF_AddInput(desc, tree_ensemble_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var stamp_token = new TF_Output (op, _idx++);
			var num_trees = new TF_Output (op, _idx++);
			var num_finalized_trees = new TF_Output (op, _idx++);
			var num_attempted_layers = new TF_Output (op, _idx++);
			var last_layer_nodes_range = new TF_Output (op, _idx++);
			return (stamp_token, num_trees, num_finalized_trees, num_attempted_layers, last_layer_nodes_range);
		}

		/// <summary>
		///   Makes the summary of quantiles for the batch.
		/// </summary>
		/// <param name="float_values">
		///   float; List of Rank 1 Tensors each containing values for a single feature.
		/// </param>
		/// <param name="example_weights">
		///   float; Rank 1 Tensor with weights per instance.
		/// </param>
		/// <param name="epsilon">
		///   float; The required maximum approximation error.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesMakeQuantileSummaries'.
		/// </param>
		/// <returns>
		///   float; List of Rank 2 Tensors each containing the quantile summary
		///   (value, weight, min_rank, max_rank) of a single feature.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   An op that takes a list of tensors (one tensor per feature) and outputs the
		///   quantile summaries for each tensor.
		/// </remarks>
		public TF_Output[] BoostedTreesMakeQuantileSummaries (TF_Output[] float_values, TF_Output example_weights, TF_Output epsilon, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesMakeQuantileSummaries", MakeName ("BoostedTreesMakeQuantileSummaries", operName));
			c_api.TF_AddInputList(desc, float_values[0], float_values.Length);
			c_api.TF_AddInput(desc, example_weights);
			c_api.TF_AddInput(desc, epsilon);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "summaries", status);
			var summaries = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				summaries [i] = new TF_Output (op, _idx++);
			
			return summaries;
		}

		/// <summary>
		///   Makes the summary of accumulated stats for the batch.
		/// </summary>
		/// <param name="node_ids">
		///   int32 Rank 1 Tensor containing node ids, which each example falls into for the requested layer.
		/// </param>
		/// <param name="gradients">
		///   float32; Rank 2 Tensor (shape=[#examples, 1]) for gradients.
		/// </param>
		/// <param name="hessians">
		///   float32; Rank 2 Tensor (shape=[#examples, 1]) for hessians.
		/// </param>
		/// <param name="bucketized_features_list">
		///   int32 list of Rank 1 Tensors, each containing the bucketized feature (for each feature column).
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesMakeStatsSummary'.
		/// </param>
		/// <param name="max_splits">
		///   int; the maximum number of splits possible in the whole tree.
		/// </param>
		/// <param name="num_buckets">
		///   int; equals to the maximum possible value of bucketized feature.
		/// </param>
		/// <returns>
		///   output Rank 4 Tensor (shape=[#features, #splits, #buckets, 2]) containing accumulated stats put into the corresponding node and bucket. The first index of 4th dimension refers to gradients, and the second to hessians.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The summary stats contains gradients and hessians accumulated into the corresponding node and bucket for each example.
		/// </remarks>
		public TF_Output BoostedTreesMakeStatsSummary (TF_Output node_ids, TF_Output gradients, TF_Output hessians, TF_Output[] bucketized_features_list, long max_splits, long num_buckets, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesMakeStatsSummary", MakeName ("BoostedTreesMakeStatsSummary", operName));
			c_api.TF_AddInput(desc, node_ids);
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, hessians);
			c_api.TF_AddInputList(desc, bucketized_features_list[0], bucketized_features_list.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "max_splits", max_splits);
			c_api.TF_SetAttrInt (desc, "num_buckets", num_buckets);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var stats_summary = new TF_Output (op, _idx++);
			return stats_summary;
		}

		/// <summary>
		///   Runs multiple additive regression ensemble predictors on input instances and
		/// </summary>
		/// <param name="tree_ensemble_handle">
		/// </param>
		/// <param name="bucketized_features">
		///   A list of rank 1 Tensors containing bucket id for each
		///   feature.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesPredict'.
		/// </param>
		/// <param name="logits_dimension">
		///   scalar, dimension of the logits, to be used for partial logits
		///   shape.
		/// </param>
		/// <returns>
		///   Output rank 2 Tensor containing logits for each example.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   computes the logits. It is designed to be used during prediction.
		///   It traverses all the trees and calculates the final score for each instance.
		/// </remarks>
		public TF_Output BoostedTreesPredict (TF_Output tree_ensemble_handle, TF_Output[] bucketized_features, long logits_dimension, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesPredict", MakeName ("BoostedTreesPredict", operName));
			c_api.TF_AddInput(desc, tree_ensemble_handle);
			c_api.TF_AddInputList(desc, bucketized_features[0], bucketized_features.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "logits_dimension", logits_dimension);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var logits = new TF_Output (op, _idx++);
			return logits;
		}

		/// <summary>
		///   Add the quantile summaries to each quantile stream resource.
		/// </summary>
		/// <param name="quantile_stream_resource_handle">
		///   resource handle referring to a QuantileStreamResource.
		/// </param>
		/// <param name="summaries">
		///   string; List of Rank 2 Tensor each containing the summaries for a single feature.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesQuantileStreamResourceAddSummaries'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   An op that adds a list of quantile summaries to a quantile stream resource. Each
		///   summary Tensor is rank 2, containing summaries (value, weight, min_rank, max_rank)
		///   for a single feature.
		/// </remarks>
		public TF_Operation BoostedTreesQuantileStreamResourceAddSummaries (TF_Output quantile_stream_resource_handle, TF_Output[] summaries, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesQuantileStreamResourceAddSummaries", MakeName ("BoostedTreesQuantileStreamResourceAddSummaries", operName));
			c_api.TF_AddInput(desc, quantile_stream_resource_handle);
			c_api.TF_AddInputList(desc, summaries[0], summaries.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Deserialize bucket boundaries and ready flag into current QuantileAccumulator.
		/// </summary>
		/// <param name="quantile_stream_resource_handle">
		///   resource handle referring to a QuantileStreamResource.
		/// </param>
		/// <param name="bucket_boundaries">
		///   float; List of Rank 1 Tensors each containing the bucket boundaries for a feature.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesQuantileStreamResourceDeserialize'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   An op that deserializes bucket boundaries and are boundaries ready flag into current QuantileAccumulator.
		/// </remarks>
		public TF_Operation BoostedTreesQuantileStreamResourceDeserialize (TF_Output quantile_stream_resource_handle, TF_Output[] bucket_boundaries, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesQuantileStreamResourceDeserialize", MakeName ("BoostedTreesQuantileStreamResourceDeserialize", operName));
			c_api.TF_AddInput(desc, quantile_stream_resource_handle);
			c_api.TF_AddInputList(desc, bucket_boundaries[0], bucket_boundaries.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Flush the summaries for a quantile stream resource.
		/// </summary>
		/// <param name="quantile_stream_resource_handle">
		///   resource handle referring to a QuantileStreamResource.
		/// </param>
		/// <param name="num_buckets">
		///   int; approximate number of buckets unless using generate_quantiles.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesQuantileStreamResourceFlush'.
		/// </param>
		/// <param name="generate_quantiles">
		///   Optional argument
		///   bool; If True, the output will be the num_quantiles for each stream where the ith
		///   entry is the ith quantile of the input with an approximation error of epsilon.
		///   Duplicate values may be present.
		///   If False, the output will be the points in the histogram that we got which roughly
		///   translates to 1/epsilon boundaries and without any duplicates.
		///   Default to False.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   An op that flushes the summaries for a quantile stream resource.
		/// </remarks>
		public TF_Operation BoostedTreesQuantileStreamResourceFlush (TF_Output quantile_stream_resource_handle, TF_Output num_buckets, bool? generate_quantiles = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesQuantileStreamResourceFlush", MakeName ("BoostedTreesQuantileStreamResourceFlush", operName));
			c_api.TF_AddInput(desc, quantile_stream_resource_handle);
			c_api.TF_AddInput(desc, num_buckets);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (generate_quantiles.HasValue)
				c_api.TF_SetAttrBool (desc, "generate_quantiles", Convert.ToByte(generate_quantiles.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Generate the bucket boundaries for each feature based on accumulated summaries.
		/// </summary>
		/// <param name="quantile_stream_resource_handle">
		///   resource handle referring to a QuantileStreamResource.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesQuantileStreamResourceGetBucketBoundaries'.
		/// </param>
		/// <param name="num_features">
		///   inferred int; number of features to get bucket boundaries for.
		/// </param>
		/// <returns>
		///   float; List of Rank 1 Tensors each containing the bucket boundaries for a feature.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   An op that returns a list of float tensors for a quantile stream resource. Each
		///   tensor is Rank 1 containing bucket boundaries for a single feature.
		/// </remarks>
		public TF_Output[] BoostedTreesQuantileStreamResourceGetBucketBoundaries (TF_Output quantile_stream_resource_handle, long num_features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesQuantileStreamResourceGetBucketBoundaries", MakeName ("BoostedTreesQuantileStreamResourceGetBucketBoundaries", operName));
			c_api.TF_AddInput(desc, quantile_stream_resource_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_features", num_features);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "bucket_boundaries", status);
			var bucket_boundaries = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				bucket_boundaries [i] = new TF_Output (op, _idx++);
			
			return bucket_boundaries;
		}

		/// <summary>
		///   Creates a handle to a BoostedTreesQuantileStreamResource.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesQuantileStreamResourceHandleOp'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BoostedTreesQuantileStreamResourceHandleOp (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesQuantileStreamResourceHandleOp", MakeName ("BoostedTreesQuantileStreamResourceHandleOp", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var resource = new TF_Output (op, _idx++);
			return resource;
		}

		/// <summary>
		///   Serializes the tree ensemble to a proto.
		/// </summary>
		/// <param name="tree_ensemble_handle">
		///   Handle to the tree ensemble.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesSerializeEnsemble'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   stamp_token: Stamp token of the tree ensemble resource.
		///   tree_ensemble_serialized: Serialized proto of the ensemble.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output stamp_token, TF_Output tree_ensemble_serialized) BoostedTreesSerializeEnsemble (TF_Output tree_ensemble_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesSerializeEnsemble", MakeName ("BoostedTreesSerializeEnsemble", operName));
			c_api.TF_AddInput(desc, tree_ensemble_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var stamp_token = new TF_Output (op, _idx++);
			var tree_ensemble_serialized = new TF_Output (op, _idx++);
			return (stamp_token, tree_ensemble_serialized);
		}

		/// <summary>
		///   Aggregates the summary of accumulated stats for the batch.
		/// </summary>
		/// <param name="node_ids">
		///   int32; Rank 1 Tensor containing node ids for each example, shape [batch_size].
		/// </param>
		/// <param name="gradients">
		///   float32; Rank 2 Tensor (shape=[batch_size, logits_dimension]) with gradients for each example.
		/// </param>
		/// <param name="hessians">
		///   float32; Rank 2 Tensor (shape=[batch_size, hessian_dimension]) with hessians for each example.
		/// </param>
		/// <param name="feature_indices">
		///   int32; Rank 2 indices of feature sparse Tensors (shape=[number of sparse entries, 2]).
		///   Number of sparse entries across all instances from the batch. The first value is
		///   the index of the instance, the second is dimension of the feature. The second axis
		///   can only have 2 values, i.e., the input dense version of Tensor can only be matrix.
		/// </param>
		/// <param name="feature_values">
		///   int32; Rank 1 values of feature sparse Tensors (shape=[number of sparse entries]).
		///   Number of sparse entries across all instances from the batch. The first value is
		///   the index of the instance, the second is dimension of the feature.
		/// </param>
		/// <param name="feature_shape">
		///   int32; Rank 1 dense shape of feature sparse Tensors (shape=[2]).
		///   The first axis can only have 2 values, [batch_size, feature_dimension].
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesSparseAggregateStats'.
		/// </param>
		/// <param name="max_splits">
		///   int; the maximum number of splits possible in the whole tree.
		/// </param>
		/// <param name="num_buckets">
		///   int; equals to the maximum possible value of bucketized feature + 1.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   stats_summary_indices: int32; Rank 2 indices of summary sparse Tensors (shape=[number of non zero statistics, 4])
		///   The second axis can only be 4 including node id, feature dimension, bucket id, and statistics_dimension.
		///   statistics_dimension = logits_dimension + hessian_dimension.
		///   stats_summary_values: output Rank 1 Tensor (shape=[number of non zero statistics])
		///   stats_summary_shape: output Rank 1 Tensor (shape=[4])
		///   The tensor has following 4 values: [max_splits, feature_dimension, num_buckets, statistics_dimension],
		///   where statistics_dimension = gradient_dimension + hessian_dimension. gradient_dimension
		///   is the same as label_dimension, i.e., the output space. hessian_dimension can be the same
		///   as logits dimension when diagonal hessian is used, or label_dimension^2 when full
		///   hessian is used.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The summary stats contains gradients and hessians accumulated for each node, bucket and dimension id.
		/// </remarks>
		public (TF_Output stats_summary_indices, TF_Output stats_summary_values, TF_Output stats_summary_shape) BoostedTreesSparseAggregateStats (TF_Output node_ids, TF_Output gradients, TF_Output hessians, TF_Output feature_indices, TF_Output feature_values, TF_Output feature_shape, long max_splits, long num_buckets, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesSparseAggregateStats", MakeName ("BoostedTreesSparseAggregateStats", operName));
			c_api.TF_AddInput(desc, node_ids);
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, hessians);
			c_api.TF_AddInput(desc, feature_indices);
			c_api.TF_AddInput(desc, feature_values);
			c_api.TF_AddInput(desc, feature_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "max_splits", max_splits);
			c_api.TF_SetAttrInt (desc, "num_buckets", num_buckets);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var stats_summary_indices = new TF_Output (op, _idx++);
			var stats_summary_values = new TF_Output (op, _idx++);
			var stats_summary_shape = new TF_Output (op, _idx++);
			return (stats_summary_indices, stats_summary_values, stats_summary_shape);
		}

		/// <summary>
		///   Calculates gains for each feature and returns the best possible split information for the feature.
		/// </summary>
		/// <param name="node_id_range">
		///   A Rank 1 tensor (shape=[2]) to specify the range [first, last) of node ids to process within <c>stats_summary_list</c>. The nodes are iterated between the two nodes specified by the tensor, as like <c>for node_id in range(node_id_range[0], node_id_range[1])</c> (Note that the last index node_id_range[1] is exclusive).
		/// </param>
		/// <param name="stats_summary_indices">
		///   A Rank 2 int64 tensor of dense shape [N, 4] (N specifies the number of non-zero values) for accumulated stats summary (gradient/hessian) per node per bucket for each feature. The second dimension contains node id, feature dimension, bucket id, and stats dim.
		///   stats dim is the sum of logits dimension and hessian dimension, hessian dimension can either be logits dimension if diagonal hessian is used, or logits dimension^2 if full hessian is used.
		/// </param>
		/// <param name="stats_summary_values">
		///   A Rank 1 float tensor of dense shape [N] (N specifies the number of non-zero values), which supplies the values for each element in summary_indices.
		/// </param>
		/// <param name="stats_summary_shape">
		///   A Rank 1 float tensor of dense shape [4], which specifies the dense shape of the sparse tensor, which is [num tree nodes, feature dimensions, num buckets, stats dim].
		/// </param>
		/// <param name="l1">
		///   l1 regularization factor on leaf weights, per instance based.
		/// </param>
		/// <param name="l2">
		///   l2 regularization factor on leaf weights, per instance based.
		/// </param>
		/// <param name="tree_complexity">
		///   adjustment to the gain, per leaf based.
		/// </param>
		/// <param name="min_node_weight">
		///   mininum avg of hessians in a node before required for the node to be considered for splitting.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesSparseCalculateBestFeatureSplit'.
		/// </param>
		/// <param name="split_type">
		///   Optional argument
		///   A string indicating if this Op should perform inequality split or equality split.
		/// </param>
		/// <param name="logits_dimension">
		///   The dimension of logit, i.e., number of classes.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   node_ids: A Rank 1 tensor indicating possible node ids that can be split.
		///   gains: A Rank 1 tensor indicating the best gains to split each node.
		///   feature_dimensions: A Rank 1 tensor indicating the best feature dimension for each feature to split for each node.
		///   thresholds: A Rank 1 tensor indicating the bucket id to compare with (as a threshold) for split in each node.
		///   left_node_contribs: A Rank 2 tensor indicating the contribution of the left nodes when branching from parent nodes to the left direction by the given threshold for each feature.
		///   This value will be used to make the left node value by adding to the parent node value. Second dimension size is logits dimension.
		///   right_node_contribs: A Rank 2 tensor, with the same shape/conditions as left_node_contribs_list, but just that the value is for the right node.
		///   split_with_default_directions: A Rank 1 tensor indicating which direction to go if data is missing.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The split information is the best threshold (bucket id), gains and left/right node contributions per node for each feature.
		///   
		///   It is possible that not all nodes can be split on each feature. Hence, the list of possible nodes can differ between the features. Therefore, we return <c>node_ids_list</c> for each feature, containing the list of nodes that this feature can be used to split.
		///   
		///   In this manner, the output is the best split per features and per node, so that it needs to be combined later to produce the best split for each node (among all possible features).
		///   
		///   The output shapes are compatible in a way that the first dimension of all tensors are the same and equal to the number of possible split nodes for each feature.
		/// </remarks>
		public (TF_Output node_ids, TF_Output gains, TF_Output feature_dimensions, TF_Output thresholds, TF_Output left_node_contribs, TF_Output right_node_contribs, TF_Output split_with_default_directions) BoostedTreesSparseCalculateBestFeatureSplit (TF_Output node_id_range, TF_Output stats_summary_indices, TF_Output stats_summary_values, TF_Output stats_summary_shape, TF_Output l1, TF_Output l2, TF_Output tree_complexity, TF_Output min_node_weight, long logits_dimension, string split_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesSparseCalculateBestFeatureSplit", MakeName ("BoostedTreesSparseCalculateBestFeatureSplit", operName));
			c_api.TF_AddInput(desc, node_id_range);
			c_api.TF_AddInput(desc, stats_summary_indices);
			c_api.TF_AddInput(desc, stats_summary_values);
			c_api.TF_AddInput(desc, stats_summary_shape);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, tree_complexity);
			c_api.TF_AddInput(desc, min_node_weight);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "logits_dimension", logits_dimension);
			if (split_type != null)
				c_api.TF_SetAttrString (desc, "split_type", split_type);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var node_ids = new TF_Output (op, _idx++);
			var gains = new TF_Output (op, _idx++);
			var feature_dimensions = new TF_Output (op, _idx++);
			var thresholds = new TF_Output (op, _idx++);
			var left_node_contribs = new TF_Output (op, _idx++);
			var right_node_contribs = new TF_Output (op, _idx++);
			var split_with_default_directions = new TF_Output (op, _idx++);
			return (node_ids, gains, feature_dimensions, thresholds, left_node_contribs, right_node_contribs, split_with_default_directions);
		}

		/// <summary>
		///   Runs multiple additive regression ensemble predictors on input instances and
		/// </summary>
		/// <param name="tree_ensemble_handle">
		/// </param>
		/// <param name="cached_tree_ids">
		///   Rank 1 Tensor containing cached tree ids which is the starting
		///   tree of prediction.
		/// </param>
		/// <param name="cached_node_ids">
		///   Rank 1 Tensor containing cached node id which is the starting
		///   node of prediction.
		/// </param>
		/// <param name="bucketized_features">
		///   A list of rank 1 Tensors containing bucket id for each
		///   feature.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesTrainingPredict'.
		/// </param>
		/// <param name="logits_dimension">
		///   scalar, dimension of the logits, to be used for partial logits
		///   shape.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   partial_logits: Rank 2 Tensor containing logits update (with respect to cached
		///   values stored) for each example.
		///   tree_ids: Rank 1 Tensor containing new tree ids for each example.
		///   node_ids: Rank 1 Tensor containing new node ids in the new tree_ids.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   computes the update to cached logits. It is designed to be used during training.
		///   It traverses the trees starting from cached tree id and cached node id and
		///   calculates the updates to be pushed to the cache.
		/// </remarks>
		public (TF_Output partial_logits, TF_Output tree_ids, TF_Output node_ids) BoostedTreesTrainingPredict (TF_Output tree_ensemble_handle, TF_Output cached_tree_ids, TF_Output cached_node_ids, TF_Output[] bucketized_features, long logits_dimension, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesTrainingPredict", MakeName ("BoostedTreesTrainingPredict", operName));
			c_api.TF_AddInput(desc, tree_ensemble_handle);
			c_api.TF_AddInput(desc, cached_tree_ids);
			c_api.TF_AddInput(desc, cached_node_ids);
			c_api.TF_AddInputList(desc, bucketized_features[0], bucketized_features.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "logits_dimension", logits_dimension);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var partial_logits = new TF_Output (op, _idx++);
			var tree_ids = new TF_Output (op, _idx++);
			var node_ids = new TF_Output (op, _idx++);
			return (partial_logits, tree_ids, node_ids);
		}

		/// <summary>
		///   Updates the tree ensemble by either adding a layer to the last tree being grown
		/// </summary>
		/// <param name="tree_ensemble_handle">
		///   Handle to the ensemble variable.
		/// </param>
		/// <param name="feature_ids">
		///   Rank 1 tensor with ids for each feature. This is the real id of
		///   the feature that will be used in the split.
		/// </param>
		/// <param name="node_ids">
		///   List of rank 1 tensors representing the nodes for which this feature
		///   has a split.
		/// </param>
		/// <param name="gains">
		///   List of rank 1 tensors representing the gains for each of the feature's
		///   split.
		/// </param>
		/// <param name="thresholds">
		///   List of rank 1 tensors representing the thesholds for each of the
		///   feature's split.
		/// </param>
		/// <param name="left_node_contribs">
		///   List of rank 2 tensors with left leaf contribs for each of
		///   the feature's splits. Will be added to the previous node values to constitute
		///   the values of the left nodes.
		/// </param>
		/// <param name="right_node_contribs">
		///   List of rank 2 tensors with right leaf contribs for each
		///   of the feature's splits. Will be added to the previous node values to constitute
		///   the values of the right nodes.
		/// </param>
		/// <param name="max_depth">
		///   Max depth of the tree to build.
		/// </param>
		/// <param name="learning_rate">
		///   shrinkage const for each new tree.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesUpdateEnsemble'.
		/// </param>
		/// <param name="pruning_mode">
		///   0-No pruning, 1-Pre-pruning, 2-Post-pruning.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   or by starting a new tree.
		/// </remarks>
		public TF_Operation BoostedTreesUpdateEnsemble (TF_Output tree_ensemble_handle, TF_Output feature_ids, TF_Output[] node_ids, TF_Output[] gains, TF_Output[] thresholds, TF_Output[] left_node_contribs, TF_Output[] right_node_contribs, TF_Output max_depth, TF_Output learning_rate, long pruning_mode, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BoostedTreesUpdateEnsemble", MakeName ("BoostedTreesUpdateEnsemble", operName));
			c_api.TF_AddInput(desc, tree_ensemble_handle);
			c_api.TF_AddInput(desc, feature_ids);
			c_api.TF_AddInputList(desc, node_ids[0], node_ids.Length);
			c_api.TF_AddInputList(desc, gains[0], gains.Length);
			c_api.TF_AddInputList(desc, thresholds[0], thresholds.Length);
			c_api.TF_AddInputList(desc, left_node_contribs[0], left_node_contribs.Length);
			c_api.TF_AddInputList(desc, right_node_contribs[0], right_node_contribs.Length);
			c_api.TF_AddInput(desc, max_depth);
			c_api.TF_AddInput(desc, learning_rate);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "pruning_mode", pruning_mode);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Return the shape of s0 op s1 with broadcast.
		/// </summary>
		/// <param name="s0">
		/// </param>
		/// <param name="s1">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BroadcastArgs'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given <c>s0</c> and <c>s1</c>, tensors that represent shapes, compute <c>r0</c>, the
		///   broadcasted shape. <c>s0</c>, <c>s1</c> and <c>r0</c> are all integer vectors.
		/// </remarks>
		public TF_Output BroadcastArgs (TF_Output s0, TF_Output s1, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BroadcastArgs", MakeName ("BroadcastArgs", operName));
			c_api.TF_AddInput(desc, s0);
			c_api.TF_AddInput(desc, s1);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var r0 = new TF_Output (op, _idx++);
			return r0;
		}

		/// <summary>
		///   Return the reduction indices for computing gradients of s0 op s1 with broadcast.
		/// </summary>
		/// <param name="s0">
		/// </param>
		/// <param name="s1">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BroadcastGradientArgs'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   r0:
		///   r1:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   This is typically used by gradient computations for a broadcasting operation.
		/// </remarks>
		public (TF_Output r0, TF_Output r1) BroadcastGradientArgs (TF_Output s0, TF_Output s1, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BroadcastGradientArgs", MakeName ("BroadcastGradientArgs", operName));
			c_api.TF_AddInput(desc, s0);
			c_api.TF_AddInput(desc, s1);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var r0 = new TF_Output (op, _idx++);
			var r1 = new TF_Output (op, _idx++);
			return (r0, r1);
		}

		/// <summary>
		///   Broadcast an array for a compatible shape.
		/// </summary>
		/// <param name="input">
		///   A Tensor to broadcast.
		/// </param>
		/// <param name="shape">
		///   An 1-D <c>int</c> Tensor. The shape of the desired output.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BroadcastTo'.
		/// </param>
		/// <returns>
		///   A Tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Broadcasting is the process of making arrays to have compatible shapes
		///   for arithmetic operations. Two shapes are compatible if for each
		///   dimension pair they are either equal or one of them is one. When trying
		///   to broadcast a Tensor to a shape, it starts with the trailing dimensions,
		///   and works its way forward.
		///   
		///   For example,
		///   
		///    <code>
		///   &amp;gt;&amp;gt;&amp;gt; x = tf.constant([1, 2, 3])
		///   &amp;gt;&amp;gt;&amp;gt; y = tf.broadcast_to(x, [3, 3])
		///   &amp;gt;&amp;gt;&amp;gt; sess.run(y)
		///   array([[1, 2, 3],
		///   [1, 2, 3],
		///   [1, 2, 3]], dtype=int32)
		///    </code>
		///   
		///   In the above example, the input Tensor with the shape of <c>[1, 3]</c>
		///   is broadcasted to output Tensor with shape of <c>[3, 3]</c>.
		/// </remarks>
		public TF_Output BroadcastTo (TF_Output input, TF_Output shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BroadcastTo", MakeName ("BroadcastTo", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Bucketizes 'input' based on 'boundaries'.
		/// </summary>
		/// <param name="input">
		///   Any shape of Tensor contains with int or float type.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Bucketize'.
		/// </param>
		/// <param name="boundaries">
		///   A sorted list of floats gives the boundary of the buckets.
		/// </param>
		/// <returns>
		///   Same shape with 'input', each value of input replaced with bucket index.
		///   
		///   @compatibility(numpy)
		///   Equivalent to np.digitize.
		///   @end_compatibility
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   For example, if the inputs are
		///   boundaries = [0, 10, 100]
		///   input = [[-5, 10000]
		///   [150,   10]
		///   [5,    100]]
		///   
		///   then the output will be
		///   output = [[0, 3]
		///   [3, 2]
		///   [1, 3]]
		/// </remarks>
		public TF_Output Bucketize (TF_Output input, float[] boundaries, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Bucketize", MakeName ("Bucketize", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFloatList (desc, "boundaries", ref boundaries[0], boundaries.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Records the bytes size of each element of <c>input_dataset</c> in a StatsAggregator.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'BytesProducedStatsDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output BytesProducedStatsDataset (TF_Output input_dataset, TF_Output tag, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "BytesProducedStatsDataset", MakeName ("BytesProducedStatsDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, tag);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that caches elements from <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="filename">
		///   A path on the filesystem where we should cache the dataset. Note: this
		///   will be a directory.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CacheDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   A CacheDataset will iterate over the input_dataset, and store tensors. If the
		///   cache already exists, the cache will be used. If the cache is inappropriate
		///   (e.g. cannot be opened, contains tensors of the wrong shape / size), an error
		///   will the returned when used.
		/// </remarks>
		public TF_Output CacheDataset (TF_Output input_dataset, TF_Output filename, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CacheDataset", MakeName ("CacheDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, filename);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="filename">
		/// </param>
		/// <param name="cache">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CacheDatasetV2'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CacheDatasetV2 (TF_Output input_dataset, TF_Output filename, TF_Output cache, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CacheDatasetV2", MakeName ("CacheDatasetV2", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, filename);
			c_api.TF_AddInput(desc, cache);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   An n-way switch statement which calls a single branch function.
		/// </summary>
		/// <param name="branch_index">
		///   The branch selector, an int32 Tensor.
		/// </param>
		/// <param name="input">
		///   A list of input tensors passed to the branch function.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Case'.
		/// </param>
		/// <param name="output_shapes">
		///   Optional argument
		/// </param>
		/// <param name="Tout">
		///   A list of output types.
		/// </param>
		/// <param name="branches">
		///   A list of functions each of which takes 'inputs' and returns a list of
		///   tensors, whose types are the same as what every other branch returns.
		/// </param>
		/// <returns>
		///   A list of return values.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   An n-way switch statement, implementing the following:
		///    <code>
		///   switch (branch_index) {
		///   case 0:
		///   output = branches[0](input);
		///   break;
		///   case 1:
		///   output = branches[1](input);
		///   break;
		///   ...
		///   case [[nbranches-1]]:
		///   default:
		///   output = branches[nbranches-1](input);
		///   break;
		///   }
		///    </code>
		/// </remarks>
		public TF_Output[] Case (TF_Output branch_index, TF_Output[] input, TF_DataType[] Tout, TF_Function[] branches, long[][] output_shapes = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Case", MakeName ("Case", operName));
			c_api.TF_AddInput(desc, branch_index);
			c_api.TF_AddInputList(desc, input[0], input.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "Tout", Tout);
			c_api.TF_SetAttrFuncNames (desc, "branches", c_api.TF_FunctionNames(branches));
			if (output_shapes != null)
				c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		///   Cast x of type SrcT to y of DstT.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Cast'.
		/// </param>
		/// <param name="Truncate">
		///   Optional argument
		/// </param>
		/// <param name="DstT">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Cast (TF_Output x, TF_DataType DstT, bool? Truncate = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Cast", MakeName ("Cast", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "DstT", DstT);
			if (Truncate.HasValue)
				c_api.TF_SetAttrBool (desc, "Truncate", Convert.ToByte(Truncate.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Returns element-wise smallest integer not less than x.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Ceil'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Ceil (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Ceil", MakeName ("Ceil", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Checks a tensor for NaN and Inf values.
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CheckNumerics'.
		/// </param>
		/// <param name="message">
		///   Prefix of the error message.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   When run, reports an <c>InvalidArgument</c> error if <c>tensor</c> has any values
		///   that are not a number (NaN) or infinity (Inf). Otherwise, passes <c>tensor</c> as-is.
		/// </remarks>
		public TF_Output CheckNumerics (TF_Output tensor, string message, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CheckNumerics", MakeName ("CheckNumerics", operName));
			c_api.TF_AddInput(desc, tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "message", message);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the Cholesky decomposition of one or more square matrices.
		/// </summary>
		/// <param name="input">
		///   Shape is <c>[..., M, M]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Cholesky'.
		/// </param>
		/// <returns>
		///   Shape is <c>[..., M, M]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The input is a tensor of shape <c>[..., M, M]</c> whose inner-most 2 dimensions
		///   form square matrices.
		///   
		///   The input has to be symmetric and positive definite. Only the lower-triangular
		///   part of the input will be used for this operation. The upper-triangular part
		///   will not be read.
		///   
		///   The output is a tensor of the same shape as the input
		///   containing the Cholesky decompositions for all input submatrices <c>[..., :, :]</c>.
		///   
		///   **Note**: The gradient computation on GPU is faster for large matrices but
		///   not for large batch dimensions when the submatrices are small. In this
		///   case it might be faster to use the CPU.
		/// </remarks>
		public TF_Output Cholesky (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Cholesky", MakeName ("Cholesky", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the reverse mode backpropagated gradient of the Cholesky algorithm.
		/// </summary>
		/// <param name="l">
		///   Output of batch Cholesky algorithm l = cholesky(A). Shape is <c>[..., M, M]</c>.
		///   Algorithm depends only on lower triangular part of the innermost matrices of
		///   this tensor.
		/// </param>
		/// <param name="grad">
		///   df/dl where f is some scalar function. Shape is <c>[..., M, M]</c>.
		///   Algorithm depends only on lower triangular part of the innermost matrices of
		///   this tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CholeskyGrad'.
		/// </param>
		/// <returns>
		///   Symmetrized version of df/dA . Shape is <c>[..., M, M]</c>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   For an explanation see "Differentiation of the Cholesky algorithm" by
		///   Iain Murray http://arxiv.org/abs/1602.07527.
		/// </remarks>
		public TF_Output CholeskyGrad (TF_Output l, TF_Output grad, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CholeskyGrad", MakeName ("CholeskyGrad", operName));
			c_api.TF_AddInput(desc, l);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="ratio_numerator">
		/// </param>
		/// <param name="ratio_denominator">
		/// </param>
		/// <param name="other_arguments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ChooseFastestBranchDataset'.
		/// </param>
		/// <param name="num_elements_per_branch">
		/// </param>
		/// <param name="branches">
		/// </param>
		/// <param name="other_arguments_lengths">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ChooseFastestBranchDataset (TF_Output input_dataset, TF_Output ratio_numerator, TF_Output ratio_denominator, TF_Output[] other_arguments, long num_elements_per_branch, TF_Function[] branches, long[] other_arguments_lengths, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ChooseFastestBranchDataset", MakeName ("ChooseFastestBranchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, ratio_numerator);
			c_api.TF_AddInput(desc, ratio_denominator);
			c_api.TF_AddInputList(desc, other_arguments[0], other_arguments.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_elements_per_branch", num_elements_per_branch);
			c_api.TF_SetAttrFuncNames (desc, "branches", c_api.TF_FunctionNames(branches));
			c_api.TF_SetAttrIntList (desc, "other_arguments_lengths", ref other_arguments_lengths[0], other_arguments_lengths.Length);
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_datasets">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ChooseFastestDataset'.
		/// </param>
		/// <param name="num_experiments">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ChooseFastestDataset (TF_Output[] input_datasets, long num_experiments, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ChooseFastestDataset", MakeName ("ChooseFastestDataset", operName));
			c_api.TF_AddInputList(desc, input_datasets[0], input_datasets.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_experiments", num_experiments);
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Clips tensor values to a specified min and max.
		/// </summary>
		/// <param name="t">
		///   A <c>Tensor</c>.
		/// </param>
		/// <param name="clip_value_min">
		///   A 0-D (scalar) <c>Tensor</c>, or a <c>Tensor</c> with the same shape
		///   as <c>t</c>. The minimum value to clip by.
		/// </param>
		/// <param name="clip_value_max">
		///   A 0-D (scalar) <c>Tensor</c>, or a <c>Tensor</c> with the same shape
		///   as <c>t</c>. The maximum value to clip by.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ClipByValue'.
		/// </param>
		/// <returns>
		///   A clipped <c>Tensor</c> with the same shape as input 't'.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given a tensor <c>t</c>, this operation returns a tensor of the same type and
		///   shape as <c>t</c> with its values clipped to <c>clip_value_min</c> and <c>clip_value_max</c>.
		///   Any values less than <c>clip_value_min</c> are set to <c>clip_value_min</c>. Any values
		///   greater than <c>clip_value_max</c> are set to <c>clip_value_max</c>.
		/// </remarks>
		public TF_Output ClipByValue (TF_Output t, TF_Output clip_value_min, TF_Output clip_value_max, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ClipByValue", MakeName ("ClipByValue", operName));
			c_api.TF_AddInput(desc, t);
			c_api.TF_AddInput(desc, clip_value_min);
			c_api.TF_AddInput(desc, clip_value_max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CloseSummaryWriter'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation CloseSummaryWriter (TF_Output writer, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CloseSummaryWriter", MakeName ("CloseSummaryWriter", operName));
			c_api.TF_AddInput(desc, writer);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Receives a tensor value broadcast from another device.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CollectiveBcastRecv'.
		/// </param>
		/// <param name="T">
		/// </param>
		/// <param name="group_size">
		/// </param>
		/// <param name="group_key">
		/// </param>
		/// <param name="instance_key">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CollectiveBcastRecv (TF_DataType T, long group_size, long group_key, long instance_key, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CollectiveBcastRecv", MakeName ("CollectiveBcastRecv", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "T", T);
			c_api.TF_SetAttrInt (desc, "group_size", group_size);
			c_api.TF_SetAttrInt (desc, "group_key", group_key);
			c_api.TF_SetAttrInt (desc, "instance_key", instance_key);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var data = new TF_Output (op, _idx++);
			return data;
		}

		/// <summary>
		///   Broadcasts a tensor value to one or more other devices.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CollectiveBcastSend'.
		/// </param>
		/// <param name="group_size">
		/// </param>
		/// <param name="group_key">
		/// </param>
		/// <param name="instance_key">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CollectiveBcastSend (TF_Output input, long group_size, long group_key, long instance_key, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CollectiveBcastSend", MakeName ("CollectiveBcastSend", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "group_size", group_size);
			c_api.TF_SetAttrInt (desc, "group_key", group_key);
			c_api.TF_SetAttrInt (desc, "instance_key", instance_key);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var data = new TF_Output (op, _idx++);
			return data;
		}

		/// <summary>
		///   Mutually accumulates multiple tensors of identical type and shape.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CollectiveGather'.
		/// </param>
		/// <param name="group_size">
		/// </param>
		/// <param name="group_key">
		/// </param>
		/// <param name="instance_key">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CollectiveGather (TF_Output input, long group_size, long group_key, long instance_key, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CollectiveGather", MakeName ("CollectiveGather", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "group_size", group_size);
			c_api.TF_SetAttrInt (desc, "group_key", group_key);
			c_api.TF_SetAttrInt (desc, "instance_key", instance_key);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var data = new TF_Output (op, _idx++);
			return data;
		}

		/// <summary>
		///   An Op to permute tensors across replicated TPU instances.
		/// </summary>
		/// <param name="input">
		///   The local input to be permuted. Currently only supports float and
		///   bfloat16.
		/// </param>
		/// <param name="source_target_pairs">
		///   A tensor with shape [num_pairs, 2].
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CollectivePermute'.
		/// </param>
		/// <returns>
		///   The permuted input.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Each instance supplies its own input.
		///   
		///   For example, suppose there are 4 TPU instances: <c>[A, B, C, D]</c>. Passing
		///   source_target_pairs=<c>[[0,1],[1,2],[2,3],[3,0]]</c> gets the outputs:
		///   <c>[D, A, B, C]</c>.
		/// </remarks>
		public TF_Output CollectivePermute (TF_Output input, TF_Output source_target_pairs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CollectivePermute", MakeName ("CollectivePermute", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, source_target_pairs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Mutually reduces multiple tensors of identical type and shape.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CollectiveReduce'.
		/// </param>
		/// <param name="wait_for">
		///   Optional argument
		/// </param>
		/// <param name="group_size">
		/// </param>
		/// <param name="group_key">
		/// </param>
		/// <param name="instance_key">
		/// </param>
		/// <param name="merge_op">
		/// </param>
		/// <param name="final_op">
		/// </param>
		/// <param name="subdiv_offsets">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CollectiveReduce (TF_Output input, long group_size, long group_key, long instance_key, string merge_op, string final_op, long[] subdiv_offsets, long[] wait_for = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CollectiveReduce", MakeName ("CollectiveReduce", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "group_size", group_size);
			c_api.TF_SetAttrInt (desc, "group_key", group_key);
			c_api.TF_SetAttrInt (desc, "instance_key", instance_key);
			c_api.TF_SetAttrString (desc, "merge_op", merge_op);
			c_api.TF_SetAttrString (desc, "final_op", final_op);
			c_api.TF_SetAttrIntList (desc, "subdiv_offsets", ref subdiv_offsets[0], subdiv_offsets.Length);
			if (wait_for != null)
				c_api.TF_SetAttrIntList (desc, "wait_for", ref wait_for[0], wait_for.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var data = new TF_Output (op, _idx++);
			return data;
		}

		/// <summary>
		///   Greedily selects a subset of bounding boxes in descending order of score,
		/// </summary>
		/// <param name="boxes">
		///   A 4-D float tensor of shape <c>[batch_size, num_boxes, q, 4]</c>. If <c>q</c> is 1 then
		///   same boxes are used for all classes otherwise, if <c>q</c> is equal to number of
		///   classes, class-specific boxes are used.
		/// </param>
		/// <param name="scores">
		///   A 3-D float tensor of shape <c>[batch_size, num_boxes, num_classes]</c>
		///   representing a single score corresponding to each box (each row of boxes).
		/// </param>
		/// <param name="max_output_size_per_class">
		///   A scalar integer tensor representing the maximum number of
		///   boxes to be selected by non max suppression per class
		/// </param>
		/// <param name="max_total_size">
		///   A scalar representing maximum number of boxes retained over all classes.
		/// </param>
		/// <param name="iou_threshold">
		///   A 0-D float tensor representing the threshold for deciding whether
		///   boxes overlap too much with respect to IOU.
		/// </param>
		/// <param name="score_threshold">
		///   A 0-D float tensor representing the threshold for deciding when to remove
		///   boxes based on score.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CombinedNonMaxSuppression'.
		/// </param>
		/// <param name="pad_per_class">
		///   Optional argument
		///   If false, the output nmsed boxes, scores and classes
		///   are padded/clipped to <c>max_total_size</c>. If true, the
		///   output nmsed boxes, scores and classes are padded to be of length
		///   <c>max_size_per_class</c>*<c>num_classes</c>, unless it exceeds <c>max_total_size</c> in
		///   which case it is clipped to <c>max_total_size</c>. Defaults to false.
		/// </param>
		/// <param name="clip_boxes">
		///   Optional argument
		///   If true, assume the box coordinates are between [0, 1] and clip the output boxes
		///   if they fall beyond [0, 1]. If false, do not do clipping and output the box
		///   coordinates as it is.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   nmsed_boxes: A [batch_size, max_detections, 4] float32 tensor
		///   containing the non-max suppressed boxes.
		///   nmsed_scores: A [batch_size, max_detections] float32 tensor
		///   containing the scores for the boxes.
		///   nmsed_classes: A [batch_size, max_detections] float32 tensor
		///   containing the classes for the boxes.
		///   valid_detections: A [batch_size] int32 tensor indicating the number of
		///   valid detections per batch item. Only the top num_detections[i] entries in
		///   nms_boxes[i], nms_scores[i] and nms_class[i] are valid. The rest of the
		///   entries are zero paddings.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   This operation performs non_max_suppression on the inputs per batch, across
		///   all classes.
		///   Prunes away boxes that have high intersection-over-union (IOU) overlap
		///   with previously selected boxes.  Bounding boxes are supplied as
		///   [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any
		///   diagonal pair of box corners and the coordinates can be provided as normalized
		///   (i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm
		///   is agnostic to where the origin is in the coordinate system. Also note that
		///   this algorithm is invariant to orthogonal transformations and translations
		///   of the coordinate system; thus translating or reflections of the coordinate
		///   system result in the same boxes being selected by the algorithm.
		///   The output of this operation is the final boxes, scores and classes tensor
		///   returned after performing non_max_suppression.
		/// </remarks>
		public (TF_Output nmsed_boxes, TF_Output nmsed_scores, TF_Output nmsed_classes, TF_Output valid_detections) CombinedNonMaxSuppression (TF_Output boxes, TF_Output scores, TF_Output max_output_size_per_class, TF_Output max_total_size, TF_Output iou_threshold, TF_Output score_threshold, bool? pad_per_class = null, bool? clip_boxes = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CombinedNonMaxSuppression", MakeName ("CombinedNonMaxSuppression", operName));
			c_api.TF_AddInput(desc, boxes);
			c_api.TF_AddInput(desc, scores);
			c_api.TF_AddInput(desc, max_output_size_per_class);
			c_api.TF_AddInput(desc, max_total_size);
			c_api.TF_AddInput(desc, iou_threshold);
			c_api.TF_AddInput(desc, score_threshold);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (pad_per_class.HasValue)
				c_api.TF_SetAttrBool (desc, "pad_per_class", Convert.ToByte(pad_per_class.Value));
			
			if (clip_boxes.HasValue)
				c_api.TF_SetAttrBool (desc, "clip_boxes", Convert.ToByte(clip_boxes.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var nmsed_boxes = new TF_Output (op, _idx++);
			var nmsed_scores = new TF_Output (op, _idx++);
			var nmsed_classes = new TF_Output (op, _idx++);
			var valid_detections = new TF_Output (op, _idx++);
			return (nmsed_boxes, nmsed_scores, nmsed_classes, valid_detections);
		}

		/// <summary>
		///   Compare values of <c>input</c> to <c>threshold</c> and pack resulting bits into a <c>uint8</c>.
		/// </summary>
		/// <param name="input">
		///   Values to compare against <c>threshold</c> and bitpack.
		/// </param>
		/// <param name="threshold">
		///   Threshold to compare against.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CompareAndBitpack'.
		/// </param>
		/// <returns>
		///   The bitpacked comparisons.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Each comparison returns a boolean <c>true</c> (if <c>input_value &amp;gt; threshold</c>)
		///   or and <c>false</c> otherwise.
		///   
		///   This operation is useful for Locality-Sensitive-Hashing (LSH) and other
		///   algorithms that use hashing approximations of cosine and <c>L2</c> distances;
		///   codes can be generated from an input via:
		///   
		///    <code>
		///   codebook_size = 50
		///   codebook_bits = codebook_size * 32
		///   codebook = tf.get_variable('codebook', [x.shape[-1].value, codebook_bits],
		///   dtype=x.dtype,
		///   initializer=tf.orthogonal_initializer())
		///   codes = compare_and_threshold(tf.matmul(x, codebook), threshold=0.)
		///   codes = tf.bitcast(codes, tf.int32)  # go from uint8 to int32
		///   # now codes has shape x.shape[:-1] + [codebook_size]
		///    </code>
		///   
		///   **NOTE**: Currently, the innermost dimension of the tensor must be divisible
		///   by 8.
		///   
		///   Given an <c>input</c> shaped <c>[s0, s1, ..., s_n]</c>, the output is
		///   a <c>uint8</c> tensor shaped <c>[s0, s1, ..., s_n / 8]</c>.
		/// </remarks>
		public TF_Output CompareAndBitpack (TF_Output input, TF_Output threshold, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CompareAndBitpack", MakeName ("CompareAndBitpack", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, threshold);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Converts two real numbers to a complex number.
		/// </summary>
		/// <param name="real">
		/// </param>
		/// <param name="imag">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Complex'.
		/// </param>
		/// <param name="Tout">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given a tensor <c>real</c> representing the real part of a complex number, and a
		///   tensor <c>imag</c> representing the imaginary part of a complex number, this
		///   operation returns complex numbers elementwise of the form \\(a + bj\\), where
		///   *a* represents the <c>real</c> part and *b* represents the <c>imag</c> part.
		///   
		///   The input tensors <c>real</c> and <c>imag</c> must have the same shape.
		///   
		///   For example:
		///   
		///    <code>
		///   # tensor 'real' is [2.25, 3.25]
		///   # tensor <c>imag</c> is [4.75, 5.75]
		///   tf.complex(real, imag) ==&amp;gt; [[2.25 + 4.75j], [3.25 + 5.75j]]
		///    </code>
		/// </remarks>
		public TF_Output Complex (TF_Output real, TF_Output imag, TF_DataType? Tout = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Complex", MakeName ("Complex", operName));
			c_api.TF_AddInput(desc, real);
			c_api.TF_AddInput(desc, imag);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Tout.HasValue)
				c_api.TF_SetAttrType (desc, "Tout", Tout.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the complex absolute value of a tensor.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ComplexAbs'.
		/// </param>
		/// <param name="Tout">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given a tensor <c>x</c> of complex numbers, this operation returns a tensor of type
		///   <c>float</c> or <c>double</c> that is the absolute value of each element in <c>x</c>. All
		///   elements in <c>x</c> must be complex numbers of the form \\(a + bj\\). The absolute
		///   value is computed as \\( \sqrt{a^2 + b^2}\\).
		/// </remarks>
		public TF_Output ComplexAbs (TF_Output x, TF_DataType? Tout = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ComplexAbs", MakeName ("ComplexAbs", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Tout.HasValue)
				c_api.TF_SetAttrType (desc, "Tout", Tout.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes the ids of the positions in sampled_candidates that match true_labels.
		/// </summary>
		/// <param name="true_classes">
		///   The true_classes output of UnpackSparseLabels.
		/// </param>
		/// <param name="sampled_candidates">
		///   The sampled_candidates output of CandidateSampler.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ComputeAccidentalHits'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either seed or seed2 are set to be non-zero, the random number
		///   generator is seeded by the given seed.  Otherwise, it is seeded by a
		///   random seed.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   An second seed to avoid seed collision.
		/// </param>
		/// <param name="num_true">
		///   Number of true labels per context.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   indices: A vector of indices corresponding to rows of true_candidates.
		///   ids: A vector of IDs of positions in sampled_candidates that match a true_label
		///   for the row with the corresponding index in indices.
		///   weights: A vector of the same length as indices and ids, in which each element
		///   is -FLOAT_MAX.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   When doing log-odds NCE, the result of this op should be passed through a
		///   SparseToDense op, then added to the logits of the sampled candidates. This has
		///   the effect of 'removing' the sampled labels that match the true labels by
		///   making the classifier sure that they are sampled labels.
		/// </remarks>
		public (TF_Output indices, TF_Output ids, TF_Output weights) ComputeAccidentalHits (TF_Output true_classes, TF_Output sampled_candidates, long num_true, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ComputeAccidentalHits", MakeName ("ComputeAccidentalHits", operName));
			c_api.TF_AddInput(desc, true_classes);
			c_api.TF_AddInput(desc, sampled_candidates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_true", num_true);
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var indices = new TF_Output (op, _idx++);
			var ids = new TF_Output (op, _idx++);
			var weights = new TF_Output (op, _idx++);
			return (indices, ids, weights);
		}

		/// <summary>
		///   Concatenates tensors along one dimension.
		/// </summary>
		/// <param name="concat_dim">
		///   0-D.  The dimension along which to concatenate.  Must be in the
		///   range [0, rank(values)).
		/// </param>
		/// <param name="values">
		///   The <c>N</c> Tensors to concatenate. Their ranks and types must match,
		///   and their sizes must match in all dimensions except <c>concat_dim</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Concat'.
		/// </param>
		/// <returns>
		///   A <c>Tensor</c> with the concatenation of values stacked along the
		///   <c>concat_dim</c> dimension.  This tensor's shape matches that of <c>values</c> except
		///   in <c>concat_dim</c> where it has the sum of the sizes.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Concat (TF_Output concat_dim, TF_Output[] values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Concat", MakeName ("Concat", operName));
			c_api.TF_AddInput(desc, concat_dim);
			c_api.TF_AddInputList(desc, values[0], values.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates a dataset that concatenates <c>input_dataset</c> with <c>another_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="another_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ConcatenateDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ConcatenateDataset (TF_Output input_dataset, TF_Output another_dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ConcatenateDataset", MakeName ("ConcatenateDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, another_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Computes offsets of concat inputs within its output.
		/// </summary>
		/// <param name="concat_dim">
		///   The dimension along which to concatenate.
		/// </param>
		/// <param name="shape">
		///   The <c>N</c> int32 vectors representing shape of tensors being concatenated.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ConcatOffset'.
		/// </param>
		/// <returns>
		///   The <c>N</c> int32 vectors representing the starting offset
		///   of input tensors within the concatenated output.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   For example:
		///   
		///    <code>
		///   # 'x' is [2, 2, 7]
		///   # 'y' is [2, 3, 7]
		///   # 'z' is [2, 5, 7]
		///   concat_offset(2, [x, y, z]) =&amp;gt; [0, 0, 0], [0, 2, 0], [0, 5, 0]
		///    </code>
		///   
		///   This is typically used by gradient computations for a concat operation.
		/// </remarks>
		public TF_Output[] ConcatOffset (TF_Output concat_dim, TF_Output[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ConcatOffset", MakeName ("ConcatOffset", operName));
			c_api.TF_AddInput(desc, concat_dim);
			c_api.TF_AddInputList(desc, shape[0], shape.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "offset", status);
			var offset = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				offset [i] = new TF_Output (op, _idx++);
			
			return offset;
		}

		/// <summary>
		///   Concatenates tensors along one dimension.
		/// </summary>
		/// <param name="values">
		///   List of <c>N</c> Tensors to concatenate. Their ranks and types must match,
		///   and their sizes must match in all dimensions except <c>concat_dim</c>.
		/// </param>
		/// <param name="axis">
		///   0-D.  The dimension along which to concatenate.  Must be in the
		///   range [-rank(values), rank(values)).
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ConcatV2'.
		/// </param>
		/// <returns>
		///   A <c>Tensor</c> with the concatenation of values stacked along the
		///   <c>concat_dim</c> dimension.  This tensor's shape matches that of <c>values</c> except
		///   in <c>concat_dim</c> where it has the sum of the sizes.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ConcatV2 (TF_Output[] values, TF_Output axis, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ConcatV2", MakeName ("ConcatV2", operName));
			c_api.TF_AddInputList(desc, values[0], values.Length);
			c_api.TF_AddInput(desc, axis);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   A conditional accumulator for aggregating gradients.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ConditionalAccumulator'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this accumulator is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this accumulator will be shared under the
		///   given name across multiple sessions.
		/// </param>
		/// <param name="reduction_type">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		///   The type of the value being accumulated.
		/// </param>
		/// <param name="shape">
		///   The shape of the values, can be [], in which case shape is unknown.
		/// </param>
		/// <returns>
		///   The handle to the accumulator.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The accumulator accepts gradients marked with local_step greater or
		///   equal to the most recent global_step known to the accumulator. The
		///   average can be extracted from the accumulator, provided sufficient
		///   gradients have been accumulated. Extracting the average automatically
		///   resets the aggregate to 0, and increments the global_step recorded by
		///   the accumulator.
		/// </remarks>
		public TF_Output ConditionalAccumulator (TF_DataType dtype, long[] shape, string container = null, string shared_name = null, string reduction_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ConditionalAccumulator", MakeName ("ConditionalAccumulator", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (reduction_type != null)
				c_api.TF_SetAttrString (desc, "reduction_type", reduction_type);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Sets up the centralized structures for a distributed TPU system.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ConfigureDistributedTPU'.
		/// </param>
		/// <param name="embedding_config">
		///   Optional argument
		///   Reserved. Do not use.
		/// </param>
		/// <param name="tpu_embedding_config">
		///   Optional argument
		///   Serialized tensorflow.tpu.TPUEmbeddingConfiguration that
		///   describes the embedding lookups of the program.
		/// </param>
		/// <param name="is_global_init">
		///   Optional argument
		///   Reserved. Do not use.
		/// </param>
		/// <returns>
		///   A serialized tensorflow.tpu.TopologyProto that describes the TPU
		///   topology.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ConfigureDistributedTPU (string embedding_config = null, string tpu_embedding_config = null, bool? is_global_init = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ConfigureDistributedTPU", MakeName ("ConfigureDistributedTPU", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (embedding_config != null)
				c_api.TF_SetAttrString (desc, "embedding_config", embedding_config);
			
			if (tpu_embedding_config != null)
				c_api.TF_SetAttrString (desc, "tpu_embedding_config", tpu_embedding_config);
			
			if (is_global_init.HasValue)
				c_api.TF_SetAttrBool (desc, "is_global_init", Convert.ToByte(is_global_init.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var topology = new TF_Output (op, _idx++);
			return topology;
		}

		/// <summary>
		///   Sets up TPUEmbedding in a distributed TPU system.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ConfigureTPUEmbedding'.
		/// </param>
		/// <param name="config">
		///   Serialized tensorflow.tpu.TPUEmbeddingConfiguration that
		///   describes the embedding lookups of the program.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ConfigureTPUEmbedding (string config, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ConfigureTPUEmbedding", MakeName ("ConfigureTPUEmbedding", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "config", config);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Returns the complex conjugate of a complex number.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Conj'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given a tensor <c>input</c> of complex numbers, this operation returns a tensor of
		///   complex numbers that are the complex conjugate of each element in <c>input</c>. The
		///   complex numbers in <c>input</c> must be of the form \\(a + bj\\), where *a* is the
		///   real part and *b* is the imaginary part.
		///   
		///   The complex conjugate returned by this operation is of the form \\(a - bj\\).
		///   
		///   For example:
		///   
		///    <code>
		///   # tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]
		///   tf.conj(input) ==&amp;gt; [-2.25 - 4.75j, 3.25 - 5.75j]
		///    </code>
		/// </remarks>
		public TF_Output Conj (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Conj", MakeName ("Conj", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Shuffle dimensions of x according to a permutation and conjugate the result.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="perm">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ConjugateTranspose'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The output <c>y</c> has the same rank as <c>x</c>. The shapes of <c>x</c> and <c>y</c> satisfy:
		///   <c>y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]</c>
		///   <c>y[i,j,k,...,s,t,u] == conj(x[perm[i], perm[j], perm[k],...,perm[s], perm[t], perm[u]])</c>
		/// </remarks>
		public TF_Output ConjugateTranspose (TF_Output x, TF_Output perm, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ConjugateTranspose", MakeName ("ConjugateTranspose", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, perm);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Returns a constant tensor.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Const'.
		/// </param>
		/// <param name="value">
		///   Attr <c>value</c> is the tensor to return.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Const (TF_Tensor value, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Const", MakeName ("Const", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTensor (desc, "value", value, status);
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   This op consumes a lock created by <c>MutexLock</c>.
		/// </summary>
		/// <param name="mutex_lock">
		///   A tensor returned by <c>MutexLock</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ConsumeMutexLock'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   This op exists to consume a tensor created by <c>MutexLock</c> (other than
		///   direct control dependencies).  It should be the only that consumes the tensor,
		///   and will raise an error if it is not.  Its only purpose is to keep the
		///   mutex lock tensor alive until it is consumed by this op.
		///   
		///   **NOTE**: This operation must run on the same device as its input.  This may
		///   be enforced via the <c>colocate_with</c> mechanism.
		/// </remarks>
		public TF_Operation ConsumeMutexLock (TF_Output mutex_lock, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ConsumeMutexLock", MakeName ("ConsumeMutexLock", operName));
			c_api.TF_AddInput(desc, mutex_lock);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Does nothing. Serves as a control trigger for scheduling.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ControlTrigger'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   Only useful as a placeholder for control edges.
		/// </remarks>
		public TF_Operation ControlTrigger (string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ControlTrigger", MakeName ("ControlTrigger", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Computes a 2-D convolution given 4-D <c>input</c> and <c>filter</c> tensors.
		/// </summary>
		/// <param name="input">
		///   A 4-D tensor. The dimension order is interpreted according to the value
		///   of <c>data_format</c>, see below for details.
		/// </param>
		/// <param name="filter">
		///   A 4-D tensor of shape
		///   <c>[filter_height, filter_width, in_channels, out_channels]</c>
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv2D'.
		/// </param>
		/// <param name="use_cudnn_on_gpu">
		///   Optional argument
		/// </param>
		/// <param name="explicit_paddings">
		///   Optional argument
		///   If <c>padding</c> is <c>"EXPLICIT"</c>, the list of explicit padding amounts. For the ith
		///   dimension, the amount of padding inserted before and after the dimension is
		///   <c>explicit_paddings[2 * i]</c> and <c>explicit_paddings[2 * i + 1]</c>, respectively. If
		///   <c>padding</c> is not <c>"EXPLICIT"</c>, <c>explicit_paddings</c> must be empty.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   Specify the data format of the input and output data. With the
		///   default format "NHWC", the data is stored in the order of:
		///   [batch, height, width, channels].
		///   Alternatively, the format could be "NCHW", the data storage order of:
		///   [batch, channels, height, width].
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		///   1-D tensor of length 4.  The dilation factor for each dimension of
		///   <c>input</c>. If set to k &amp;gt; 1, there will be k-1 skipped cells between each
		///   filter element on that dimension. The dimension order is determined by the
		///   value of <c>data_format</c>, see above for details. Dilations in the batch and
		///   depth dimensions must be 1.
		/// </param>
		/// <param name="strides">
		///   1-D tensor of length 4.  The stride of the sliding window for each
		///   dimension of <c>input</c>. The dimension order is determined by the value of
		///   <c>data_format</c>, see below for details.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   A 4-D tensor. The dimension order is determined by the value of
		///   <c>data_format</c>, see below for details.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given an input tensor of shape <c>[batch, in_height, in_width, in_channels]</c>
		///   and a filter / kernel tensor of shape
		///   <c>[filter_height, filter_width, in_channels, out_channels]</c>, this op
		///   performs the following:
		///   
		///   1. Flattens the filter to a 2-D matrix with shape
		///   <c>[filter_height * filter_width * in_channels, output_channels]</c>.
		///   2. Extracts image patches from the input tensor to form a *virtual*
		///   tensor of shape <c>[batch, out_height, out_width,
		///   filter_height * filter_width * in_channels]</c>.
		///   3. For each patch, right-multiplies the filter matrix and the image patch
		///   vector.
		///   
		///   In detail, with the default NHWC format,
		///   
		///   output[b, i, j, k] =
		///   sum_{di, dj, q} input[b, strides[1] * i + di, strides[2] * j + dj, q] *
		///   filter[di, dj, q, k]
		///   
		///   Must have <c>strides[0] = strides[3] = 1</c>.  For the most common case of the same
		///   horizontal and vertices strides, <c>strides = [1, stride, stride, 1]</c>.
		/// </remarks>
		public TF_Output Conv2D (TF_Output input, TF_Output filter, long[] strides, string padding, bool? use_cudnn_on_gpu = null, long[] explicit_paddings = null, string data_format = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Conv2D", MakeName ("Conv2D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (use_cudnn_on_gpu.HasValue)
				c_api.TF_SetAttrBool (desc, "use_cudnn_on_gpu", Convert.ToByte(use_cudnn_on_gpu.Value));
			
			if (explicit_paddings != null)
				c_api.TF_SetAttrIntList (desc, "explicit_paddings", ref explicit_paddings[0], explicit_paddings.Length);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the gradients of convolution with respect to the filter.
		/// </summary>
		/// <param name="input">
		///   4-D with shape <c>[batch, in_height, in_width, in_channels]</c>.
		/// </param>
		/// <param name="filter_sizes">
		///   An integer vector representing the tensor shape of <c>filter</c>,
		///   where <c>filter</c> is a 4-D
		///   <c>[filter_height, filter_width, in_channels, out_channels]</c> tensor.
		/// </param>
		/// <param name="out_backprop">
		///   4-D with shape <c>[batch, out_height, out_width, out_channels]</c>.
		///   Gradients w.r.t. the output of the convolution.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv2DBackpropFilter'.
		/// </param>
		/// <param name="use_cudnn_on_gpu">
		///   Optional argument
		/// </param>
		/// <param name="explicit_paddings">
		///   Optional argument
		///   If <c>padding</c> is <c>"EXPLICIT"</c>, the list of explicit padding amounts. For the ith
		///   dimension, the amount of padding inserted before and after the dimension is
		///   <c>explicit_paddings[2 * i]</c> and <c>explicit_paddings[2 * i + 1]</c>, respectively. If
		///   <c>padding</c> is not <c>"EXPLICIT"</c>, <c>explicit_paddings</c> must be empty.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   Specify the data format of the input and output data. With the
		///   default format "NHWC", the data is stored in the order of:
		///   [batch, in_height, in_width, in_channels].
		///   Alternatively, the format could be "NCHW", the data storage order of:
		///   [batch, in_channels, in_height, in_width].
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		///   1-D tensor of length 4.  The dilation factor for each dimension of
		///   <c>input</c>. If set to k &amp;gt; 1, there will be k-1 skipped cells between each filter
		///   element on that dimension. The dimension order is determined by the value of
		///   <c>data_format</c>, see above for details. Dilations in the batch and depth
		///   dimensions must be 1.
		/// </param>
		/// <param name="strides">
		///   The stride of the sliding window for each dimension of the input
		///   of the convolution. Must be in the same order as the dimension specified with
		///   format.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   4-D with shape
		///   <c>[filter_height, filter_width, in_channels, out_channels]</c>.  Gradient w.r.t.
		///   the <c>filter</c> input of the convolution.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Conv2DBackpropFilter (TF_Output input, TF_Output filter_sizes, TF_Output out_backprop, long[] strides, string padding, bool? use_cudnn_on_gpu = null, long[] explicit_paddings = null, string data_format = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Conv2DBackpropFilter", MakeName ("Conv2DBackpropFilter", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter_sizes);
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (use_cudnn_on_gpu.HasValue)
				c_api.TF_SetAttrBool (desc, "use_cudnn_on_gpu", Convert.ToByte(use_cudnn_on_gpu.Value));
			
			if (explicit_paddings != null)
				c_api.TF_SetAttrIntList (desc, "explicit_paddings", ref explicit_paddings[0], explicit_paddings.Length);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the gradients of convolution with respect to the input.
		/// </summary>
		/// <param name="input_sizes">
		///   An integer vector representing the shape of <c>input</c>,
		///   where <c>input</c> is a 4-D <c>[batch, height, width, channels]</c> tensor.
		/// </param>
		/// <param name="filter">
		///   4-D with shape
		///   <c>[filter_height, filter_width, in_channels, out_channels]</c>.
		/// </param>
		/// <param name="out_backprop">
		///   4-D with shape <c>[batch, out_height, out_width, out_channels]</c>.
		///   Gradients w.r.t. the output of the convolution.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv2DBackpropInput'.
		/// </param>
		/// <param name="use_cudnn_on_gpu">
		///   Optional argument
		/// </param>
		/// <param name="explicit_paddings">
		///   Optional argument
		///   If <c>padding</c> is <c>"EXPLICIT"</c>, the list of explicit padding amounts. For the ith
		///   dimension, the amount of padding inserted before and after the dimension is
		///   <c>explicit_paddings[2 * i]</c> and <c>explicit_paddings[2 * i + 1]</c>, respectively. If
		///   <c>padding</c> is not <c>"EXPLICIT"</c>, <c>explicit_paddings</c> must be empty.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   Specify the data format of the input and output data. With the
		///   default format "NHWC", the data is stored in the order of:
		///   [batch, in_height, in_width, in_channels].
		///   Alternatively, the format could be "NCHW", the data storage order of:
		///   [batch, in_channels, in_height, in_width].
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		///   1-D tensor of length 4.  The dilation factor for each dimension of
		///   <c>input</c>. If set to k &amp;gt; 1, there will be k-1 skipped cells between each filter
		///   element on that dimension. The dimension order is determined by the value of
		///   <c>data_format</c>, see above for details. Dilations in the batch and depth
		///   dimensions must be 1.
		/// </param>
		/// <param name="strides">
		///   The stride of the sliding window for each dimension of the input
		///   of the convolution. Must be in the same order as the dimension specified with
		///   format.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   4-D with shape <c>[batch, in_height, in_width, in_channels]</c>.  Gradient
		///   w.r.t. the input of the convolution.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Conv2DBackpropInput (TF_Output input_sizes, TF_Output filter, TF_Output out_backprop, long[] strides, string padding, bool? use_cudnn_on_gpu = null, long[] explicit_paddings = null, string data_format = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Conv2DBackpropInput", MakeName ("Conv2DBackpropInput", operName));
			c_api.TF_AddInput(desc, input_sizes);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (use_cudnn_on_gpu.HasValue)
				c_api.TF_SetAttrBool (desc, "use_cudnn_on_gpu", Convert.ToByte(use_cudnn_on_gpu.Value));
			
			if (explicit_paddings != null)
				c_api.TF_SetAttrIntList (desc, "explicit_paddings", ref explicit_paddings[0], explicit_paddings.Length);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes a 3-D convolution given 5-D <c>input</c> and <c>filter</c> tensors.
		/// </summary>
		/// <param name="input">
		///   Shape <c>[batch, in_depth, in_height, in_width, in_channels]</c>.
		/// </param>
		/// <param name="filter">
		///   Shape <c>[filter_depth, filter_height, filter_width, in_channels,
		///   out_channels]</c>. <c>in_channels</c> must match between <c>input</c> and <c>filter</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv3D'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   The data format of the input and output data. With the
		///   default format "NDHWC", the data is stored in the order of:
		///   [batch, in_depth, in_height, in_width, in_channels].
		///   Alternatively, the format could be "NCDHW", the data storage order is:
		///   [batch, in_channels, in_depth, in_height, in_width].
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		///   1-D tensor of length 5.  The dilation factor for each dimension of
		///   <c>input</c>. If set to k &amp;gt; 1, there will be k-1 skipped cells between each
		///   filter element on that dimension. The dimension order is determined by the
		///   value of <c>data_format</c>, see above for details. Dilations in the batch and
		///   depth dimensions must be 1.
		/// </param>
		/// <param name="strides">
		///   1-D tensor of length 5. The stride of the sliding window for each
		///   dimension of <c>input</c>. Must have <c>strides[0] = strides[4] = 1</c>.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   In signal processing, cross-correlation is a measure of similarity of
		///   two waveforms as a function of a time-lag applied to one of them. This
		///   is also known as a sliding dot product or sliding inner-product.
		///   
		///   Our Conv3D implements a form of cross-correlation.
		/// </remarks>
		public TF_Output Conv3D (TF_Output input, TF_Output filter, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Conv3D", MakeName ("Conv3D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the gradients of 3-D convolution with respect to the filter.
		/// </summary>
		/// <param name="input">
		///   Shape <c>[batch, depth, rows, cols, in_channels]</c>.
		/// </param>
		/// <param name="filter">
		///   Shape <c>[depth, rows, cols, in_channels, out_channels]</c>.
		///   <c>in_channels</c> must match between <c>input</c> and <c>filter</c>.
		/// </param>
		/// <param name="out_backprop">
		///   Backprop signal of shape <c>[batch, out_depth, out_rows, out_cols,
		///   out_channels]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv3DBackpropFilter'.
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		///   1-D tensor of length 5. The stride of the sliding window for each
		///   dimension of <c>input</c>. Must have <c>strides[0] = strides[4] = 1</c>.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Conv3DBackpropFilter (TF_Output input, TF_Output filter, TF_Output out_backprop, long[] strides, string padding, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Conv3DBackpropFilter", MakeName ("Conv3DBackpropFilter", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the gradients of 3-D convolution with respect to the filter.
		/// </summary>
		/// <param name="input">
		///   Shape <c>[batch, depth, rows, cols, in_channels]</c>.
		/// </param>
		/// <param name="filter_sizes">
		///   An integer vector representing the tensor shape of <c>filter</c>,
		///   where <c>filter</c> is a 5-D
		///   <c>[filter_depth, filter_height, filter_width, in_channels, out_channels]</c>
		///   tensor.
		/// </param>
		/// <param name="out_backprop">
		///   Backprop signal of shape <c>[batch, out_depth, out_rows, out_cols,
		///   out_channels]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv3DBackpropFilterV2'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   The data format of the input and output data. With the
		///   default format "NDHWC", the data is stored in the order of:
		///   [batch, in_depth, in_height, in_width, in_channels].
		///   Alternatively, the format could be "NCDHW", the data storage order is:
		///   [batch, in_channels, in_depth, in_height, in_width].
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		///   1-D tensor of length 5.  The dilation factor for each dimension of
		///   <c>input</c>. If set to k &amp;gt; 1, there will be k-1 skipped cells between each
		///   filter element on that dimension. The dimension order is determined by the
		///   value of <c>data_format</c>, see above for details. Dilations in the batch and
		///   depth dimensions must be 1.
		/// </param>
		/// <param name="strides">
		///   1-D tensor of length 5. The stride of the sliding window for each
		///   dimension of <c>input</c>. Must have <c>strides[0] = strides[4] = 1</c>.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Conv3DBackpropFilterV2 (TF_Output input, TF_Output filter_sizes, TF_Output out_backprop, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Conv3DBackpropFilterV2", MakeName ("Conv3DBackpropFilterV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter_sizes);
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the gradients of 3-D convolution with respect to the input.
		/// </summary>
		/// <param name="input">
		///   Shape <c>[batch, depth, rows, cols, in_channels]</c>.
		/// </param>
		/// <param name="filter">
		///   Shape <c>[depth, rows, cols, in_channels, out_channels]</c>.
		///   <c>in_channels</c> must match between <c>input</c> and <c>filter</c>.
		/// </param>
		/// <param name="out_backprop">
		///   Backprop signal of shape <c>[batch, out_depth, out_rows, out_cols,
		///   out_channels]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv3DBackpropInput'.
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		///   1-D tensor of length 5. The stride of the sliding window for each
		///   dimension of <c>input</c>. Must have <c>strides[0] = strides[4] = 1</c>.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Conv3DBackpropInput (TF_Output input, TF_Output filter, TF_Output out_backprop, long[] strides, string padding, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Conv3DBackpropInput", MakeName ("Conv3DBackpropInput", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the gradients of 3-D convolution with respect to the input.
		/// </summary>
		/// <param name="input_sizes">
		///   An integer vector representing the tensor shape of <c>input</c>,
		///   where <c>input</c> is a 5-D
		///   <c>[batch, depth, rows, cols, in_channels]</c> tensor.
		/// </param>
		/// <param name="filter">
		///   Shape <c>[depth, rows, cols, in_channels, out_channels]</c>.
		///   <c>in_channels</c> must match between <c>input</c> and <c>filter</c>.
		/// </param>
		/// <param name="out_backprop">
		///   Backprop signal of shape <c>[batch, out_depth, out_rows, out_cols,
		///   out_channels]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv3DBackpropInputV2'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   The data format of the input and output data. With the
		///   default format "NDHWC", the data is stored in the order of:
		///   [batch, in_depth, in_height, in_width, in_channels].
		///   Alternatively, the format could be "NCDHW", the data storage order is:
		///   [batch, in_channels, in_depth, in_height, in_width].
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		///   1-D tensor of length 5.  The dilation factor for each dimension of
		///   <c>input</c>. If set to k &amp;gt; 1, there will be k-1 skipped cells between each
		///   filter element on that dimension. The dimension order is determined by the
		///   value of <c>data_format</c>, see above for details. Dilations in the batch and
		///   depth dimensions must be 1.
		/// </param>
		/// <param name="strides">
		///   1-D tensor of length 5. The stride of the sliding window for each
		///   dimension of <c>input</c>. Must have <c>strides[0] = strides[4] = 1</c>.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Conv3DBackpropInputV2 (TF_Output input_sizes, TF_Output filter, TF_Output out_backprop, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Conv3DBackpropInputV2", MakeName ("Conv3DBackpropInputV2", operName));
			c_api.TF_AddInput(desc, input_sizes);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Copy Op.
		/// </summary>
		/// <param name="input">
		///   Input tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Copy'.
		/// </param>
		/// <param name="tensor_name">
		///   Optional argument
		///   The name of the input tensor.
		/// </param>
		/// <param name="debug_ops_spec">
		///   Optional argument
		///   A list of debug op spec (op, url, gated_grpc) for attached debug
		///   ops. Each element of the list has the format
		///   &amp;lt;debug_op&amp;gt;;&amp;lt;grpc_url&amp;gt;;&amp;lt;gated_grpc&amp;gt;, wherein gated_grpc is boolean represented
		///   as 0/1. E.g., "DebugIdentity;grpc://foo:3333;1",
		///   "DebugIdentity;file:///tmp/tfdbg_1;0".
		/// </param>
		/// <returns>
		///   Output tensor, deep-copied from input.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Performs CPU-to-CPU or GPU-to-GPU deep-copying of tensor, depending on the
		///   device on which the tensor is allocated.
		///   N.B.: If the all downstream attached debug ops are disabled given the current
		///   gRPC gating status, the output will simply forward the input tensor without
		///   deep-copying. See the documentation of Debug* ops for more details.
		///   
		///   Unlike the CopyHost Op, this op does not have HostMemory constraint on its
		///   input or output.
		/// </remarks>
		public TF_Output Copy (TF_Output input, string tensor_name = null, string[] debug_ops_spec = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Copy", MakeName ("Copy", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (tensor_name != null)
				c_api.TF_SetAttrString (desc, "tensor_name", tensor_name);
			
			if (debug_ops_spec != null)
				c_api.TF_SetAttrStringList (desc, "debug_ops_spec", debug_ops_spec);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Copy Host Op.
		/// </summary>
		/// <param name="input">
		///   Input tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CopyHost'.
		/// </param>
		/// <param name="tensor_name">
		///   Optional argument
		///   The name of the input tensor.
		/// </param>
		/// <param name="debug_ops_spec">
		///   Optional argument
		///   A list of debug op spec (op, url, gated_grpc) for attached debug
		///   ops. Each element of the list has the format
		///   &amp;lt;debug_op&amp;gt;;&amp;lt;grpc_url&amp;gt;;&amp;lt;gated_grpc&amp;gt;, wherein gated_grpc is boolean represented
		///   as 0/1. E.g., "DebugIdentity;grpc://foo:3333;1",
		///   "DebugIdentity;file:///tmp/tfdbg_1;0".
		/// </param>
		/// <returns>
		///   Output tensor, deep-copied from input.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Performs CPU-to-CPU deep-copying of tensor.
		///   N.B.: If the all downstream attached debug ops are disabled given the current
		///   gRPC gating status, the output will simply forward the input tensor without
		///   deep-copying. See the documentation of Debug* ops for more details.
		///   
		///   Unlike the Copy Op, this op has HostMemory constraint on its input or output.
		/// </remarks>
		public TF_Output CopyHost (TF_Output input, string tensor_name = null, string[] debug_ops_spec = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CopyHost", MakeName ("CopyHost", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (tensor_name != null)
				c_api.TF_SetAttrString (desc, "tensor_name", tensor_name);
			
			if (debug_ops_spec != null)
				c_api.TF_SetAttrStringList (desc, "debug_ops_spec", debug_ops_spec);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes cos of x element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Cos'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given an input tensor, this function computes cosine of every
		///   element in the tensor. Input range is <c>(-inf, inf)</c> and
		///   output range is <c>[-1,1]</c>. If input lies outside the boundary, <c>nan</c>
		///   is returned.
		///   
		///    <code>
		///   x = tf.constant([-float("inf"), -9, -0.5, 1, 1.2, 200, 10000, float("inf")])
		///   tf.math.cos(x) ==&amp;gt; [nan -0.91113025 0.87758255 0.5403023 0.36235774 0.48718765 -0.95215535 nan]
		///    </code>
		/// </remarks>
		public TF_Output Cos (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Cos", MakeName ("Cos", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes hyperbolic cosine of x element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Cosh'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given an input tensor, this function computes hyperbolic cosine of every
		///   element in the tensor. Input range is <c>[-inf, inf]</c> and output range
		///   is <c>[1, inf]</c>.
		///   
		///    <code>
		///   x = tf.constant([-float("inf"), -9, -0.5, 1, 1.2, 2, 10, float("inf")])
		///   tf.math.cosh(x) ==&amp;gt; [inf 4.0515420e+03 1.1276259e+00 1.5430807e+00 1.8106556e+00 3.7621956e+00 1.1013233e+04 inf]
		///    </code>
		/// </remarks>
		public TF_Output Cosh (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Cosh", MakeName ("Cosh", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Increments 'ref' until it reaches 'limit'.
		/// </summary>
		/// <param name="reference">
		///   Should be from a scalar <c>Variable</c> node.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CountUpTo'.
		/// </param>
		/// <param name="limit">
		///   If incrementing ref would bring it above limit, instead generates an
		///   'OutOfRange' error.
		/// </param>
		/// <returns>
		///   A copy of the input before increment. If nothing else modifies the
		///   input, the values produced will all be distinct.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CountUpTo (TF_Output reference, long limit, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CountUpTo", MakeName ("CountUpTo", operName));
			c_api.TF_AddInput(desc, reference);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "limit", limit);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="db_uri">
		/// </param>
		/// <param name="experiment_name">
		/// </param>
		/// <param name="run_name">
		/// </param>
		/// <param name="user_name">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CreateSummaryDbWriter'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation CreateSummaryDbWriter (TF_Output writer, TF_Output db_uri, TF_Output experiment_name, TF_Output run_name, TF_Output user_name, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CreateSummaryDbWriter", MakeName ("CreateSummaryDbWriter", operName));
			c_api.TF_AddInput(desc, writer);
			c_api.TF_AddInput(desc, db_uri);
			c_api.TF_AddInput(desc, experiment_name);
			c_api.TF_AddInput(desc, run_name);
			c_api.TF_AddInput(desc, user_name);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="logdir">
		/// </param>
		/// <param name="max_queue">
		/// </param>
		/// <param name="flush_millis">
		/// </param>
		/// <param name="filename_suffix">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CreateSummaryFileWriter'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation CreateSummaryFileWriter (TF_Output writer, TF_Output logdir, TF_Output max_queue, TF_Output flush_millis, TF_Output filename_suffix, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CreateSummaryFileWriter", MakeName ("CreateSummaryFileWriter", operName));
			c_api.TF_AddInput(desc, writer);
			c_api.TF_AddInput(desc, logdir);
			c_api.TF_AddInput(desc, max_queue);
			c_api.TF_AddInput(desc, flush_millis);
			c_api.TF_AddInput(desc, filename_suffix);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Extracts crops from the input image tensor and resizes them.
		/// </summary>
		/// <param name="image">
		///   A 4-D tensor of shape <c>[batch, image_height, image_width, depth]</c>.
		///   Both <c>image_height</c> and <c>image_width</c> need to be positive.
		/// </param>
		/// <param name="boxes">
		///   A 2-D tensor of shape <c>[num_boxes, 4]</c>. The <c>i</c>-th row of the tensor
		///   specifies the coordinates of a box in the <c>box_ind[i]</c> image and is specified
		///   in normalized coordinates <c>[y1, x1, y2, x2]</c>. A normalized coordinate value of
		///   <c>y</c> is mapped to the image coordinate at <c>y * (image_height - 1)</c>, so as the
		///   <c>[0, 1]</c> interval of normalized image height is mapped to
		///   <c>[0, image_height - 1]</c> in image height coordinates. We do allow <c>y1</c> &amp;gt; <c>y2</c>, in
		///   which case the sampled crop is an up-down flipped version of the original
		///   image. The width dimension is treated similarly. Normalized coordinates
		///   outside the <c>[0, 1]</c> range are allowed, in which case we use
		///   <c>extrapolation_value</c> to extrapolate the input image values.
		/// </param>
		/// <param name="box_ind">
		///   A 1-D tensor of shape <c>[num_boxes]</c> with int32 values in <c>[0, batch)</c>.
		///   The value of <c>box_ind[i]</c> specifies the image that the <c>i</c>-th box refers to.
		/// </param>
		/// <param name="crop_size">
		///   A 1-D tensor of 2 elements, <c>size = [crop_height, crop_width]</c>. All
		///   cropped image patches are resized to this size. The aspect ratio of the image
		///   content is not preserved. Both <c>crop_height</c> and <c>crop_width</c> need to be
		///   positive.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CropAndResize'.
		/// </param>
		/// <param name="method">
		///   Optional argument
		///   A string specifying the sampling method for resizing. It can be either
		///   <c>"bilinear"</c> or <c>"nearest"</c> and default to <c>"bilinear"</c>. Currently two sampling
		///   methods are supported: Bilinear and Nearest Neighbor.
		/// </param>
		/// <param name="extrapolation_value">
		///   Optional argument
		///   Value used for extrapolation, when applicable.
		/// </param>
		/// <returns>
		///   A 4-D tensor of shape <c>[num_boxes, crop_height, crop_width, depth]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Extracts crops from the input image tensor and resizes them using bilinear
		///   sampling or nearest neighbor sampling (possibly with aspect ratio change) to a
		///   common output size specified by <c>crop_size</c>. This is more general than the
		///   <c>crop_to_bounding_box</c> op which extracts a fixed size slice from the input image
		///   and does not allow resizing or aspect ratio change.
		///   
		///   Returns a tensor with <c>crops</c> from the input <c>image</c> at positions defined at the
		///   bounding box locations in <c>boxes</c>. The cropped boxes are all resized (with
		///   bilinear or nearest neighbor interpolation) to a fixed
		///   <c>size = [crop_height, crop_width]</c>. The result is a 4-D tensor
		///   <c>[num_boxes, crop_height, crop_width, depth]</c>. The resizing is corner aligned.
		///   In particular, if <c>boxes = [[0, 0, 1, 1]]</c>, the method will give identical
		///   results to using <c>tf.image.resize_bilinear()</c> or
		///   <c>tf.image.resize_nearest_neighbor()</c>(depends on the <c>method</c> argument) with
		///   <c>align_corners=True</c>.
		/// </remarks>
		public TF_Output CropAndResize (TF_Output image, TF_Output boxes, TF_Output box_ind, TF_Output crop_size, string method = null, float? extrapolation_value = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CropAndResize", MakeName ("CropAndResize", operName));
			c_api.TF_AddInput(desc, image);
			c_api.TF_AddInput(desc, boxes);
			c_api.TF_AddInput(desc, box_ind);
			c_api.TF_AddInput(desc, crop_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (method != null)
				c_api.TF_SetAttrString (desc, "method", method);
			
			if (extrapolation_value.HasValue)
				c_api.TF_SetAttrFloat (desc, "extrapolation_value", extrapolation_value.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var crops = new TF_Output (op, _idx++);
			return crops;
		}

		/// <summary>
		///   Computes the gradient of the crop_and_resize op wrt the input boxes tensor.
		/// </summary>
		/// <param name="grads">
		///   A 4-D tensor of shape <c>[num_boxes, crop_height, crop_width, depth]</c>.
		/// </param>
		/// <param name="image">
		///   A 4-D tensor of shape <c>[batch, image_height, image_width, depth]</c>.
		///   Both <c>image_height</c> and <c>image_width</c> need to be positive.
		/// </param>
		/// <param name="boxes">
		///   A 2-D tensor of shape <c>[num_boxes, 4]</c>. The <c>i</c>-th row of the tensor
		///   specifies the coordinates of a box in the <c>box_ind[i]</c> image and is specified
		///   in normalized coordinates <c>[y1, x1, y2, x2]</c>. A normalized coordinate value of
		///   <c>y</c> is mapped to the image coordinate at <c>y * (image_height - 1)</c>, so as the
		///   <c>[0, 1]</c> interval of normalized image height is mapped to
		///   <c>[0, image_height - 1] in image height coordinates. We do allow y1 &amp;gt; y2, in
		///   which case the sampled crop is an up-down flipped version of the original
		///   image. The width dimension is treated similarly. Normalized coordinates
		///   outside the </c>[0, 1]<c> range are allowed, in which case we use
		///   </c>extrapolation_value<c> to extrapolate the input image values.
		/// </param>
		/// <param name="box_ind">
		///   A 1-D tensor of shape <c>[num_boxes]</c> with int32 values in <c>[0, batch)</c>.
		///   The value of <c>box_ind[i]</c> specifies the image that the <c>i</c>-th box refers to.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CropAndResizeGradBoxes'.
		/// </param>
		/// <param name="method">
		///   Optional argument
		///   A string specifying the interpolation method. Only 'bilinear' is
		///   supported for now.
		/// </param>
		/// <returns>
		///   A 2-D tensor of shape <c>[num_boxes, 4]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CropAndResizeGradBoxes (TF_Output grads, TF_Output image, TF_Output boxes, TF_Output box_ind, string method = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CropAndResizeGradBoxes", MakeName ("CropAndResizeGradBoxes", operName));
			c_api.TF_AddInput(desc, grads);
			c_api.TF_AddInput(desc, image);
			c_api.TF_AddInput(desc, boxes);
			c_api.TF_AddInput(desc, box_ind);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (method != null)
				c_api.TF_SetAttrString (desc, "method", method);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the gradient of the crop_and_resize op wrt the input image tensor.
		/// </summary>
		/// <param name="grads">
		///   A 4-D tensor of shape <c>[num_boxes, crop_height, crop_width, depth]</c>.
		/// </param>
		/// <param name="boxes">
		///   A 2-D tensor of shape <c>[num_boxes, 4]</c>. The <c>i</c>-th row of the tensor
		///   specifies the coordinates of a box in the <c>box_ind[i]</c> image and is specified
		///   in normalized coordinates <c>[y1, x1, y2, x2]</c>. A normalized coordinate value of
		///   <c>y</c> is mapped to the image coordinate at <c>y * (image_height - 1)</c>, so as the
		///   <c>[0, 1]</c> interval of normalized image height is mapped to
		///   <c>[0, image_height - 1] in image height coordinates. We do allow y1 &amp;gt; y2, in
		///   which case the sampled crop is an up-down flipped version of the original
		///   image. The width dimension is treated similarly. Normalized coordinates
		///   outside the </c>[0, 1]<c> range are allowed, in which case we use
		///   </c>extrapolation_value<c> to extrapolate the input image values.
		/// </param>
		/// <param name="box_ind">
		///   A 1-D tensor of shape <c>[num_boxes]</c> with int32 values in <c>[0, batch)</c>.
		///   The value of <c>box_ind[i]</c> specifies the image that the <c>i</c>-th box refers to.
		/// </param>
		/// <param name="image_size">
		///   A 1-D tensor with value <c>[batch, image_height, image_width, depth]</c>
		///   containing the original image size. Both <c>image_height</c> and <c>image_width</c> need
		///   to be positive.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CropAndResizeGradImage'.
		/// </param>
		/// <param name="method">
		///   Optional argument
		///   A string specifying the interpolation method. Only 'bilinear' is
		///   supported for now.
		/// </param>
		/// <param name="T">
		/// </param>
		/// <returns>
		///   A 4-D tensor of shape <c>[batch, image_height, image_width, depth]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CropAndResizeGradImage (TF_Output grads, TF_Output boxes, TF_Output box_ind, TF_Output image_size, TF_DataType T, string method = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CropAndResizeGradImage", MakeName ("CropAndResizeGradImage", operName));
			c_api.TF_AddInput(desc, grads);
			c_api.TF_AddInput(desc, boxes);
			c_api.TF_AddInput(desc, box_ind);
			c_api.TF_AddInput(desc, image_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "T", T);
			if (method != null)
				c_api.TF_SetAttrString (desc, "method", method);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Compute the pairwise cross product.
		/// </summary>
		/// <param name="a">
		///   A tensor containing 3-element vectors.
		/// </param>
		/// <param name="b">
		///   Another tensor, of same type and shape as <c>a</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Cross'.
		/// </param>
		/// <returns>
		///   Pairwise cross product of the vectors in <c>a</c> and <c>b</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   <c>a</c> and <c>b</c> must be the same shape; they can either be simple 3-element vectors,
		///   or any shape where the innermost dimension is 3. In the latter case, each pair
		///   of corresponding 3-element vectors is cross-multiplied independently.
		/// </remarks>
		public TF_Output Cross (TF_Output a, TF_Output b, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Cross", MakeName ("Cross", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var product = new TF_Output (op, _idx++);
			return product;
		}

		/// <summary>
		///   An Op to sum inputs across replicated TPU instances.
		/// </summary>
		/// <param name="input">
		///   The local input to the sum.
		/// </param>
		/// <param name="group_assignment">
		///   An int32 tensor with shape
		///   [num_groups, num_replicas_per_group]. <c>group_assignment[i]</c> represents the
		///   replica ids in the ith subgroup.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CrossReplicaSum'.
		/// </param>
		/// <returns>
		///   The sum of all the distributed inputs.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Each instance supplies its own input.
		///   
		///   For example, suppose there are 8 TPU instances: <c>[A, B, C, D, E, F, G, H]</c>.
		///   Passing group_assignment=<c>[[0,2,4,6],[1,3,5,7]]</c> sets <c>A, C, E, G</c> as group 0,
		///   and <c>B, D, F, H</c> as group 1. Thus we get the outputs:
		///   <c>[A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H]</c>.
		/// </remarks>
		public TF_Output CrossReplicaSum (TF_Output input, TF_Output group_assignment, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CrossReplicaSum", MakeName ("CrossReplicaSum", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, group_assignment);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="filenames">
		/// </param>
		/// <param name="compression_type">
		/// </param>
		/// <param name="buffer_size">
		/// </param>
		/// <param name="header">
		/// </param>
		/// <param name="field_delim">
		/// </param>
		/// <param name="use_quote_delim">
		/// </param>
		/// <param name="na_value">
		/// </param>
		/// <param name="select_cols">
		/// </param>
		/// <param name="record_defaults">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CSVDataset'.
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output CSVDataset (TF_Output filenames, TF_Output compression_type, TF_Output buffer_size, TF_Output header, TF_Output field_delim, TF_Output use_quote_delim, TF_Output na_value, TF_Output select_cols, TF_Output[] record_defaults, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CSVDataset", MakeName ("CSVDataset", operName));
			c_api.TF_AddInput(desc, filenames);
			c_api.TF_AddInput(desc, compression_type);
			c_api.TF_AddInput(desc, buffer_size);
			c_api.TF_AddInput(desc, header);
			c_api.TF_AddInput(desc, field_delim);
			c_api.TF_AddInput(desc, use_quote_delim);
			c_api.TF_AddInput(desc, na_value);
			c_api.TF_AddInput(desc, select_cols);
			c_api.TF_AddInputList(desc, record_defaults[0], record_defaults.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Performs beam search decoding on the logits given in input.
		/// </summary>
		/// <param name="inputs">
		///   3-D, shape: <c>(max_time x batch_size x num_classes)</c>, the logits.
		/// </param>
		/// <param name="sequence_length">
		///   A vector containing sequence lengths, size <c>(batch)</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CTCBeamSearchDecoder'.
		/// </param>
		/// <param name="merge_repeated">
		///   Optional argument
		///   If true, merge repeated classes in output.
		/// </param>
		/// <param name="beam_width">
		///   A scalar &amp;gt;= 0 (beam search beam width).
		/// </param>
		/// <param name="top_paths">
		///   A scalar &amp;gt;= 0, &amp;lt;= beam_width (controls output size).
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   decoded_indices: A list (length: top_paths) of indices matrices.  Matrix j,
		///   size <c>(total_decoded_outputs[j] x 2)</c>, has indices of a
		///   <c>SparseTensor&amp;lt;int64, 2&amp;gt;</c>.  The rows store: [batch, time].
		///   decoded_values: A list (length: top_paths) of values vectors.  Vector j,
		///   size <c>(length total_decoded_outputs[j])</c>, has the values of a
		///   <c>SparseTensor&amp;lt;int64, 2&amp;gt;</c>.  The vector stores the decoded classes for beam j.
		///   decoded_shape: A list (length: top_paths) of shape vector.  Vector j,
		///   size <c>(2)</c>, stores the shape of the decoded <c>SparseTensor[j]</c>.
		///   Its values are: <c>[batch_size, max_decoded_length[j]]</c>.
		///   log_probability: A matrix, shaped: <c>(batch_size x top_paths)</c>.  The
		///   sequence log-probabilities.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   A note about the attribute merge_repeated: For the beam search decoder,
		///   this means that if consecutive entries in a beam are the same, only
		///   the first of these is emitted.  That is, when the top path is "A B B B B",
		///   "A B" is returned if merge_repeated = True but "A B B B B" is
		///   returned if merge_repeated = False.
		/// </remarks>
		public (TF_Output[] decoded_indices, TF_Output[] decoded_values, TF_Output[] decoded_shape, TF_Output log_probability) CTCBeamSearchDecoder (TF_Output inputs, TF_Output sequence_length, long beam_width, long top_paths, bool? merge_repeated = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CTCBeamSearchDecoder", MakeName ("CTCBeamSearchDecoder", operName));
			c_api.TF_AddInput(desc, inputs);
			c_api.TF_AddInput(desc, sequence_length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "beam_width", beam_width);
			c_api.TF_SetAttrInt (desc, "top_paths", top_paths);
			if (merge_repeated.HasValue)
				c_api.TF_SetAttrBool (desc, "merge_repeated", Convert.ToByte(merge_repeated.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "decoded_indices", status);
			var decoded_indices = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				decoded_indices [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "decoded_values", status);
			var decoded_values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				decoded_values [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "decoded_shape", status);
			var decoded_shape = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				decoded_shape [i] = new TF_Output (op, _idx++);
			
			var log_probability = new TF_Output (op, _idx++);
			return (decoded_indices, decoded_values, decoded_shape, log_probability);
		}

		/// <summary>
		///   Performs greedy decoding on the logits given in inputs.
		/// </summary>
		/// <param name="inputs">
		///   3-D, shape: <c>(max_time x batch_size x num_classes)</c>, the logits.
		/// </param>
		/// <param name="sequence_length">
		///   A vector containing sequence lengths, size <c>(batch_size)</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CTCGreedyDecoder'.
		/// </param>
		/// <param name="merge_repeated">
		///   Optional argument
		///   If True, merge repeated classes in output.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   decoded_indices: Indices matrix, size <c>(total_decoded_outputs x 2)</c>,
		///   of a <c>SparseTensor&amp;lt;int64, 2&amp;gt;</c>.  The rows store: [batch, time].
		///   decoded_values: Values vector, size: <c>(total_decoded_outputs)</c>,
		///   of a <c>SparseTensor&amp;lt;int64, 2&amp;gt;</c>.  The vector stores the decoded classes.
		///   decoded_shape: Shape vector, size <c>(2)</c>, of the decoded SparseTensor.
		///   Values are: <c>[batch_size, max_decoded_length]</c>.
		///   log_probability: Matrix, size <c>(batch_size x 1)</c>, containing sequence
		///   log-probabilities.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   A note about the attribute merge_repeated: if enabled, when
		///   consecutive logits' maximum indices are the same, only the first of
		///   these is emitted.  Labeling the blank '*', the sequence "A B B * B B"
		///   becomes "A B B" if merge_repeated = True and "A B B B B" if
		///   merge_repeated = False.
		///   
		///   Regardless of the value of merge_repeated, if the maximum index of a given
		///   time and batch corresponds to the blank, index <c>(num_classes - 1)</c>, no new
		///   element is emitted.
		/// </remarks>
		public (TF_Output decoded_indices, TF_Output decoded_values, TF_Output decoded_shape, TF_Output log_probability) CTCGreedyDecoder (TF_Output inputs, TF_Output sequence_length, bool? merge_repeated = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CTCGreedyDecoder", MakeName ("CTCGreedyDecoder", operName));
			c_api.TF_AddInput(desc, inputs);
			c_api.TF_AddInput(desc, sequence_length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (merge_repeated.HasValue)
				c_api.TF_SetAttrBool (desc, "merge_repeated", Convert.ToByte(merge_repeated.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var decoded_indices = new TF_Output (op, _idx++);
			var decoded_values = new TF_Output (op, _idx++);
			var decoded_shape = new TF_Output (op, _idx++);
			var log_probability = new TF_Output (op, _idx++);
			return (decoded_indices, decoded_values, decoded_shape, log_probability);
		}

		/// <summary>
		///   Calculates the CTC Loss (log probability) for each batch entry.  Also calculates
		/// </summary>
		/// <param name="inputs">
		///   3-D, shape: <c>(max_time x batch_size x num_classes)</c>, the logits.
		/// </param>
		/// <param name="labels_indices">
		///   The indices of a <c>SparseTensor&amp;lt;int32, 2&amp;gt;</c>.
		///   <c>labels_indices(i, :) == [b, t]</c> means <c>labels_values(i)</c> stores the id for
		///   <c>(batch b, time t)</c>.
		/// </param>
		/// <param name="labels_values">
		///   The values (labels) associated with the given batch and time.
		/// </param>
		/// <param name="sequence_length">
		///   A vector containing sequence lengths (batch).
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CTCLoss'.
		/// </param>
		/// <param name="preprocess_collapse_repeated">
		///   Optional argument
		///   Scalar, if true then repeated labels are
		///   collapsed prior to the CTC calculation.
		/// </param>
		/// <param name="ctc_merge_repeated">
		///   Optional argument
		///   Scalar.  If set to false, *during* CTC calculation
		///   repeated non-blank labels will not be merged and are interpreted as
		///   individual labels.  This is a simplified version of CTC.
		/// </param>
		/// <param name="ignore_longer_outputs_than_inputs">
		///   Optional argument
		///   Scalar. If set to true, during CTC
		///   calculation, items that have longer output sequences than input sequences
		///   are skipped: they don't contribute to the loss term and have zero-gradient.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   loss: A vector (batch) containing log-probabilities.
		///   gradient: The gradient of <c>loss</c>.  3-D, shape:
		///   <c>(max_time x batch_size x num_classes)</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   the gradient.  This class performs the softmax operation for you, so inputs
		///   should be e.g. linear projections of outputs by an LSTM.
		/// </remarks>
		public (TF_Output loss, TF_Output gradient) CTCLoss (TF_Output inputs, TF_Output labels_indices, TF_Output labels_values, TF_Output sequence_length, bool? preprocess_collapse_repeated = null, bool? ctc_merge_repeated = null, bool? ignore_longer_outputs_than_inputs = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CTCLoss", MakeName ("CTCLoss", operName));
			c_api.TF_AddInput(desc, inputs);
			c_api.TF_AddInput(desc, labels_indices);
			c_api.TF_AddInput(desc, labels_values);
			c_api.TF_AddInput(desc, sequence_length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (preprocess_collapse_repeated.HasValue)
				c_api.TF_SetAttrBool (desc, "preprocess_collapse_repeated", Convert.ToByte(preprocess_collapse_repeated.Value));
			
			if (ctc_merge_repeated.HasValue)
				c_api.TF_SetAttrBool (desc, "ctc_merge_repeated", Convert.ToByte(ctc_merge_repeated.Value));
			
			if (ignore_longer_outputs_than_inputs.HasValue)
				c_api.TF_SetAttrBool (desc, "ignore_longer_outputs_than_inputs", Convert.ToByte(ignore_longer_outputs_than_inputs.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var loss = new TF_Output (op, _idx++);
			var gradient = new TF_Output (op, _idx++);
			return (loss, gradient);
		}

		/// <summary>
		///   A RNN backed by cuDNN.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_h">
		/// </param>
		/// <param name="input_c">
		/// </param>
		/// <param name="parameters">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNN'.
		/// </param>
		/// <param name="rnn_mode">
		///   Optional argument
		/// </param>
		/// <param name="input_mode">
		///   Optional argument
		/// </param>
		/// <param name="direction">
		///   Optional argument
		/// </param>
		/// <param name="dropout">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="is_training">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   output_h:
		///   output_c:
		///   reserve_space:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Computes the RNN from the input and initial states, with respect to the params
		///   buffer.
		///   
		///   rnn_mode: Indicates the type of the RNN model.
		///   input_mode: Indicate whether there is a linear projection between the input and
		///   the actual computation before the first layer. 'skip_input' is only allowed
		///   when input_size == num_units; 'auto_select' implies 'skip_input' when
		///   input_size == num_units; otherwise, it implies 'linear_input'.
		///   direction: Indicates whether a bidirectional model will be used. Should be
		///   "unidirectional" or "bidirectional".
		///   dropout: Dropout probability. When set to 0., dropout is disabled.
		///   seed: The 1st part of a seed to initialize dropout.
		///   seed2: The 2nd part of a seed to initialize dropout.
		///   input: A 3-D tensor with the shape of [seq_length, batch_size, input_size].
		///   input_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,
		///   num_units].
		///   input_c: For LSTM, a 3-D tensor with the shape of
		///   [num_layer * dir, batch, num_units]. For other models, it is ignored.
		///   params: A 1-D tensor that contains the weights and biases in an opaque layout.
		///   The size must be created through CudnnRNNParamsSize, and initialized
		///   separately. Note that they might not be compatible across different
		///   generations. So it is a good idea to save and restore
		///   output: A 3-D tensor with the shape of [seq_length, batch_size,
		///   dir * num_units].
		///   output_h: The same shape has input_h.
		///   output_c: The same shape as input_c for LSTM. An empty tensor for other models.
		///   is_training: Indicates whether this operation is used for inferenece or
		///   training.
		///   reserve_space: An opaque tensor that can be used in backprop calculation. It
		///   is only produced if is_training is false.
		/// </remarks>
		public (TF_Output output, TF_Output output_h, TF_Output output_c, TF_Output reserve_space) CudnnRNN (TF_Output input, TF_Output input_h, TF_Output input_c, TF_Output parameters, string rnn_mode = null, string input_mode = null, string direction = null, float? dropout = null, long? seed = null, long? seed2 = null, bool? is_training = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CudnnRNN", MakeName ("CudnnRNN", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_h);
			c_api.TF_AddInput(desc, input_c);
			c_api.TF_AddInput(desc, parameters);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (rnn_mode != null)
				c_api.TF_SetAttrString (desc, "rnn_mode", rnn_mode);
			
			if (input_mode != null)
				c_api.TF_SetAttrString (desc, "input_mode", input_mode);
			
			if (direction != null)
				c_api.TF_SetAttrString (desc, "direction", direction);
			
			if (dropout.HasValue)
				c_api.TF_SetAttrFloat (desc, "dropout", dropout.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (is_training.HasValue)
				c_api.TF_SetAttrBool (desc, "is_training", Convert.ToByte(is_training.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var output_h = new TF_Output (op, _idx++);
			var output_c = new TF_Output (op, _idx++);
			var reserve_space = new TF_Output (op, _idx++);
			return (output, output_h, output_c, reserve_space);
		}

		/// <summary>
		///   Backprop step of CudnnRNN.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_h">
		/// </param>
		/// <param name="input_c">
		/// </param>
		/// <param name="parameters">
		/// </param>
		/// <param name="output">
		/// </param>
		/// <param name="output_h">
		/// </param>
		/// <param name="output_c">
		/// </param>
		/// <param name="output_backprop">
		/// </param>
		/// <param name="output_h_backprop">
		/// </param>
		/// <param name="output_c_backprop">
		/// </param>
		/// <param name="reserve_space">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNBackprop'.
		/// </param>
		/// <param name="rnn_mode">
		///   Optional argument
		/// </param>
		/// <param name="input_mode">
		///   Optional argument
		/// </param>
		/// <param name="direction">
		///   Optional argument
		/// </param>
		/// <param name="dropout">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   input_backprop:
		///   input_h_backprop:
		///   input_c_backprop:
		///   params_backprop:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Compute the backprop of both data and weights in a RNN.
		///   
		///   rnn_mode: Indicates the type of the RNN model.
		///   input_mode: Indicate whether there is a linear projection between the input and
		///   the actual computation before the first layer. 'skip_input' is only allowed
		///   when input_size == num_units; 'auto_select' implies 'skip_input' when
		///   input_size == num_units; otherwise, it implies 'linear_input'.
		///   direction: Indicates whether a bidirectional model will be used. Should be
		///   "unidirectional" or "bidirectional".
		///   dropout: Dropout probability. When set to 0., dropout is disabled.
		///   seed: The 1st part of a seed to initialize dropout.
		///   seed2: The 2nd part of a seed to initialize dropout.
		///   input: A 3-D tensor with the shape of [seq_length, batch_size, input_size].
		///   input_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,
		///   num_units].
		///   input_c: For LSTM, a 3-D tensor with the shape of
		///   [num_layer * dir, batch, num_units]. For other models, it is ignored.
		///   params: A 1-D tensor that contains the weights and biases in an opaque layout.
		///   The size must be created through CudnnRNNParamsSize, and initialized
		///   separately. Note that they might not be compatible across different
		///   generations. So it is a good idea to save and restore
		///   output: A 3-D tensor with the shape of [seq_length, batch_size,
		///   dir * num_units].
		///   output_h: The same shape has input_h.
		///   output_c: The same shape as input_c for LSTM. An empty tensor for other models.
		///   output_backprop: A 3-D tensor with the same shape as output in the forward pass.
		///   output_h_backprop: A 3-D tensor with the same shape as output_h in the forward
		///   pass.
		///   output_c_backprop: A 3-D tensor with the same shape as output_c in the forward
		///   pass.
		///   reserve_space: The same reserve_space produced in for forward operation.
		///   input_backprop: The backprop to input in the forward pass. Has the same shape
		///   as input.
		///   input_h_backprop: The backprop to input_h in the forward pass. Has the same
		///   shape as input_h.
		///   input_c_backprop: The backprop to input_c in the forward pass. Has the same
		///   shape as input_c.
		///   params_backprop: The backprop to the params buffer in the forward pass. Has the
		///   same shape as params.
		/// </remarks>
		public (TF_Output input_backprop, TF_Output input_h_backprop, TF_Output input_c_backprop, TF_Output params_backprop) CudnnRNNBackprop (TF_Output input, TF_Output input_h, TF_Output input_c, TF_Output parameters, TF_Output output, TF_Output output_h, TF_Output output_c, TF_Output output_backprop, TF_Output output_h_backprop, TF_Output output_c_backprop, TF_Output reserve_space, string rnn_mode = null, string input_mode = null, string direction = null, float? dropout = null, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CudnnRNNBackprop", MakeName ("CudnnRNNBackprop", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_h);
			c_api.TF_AddInput(desc, input_c);
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, output);
			c_api.TF_AddInput(desc, output_h);
			c_api.TF_AddInput(desc, output_c);
			c_api.TF_AddInput(desc, output_backprop);
			c_api.TF_AddInput(desc, output_h_backprop);
			c_api.TF_AddInput(desc, output_c_backprop);
			c_api.TF_AddInput(desc, reserve_space);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (rnn_mode != null)
				c_api.TF_SetAttrString (desc, "rnn_mode", rnn_mode);
			
			if (input_mode != null)
				c_api.TF_SetAttrString (desc, "input_mode", input_mode);
			
			if (direction != null)
				c_api.TF_SetAttrString (desc, "direction", direction);
			
			if (dropout.HasValue)
				c_api.TF_SetAttrFloat (desc, "dropout", dropout.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var input_backprop = new TF_Output (op, _idx++);
			var input_h_backprop = new TF_Output (op, _idx++);
			var input_c_backprop = new TF_Output (op, _idx++);
			var params_backprop = new TF_Output (op, _idx++);
			return (input_backprop, input_h_backprop, input_c_backprop, params_backprop);
		}

		/// <summary>
		///   Backprop step of CudnnRNN.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_h">
		/// </param>
		/// <param name="input_c">
		/// </param>
		/// <param name="parameters">
		/// </param>
		/// <param name="output">
		/// </param>
		/// <param name="output_h">
		/// </param>
		/// <param name="output_c">
		/// </param>
		/// <param name="output_backprop">
		/// </param>
		/// <param name="output_h_backprop">
		/// </param>
		/// <param name="output_c_backprop">
		/// </param>
		/// <param name="reserve_space">
		/// </param>
		/// <param name="host_reserved">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNBackpropV2'.
		/// </param>
		/// <param name="rnn_mode">
		///   Optional argument
		/// </param>
		/// <param name="input_mode">
		///   Optional argument
		/// </param>
		/// <param name="direction">
		///   Optional argument
		/// </param>
		/// <param name="dropout">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   input_backprop:
		///   input_h_backprop:
		///   input_c_backprop:
		///   params_backprop:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Compute the backprop of both data and weights in a RNN. Takes an extra
		///   "host_reserved" inupt than CudnnRNNBackprop, which is used to determine RNN
		///   cudnnRNNAlgo_t and cudnnMathType_t.
		///   
		///   rnn_mode: Indicates the type of the RNN model.
		///   input_mode: Indicates whether there is a linear projection between the input and
		///   the actual computation before the first layer. 'skip_input' is only allowed
		///   when input_size == num_units; 'auto_select' implies 'skip_input' when
		///   input_size == num_units; otherwise, it implies 'linear_input'.
		///   direction: Indicates whether a bidirectional model will be used. Should be
		///   "unidirectional" or "bidirectional".
		///   dropout: Dropout probability. When set to 0., dropout is disabled.
		///   seed: The 1st part of a seed to initialize dropout.
		///   seed2: The 2nd part of a seed to initialize dropout.
		///   input: A 3-D tensor with the shape of [seq_length, batch_size, input_size].
		///   input_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,
		///   num_units].
		///   input_c: For LSTM, a 3-D tensor with the shape of
		///   [num_layer * dir, batch, num_units]. For other models, it is ignored.
		///   params: A 1-D tensor that contains the weights and biases in an opaque layout.
		///   The size must be created through CudnnRNNParamsSize, and initialized
		///   separately. Note that they might not be compatible across different
		///   generations. So it is a good idea to save and restore
		///   output: A 3-D tensor with the shape of [seq_length, batch_size,
		///   dir * num_units].
		///   output_h: The same shape has input_h.
		///   output_c: The same shape as input_c for LSTM. An empty tensor for other models.
		///   output_backprop: A 3-D tensor with the same shape as output in the forward pass.
		///   output_h_backprop: A 3-D tensor with the same shape as output_h in the forward
		///   pass.
		///   output_c_backprop: A 3-D tensor with the same shape as output_c in the forward
		///   pass.
		///   reserve_space: The same reserve_space produced in the forward operation.
		///   host_reserved: The same host_reserved produced in the forward operation.
		///   input_backprop: The backprop to input in the forward pass. Has the same shape
		///   as input.
		///   input_h_backprop: The backprop to input_h in the forward pass. Has the same
		///   shape as input_h.
		///   input_c_backprop: The backprop to input_c in the forward pass. Has the same
		///   shape as input_c.
		///   params_backprop: The backprop to the params buffer in the forward pass. Has the
		///   same shape as params.
		/// </remarks>
		public (TF_Output input_backprop, TF_Output input_h_backprop, TF_Output input_c_backprop, TF_Output params_backprop) CudnnRNNBackpropV2 (TF_Output input, TF_Output input_h, TF_Output input_c, TF_Output parameters, TF_Output output, TF_Output output_h, TF_Output output_c, TF_Output output_backprop, TF_Output output_h_backprop, TF_Output output_c_backprop, TF_Output reserve_space, TF_Output host_reserved, string rnn_mode = null, string input_mode = null, string direction = null, float? dropout = null, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CudnnRNNBackpropV2", MakeName ("CudnnRNNBackpropV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_h);
			c_api.TF_AddInput(desc, input_c);
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, output);
			c_api.TF_AddInput(desc, output_h);
			c_api.TF_AddInput(desc, output_c);
			c_api.TF_AddInput(desc, output_backprop);
			c_api.TF_AddInput(desc, output_h_backprop);
			c_api.TF_AddInput(desc, output_c_backprop);
			c_api.TF_AddInput(desc, reserve_space);
			c_api.TF_AddInput(desc, host_reserved);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (rnn_mode != null)
				c_api.TF_SetAttrString (desc, "rnn_mode", rnn_mode);
			
			if (input_mode != null)
				c_api.TF_SetAttrString (desc, "input_mode", input_mode);
			
			if (direction != null)
				c_api.TF_SetAttrString (desc, "direction", direction);
			
			if (dropout.HasValue)
				c_api.TF_SetAttrFloat (desc, "dropout", dropout.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var input_backprop = new TF_Output (op, _idx++);
			var input_h_backprop = new TF_Output (op, _idx++);
			var input_c_backprop = new TF_Output (op, _idx++);
			var params_backprop = new TF_Output (op, _idx++);
			return (input_backprop, input_h_backprop, input_c_backprop, params_backprop);
		}

		/// <summary>
		///   Backprop step of CudnnRNNV3.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_h">
		/// </param>
		/// <param name="input_c">
		/// </param>
		/// <param name="parameters">
		/// </param>
		/// <param name="sequence_lengths">
		/// </param>
		/// <param name="output">
		/// </param>
		/// <param name="output_h">
		/// </param>
		/// <param name="output_c">
		/// </param>
		/// <param name="output_backprop">
		/// </param>
		/// <param name="output_h_backprop">
		/// </param>
		/// <param name="output_c_backprop">
		/// </param>
		/// <param name="reserve_space">
		/// </param>
		/// <param name="host_reserved">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNBackpropV3'.
		/// </param>
		/// <param name="rnn_mode">
		///   Optional argument
		/// </param>
		/// <param name="input_mode">
		///   Optional argument
		/// </param>
		/// <param name="direction">
		///   Optional argument
		/// </param>
		/// <param name="dropout">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="num_proj">
		///   Optional argument
		/// </param>
		/// <param name="time_major">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   input_backprop:
		///   input_h_backprop:
		///   input_c_backprop:
		///   params_backprop:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Compute the backprop of both data and weights in a RNN. Takes an extra
		///   "sequence_lengths" input than CudnnRNNBackprop.
		///   
		///   rnn_mode: Indicates the type of the RNN model.
		///   input_mode: Indicates whether there is a linear projection between the input and
		///   the actual computation before the first layer. 'skip_input' is only allowed
		///   when input_size == num_units; 'auto_select' implies 'skip_input' when
		///   input_size == num_units; otherwise, it implies 'linear_input'.
		///   direction: Indicates whether a bidirectional model will be used. Should be
		///   "unidirectional" or "bidirectional".
		///   dropout: Dropout probability. When set to 0., dropout is disabled.
		///   seed: The 1st part of a seed to initialize dropout.
		///   seed2: The 2nd part of a seed to initialize dropout.
		///   input: If time_major is true, this is a 3-D tensor with the shape of
		///   [seq_length, batch_size, input_size]. If time_major is false, the shape is
		///   [batch_size, seq_length, input_size].
		///   input_h: If time_major is true, this is a 3-D tensor with the shape of
		///   [num_layer * dir, batch_size, num_units]. If time_major is false, the shape
		///   is [batch_size, num_layer * dir, num_units].
		///   input_c: For LSTM, a 3-D tensor with the shape of
		///   [num_layer * dir, batch, num_units]. For other models, it is ignored.
		///   params: A 1-D tensor that contains the weights and biases in an opaque layout.
		///   The size must be created through CudnnRNNParamsSize, and initialized
		///   separately. Note that they might not be compatible across different
		///   generations. So it is a good idea to save and restore
		///   sequence_lengths: a vector of lengths of each input sequence.
		///   output: If time_major is true, this is a 3-D tensor with the shape of
		///   [seq_length, batch_size, dir * num_units]. If time_major is false, the
		///   shape is [batch_size, seq_length, dir * num_units].
		///   output_h: The same shape has input_h.
		///   output_c: The same shape as input_c for LSTM. An empty tensor for other models.
		///   output_backprop: A 3-D tensor with the same shape as output in the forward pass.
		///   output_h_backprop: A 3-D tensor with the same shape as output_h in the forward
		///   pass.
		///   output_c_backprop: A 3-D tensor with the same shape as output_c in the forward
		///   pass.
		///   time_major: Indicates whether the input/output format is time major or batch
		///   major.
		///   reserve_space: The same reserve_space produced in the forward operation.
		///   input_backprop: The backprop to input in the forward pass. Has the same shape
		///   as input.
		///   input_h_backprop: The backprop to input_h in the forward pass. Has the same
		///   shape as input_h.
		///   input_c_backprop: The backprop to input_c in the forward pass. Has the same
		///   shape as input_c.
		///   params_backprop: The backprop to the params buffer in the forward pass. Has the
		///   same shape as params.
		/// </remarks>
		public (TF_Output input_backprop, TF_Output input_h_backprop, TF_Output input_c_backprop, TF_Output params_backprop) CudnnRNNBackpropV3 (TF_Output input, TF_Output input_h, TF_Output input_c, TF_Output parameters, TF_Output sequence_lengths, TF_Output output, TF_Output output_h, TF_Output output_c, TF_Output output_backprop, TF_Output output_h_backprop, TF_Output output_c_backprop, TF_Output reserve_space, TF_Output host_reserved, string rnn_mode = null, string input_mode = null, string direction = null, float? dropout = null, long? seed = null, long? seed2 = null, long? num_proj = null, bool? time_major = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CudnnRNNBackpropV3", MakeName ("CudnnRNNBackpropV3", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_h);
			c_api.TF_AddInput(desc, input_c);
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, sequence_lengths);
			c_api.TF_AddInput(desc, output);
			c_api.TF_AddInput(desc, output_h);
			c_api.TF_AddInput(desc, output_c);
			c_api.TF_AddInput(desc, output_backprop);
			c_api.TF_AddInput(desc, output_h_backprop);
			c_api.TF_AddInput(desc, output_c_backprop);
			c_api.TF_AddInput(desc, reserve_space);
			c_api.TF_AddInput(desc, host_reserved);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (rnn_mode != null)
				c_api.TF_SetAttrString (desc, "rnn_mode", rnn_mode);
			
			if (input_mode != null)
				c_api.TF_SetAttrString (desc, "input_mode", input_mode);
			
			if (direction != null)
				c_api.TF_SetAttrString (desc, "direction", direction);
			
			if (dropout.HasValue)
				c_api.TF_SetAttrFloat (desc, "dropout", dropout.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (num_proj.HasValue)
				c_api.TF_SetAttrInt (desc, "num_proj", num_proj.Value);
			
			if (time_major.HasValue)
				c_api.TF_SetAttrBool (desc, "time_major", Convert.ToByte(time_major.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var input_backprop = new TF_Output (op, _idx++);
			var input_h_backprop = new TF_Output (op, _idx++);
			var input_c_backprop = new TF_Output (op, _idx++);
			var params_backprop = new TF_Output (op, _idx++);
			return (input_backprop, input_h_backprop, input_c_backprop, params_backprop);
		}

		/// <summary>
		///   Converts CudnnRNN params from canonical form to usable form.
		/// </summary>
		/// <param name="num_layers">
		/// </param>
		/// <param name="num_units">
		/// </param>
		/// <param name="input_size">
		/// </param>
		/// <param name="weights">
		/// </param>
		/// <param name="biases">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNCanonicalToParams'.
		/// </param>
		/// <param name="rnn_mode">
		///   Optional argument
		/// </param>
		/// <param name="input_mode">
		///   Optional argument
		/// </param>
		/// <param name="direction">
		///   Optional argument
		/// </param>
		/// <param name="dropout">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Writes a set of weights into the opaque params buffer so they can be used in
		///   upcoming training or inferences.
		///   
		///   Note that the params buffer may not be compatible across different GPUs. So any
		///   save and restoration should be converted to and from the canonical weights and
		///   biases.
		///   
		///   num_layers: Specifies the number of layers in the RNN model.
		///   num_units: Specifies the size of the hidden state.
		///   input_size: Specifies the size of the input state.
		///   weights: the canonical form of weights that can be used for saving
		///   and restoration. They are more likely to be compatible across different
		///   generations.
		///   biases: the canonical form of biases that can be used for saving
		///   and restoration. They are more likely to be compatible across different
		///   generations.
		///   num_params: number of parameter sets for all layers.
		///   Each layer may contain multiple parameter sets, with each set consisting of
		///   a weight matrix and a bias vector.
		///   rnn_mode: Indicates the type of the RNN model.
		///   input_mode: Indicate whether there is a linear projection between the input and
		///   The actual computation before the first layer. 'skip_input' is only allowed
		///   when input_size == num_units; 'auto_select' implies 'skip_input' when
		///   input_size == num_units; otherwise, it implies 'linear_input'.
		///   direction: Indicates whether a bidirectional model will be used.
		///   dir = (direction == bidirectional) ? 2 : 1
		///   dropout: dropout probability. When set to 0., dropout is disabled.
		///   seed: the 1st part of a seed to initialize dropout.
		///   seed2: the 2nd part of a seed to initialize dropout.
		/// </remarks>
		public TF_Output CudnnRNNCanonicalToParams (TF_Output num_layers, TF_Output num_units, TF_Output input_size, TF_Output[] weights, TF_Output[] biases, string rnn_mode = null, string input_mode = null, string direction = null, float? dropout = null, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CudnnRNNCanonicalToParams", MakeName ("CudnnRNNCanonicalToParams", operName));
			c_api.TF_AddInput(desc, num_layers);
			c_api.TF_AddInput(desc, num_units);
			c_api.TF_AddInput(desc, input_size);
			c_api.TF_AddInputList(desc, weights[0], weights.Length);
			c_api.TF_AddInputList(desc, biases[0], biases.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (rnn_mode != null)
				c_api.TF_SetAttrString (desc, "rnn_mode", rnn_mode);
			
			if (input_mode != null)
				c_api.TF_SetAttrString (desc, "input_mode", input_mode);
			
			if (direction != null)
				c_api.TF_SetAttrString (desc, "direction", direction);
			
			if (dropout.HasValue)
				c_api.TF_SetAttrFloat (desc, "dropout", dropout.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			return parameters;
		}

		/// <summary>
		///   Converts CudnnRNN params from canonical form to usable form. It supports the projection in LSTM.
		/// </summary>
		/// <param name="num_layers">
		/// </param>
		/// <param name="num_units">
		/// </param>
		/// <param name="input_size">
		/// </param>
		/// <param name="weights">
		/// </param>
		/// <param name="biases">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNCanonicalToParamsV2'.
		/// </param>
		/// <param name="rnn_mode">
		///   Optional argument
		/// </param>
		/// <param name="input_mode">
		///   Optional argument
		/// </param>
		/// <param name="direction">
		///   Optional argument
		/// </param>
		/// <param name="dropout">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="num_proj">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Writes a set of weights into the opaque params buffer so they can be used in
		///   upcoming training or inferences.
		///   
		///   Note that the params buffer may not be compatible across different GPUs. So any
		///   save and restoration should be converted to and from the canonical weights and
		///   biases.
		///   
		///   num_layers: Specifies the number of layers in the RNN model.
		///   num_units: Specifies the size of the hidden state.
		///   input_size: Specifies the size of the input state.
		///   weights: the canonical form of weights that can be used for saving
		///   and restoration. They are more likely to be compatible across different
		///   generations.
		///   biases: the canonical form of biases that can be used for saving
		///   and restoration. They are more likely to be compatible across different
		///   generations.
		///   num_params_weigths: number of weight parameter matrix for all layers.
		///   num_params_biases: number of bias parameter vector for all layers.
		///   rnn_mode: Indicates the type of the RNN model.
		///   input_mode: Indicate whether there is a linear projection between the input and
		///   The actual computation before the first layer. 'skip_input' is only allowed
		///   when input_size == num_units; 'auto_select' implies 'skip_input' when
		///   input_size == num_units; otherwise, it implies 'linear_input'.
		///   direction: Indicates whether a bidirectional model will be used.
		///   dir = (direction == bidirectional) ? 2 : 1
		///   dropout: dropout probability. When set to 0., dropout is disabled.
		///   seed: the 1st part of a seed to initialize dropout.
		///   seed2: the 2nd part of a seed to initialize dropout.
		///   num_proj: The output dimensionality for the projection matrices. If None or 0,
		///   no projection is performed.
		/// </remarks>
		public TF_Output CudnnRNNCanonicalToParamsV2 (TF_Output num_layers, TF_Output num_units, TF_Output input_size, TF_Output[] weights, TF_Output[] biases, string rnn_mode = null, string input_mode = null, string direction = null, float? dropout = null, long? seed = null, long? seed2 = null, long? num_proj = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CudnnRNNCanonicalToParamsV2", MakeName ("CudnnRNNCanonicalToParamsV2", operName));
			c_api.TF_AddInput(desc, num_layers);
			c_api.TF_AddInput(desc, num_units);
			c_api.TF_AddInput(desc, input_size);
			c_api.TF_AddInputList(desc, weights[0], weights.Length);
			c_api.TF_AddInputList(desc, biases[0], biases.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (rnn_mode != null)
				c_api.TF_SetAttrString (desc, "rnn_mode", rnn_mode);
			
			if (input_mode != null)
				c_api.TF_SetAttrString (desc, "input_mode", input_mode);
			
			if (direction != null)
				c_api.TF_SetAttrString (desc, "direction", direction);
			
			if (dropout.HasValue)
				c_api.TF_SetAttrFloat (desc, "dropout", dropout.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (num_proj.HasValue)
				c_api.TF_SetAttrInt (desc, "num_proj", num_proj.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			return parameters;
		}

		/// <summary>
		///   Computes size of weights that can be used by a Cudnn RNN model.
		/// </summary>
		/// <param name="num_layers">
		/// </param>
		/// <param name="num_units">
		/// </param>
		/// <param name="input_size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNParamsSize'.
		/// </param>
		/// <param name="rnn_mode">
		///   Optional argument
		/// </param>
		/// <param name="input_mode">
		///   Optional argument
		/// </param>
		/// <param name="direction">
		///   Optional argument
		/// </param>
		/// <param name="dropout">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="num_proj">
		///   Optional argument
		/// </param>
		/// <param name="T">
		/// </param>
		/// <param name="S">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Return the params size that can be used by the Cudnn RNN model. Subsequent
		///   weight allocation and initialization should use this size.
		///   
		///   num_layers: Specifies the number of layers in the RNN model.
		///   num_units: Specifies the size of the hidden state.
		///   input_size: Specifies the size of the input state.
		///   rnn_mode: Indicates the type of the RNN model.
		///   input_mode: Indicate whether there is a linear projection between the input and
		///   The actual computation before the first layer. 'skip_input' is only allowed
		///   when input_size == num_units; 'auto_select' implies 'skip_input' when
		///   input_size == num_units; otherwise, it implies 'linear_input'.
		///   direction: Indicates whether a bidirectional model will be used.
		///   dir = (direction == bidirectional) ? 2 : 1
		///   dropout: dropout probability. When set to 0., dropout is disabled.
		///   seed: the 1st part of a seed to initialize dropout.
		///   seed2: the 2nd part of a seed to initialize dropout.
		///   params_size: The size of the params buffer that should be allocated and
		///   initialized for this RNN model. Note that this params buffer may not be
		///   compatible across GPUs. Please use CudnnRNNParamsWeights and
		///   CudnnRNNParamsBiases to save and restore them in a way that is compatible
		///   across different runs.
		/// </remarks>
		public TF_Output CudnnRNNParamsSize (TF_Output num_layers, TF_Output num_units, TF_Output input_size, TF_DataType T, TF_DataType S, string rnn_mode = null, string input_mode = null, string direction = null, float? dropout = null, long? seed = null, long? seed2 = null, long? num_proj = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CudnnRNNParamsSize", MakeName ("CudnnRNNParamsSize", operName));
			c_api.TF_AddInput(desc, num_layers);
			c_api.TF_AddInput(desc, num_units);
			c_api.TF_AddInput(desc, input_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "T", T);
			c_api.TF_SetAttrType (desc, "S", S);
			if (rnn_mode != null)
				c_api.TF_SetAttrString (desc, "rnn_mode", rnn_mode);
			
			if (input_mode != null)
				c_api.TF_SetAttrString (desc, "input_mode", input_mode);
			
			if (direction != null)
				c_api.TF_SetAttrString (desc, "direction", direction);
			
			if (dropout.HasValue)
				c_api.TF_SetAttrFloat (desc, "dropout", dropout.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (num_proj.HasValue)
				c_api.TF_SetAttrInt (desc, "num_proj", num_proj.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var params_size = new TF_Output (op, _idx++);
			return params_size;
		}

		/// <summary>
		///   Retrieves CudnnRNN params in canonical form.
		/// </summary>
		/// <param name="num_layers">
		/// </param>
		/// <param name="num_units">
		/// </param>
		/// <param name="input_size">
		/// </param>
		/// <param name="parameters">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNParamsToCanonical'.
		/// </param>
		/// <param name="rnn_mode">
		///   Optional argument
		/// </param>
		/// <param name="input_mode">
		///   Optional argument
		/// </param>
		/// <param name="direction">
		///   Optional argument
		/// </param>
		/// <param name="dropout">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="num_params">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   weights:
		///   biases:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Retrieves a set of weights from the opaque params buffer that can be saved and
		///   restored in a way compatible with future runs.
		///   
		///   Note that the params buffer may not be compatible across different GPUs. So any
		///   save and restoration should be converted to and from the canonical weights and
		///   biases.
		///   
		///   num_layers: Specifies the number of layers in the RNN model.
		///   num_units: Specifies the size of the hidden state.
		///   input_size: Specifies the size of the input state.
		///   num_params: number of parameter sets for all layers.
		///   Each layer may contain multiple parameter sets, with each set consisting of
		///   a weight matrix and a bias vector.
		///   weights: the canonical form of weights that can be used for saving
		///   and restoration. They are more likely to be compatible across different
		///   generations.
		///   biases: the canonical form of biases that can be used for saving
		///   and restoration. They are more likely to be compatible across different
		///   generations.
		///   rnn_mode: Indicates the type of the RNN model.
		///   input_mode: Indicate whether there is a linear projection between the input and
		///   The actual computation before the first layer. 'skip_input' is only allowed
		///   when input_size == num_units; 'auto_select' implies 'skip_input' when
		///   input_size == num_units; otherwise, it implies 'linear_input'.
		///   direction: Indicates whether a bidirectional model will be used.
		///   dir = (direction == bidirectional) ? 2 : 1
		///   dropout: dropout probability. When set to 0., dropout is disabled.
		///   seed: the 1st part of a seed to initialize dropout.
		///   seed2: the 2nd part of a seed to initialize dropout.
		/// </remarks>
		public (TF_Output[] weights, TF_Output[] biases) CudnnRNNParamsToCanonical (TF_Output num_layers, TF_Output num_units, TF_Output input_size, TF_Output parameters, long num_params, string rnn_mode = null, string input_mode = null, string direction = null, float? dropout = null, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CudnnRNNParamsToCanonical", MakeName ("CudnnRNNParamsToCanonical", operName));
			c_api.TF_AddInput(desc, num_layers);
			c_api.TF_AddInput(desc, num_units);
			c_api.TF_AddInput(desc, input_size);
			c_api.TF_AddInput(desc, parameters);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_params", num_params);
			if (rnn_mode != null)
				c_api.TF_SetAttrString (desc, "rnn_mode", rnn_mode);
			
			if (input_mode != null)
				c_api.TF_SetAttrString (desc, "input_mode", input_mode);
			
			if (direction != null)
				c_api.TF_SetAttrString (desc, "direction", direction);
			
			if (dropout.HasValue)
				c_api.TF_SetAttrFloat (desc, "dropout", dropout.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "weights", status);
			var weights = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				weights [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "biases", status);
			var biases = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				biases [i] = new TF_Output (op, _idx++);
			
			return (weights, biases);
		}

		/// <summary>
		///   Retrieves CudnnRNN params in canonical form. It supports the projection in LSTM.
		/// </summary>
		/// <param name="num_layers">
		/// </param>
		/// <param name="num_units">
		/// </param>
		/// <param name="input_size">
		/// </param>
		/// <param name="parameters">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNParamsToCanonicalV2'.
		/// </param>
		/// <param name="rnn_mode">
		///   Optional argument
		/// </param>
		/// <param name="input_mode">
		///   Optional argument
		/// </param>
		/// <param name="direction">
		///   Optional argument
		/// </param>
		/// <param name="dropout">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="num_proj">
		///   Optional argument
		/// </param>
		/// <param name="num_params_weights">
		/// </param>
		/// <param name="num_params_biases">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   weights:
		///   biases:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Retrieves a set of weights from the opaque params buffer that can be saved and
		///   restored in a way compatible with future runs.
		///   
		///   Note that the params buffer may not be compatible across different GPUs. So any
		///   save and restoration should be converted to and from the canonical weights and
		///   biases.
		///   
		///   num_layers: Specifies the number of layers in the RNN model.
		///   num_units: Specifies the size of the hidden state.
		///   input_size: Specifies the size of the input state.
		///   num_params_weigths: number of weight parameter matrix for all layers.
		///   num_params_biases: number of bias parameter vector for all layers.
		///   weights: the canonical form of weights that can be used for saving
		///   and restoration. They are more likely to be compatible across different
		///   generations.
		///   biases: the canonical form of biases that can be used for saving
		///   and restoration. They are more likely to be compatible across different
		///   generations.
		///   rnn_mode: Indicates the type of the RNN model.
		///   input_mode: Indicate whether there is a linear projection between the input and
		///   The actual computation before the first layer. 'skip_input' is only allowed
		///   when input_size == num_units; 'auto_select' implies 'skip_input' when
		///   input_size == num_units; otherwise, it implies 'linear_input'.
		///   direction: Indicates whether a bidirectional model will be used.
		///   dir = (direction == bidirectional) ? 2 : 1
		///   dropout: dropout probability. When set to 0., dropout is disabled.
		///   seed: the 1st part of a seed to initialize dropout.
		///   seed2: the 2nd part of a seed to initialize dropout.
		///   num_proj: The output dimensionality for the projection matrices. If None or 0,
		///   no projection is performed.
		/// </remarks>
		public (TF_Output[] weights, TF_Output[] biases) CudnnRNNParamsToCanonicalV2 (TF_Output num_layers, TF_Output num_units, TF_Output input_size, TF_Output parameters, long num_params_weights, long num_params_biases, string rnn_mode = null, string input_mode = null, string direction = null, float? dropout = null, long? seed = null, long? seed2 = null, long? num_proj = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CudnnRNNParamsToCanonicalV2", MakeName ("CudnnRNNParamsToCanonicalV2", operName));
			c_api.TF_AddInput(desc, num_layers);
			c_api.TF_AddInput(desc, num_units);
			c_api.TF_AddInput(desc, input_size);
			c_api.TF_AddInput(desc, parameters);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_params_weights", num_params_weights);
			c_api.TF_SetAttrInt (desc, "num_params_biases", num_params_biases);
			if (rnn_mode != null)
				c_api.TF_SetAttrString (desc, "rnn_mode", rnn_mode);
			
			if (input_mode != null)
				c_api.TF_SetAttrString (desc, "input_mode", input_mode);
			
			if (direction != null)
				c_api.TF_SetAttrString (desc, "direction", direction);
			
			if (dropout.HasValue)
				c_api.TF_SetAttrFloat (desc, "dropout", dropout.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (num_proj.HasValue)
				c_api.TF_SetAttrInt (desc, "num_proj", num_proj.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "weights", status);
			var weights = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				weights [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "biases", status);
			var biases = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				biases [i] = new TF_Output (op, _idx++);
			
			return (weights, biases);
		}

		/// <summary>
		///   A RNN backed by cuDNN.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_h">
		/// </param>
		/// <param name="input_c">
		/// </param>
		/// <param name="parameters">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNV2'.
		/// </param>
		/// <param name="rnn_mode">
		///   Optional argument
		/// </param>
		/// <param name="input_mode">
		///   Optional argument
		/// </param>
		/// <param name="direction">
		///   Optional argument
		/// </param>
		/// <param name="dropout">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="is_training">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   output_h:
		///   output_c:
		///   reserve_space:
		///   host_reserved:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Computes the RNN from the input and initial states, with respect to the params
		///   buffer. Produces one extra output "host_reserved" than CudnnRNN.
		///   
		///   rnn_mode: Indicates the type of the RNN model.
		///   input_mode: Indicates whether there is a linear projection between the input and
		///   the actual computation before the first layer. 'skip_input' is only allowed
		///   when input_size == num_units; 'auto_select' implies 'skip_input' when
		///   input_size == num_units; otherwise, it implies 'linear_input'.
		///   direction: Indicates whether a bidirectional model will be used. Should be
		///   "unidirectional" or "bidirectional".
		///   dropout: Dropout probability. When set to 0., dropout is disabled.
		///   seed: The 1st part of a seed to initialize dropout.
		///   seed2: The 2nd part of a seed to initialize dropout.
		///   input: A 3-D tensor with the shape of [seq_length, batch_size, input_size].
		///   input_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,
		///   num_units].
		///   input_c: For LSTM, a 3-D tensor with the shape of
		///   [num_layer * dir, batch, num_units]. For other models, it is ignored.
		///   params: A 1-D tensor that contains the weights and biases in an opaque layout.
		///   The size must be created through CudnnRNNParamsSize, and initialized
		///   separately. Note that they might not be compatible across different
		///   generations. So it is a good idea to save and restore
		///   output: A 3-D tensor with the shape of [seq_length, batch_size,
		///   dir * num_units].
		///   output_h: The same shape has input_h.
		///   output_c: The same shape as input_c for LSTM. An empty tensor for other models.
		///   is_training: Indicates whether this operation is used for inferenece or
		///   training.
		///   reserve_space: An opaque tensor that can be used in backprop calculation. It
		///   is only produced if is_training is true.
		///   host_reserved: An opaque tensor that can be used in backprop calculation. It is
		///   only produced if is_training is true. It is output on host memory rather than
		///   device memory.
		/// </remarks>
		public (TF_Output output, TF_Output output_h, TF_Output output_c, TF_Output reserve_space, TF_Output host_reserved) CudnnRNNV2 (TF_Output input, TF_Output input_h, TF_Output input_c, TF_Output parameters, string rnn_mode = null, string input_mode = null, string direction = null, float? dropout = null, long? seed = null, long? seed2 = null, bool? is_training = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CudnnRNNV2", MakeName ("CudnnRNNV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_h);
			c_api.TF_AddInput(desc, input_c);
			c_api.TF_AddInput(desc, parameters);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (rnn_mode != null)
				c_api.TF_SetAttrString (desc, "rnn_mode", rnn_mode);
			
			if (input_mode != null)
				c_api.TF_SetAttrString (desc, "input_mode", input_mode);
			
			if (direction != null)
				c_api.TF_SetAttrString (desc, "direction", direction);
			
			if (dropout.HasValue)
				c_api.TF_SetAttrFloat (desc, "dropout", dropout.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (is_training.HasValue)
				c_api.TF_SetAttrBool (desc, "is_training", Convert.ToByte(is_training.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var output_h = new TF_Output (op, _idx++);
			var output_c = new TF_Output (op, _idx++);
			var reserve_space = new TF_Output (op, _idx++);
			var host_reserved = new TF_Output (op, _idx++);
			return (output, output_h, output_c, reserve_space, host_reserved);
		}

		/// <summary>
		///   A RNN backed by cuDNN.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_h">
		/// </param>
		/// <param name="input_c">
		/// </param>
		/// <param name="parameters">
		/// </param>
		/// <param name="sequence_lengths">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNV3'.
		/// </param>
		/// <param name="rnn_mode">
		///   Optional argument
		/// </param>
		/// <param name="input_mode">
		///   Optional argument
		/// </param>
		/// <param name="direction">
		///   Optional argument
		/// </param>
		/// <param name="dropout">
		///   Optional argument
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <param name="num_proj">
		///   Optional argument
		/// </param>
		/// <param name="is_training">
		///   Optional argument
		/// </param>
		/// <param name="time_major">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   output_h:
		///   output_c:
		///   reserve_space:
		///   host_reserved:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Computes the RNN from the input and initial states, with respect to the params
		///   buffer. Accepts one extra input "sequence_lengths" than CudnnRNN.
		///   
		///   rnn_mode: Indicates the type of the RNN model.
		///   input_mode: Indicates whether there is a linear projection between the input and
		///   the actual computation before the first layer. 'skip_input' is only allowed
		///   when input_size == num_units; 'auto_select' implies 'skip_input' when
		///   input_size == num_units; otherwise, it implies 'linear_input'.
		///   direction: Indicates whether a bidirectional model will be used. Should be
		///   "unidirectional" or "bidirectional".
		///   dropout: Dropout probability. When set to 0., dropout is disabled.
		///   seed: The 1st part of a seed to initialize dropout.
		///   seed2: The 2nd part of a seed to initialize dropout.
		///   input: If time_major is true, this is a 3-D tensor with the shape of
		///   [seq_length, batch_size, input_size]. If time_major is false, the shape is
		///   [batch_size, seq_length, input_size].
		///   input_h: If time_major is true, this is a 3-D tensor with the shape of
		///   [num_layer * dir, batch_size, num_units]. If time_major is false, the shape
		///   is [batch_size, num_layer * dir, num_units].
		///   input_c: For LSTM, a 3-D tensor with the shape of
		///   [num_layer * dir, batch, num_units]. For other models, it is ignored.
		///   params: A 1-D tensor that contains the weights and biases in an opaque layout.
		///   The size must be created through CudnnRNNParamsSize, and initialized
		///   separately. Note that they might not be compatible across different
		///   generations. So it is a good idea to save and restore
		///   sequence_lengths: a vector of lengths of each input sequence.
		///   output: If time_major is true, this is a 3-D tensor with the shape of
		///   [seq_length, batch_size, dir * num_units]. If time_major is false, the
		///   shape is [batch_size, seq_length, dir * num_units].
		///   output_h: The same shape has input_h.
		///   output_c: The same shape as input_c for LSTM. An empty tensor for other models.
		///   is_training: Indicates whether this operation is used for inferenece or
		///   training.
		///   time_major: Indicates whether the input/output format is time major or batch
		///   major.
		///   reserve_space: An opaque tensor that can be used in backprop calculation. It
		///   is only produced if is_training is true.
		/// </remarks>
		public (TF_Output output, TF_Output output_h, TF_Output output_c, TF_Output reserve_space, TF_Output host_reserved) CudnnRNNV3 (TF_Output input, TF_Output input_h, TF_Output input_c, TF_Output parameters, TF_Output sequence_lengths, string rnn_mode = null, string input_mode = null, string direction = null, float? dropout = null, long? seed = null, long? seed2 = null, long? num_proj = null, bool? is_training = null, bool? time_major = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CudnnRNNV3", MakeName ("CudnnRNNV3", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_h);
			c_api.TF_AddInput(desc, input_c);
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, sequence_lengths);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (rnn_mode != null)
				c_api.TF_SetAttrString (desc, "rnn_mode", rnn_mode);
			
			if (input_mode != null)
				c_api.TF_SetAttrString (desc, "input_mode", input_mode);
			
			if (direction != null)
				c_api.TF_SetAttrString (desc, "direction", direction);
			
			if (dropout.HasValue)
				c_api.TF_SetAttrFloat (desc, "dropout", dropout.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (num_proj.HasValue)
				c_api.TF_SetAttrInt (desc, "num_proj", num_proj.Value);
			
			if (is_training.HasValue)
				c_api.TF_SetAttrBool (desc, "is_training", Convert.ToByte(is_training.Value));
			
			if (time_major.HasValue)
				c_api.TF_SetAttrBool (desc, "time_major", Convert.ToByte(time_major.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var output_h = new TF_Output (op, _idx++);
			var output_c = new TF_Output (op, _idx++);
			var reserve_space = new TF_Output (op, _idx++);
			var host_reserved = new TF_Output (op, _idx++);
			return (output, output_h, output_c, reserve_space, host_reserved);
		}

		/// <summary>
		///   Compute the cumulative product of the tensor <c>x</c> along <c>axis</c>.
		/// </summary>
		/// <param name="x">
		///   A <c>Tensor</c>. Must be one of the following types: <c>float32</c>, <c>float64</c>,
		///   <c>int64</c>, <c>int32</c>, <c>uint8</c>, <c>uint16</c>, <c>int16</c>, <c>int8</c>, <c>complex64</c>,
		///   <c>complex128</c>, <c>qint8</c>, <c>quint8</c>, <c>qint32</c>, <c>half</c>.
		/// </param>
		/// <param name="axis">
		///   A <c>Tensor</c> of type <c>int32</c> (default: 0). Must be in the range
		///   <c>[-rank(x), rank(x))</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Cumprod'.
		/// </param>
		/// <param name="exclusive">
		///   Optional argument
		///   If <c>True</c>, perform exclusive cumprod.
		/// </param>
		/// <param name="reverse">
		///   Optional argument
		///   A <c>bool</c> (default: False).
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   By default, this op performs an inclusive cumprod, which means that the first
		///   element of the input is identical to the first element of the output:
		///   
		///    <code>
		///   tf.cumprod([a, b, c])  # =&amp;gt; [a, a * b, a * b * c]
		///    </code>
		///   
		///   By setting the <c>exclusive</c> kwarg to <c>True</c>, an exclusive cumprod is
		///   performed instead:
		///   
		///    <code>
		///   tf.cumprod([a, b, c], exclusive=True)  # =&amp;gt; [1, a, a * b]
		///    </code>
		///   
		///   By setting the <c>reverse</c> kwarg to <c>True</c>, the cumprod is performed in the
		///   opposite direction:
		///   
		///    <code>
		///   tf.cumprod([a, b, c], reverse=True)  # =&amp;gt; [a * b * c, b * c, c]
		///    </code>
		///   
		///   This is more efficient than using separate <c>tf.reverse</c> ops.
		///   
		///   The <c>reverse</c> and <c>exclusive</c> kwargs can also be combined:
		///   
		///    <code>
		///   tf.cumprod([a, b, c], exclusive=True, reverse=True)  # =&amp;gt; [b * c, c, 1]
		///    </code>
		/// </remarks>
		public TF_Output Cumprod (TF_Output x, TF_Output axis, bool? exclusive = null, bool? reverse = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Cumprod", MakeName ("Cumprod", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, axis);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (exclusive.HasValue)
				c_api.TF_SetAttrBool (desc, "exclusive", Convert.ToByte(exclusive.Value));
			
			if (reverse.HasValue)
				c_api.TF_SetAttrBool (desc, "reverse", Convert.ToByte(reverse.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Compute the cumulative sum of the tensor <c>x</c> along <c>axis</c>.
		/// </summary>
		/// <param name="x">
		///   A <c>Tensor</c>. Must be one of the following types: <c>float32</c>, <c>float64</c>,
		///   <c>int64</c>, <c>int32</c>, <c>uint8</c>, <c>uint16</c>, <c>int16</c>, <c>int8</c>, <c>complex64</c>,
		///   <c>complex128</c>, <c>qint8</c>, <c>quint8</c>, <c>qint32</c>, <c>half</c>.
		/// </param>
		/// <param name="axis">
		///   A <c>Tensor</c> of type <c>int32</c> (default: 0). Must be in the range
		///   <c>[-rank(x), rank(x))</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Cumsum'.
		/// </param>
		/// <param name="exclusive">
		///   Optional argument
		///   If <c>True</c>, perform exclusive cumsum.
		/// </param>
		/// <param name="reverse">
		///   Optional argument
		///   A <c>bool</c> (default: False).
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   By default, this op performs an inclusive cumsum, which means that the first
		///   element of the input is identical to the first element of the output:
		///   
		///    <code>
		///   tf.cumsum([a, b, c])  # =&amp;gt; [a, a + b, a + b + c]
		///    </code>
		///   
		///   By setting the <c>exclusive</c> kwarg to <c>True</c>, an exclusive cumsum is
		///   performed instead:
		///   
		///    <code>
		///   tf.cumsum([a, b, c], exclusive=True)  # =&amp;gt; [0, a, a + b]
		///    </code>
		///   
		///   By setting the <c>reverse</c> kwarg to <c>True</c>, the cumsum is performed in the
		///   opposite direction:
		///   
		///    <code>
		///   tf.cumsum([a, b, c], reverse=True)  # =&amp;gt; [a + b + c, b + c, c]
		///    </code>
		///   
		///   This is more efficient than using separate <c>tf.reverse</c> ops.
		///   
		///   The <c>reverse</c> and <c>exclusive</c> kwargs can also be combined:
		///   
		///    <code>
		///   tf.cumsum([a, b, c], exclusive=True, reverse=True)  # =&amp;gt; [b + c, c, 0]
		///    </code>
		/// </remarks>
		public TF_Output Cumsum (TF_Output x, TF_Output axis, bool? exclusive = null, bool? reverse = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Cumsum", MakeName ("Cumsum", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, axis);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (exclusive.HasValue)
				c_api.TF_SetAttrBool (desc, "exclusive", Convert.ToByte(exclusive.Value));
			
			if (reverse.HasValue)
				c_api.TF_SetAttrBool (desc, "reverse", Convert.ToByte(reverse.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Compute the cumulative product of the tensor <c>x</c> along <c>axis</c>.
		/// </summary>
		/// <param name="x">
		///   A <c>Tensor</c>. Must be one of the following types: <c>float16</c>, <c>float32</c>, <c>float64</c>.
		/// </param>
		/// <param name="axis">
		///   A <c>Tensor</c> of type <c>int32</c> (default: 0). Must be in the range
		///   <c>[-rank(x), rank(x))</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'CumulativeLogsumexp'.
		/// </param>
		/// <param name="exclusive">
		///   Optional argument
		///   If <c>True</c>, perform exclusive cumulative log-sum-exp.
		/// </param>
		/// <param name="reverse">
		///   Optional argument
		///   A <c>bool</c> (default: False).
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   By default, this op performs an inclusive cumulative log-sum-exp,
		///   which means that the first
		///   element of the input is identical to the first element of the output:
		///    <code>
		///   tf.math.cumulative_logsumexp([a, b, c])  # =&amp;gt; [a, log(exp(a) + exp(b)), log(exp(a) + exp(b) + exp(c))]
		///    </code>
		///   
		///   By setting the <c>exclusive</c> kwarg to <c>True</c>, an exclusive cumulative log-sum-exp is
		///   performed instead:
		///    <code>
		///   tf.cumulative_logsumexp([a, b, c], exclusive=True)  # =&amp;gt; [-inf, a, log(exp(a) * exp(b))]
		///    </code>
		///   Note that the neutral element of the log-sum-exp operation is <c>-inf</c>,
		///   however, for performance reasons, the minimal value representable by the
		///   floating point type is used instead.
		///   
		///   By setting the <c>reverse</c> kwarg to <c>True</c>, the cumulative log-sum-exp is performed in the
		///   opposite direction.
		/// </remarks>
		public TF_Output CumulativeLogsumexp (TF_Output x, TF_Output axis, bool? exclusive = null, bool? reverse = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "CumulativeLogsumexp", MakeName ("CumulativeLogsumexp", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, axis);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (exclusive.HasValue)
				c_api.TF_SetAttrBool (desc, "exclusive", Convert.ToByte(exclusive.Value));
			
			if (reverse.HasValue)
				c_api.TF_SetAttrBool (desc, "reverse", Convert.ToByte(reverse.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns the dimension index in the destination data format given the one in
		/// </summary>
		/// <param name="x">
		///   A Tensor with each element as a dimension index in source data format.
		///   Must be in the range [-4, 4).
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DataFormatDimMap'.
		/// </param>
		/// <param name="src_format">
		///   Optional argument
		///   source data format.
		/// </param>
		/// <param name="dst_format">
		///   Optional argument
		///   destination data format.
		/// </param>
		/// <returns>
		///   A Tensor with each element as a dimension index in destination data format.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   the source data format.
		/// </remarks>
		public TF_Output DataFormatDimMap (TF_Output x, string src_format = null, string dst_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DataFormatDimMap", MakeName ("DataFormatDimMap", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (src_format != null)
				c_api.TF_SetAttrString (desc, "src_format", src_format);
			
			if (dst_format != null)
				c_api.TF_SetAttrString (desc, "dst_format", dst_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Returns the permuted vector/tensor in the destination data format given the
		/// </summary>
		/// <param name="x">
		///   Vector of size 4 or Tensor of shape (4, 2) in source data format.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DataFormatVecPermute'.
		/// </param>
		/// <param name="src_format">
		///   Optional argument
		///   source data format.
		/// </param>
		/// <param name="dst_format">
		///   Optional argument
		///   destination data format.
		/// </param>
		/// <returns>
		///   Vector of size 4 or Tensor of shape (4, 2) in destination data format.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   one in the source data format.
		/// </remarks>
		public TF_Output DataFormatVecPermute (TF_Output x, string src_format = null, string dst_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DataFormatVecPermute", MakeName ("DataFormatVecPermute", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (src_format != null)
				c_api.TF_SetAttrString (desc, "src_format", src_format);
			
			if (dst_format != null)
				c_api.TF_SetAttrString (desc, "dst_format", dst_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Returns the cardinality of <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		///   A variant tensor representing the dataset to return cardinality for.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DatasetCardinality'.
		/// </param>
		/// <returns>
		///   The cardinality of <c>input_dataset</c>. Named constants are used to represent
		///   infinite and unknown cardinality.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Returns the cardinality of <c>input_dataset</c>.
		/// </remarks>
		public TF_Output DatasetCardinality (TF_Output input_dataset, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DatasetCardinality", MakeName ("DatasetCardinality", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var cardinality = new TF_Output (op, _idx++);
			return cardinality;
		}

		/// <summary>
		///   Creates a dataset from the given <c>graph_def</c>.
		/// </summary>
		/// <param name="graph_def">
		///   The graph representation of the dataset (as serialized GraphDef).
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DatasetFromGraph'.
		/// </param>
		/// <returns>
		///   A variant tensor representing the dataset.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Creates a dataset from the provided <c>graph_def</c>.
		/// </remarks>
		public TF_Output DatasetFromGraph (TF_Output graph_def, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DatasetFromGraph", MakeName ("DatasetFromGraph", operName));
			c_api.TF_AddInput(desc, graph_def);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Returns a serialized GraphDef representing <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		///   A variant tensor representing the dataset to return the graph representation for.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DatasetToGraph'.
		/// </param>
		/// <returns>
		///   The graph representation of the dataset (as serialized GraphDef).
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Returns a graph representation for <c>input_dataset</c>.
		/// </remarks>
		public TF_Output DatasetToGraph (TF_Output input_dataset, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DatasetToGraph", MakeName ("DatasetToGraph", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var graph = new TF_Output (op, _idx++);
			return graph;
		}

		/// <summary>
		///   Outputs the single element from the given dataset.
		/// </summary>
		/// <param name="dataset">
		///   A handle to a dataset that contains a single element.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DatasetToSingleElement'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The components of the single element of <c>input</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] DatasetToSingleElement (TF_Output dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DatasetToSingleElement", MakeName ("DatasetToSingleElement", operName));
			c_api.TF_AddInput(desc, dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "components", status);
			var components = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				components [i] = new TF_Output (op, _idx++);
			
			return components;
		}

		/// <summary>
		///   Writes the given dataset to the given file using the TFRecord format.
		/// </summary>
		/// <param name="input_dataset">
		///   A variant tensor representing the dataset to write.
		/// </param>
		/// <param name="filename">
		///   A scalar string tensor representing the filename to use.
		/// </param>
		/// <param name="compression_type">
		///   A scalar string tensor containing either (i) the empty string (no
		///   compression), (ii) "ZLIB", or (iii) "GZIP".
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DatasetToTFRecord'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation DatasetToTFRecord (TF_Output input_dataset, TF_Output filename, TF_Output compression_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DatasetToTFRecord", MakeName ("DatasetToTFRecord", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, filename);
			c_api.TF_AddInput(desc, compression_type);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Identity op for gradient debugging.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DebugGradientIdentity'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op is hidden from public in Python. It is used by TensorFlow Debugger to
		///   register gradient tensors for gradient debugging.
		///   This op operates on non-reference-type tensors.
		/// </remarks>
		public TF_Output DebugGradientIdentity (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DebugGradientIdentity", MakeName ("DebugGradientIdentity", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Identity op for gradient debugging.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DebugGradientRefIdentity'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op is hidden from public in Python. It is used by TensorFlow Debugger to
		///   register gradient tensors for gradient debugging.
		///   This op operates on reference-type tensors.
		/// </remarks>
		public TF_Output DebugGradientRefIdentity (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DebugGradientRefIdentity", MakeName ("DebugGradientRefIdentity", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Debug Identity Op.
		/// </summary>
		/// <param name="input">
		///   Input tensor, non-Reference type.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DebugIdentity'.
		/// </param>
		/// <param name="device_name">
		///   Optional argument
		/// </param>
		/// <param name="tensor_name">
		///   Optional argument
		///   Name of the input tensor.
		/// </param>
		/// <param name="debug_urls">
		///   Optional argument
		///   List of URLs to debug targets, e.g.,
		///   file:///foo/tfdbg_dump, grpc:://localhost:11011
		/// </param>
		/// <param name="gated_grpc">
		///   Optional argument
		///   Whether this op will be gated. If any of the debug_urls of this
		///   debug node is of the grpc:// scheme, when the value of this attribute is set
		///   to True, the data will not actually be sent via the grpc stream unless this
		///   debug op has been enabled at the debug_url. If all of the debug_urls of this
		///   debug node are of the grpc:// scheme and the debug op is enabled at none of
		///   them, the output will be an empty Tensor.
		/// </param>
		/// <returns>
		///   Output tensor that equals the input tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Provides an identity mapping of the non-Ref type input tensor for debugging.
		/// </remarks>
		public TF_Output DebugIdentity (TF_Output input, string device_name = null, string tensor_name = null, string[] debug_urls = null, bool? gated_grpc = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DebugIdentity", MakeName ("DebugIdentity", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (device_name != null)
				c_api.TF_SetAttrString (desc, "device_name", device_name);
			
			if (tensor_name != null)
				c_api.TF_SetAttrString (desc, "tensor_name", tensor_name);
			
			if (debug_urls != null)
				c_api.TF_SetAttrStringList (desc, "debug_urls", debug_urls);
			
			if (gated_grpc.HasValue)
				c_api.TF_SetAttrBool (desc, "gated_grpc", Convert.ToByte(gated_grpc.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Debug NaN Value Counter Op
		/// </summary>
		/// <param name="input">
		///   Input tensor, non-Reference type.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DebugNanCount'.
		/// </param>
		/// <param name="device_name">
		///   Optional argument
		/// </param>
		/// <param name="tensor_name">
		///   Optional argument
		///   Name of the input tensor.
		/// </param>
		/// <param name="debug_urls">
		///   Optional argument
		///   List of URLs to debug targets, e.g.,
		///   file:///foo/tfdbg_dump, grpc:://localhost:11011.
		/// </param>
		/// <param name="gated_grpc">
		///   Optional argument
		///   Whether this op will be gated. If any of the debug_urls of this
		///   debug node is of the grpc:// scheme, when the value of this attribute is set
		///   to True, the data will not actually be sent via the grpc stream unless this
		///   debug op has been enabled at the debug_url. If all of the debug_urls of this
		///   debug node are of the grpc:// scheme and the debug op is enabled at none of
		///   them, the output will be an empty Tensor.
		/// </param>
		/// <returns>
		///   An integer output tensor that is the number of NaNs in the input.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Counts number of NaNs in the input tensor, for debugging.
		/// </remarks>
		public TF_Output DebugNanCount (TF_Output input, string device_name = null, string tensor_name = null, string[] debug_urls = null, bool? gated_grpc = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DebugNanCount", MakeName ("DebugNanCount", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (device_name != null)
				c_api.TF_SetAttrString (desc, "device_name", device_name);
			
			if (tensor_name != null)
				c_api.TF_SetAttrString (desc, "tensor_name", tensor_name);
			
			if (debug_urls != null)
				c_api.TF_SetAttrStringList (desc, "debug_urls", debug_urls);
			
			if (gated_grpc.HasValue)
				c_api.TF_SetAttrBool (desc, "gated_grpc", Convert.ToByte(gated_grpc.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Debug Numeric Summary Op.
		/// </summary>
		/// <param name="input">
		///   Input tensor, non-Reference type, float or double.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DebugNumericSummary'.
		/// </param>
		/// <param name="device_name">
		///   Optional argument
		/// </param>
		/// <param name="tensor_name">
		///   Optional argument
		///   Name of the input tensor.
		/// </param>
		/// <param name="debug_urls">
		///   Optional argument
		///   List of URLs to debug targets, e.g.,
		///   file:///foo/tfdbg_dump, grpc:://localhost:11011
		/// </param>
		/// <param name="lower_bound">
		///   Optional argument
		///   (float) The lower bound &amp;lt;= which values will be included in the
		///   generalized -inf count. Default: -inf.
		/// </param>
		/// <param name="upper_bound">
		///   Optional argument
		///   (float) The upper bound &amp;gt;= which values will be included in the
		///   generalized +inf count. Default: +inf.
		/// </param>
		/// <param name="mute_if_healthy">
		///   Optional argument
		///   (bool) Do not send data to the debug URLs unless at least one
		///   of elements [2], [3] and [7] (i.e., the nan count and the generalized -inf and
		///   inf counts) is non-zero.
		/// </param>
		/// <param name="gated_grpc">
		///   Optional argument
		///   Whether this op will be gated. If any of the debug_urls of this
		///   debug node is of the grpc:// scheme, when the value of this attribute is set
		///   to True, the data will not actually be sent via the grpc stream unless this
		///   debug op has been enabled at the debug_url. If all of the debug_urls of this
		///   debug node are of the grpc:// scheme and the debug op is enabled at none of
		///   them, the output will be an empty Tensor.
		/// </param>
		/// <returns>
		///   A double tensor of shape [14 + nDimensions], where nDimensions is the
		///   the number of dimensions of the tensor's shape. The elements of output are:
		///   [0]: is initialized (1.0) or not (0.0).
		///   [1]: total number of elements
		///   [2]: NaN element count
		///   [3]: generalized -inf count: elements &amp;lt;= lower_bound. lower_bound is -inf by
		///   default.
		///   [4]: negative element count (excluding -inf), if lower_bound is the default
		///   -inf. Otherwise, this is the count of elements &amp;gt; lower_bound and &amp;lt; 0.
		///   [5]: zero element count
		///   [6]: positive element count (excluding +inf), if upper_bound is the default
		///   -inf. Otherwise, this is the count of elements &amp;lt; upper_bound and &amp;gt; 0.
		///   [7]: generalized +inf count, elements &amp;gt;= upper_bound. upper_bound is +inf by
		///   default.
		///   Output elements [1:8] are all zero, if the tensor is uninitialized.
		///   [8]: minimum of all non-inf and non-NaN elements.
		///   If uninitialized or no such element exists: +inf.
		///   [9]: maximum of all non-inf and non-NaN elements.
		///   If uninitialized or no such element exists: -inf.
		///   [10]: mean of all non-inf and non-NaN elements.
		///   If uninitialized or no such element exists: NaN.
		///   [11]: variance of all non-inf and non-NaN elements.
		///   If uninitialized or no such element exists: NaN.
		///   [12]: Data type of the tensor encoded as an enum integer. See the DataType
		///   proto for more details.
		///   [13]: Number of dimensions of the tensor (ndims).
		///   [14+]: Sizes of the dimensions.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Provide a basic summary of numeric value types, range and distribution.
		/// </remarks>
		public TF_Output DebugNumericSummary (TF_Output input, string device_name = null, string tensor_name = null, string[] debug_urls = null, float? lower_bound = null, float? upper_bound = null, bool? mute_if_healthy = null, bool? gated_grpc = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DebugNumericSummary", MakeName ("DebugNumericSummary", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (device_name != null)
				c_api.TF_SetAttrString (desc, "device_name", device_name);
			
			if (tensor_name != null)
				c_api.TF_SetAttrString (desc, "tensor_name", tensor_name);
			
			if (debug_urls != null)
				c_api.TF_SetAttrStringList (desc, "debug_urls", debug_urls);
			
			if (lower_bound.HasValue)
				c_api.TF_SetAttrFloat (desc, "lower_bound", lower_bound.Value);
			
			if (upper_bound.HasValue)
				c_api.TF_SetAttrFloat (desc, "upper_bound", upper_bound.Value);
			
			if (mute_if_healthy.HasValue)
				c_api.TF_SetAttrBool (desc, "mute_if_healthy", Convert.ToByte(mute_if_healthy.Value));
			
			if (gated_grpc.HasValue)
				c_api.TF_SetAttrBool (desc, "gated_grpc", Convert.ToByte(gated_grpc.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Decode and Crop a JPEG-encoded image to a uint8 tensor.
		/// </summary>
		/// <param name="contents">
		///   0-D.  The JPEG-encoded image.
		/// </param>
		/// <param name="crop_window">
		///   1-D.  The crop window: [crop_y, crop_x, crop_height, crop_width].
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeAndCropJpeg'.
		/// </param>
		/// <param name="channels">
		///   Optional argument
		///   Number of color channels for the decoded image.
		/// </param>
		/// <param name="ratio">
		///   Optional argument
		///   Downscaling ratio.
		/// </param>
		/// <param name="fancy_upscaling">
		///   Optional argument
		///   If true use a slower but nicer upscaling of the
		///   chroma planes (yuv420/422 only).
		/// </param>
		/// <param name="try_recover_truncated">
		///   Optional argument
		///   If true try to recover an image from truncated input.
		/// </param>
		/// <param name="acceptable_fraction">
		///   Optional argument
		///   The minimum required fraction of lines before a truncated
		///   input is accepted.
		/// </param>
		/// <param name="dct_method">
		///   Optional argument
		///   string specifying a hint about the algorithm used for
		///   decompression.  Defaults to "" which maps to a system-specific
		///   default.  Currently valid values are ["INTEGER_FAST",
		///   "INTEGER_ACCURATE"].  The hint may be ignored (e.g., the internal
		///   jpeg library changes to a version that does not have that specific
		///   option.)
		/// </param>
		/// <returns>
		///   3-D with shape <c>[height, width, channels]</c>..
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The attr <c>channels</c> indicates the desired number of color channels for the
		///   decoded image.
		///   
		///   Accepted values are:
		///   
		///   *   0: Use the number of channels in the JPEG-encoded image.
		///   *   1: output a grayscale image.
		///   *   3: output an RGB image.
		///   
		///   If needed, the JPEG-encoded image is transformed to match the requested number
		///   of color channels.
		///   
		///   The attr <c>ratio</c> allows downscaling the image by an integer factor during
		///   decoding.  Allowed values are: 1, 2, 4, and 8.  This is much faster than
		///   downscaling the image later.
		///   
		///   
		///   It is equivalent to a combination of decode and crop, but much faster by only
		///   decoding partial jpeg image.
		/// </remarks>
		public TF_Output DecodeAndCropJpeg (TF_Output contents, TF_Output crop_window, long? channels = null, long? ratio = null, bool? fancy_upscaling = null, bool? try_recover_truncated = null, float? acceptable_fraction = null, string dct_method = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodeAndCropJpeg", MakeName ("DecodeAndCropJpeg", operName));
			c_api.TF_AddInput(desc, contents);
			c_api.TF_AddInput(desc, crop_window);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (channels.HasValue)
				c_api.TF_SetAttrInt (desc, "channels", channels.Value);
			
			if (ratio.HasValue)
				c_api.TF_SetAttrInt (desc, "ratio", ratio.Value);
			
			if (fancy_upscaling.HasValue)
				c_api.TF_SetAttrBool (desc, "fancy_upscaling", Convert.ToByte(fancy_upscaling.Value));
			
			if (try_recover_truncated.HasValue)
				c_api.TF_SetAttrBool (desc, "try_recover_truncated", Convert.ToByte(try_recover_truncated.Value));
			
			if (acceptable_fraction.HasValue)
				c_api.TF_SetAttrFloat (desc, "acceptable_fraction", acceptable_fraction.Value);
			
			if (dct_method != null)
				c_api.TF_SetAttrString (desc, "dct_method", dct_method);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var image = new TF_Output (op, _idx++);
			return image;
		}

		/// <summary>
		///   Decode web-safe base64-encoded strings.
		/// </summary>
		/// <param name="input">
		///   Base64 strings to decode.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeBase64'.
		/// </param>
		/// <returns>
		///   Decoded strings.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Input may or may not have padding at the end. See EncodeBase64 for padding.
		///   Web-safe means that input must use - and _ instead of + and /.
		/// </remarks>
		public TF_Output DecodeBase64 (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodeBase64", MakeName ("DecodeBase64", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Decode the first frame of a BMP-encoded image to a uint8 tensor.
		/// </summary>
		/// <param name="contents">
		///   0-D.  The BMP-encoded image.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeBmp'.
		/// </param>
		/// <param name="channels">
		///   Optional argument
		/// </param>
		/// <returns>
		///   3-D with shape <c>[height, width, channels]</c>. RGB order
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The attr <c>channels</c> indicates the desired number of color channels for the
		///   decoded image.
		///   
		///   Accepted values are:
		///   
		///   *   0: Use the number of channels in the BMP-encoded image.
		///   *   3: output an RGB image.
		///   *   4: output an RGBA image.
		/// </remarks>
		public TF_Output DecodeBmp (TF_Output contents, long? channels = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodeBmp", MakeName ("DecodeBmp", operName));
			c_api.TF_AddInput(desc, contents);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (channels.HasValue)
				c_api.TF_SetAttrInt (desc, "channels", channels.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var image = new TF_Output (op, _idx++);
			return image;
		}

		/// <summary>
		///   Decompress strings.
		/// </summary>
		/// <param name="bytes">
		///   A Tensor of string which is compressed.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeCompressed'.
		/// </param>
		/// <param name="compression_type">
		///   Optional argument
		///   A scalar containing either (i) the empty string (no
		///   compression), (ii) "ZLIB", or (iii) "GZIP".
		/// </param>
		/// <returns>
		///   A Tensor with the same shape as input <c>bytes</c>, uncompressed
		///   from bytes.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op decompresses each element of the <c>bytes</c> input <c>Tensor</c>, which
		///   is assumed to be compressed using the given <c>compression_type</c>.
		///   
		///   The <c>output</c> is a string <c>Tensor</c> of the same shape as <c>bytes</c>,
		///   each element containing the decompressed data from the corresponding
		///   element in <c>bytes</c>.
		/// </remarks>
		public TF_Output DecodeCompressed (TF_Output bytes, string compression_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodeCompressed", MakeName ("DecodeCompressed", operName));
			c_api.TF_AddInput(desc, bytes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (compression_type != null)
				c_api.TF_SetAttrString (desc, "compression_type", compression_type);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Convert CSV records to tensors. Each column maps to one tensor.
		/// </summary>
		/// <param name="records">
		///   Each string is a record/row in the csv and all records should have
		///   the same format.
		/// </param>
		/// <param name="record_defaults">
		///   One tensor per column of the input record, with either a
		///   scalar default value for that column or an empty vector if the column is
		///   required.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeCSV'.
		/// </param>
		/// <param name="field_delim">
		///   Optional argument
		///   char delimiter to separate fields in a record.
		/// </param>
		/// <param name="use_quote_delim">
		///   Optional argument
		///   If false, treats double quotation marks as regular
		///   characters inside of the string fields (ignoring RFC 4180, Section 2,
		///   Bullet 5).
		/// </param>
		/// <param name="na_value">
		///   Optional argument
		///   Additional string to recognize as NA/NaN.
		/// </param>
		/// <param name="select_cols">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Each tensor will have the same shape as records.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   RFC 4180 format is expected for the CSV records.
		///   (https://tools.ietf.org/html/rfc4180)
		///   Note that we allow leading and trailing spaces with int or float field.
		/// </remarks>
		public TF_Output[] DecodeCSV (TF_Output records, TF_Output[] record_defaults, string field_delim = null, bool? use_quote_delim = null, string na_value = null, long[] select_cols = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodeCSV", MakeName ("DecodeCSV", operName));
			c_api.TF_AddInput(desc, records);
			c_api.TF_AddInputList(desc, record_defaults[0], record_defaults.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (field_delim != null)
				c_api.TF_SetAttrString (desc, "field_delim", field_delim);
			
			if (use_quote_delim.HasValue)
				c_api.TF_SetAttrBool (desc, "use_quote_delim", Convert.ToByte(use_quote_delim.Value));
			
			if (na_value != null)
				c_api.TF_SetAttrString (desc, "na_value", na_value);
			
			if (select_cols != null)
				c_api.TF_SetAttrIntList (desc, "select_cols", ref select_cols[0], select_cols.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		///   Decode the frame(s) of a GIF-encoded image to a uint8 tensor.
		/// </summary>
		/// <param name="contents">
		///   0-D.  The GIF-encoded image.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeGif'.
		/// </param>
		/// <returns>
		///   4-D with shape <c>[num_frames, height, width, 3]</c>. RGB channel order.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   GIF images with frame or transparency compression are not supported.
		///   On Linux and MacOS systems, convert animated GIFs from compressed to
		///   uncompressed by running:
		///   
		///   convert $src.gif -coalesce $dst.gif
		///   
		///   This op also supports decoding JPEGs and PNGs, though it is cleaner to use
		///   <c>tf.image.decode_image</c>.
		/// </remarks>
		public TF_Output DecodeGif (TF_Output contents, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodeGif", MakeName ("DecodeGif", operName));
			c_api.TF_AddInput(desc, contents);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var image = new TF_Output (op, _idx++);
			return image;
		}

		/// <summary>
		///   Decode a JPEG-encoded image to a uint8 tensor.
		/// </summary>
		/// <param name="contents">
		///   0-D.  The JPEG-encoded image.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeJpeg'.
		/// </param>
		/// <param name="channels">
		///   Optional argument
		///   Number of color channels for the decoded image.
		/// </param>
		/// <param name="ratio">
		///   Optional argument
		///   Downscaling ratio.
		/// </param>
		/// <param name="fancy_upscaling">
		///   Optional argument
		///   If true use a slower but nicer upscaling of the
		///   chroma planes (yuv420/422 only).
		/// </param>
		/// <param name="try_recover_truncated">
		///   Optional argument
		///   If true try to recover an image from truncated input.
		/// </param>
		/// <param name="acceptable_fraction">
		///   Optional argument
		///   The minimum required fraction of lines before a truncated
		///   input is accepted.
		/// </param>
		/// <param name="dct_method">
		///   Optional argument
		///   string specifying a hint about the algorithm used for
		///   decompression.  Defaults to "" which maps to a system-specific
		///   default.  Currently valid values are ["INTEGER_FAST",
		///   "INTEGER_ACCURATE"].  The hint may be ignored (e.g., the internal
		///   jpeg library changes to a version that does not have that specific
		///   option.)
		/// </param>
		/// <returns>
		///   3-D with shape <c>[height, width, channels]</c>..
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The attr <c>channels</c> indicates the desired number of color channels for the
		///   decoded image.
		///   
		///   Accepted values are:
		///   
		///   *   0: Use the number of channels in the JPEG-encoded image.
		///   *   1: output a grayscale image.
		///   *   3: output an RGB image.
		///   
		///   If needed, the JPEG-encoded image is transformed to match the requested number
		///   of color channels.
		///   
		///   The attr <c>ratio</c> allows downscaling the image by an integer factor during
		///   decoding.  Allowed values are: 1, 2, 4, and 8.  This is much faster than
		///   downscaling the image later.
		///   
		///   
		///   This op also supports decoding PNGs and non-animated GIFs since the interface is
		///   the same, though it is cleaner to use <c>tf.image.decode_image</c>.
		/// </remarks>
		public TF_Output DecodeJpeg (TF_Output contents, long? channels = null, long? ratio = null, bool? fancy_upscaling = null, bool? try_recover_truncated = null, float? acceptable_fraction = null, string dct_method = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodeJpeg", MakeName ("DecodeJpeg", operName));
			c_api.TF_AddInput(desc, contents);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (channels.HasValue)
				c_api.TF_SetAttrInt (desc, "channels", channels.Value);
			
			if (ratio.HasValue)
				c_api.TF_SetAttrInt (desc, "ratio", ratio.Value);
			
			if (fancy_upscaling.HasValue)
				c_api.TF_SetAttrBool (desc, "fancy_upscaling", Convert.ToByte(fancy_upscaling.Value));
			
			if (try_recover_truncated.HasValue)
				c_api.TF_SetAttrBool (desc, "try_recover_truncated", Convert.ToByte(try_recover_truncated.Value));
			
			if (acceptable_fraction.HasValue)
				c_api.TF_SetAttrFloat (desc, "acceptable_fraction", acceptable_fraction.Value);
			
			if (dct_method != null)
				c_api.TF_SetAttrString (desc, "dct_method", dct_method);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var image = new TF_Output (op, _idx++);
			return image;
		}

		/// <summary>
		///   Convert JSON-encoded Example records to binary protocol buffer strings.
		/// </summary>
		/// <param name="json_examples">
		///   Each string is a JSON object serialized according to the JSON
		///   mapping of the Example proto.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeJSONExample'.
		/// </param>
		/// <returns>
		///   Each string is a binary Example protocol buffer corresponding
		///   to the respective element of <c>json_examples</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op translates a tensor containing Example records, encoded using
		///   the [standard JSON
		///   mapping](https://developers.google.com/protocol-buffers/docs/proto3#json),
		///   into a tensor containing the same records encoded as binary protocol
		///   buffers. The resulting tensor can then be fed to any of the other
		///   Example-parsing ops.
		/// </remarks>
		public TF_Output DecodeJSONExample (TF_Output json_examples, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodeJSONExample", MakeName ("DecodeJSONExample", operName));
			c_api.TF_AddInput(desc, json_examples);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var binary_examples = new TF_Output (op, _idx++);
			return binary_examples;
		}

		/// <summary>
		///   Reinterpret the bytes of a string as a vector of numbers.
		/// </summary>
		/// <param name="input_bytes">
		///   Tensor of string to be decoded.
		/// </param>
		/// <param name="fixed_length">
		///   Length in bytes for each element of the decoded output. Must be a multiple
		///   of the size of the output type.
		///   END
		///   }
		///   out_arg {
		///   name: "output"
		///   description: &amp;lt;&amp;lt;END
		///   A Tensor with one more dimension than the input <c>bytes</c>. The added dimension
		///   will have size equal to the length of the elements of <c>bytes</c> divided by the
		///   number of bytes to represent <c>out_type</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodePaddedRaw'.
		/// </param>
		/// <param name="little_endian">
		///   Optional argument
		///   Whether the input <c>input_bytes</c> is in little-endian order. Ignored for
		///   <c>out_type</c> values that are stored in a single byte, like <c>uint8</c>
		/// </param>
		/// <param name="out_type">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DecodePaddedRaw (TF_Output input_bytes, TF_Output fixed_length, TF_DataType out_type, bool? little_endian = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodePaddedRaw", MakeName ("DecodePaddedRaw", operName));
			c_api.TF_AddInput(desc, input_bytes);
			c_api.TF_AddInput(desc, fixed_length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "out_type", out_type);
			if (little_endian.HasValue)
				c_api.TF_SetAttrBool (desc, "little_endian", Convert.ToByte(little_endian.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Decode a PNG-encoded image to a uint8 or uint16 tensor.
		/// </summary>
		/// <param name="contents">
		///   0-D.  The PNG-encoded image.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodePng'.
		/// </param>
		/// <param name="channels">
		///   Optional argument
		///   Number of color channels for the decoded image.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   3-D with shape <c>[height, width, channels]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The attr <c>channels</c> indicates the desired number of color channels for the
		///   decoded image.
		///   
		///   Accepted values are:
		///   
		///   *   0: Use the number of channels in the PNG-encoded image.
		///   *   1: output a grayscale image.
		///   *   3: output an RGB image.
		///   *   4: output an RGBA image.
		///   
		///   If needed, the PNG-encoded image is transformed to match the requested number
		///   of color channels.
		///   
		///   This op also supports decoding JPEGs and non-animated GIFs since the interface
		///   is the same, though it is cleaner to use <c>tf.image.decode_image</c>.
		/// </remarks>
		public TF_Output DecodePng (TF_Output contents, long? channels = null, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodePng", MakeName ("DecodePng", operName));
			c_api.TF_AddInput(desc, contents);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (channels.HasValue)
				c_api.TF_SetAttrInt (desc, "channels", channels.Value);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var image = new TF_Output (op, _idx++);
			return image;
		}

		/// <summary>
		///   The op extracts fields from a serialized protocol buffers message into tensors.
		/// </summary>
		/// <param name="bytes">
		///   Tensor of serialized protos with shape <c>batch_shape</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeProtoV2'.
		/// </param>
		/// <param name="descriptor_source">
		///   Optional argument
		///   Either the special value <c>local://</c> or a path to a file containing
		///   a serialized <c>FileDescriptorSet</c>.
		/// </param>
		/// <param name="message_format">
		///   Optional argument
		///   Either <c>binary</c> or <c>text</c>.
		/// </param>
		/// <param name="sanitize">
		///   Optional argument
		///   Whether to sanitize the result or not.
		/// </param>
		/// <param name="message_type">
		///   Name of the proto message type to decode.
		/// </param>
		/// <param name="field_names">
		///   List of strings containing proto field names. An extension field can be decoded
		///   by using its full name, e.g. EXT_PACKAGE.EXT_FIELD_NAME.
		/// </param>
		/// <param name="output_types">
		///   List of TF types to use for the respective field in field_names.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sizes: Tensor of int32 with shape <c>[batch_shape, len(field_names)]</c>.
		///   Each entry is the number of values found for the corresponding field.
		///   Optional fields may have 0 or 1 values.
		///   values: List of tensors containing values for the corresponding field.
		///   <c>values[i]</c> has datatype <c>output_types[i]</c>
		///   and shape <c>[batch_shape, max(sizes[...,i])]</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The <c>decode_proto</c> op extracts fields from a serialized protocol buffers
		///   message into tensors.  The fields in <c>field_names</c> are decoded and converted
		///   to the corresponding <c>output_types</c> if possible.
		///   
		///   A <c>message_type</c> name must be provided to give context for the field names.
		///   The actual message descriptor can be looked up either in the linked-in
		///   descriptor pool or a filename provided by the caller using the
		///   <c>descriptor_source</c> attribute.
		///   
		///   Each output tensor is a dense tensor. This means that it is padded to hold
		///   the largest number of repeated elements seen in the input minibatch. (The
		///   shape is also padded by one to prevent zero-sized dimensions). The actual
		///   repeat counts for each example in the minibatch can be found in the <c>sizes</c>
		///   output. In many cases the output of <c>decode_proto</c> is fed immediately into
		///   tf.squeeze if missing values are not a concern. When using tf.squeeze, always
		///   pass the squeeze dimension explicitly to avoid surprises.
		///   
		///   For the most part, the mapping between Proto field types and TensorFlow dtypes
		///   is straightforward. However, there are a few special cases:
		///   
		///   - A proto field that contains a submessage or group can only be converted
		///   to <c>DT_STRING</c> (the serialized submessage). This is to reduce the complexity
		///   of the API. The resulting string can be used as input to another instance of
		///   the decode_proto op.
		///   
		///   - TensorFlow lacks support for unsigned integers. The ops represent uint64
		///   types as a <c>DT_INT64</c> with the same twos-complement bit pattern (the obvious
		///   way). Unsigned int32 values can be represented exactly by specifying type
		///   <c>DT_INT64</c>, or using twos-complement if the caller specifies <c>DT_INT32</c> in
		///   the <c>output_types</c> attribute.
		///   
		///   Both binary and text proto serializations are supported, and can be
		///   chosen using the <c>format</c> attribute.
		///   
		///   The <c>descriptor_source</c> attribute selects the source of protocol
		///   descriptors to consult when looking up <c>message_type</c>. This may be:
		///   
		///   - An empty string  or "local://", in which case protocol descriptors are
		///   created for C++ (not Python) proto definitions linked to the binary.
		///   
		///   - A file, in which case protocol descriptors are created from the file,
		///   which is expected to contain a <c>FileDescriptorSet</c> serialized as a string.
		///   NOTE: You can build a <c>descriptor_source</c> file using the <c>--descriptor_set_out</c>
		///   and <c>--include_imports</c> options to the protocol compiler <c>protoc</c>.
		///   
		///   - A "bytes://&amp;lt;bytes&amp;gt;", in which protocol descriptors are created from <c>&amp;lt;bytes&amp;gt;</c>,
		///   which is expected to be a <c>FileDescriptorSet</c> serialized as a string.
		/// </remarks>
		public (TF_Output sizes, TF_Output[] values) DecodeProtoV2 (TF_Output bytes, string message_type, string[] field_names, TF_DataType[] output_types, string descriptor_source = null, string message_format = null, bool? sanitize = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodeProtoV2", MakeName ("DecodeProtoV2", operName));
			c_api.TF_AddInput(desc, bytes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "message_type", message_type);
			c_api.TF_SetAttrStringList (desc, "field_names", field_names);
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			if (descriptor_source != null)
				c_api.TF_SetAttrString (desc, "descriptor_source", descriptor_source);
			
			if (message_format != null)
				c_api.TF_SetAttrString (desc, "message_format", message_format);
			
			if (sanitize.HasValue)
				c_api.TF_SetAttrBool (desc, "sanitize", Convert.ToByte(sanitize.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			var sizes = new TF_Output (op, _idx++);
			_n = c_api.TF_OperationOutputListLength(op, "values", status);
			var values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				values [i] = new TF_Output (op, _idx++);
			
			return (sizes, values);
		}

		/// <summary>
		///   Reinterpret the bytes of a string as a vector of numbers.
		/// </summary>
		/// <param name="bytes">
		///   All the elements must have the same length.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeRaw'.
		/// </param>
		/// <param name="little_endian">
		///   Optional argument
		///   Whether the input <c>bytes</c> are in little-endian order.
		///   Ignored for <c>out_type</c> values that are stored in a single byte like
		///   <c>uint8</c>.
		/// </param>
		/// <param name="out_type">
		/// </param>
		/// <returns>
		///   A Tensor with one more dimension than the input <c>bytes</c>.  The
		///   added dimension will have size equal to the length of the elements
		///   of <c>bytes</c> divided by the number of bytes to represent <c>out_type</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DecodeRaw (TF_Output bytes, TF_DataType out_type, bool? little_endian = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodeRaw", MakeName ("DecodeRaw", operName));
			c_api.TF_AddInput(desc, bytes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "out_type", out_type);
			if (little_endian.HasValue)
				c_api.TF_SetAttrBool (desc, "little_endian", Convert.ToByte(little_endian.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Decode a 16-bit PCM WAV file to a float tensor.
		/// </summary>
		/// <param name="contents">
		///   The WAV-encoded audio, usually from a file.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeWav'.
		/// </param>
		/// <param name="desired_channels">
		///   Optional argument
		///   Number of sample channels wanted.
		/// </param>
		/// <param name="desired_samples">
		///   Optional argument
		///   Length of audio requested.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   audio: 2-D with shape <c>[length, channels]</c>.
		///   sample_rate: Scalar holding the sample rate found in the WAV header.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The -32768 to 32767 signed 16-bit values will be scaled to -1.0 to 1.0 in float.
		///   
		///   When desired_channels is set, if the input contains fewer channels than this
		///   then the last channel will be duplicated to give the requested number, else if
		///   the input has more channels than requested then the additional channels will be
		///   ignored.
		///   
		///   If desired_samples is set, then the audio will be cropped or padded with zeroes
		///   to the requested length.
		///   
		///   The first output contains a Tensor with the content of the audio samples. The
		///   lowest dimension will be the number of channels, and the second will be the
		///   number of samples. For example, a ten-sample-long stereo WAV file should give an
		///   output shape of [10, 2].
		/// </remarks>
		public (TF_Output audio, TF_Output sample_rate) DecodeWav (TF_Output contents, long? desired_channels = null, long? desired_samples = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DecodeWav", MakeName ("DecodeWav", operName));
			c_api.TF_AddInput(desc, contents);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (desired_channels.HasValue)
				c_api.TF_SetAttrInt (desc, "desired_channels", desired_channels.Value);
			
			if (desired_samples.HasValue)
				c_api.TF_SetAttrInt (desc, "desired_samples", desired_samples.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var audio = new TF_Output (op, _idx++);
			var sample_rate = new TF_Output (op, _idx++);
			return (audio, sample_rate);
		}

		/// <summary>
		///   Makes a copy of <c>x</c>.
		/// </summary>
		/// <param name="x">
		///   The source tensor of type <c>T</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DeepCopy'.
		/// </param>
		/// <returns>
		///   y: A <c>Tensor</c> of type <c>T</c>. A copy of <c>x</c>. Guaranteed that <c>y</c>
		///   is not an alias of <c>x</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DeepCopy (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DeepCopy", MakeName ("DeepCopy", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   A container for an iterator resource.
		/// </summary>
		/// <param name="handle">
		///   A handle to the iterator to delete.
		/// </param>
		/// <param name="deleter">
		///   A variant deleter.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DeleteIterator'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation DeleteIterator (TF_Output handle, TF_Output deleter, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DeleteIterator", MakeName ("DeleteIterator", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, deleter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="deleter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DeleteMemoryCache'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation DeleteMemoryCache (TF_Output handle, TF_Output deleter, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DeleteMemoryCache", MakeName ("DeleteMemoryCache", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, deleter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   A container for an iterator resource.
		/// </summary>
		/// <param name="multi_device_iterator">
		///   A handle to the multi device iterator to delete.
		/// </param>
		/// <param name="iterators">
		///   A list of iterator handles (unused). This is added so that automatic control dependencies get added during function tracing that ensure this op runs after all the dependent iterators are deleted.
		/// </param>
		/// <param name="deleter">
		///   A variant deleter.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DeleteMultiDeviceIterator'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation DeleteMultiDeviceIterator (TF_Output multi_device_iterator, TF_Output[] iterators, TF_Output deleter, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DeleteMultiDeviceIterator", MakeName ("DeleteMultiDeviceIterator", operName));
			c_api.TF_AddInput(desc, multi_device_iterator);
			c_api.TF_AddInputList(desc, iterators[0], iterators.Length);
			c_api.TF_AddInput(desc, deleter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="deleter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DeleteRandomSeedGenerator'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation DeleteRandomSeedGenerator (TF_Output handle, TF_Output deleter, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DeleteRandomSeedGenerator", MakeName ("DeleteRandomSeedGenerator", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, deleter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Delete the tensor specified by its handle in the session.
		/// </summary>
		/// <param name="handle">
		///   The handle for a tensor stored in the session state.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DeleteSessionTensor'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation DeleteSessionTensor (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DeleteSessionTensor", MakeName ("DeleteSessionTensor", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Applies set operation along last dimension of 2 <c>Tensor</c> inputs.
		/// </summary>
		/// <param name="set1">
		///   <c>Tensor</c> with rank <c>n</c>. 1st <c>n-1</c> dimensions must be the same as <c>set2</c>.
		///   Dimension <c>n</c> contains values in a set, duplicates are allowed but ignored.
		/// </param>
		/// <param name="set2">
		///   <c>Tensor</c> with rank <c>n</c>. 1st <c>n-1</c> dimensions must be the same as <c>set1</c>.
		///   Dimension <c>n</c> contains values in a set, duplicates are allowed but ignored.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DenseToDenseSetOperation'.
		/// </param>
		/// <param name="validate_indices">
		///   Optional argument
		/// </param>
		/// <param name="set_operation">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   result_indices: 2D indices of a <c>SparseTensor</c>.
		///   result_values: 1D values of a <c>SparseTensor</c>.
		///   result_shape: 1D <c>Tensor</c> shape of a <c>SparseTensor</c>. <c>result_shape[0...n-1]</c> is
		///   the same as the 1st <c>n-1</c> dimensions of <c>set1</c> and <c>set2</c>, <c>result_shape[n]</c>
		///   is the max result set size across all <c>0...n-1</c> dimensions.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   See SetOperationOp::SetOperationFromContext for values of <c>set_operation</c>.
		///   
		///   Output <c>result</c> is a <c>SparseTensor</c> represented by <c>result_indices</c>,
		///   <c>result_values</c>, and <c>result_shape</c>. For <c>set1</c> and <c>set2</c> ranked <c>n</c>, this
		///   has rank <c>n</c> and the same 1st <c>n-1</c> dimensions as <c>set1</c> and <c>set2</c>. The <c>nth</c>
		///   dimension contains the result of <c>set_operation</c> applied to the corresponding
		///   <c>[0...n-1]</c> dimension of <c>set</c>.
		/// </remarks>
		public (TF_Output result_indices, TF_Output result_values, TF_Output result_shape) DenseToDenseSetOperation (TF_Output set1, TF_Output set2, string set_operation, bool? validate_indices = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DenseToDenseSetOperation", MakeName ("DenseToDenseSetOperation", operName));
			c_api.TF_AddInput(desc, set1);
			c_api.TF_AddInput(desc, set2);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "set_operation", set_operation);
			if (validate_indices.HasValue)
				c_api.TF_SetAttrBool (desc, "validate_indices", Convert.ToByte(validate_indices.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var result_indices = new TF_Output (op, _idx++);
			var result_values = new TF_Output (op, _idx++);
			var result_shape = new TF_Output (op, _idx++);
			return (result_indices, result_values, result_shape);
		}

		/// <summary>
		///   Creates a dataset that batches input elements into a SparseTensor.
		/// </summary>
		/// <param name="input_dataset">
		///   A handle to an input dataset. Must have a single component.
		/// </param>
		/// <param name="batch_size">
		///   A scalar representing the number of elements to accumulate in a
		///   batch.
		/// </param>
		/// <param name="row_shape">
		///   A vector representing the dense shape of each row in the produced
		///   SparseTensor. The shape may be partially specified, using <c>-1</c> to indicate
		///   that a particular dimension should use the maximum size of all batch elements.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DenseToSparseBatchDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DenseToSparseBatchDataset (TF_Output input_dataset, TF_Output batch_size, TF_Output row_shape, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DenseToSparseBatchDataset", MakeName ("DenseToSparseBatchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, batch_size);
			c_api.TF_AddInput(desc, row_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Applies set operation along last dimension of <c>Tensor</c> and <c>SparseTensor</c>.
		/// </summary>
		/// <param name="set1">
		///   <c>Tensor</c> with rank <c>n</c>. 1st <c>n-1</c> dimensions must be the same as <c>set2</c>.
		///   Dimension <c>n</c> contains values in a set, duplicates are allowed but ignored.
		/// </param>
		/// <param name="set2_indices">
		///   2D <c>Tensor</c>, indices of a <c>SparseTensor</c>. Must be in row-major
		///   order.
		/// </param>
		/// <param name="set2_values">
		///   1D <c>Tensor</c>, values of a <c>SparseTensor</c>. Must be in row-major
		///   order.
		/// </param>
		/// <param name="set2_shape">
		///   1D <c>Tensor</c>, shape of a <c>SparseTensor</c>. <c>set2_shape[0...n-1]</c> must
		///   be the same as the 1st <c>n-1</c> dimensions of <c>set1</c>, <c>result_shape[n]</c> is the
		///   max set size across <c>n-1</c> dimensions.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DenseToSparseSetOperation'.
		/// </param>
		/// <param name="validate_indices">
		///   Optional argument
		/// </param>
		/// <param name="set_operation">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   result_indices: 2D indices of a <c>SparseTensor</c>.
		///   result_values: 1D values of a <c>SparseTensor</c>.
		///   result_shape: 1D <c>Tensor</c> shape of a <c>SparseTensor</c>. <c>result_shape[0...n-1]</c> is
		///   the same as the 1st <c>n-1</c> dimensions of <c>set1</c> and <c>set2</c>, <c>result_shape[n]</c>
		///   is the max result set size across all <c>0...n-1</c> dimensions.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   See SetOperationOp::SetOperationFromContext for values of <c>set_operation</c>.
		///   
		///   Input <c>set2</c> is a <c>SparseTensor</c> represented by <c>set2_indices</c>, <c>set2_values</c>,
		///   and <c>set2_shape</c>. For <c>set2</c> ranked <c>n</c>, 1st <c>n-1</c> dimensions must be the same
		///   as <c>set1</c>. Dimension <c>n</c> contains values in a set, duplicates are allowed but
		///   ignored.
		///   
		///   If <c>validate_indices</c> is <c>True</c>, this op validates the order and range of <c>set2</c>
		///   indices.
		///   
		///   Output <c>result</c> is a <c>SparseTensor</c> represented by <c>result_indices</c>,
		///   <c>result_values</c>, and <c>result_shape</c>. For <c>set1</c> and <c>set2</c> ranked <c>n</c>, this
		///   has rank <c>n</c> and the same 1st <c>n-1</c> dimensions as <c>set1</c> and <c>set2</c>. The <c>nth</c>
		///   dimension contains the result of <c>set_operation</c> applied to the corresponding
		///   <c>[0...n-1]</c> dimension of <c>set</c>.
		/// </remarks>
		public (TF_Output result_indices, TF_Output result_values, TF_Output result_shape) DenseToSparseSetOperation (TF_Output set1, TF_Output set2_indices, TF_Output set2_values, TF_Output set2_shape, string set_operation, bool? validate_indices = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DenseToSparseSetOperation", MakeName ("DenseToSparseSetOperation", operName));
			c_api.TF_AddInput(desc, set1);
			c_api.TF_AddInput(desc, set2_indices);
			c_api.TF_AddInput(desc, set2_values);
			c_api.TF_AddInput(desc, set2_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "set_operation", set_operation);
			if (validate_indices.HasValue)
				c_api.TF_SetAttrBool (desc, "validate_indices", Convert.ToByte(validate_indices.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var result_indices = new TF_Output (op, _idx++);
			var result_values = new TF_Output (op, _idx++);
			var result_shape = new TF_Output (op, _idx++);
			return (result_indices, result_values, result_shape);
		}

		/// <summary>
		///   DepthToSpace for tensors of type T.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DepthToSpace'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="block_size">
		///   The size of the spatial block, same as in Space2Depth.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Rearranges data from depth into blocks of spatial data.
		///   This is the reverse transformation of SpaceToDepth. More specifically,
		///   this op outputs a copy of the input tensor where values from the <c>depth</c>
		///   dimension are moved in spatial blocks to the <c>height</c> and <c>width</c> dimensions.
		///   The attr <c>block_size</c> indicates the input block size and how the data is moved.
		///   
		///   * Chunks of data of size <c>block_size * block_size</c> from depth are rearranged
		///   into non-overlapping blocks of size <c>block_size x block_size</c>
		///   * The width the output tensor is <c>input_depth * block_size</c>, whereas the
		///   height is <c>input_height * block_size</c>.
		///   * The Y, X coordinates within each block of the output image are determined
		///   by the high order component of the input channel index.
		///   * The depth of the input tensor must be divisible by
		///   <c>block_size * block_size</c>.
		///   
		///   The <c>data_format</c> attr specifies the layout of the input and output tensors
		///   with the following options:
		///   "NHWC": <c>[ batch, height, width, channels ]</c>
		///   "NCHW": <c>[ batch, channels, height, width ]</c>
		///   "NCHW_VECT_C":
		///   <c>qint8 [ batch, channels / 4, height, width, 4 ]</c>
		///   
		///   It is useful to consider the operation as transforming a 6-D Tensor.
		///   e.g. for data_format = NHWC,
		///   Each element in the input tensor can be specified via 6 coordinates,
		///   ordered by decreasing memory layout significance as:
		///   n,iY,iX,bY,bX,oC  (where n=batch index, iX, iY means X or Y coordinates
		///   within the input image, bX, bY means coordinates
		///   within the output block, oC means output channels).
		///   The output would be the input transposed to the following layout:
		///   n,iY,bY,iX,bX,oC
		///   
		///   This operation is useful for resizing the activations between convolutions
		///   (but keeping all data), e.g. instead of pooling. It is also useful for training
		///   purely convolutional models.
		///   
		///   For example, given an input of shape <c>[1, 1, 1, 4]</c>, data_format = "NHWC" and
		///   block_size = 2:
		///   
		///    <code>
		///   x = [[[[1, 2, 3, 4]]]]
		///   
		///    </code>
		///   
		///   This operation will output a tensor of shape <c>[1, 2, 2, 1]</c>:
		///   
		///    <code>
		///   [[[[1], [2]],
		///   [[3], [4]]]]
		///    </code>
		///   
		///   Here, the input has a batch of 1 and each batch element has shape <c>[1, 1, 4]</c>,
		///   the corresponding output will have 2x2 elements and will have a depth of
		///   1 channel (1 = <c>4 / (block_size * block_size)</c>).
		///   The output element shape is <c>[2, 2, 1]</c>.
		///   
		///   For an input tensor with larger depth, here of shape <c>[1, 1, 1, 12]</c>, e.g.
		///   
		///    <code>
		///   x = [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]
		///    </code>
		///   
		///   This operation, for block size of 2, will return the following tensor of shape
		///   <c>[1, 2, 2, 3]</c>
		///   
		///    <code>
		///   [[[[1, 2, 3], [4, 5, 6]],
		///   [[7, 8, 9], [10, 11, 12]]]]
		///   
		///    </code>
		///   
		///   Similarly, for the following input of shape <c>[1 2 2 4]</c>, and a block size of 2:
		///   
		///    <code>
		///   x =  [[[[1, 2, 3, 4],
		///   [5, 6, 7, 8]],
		///   [[9, 10, 11, 12],
		///   [13, 14, 15, 16]]]]
		///    </code>
		///   
		///   the operator will return the following tensor of shape <c>[1 4 4 1]</c>:
		///   
		///    <code>
		///   x = [[[ [1],   [2],  [5],  [6]],
		///   [ [3],   [4],  [7],  [8]],
		///   [ [9],  [10], [13],  [14]],
		///   [ [11], [12], [15],  [16]]]]
		///   
		///    </code>
		/// </remarks>
		public TF_Output DepthToSpace (TF_Output input, long block_size, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DepthToSpace", MakeName ("DepthToSpace", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "block_size", block_size);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes a 2-D depthwise convolution given 4-D <c>input</c> and <c>filter</c> tensors.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DepthwiseConv2dNative'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   Specify the data format of the input and output data. With the
		///   default format "NHWC", the data is stored in the order of:
		///   [batch, height, width, channels].
		///   Alternatively, the format could be "NCHW", the data storage order of:
		///   [batch, channels, height, width].
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		///   1-D tensor of length 4.  The dilation factor for each dimension of
		///   <c>input</c>. If set to k &amp;gt; 1, there will be k-1 skipped cells between each filter
		///   element on that dimension. The dimension order is determined by the value of
		///   <c>data_format</c>, see above for details. Dilations in the batch and depth
		///   dimensions must be 1.
		/// </param>
		/// <param name="strides">
		///   1-D of length 4.  The stride of the sliding window for each dimension
		///   of <c>input</c>.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given an input tensor of shape <c>[batch, in_height, in_width, in_channels]</c>
		///   and a filter / kernel tensor of shape
		///   <c>[filter_height, filter_width, in_channels, channel_multiplier]</c>, containing
		///   <c>in_channels</c> convolutional filters of depth 1, <c>depthwise_conv2d</c> applies
		///   a different filter to each input channel (expanding from 1 channel to
		///   <c>channel_multiplier</c> channels for each), then concatenates the results
		///   together. Thus, the output has <c>in_channels * channel_multiplier</c> channels.
		///   
		///    <code>
		///   for k in 0..in_channels-1
		///   for q in 0..channel_multiplier-1
		///   output[b, i, j, k * channel_multiplier + q] =
		///   sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] *
		///   filter[di, dj, k, q]
		///    </code>
		///   
		///   Must have <c>strides[0] = strides[3] = 1</c>.  For the most common case of the same
		///   horizontal and vertices strides, <c>strides = [1, stride, stride, 1]</c>.
		/// </remarks>
		public TF_Output DepthwiseConv2dNative (TF_Output input, TF_Output filter, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DepthwiseConv2dNative", MakeName ("DepthwiseConv2dNative", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the gradients of depthwise convolution with respect to the filter.
		/// </summary>
		/// <param name="input">
		///   4-D with shape based on <c>data_format</c>.  For example, if
		///   <c>data_format</c> is 'NHWC' then <c>input</c> is a 4-D <c>[batch, in_height,
		///   in_width, in_channels]</c> tensor.
		/// </param>
		/// <param name="filter_sizes">
		///   An integer vector representing the tensor shape of <c>filter</c>,
		///   where <c>filter</c> is a 4-D
		///   <c>[filter_height, filter_width, in_channels, depthwise_multiplier]</c> tensor.
		/// </param>
		/// <param name="out_backprop">
		///   4-D with shape  based on <c>data_format</c>.
		///   For example, if <c>data_format</c> is 'NHWC' then
		///   out_backprop shape is <c>[batch, out_height, out_width, out_channels]</c>.
		///   Gradients w.r.t. the output of the convolution.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DepthwiseConv2dNativeBackpropFilter'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   Specify the data format of the input and output data. With the
		///   default format "NHWC", the data is stored in the order of:
		///   [batch, height, width, channels].
		///   Alternatively, the format could be "NCHW", the data storage order of:
		///   [batch, channels, height, width].
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		///   1-D tensor of length 4.  The dilation factor for each dimension of
		///   <c>input</c>. If set to k &amp;gt; 1, there will be k-1 skipped cells between each filter
		///   element on that dimension. The dimension order is determined by the value of
		///   <c>data_format</c>, see above for details. Dilations in the batch and depth
		///   dimensions must be 1.
		/// </param>
		/// <param name="strides">
		///   The stride of the sliding window for each dimension of the input
		///   of the convolution.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   4-D with shape
		///   <c>[filter_height, filter_width, in_channels, out_channels]</c>.  Gradient w.r.t.
		///   the <c>filter</c> input of the convolution.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DepthwiseConv2dNativeBackpropFilter (TF_Output input, TF_Output filter_sizes, TF_Output out_backprop, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DepthwiseConv2dNativeBackpropFilter", MakeName ("DepthwiseConv2dNativeBackpropFilter", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter_sizes);
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the gradients of depthwise convolution with respect to the input.
		/// </summary>
		/// <param name="input_sizes">
		///   An integer vector representing the shape of <c>input</c>, based
		///   on <c>data_format</c>.  For example, if <c>data_format</c> is 'NHWC' then
		///   <c>input</c> is a 4-D <c>[batch, height, width, channels]</c> tensor.
		/// </param>
		/// <param name="filter">
		///   4-D with shape
		///   <c>[filter_height, filter_width, in_channels, depthwise_multiplier]</c>.
		/// </param>
		/// <param name="out_backprop">
		///   4-D with shape  based on <c>data_format</c>.
		///   For example, if <c>data_format</c> is 'NHWC' then
		///   out_backprop shape is <c>[batch, out_height, out_width, out_channels]</c>.
		///   Gradients w.r.t. the output of the convolution.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DepthwiseConv2dNativeBackpropInput'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   Specify the data format of the input and output data. With the
		///   default format "NHWC", the data is stored in the order of:
		///   [batch, height, width, channels].
		///   Alternatively, the format could be "NCHW", the data storage order of:
		///   [batch, channels, height, width].
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		///   1-D tensor of length 4.  The dilation factor for each dimension of
		///   <c>input</c>. If set to k &amp;gt; 1, there will be k-1 skipped cells between each filter
		///   element on that dimension. The dimension order is determined by the value of
		///   <c>data_format</c>, see above for details. Dilations in the batch and depth
		///   dimensions must be 1.
		/// </param>
		/// <param name="strides">
		///   The stride of the sliding window for each dimension of the input
		///   of the convolution.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   4-D with shape according to <c>data_format</c>.  For example, if
		///   <c>data_format</c> is 'NHWC', output shape is <c>[batch, in_height,
		///   in_width, in_channels]</c>.  Gradient w.r.t. the input of the
		///   convolution.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DepthwiseConv2dNativeBackpropInput (TF_Output input_sizes, TF_Output filter, TF_Output out_backprop, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DepthwiseConv2dNativeBackpropInput", MakeName ("DepthwiseConv2dNativeBackpropInput", operName));
			c_api.TF_AddInput(desc, input_sizes);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Dequantize the 'input' tensor into a float Tensor.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="min_range">
		///   The minimum scalar value possibly produced for the input.
		/// </param>
		/// <param name="max_range">
		///   The maximum scalar value possibly produced for the input.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Dequantize'.
		/// </param>
		/// <param name="mode">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   [min_range, max_range] are scalar floats that specify the range for
		///   the 'input' data. The 'mode' attribute controls exactly which calculations are
		///   used to convert the float values to their quantized equivalents.
		///   
		///   In 'MIN_COMBINED' mode, each value of the tensor will undergo the following:
		///   
		///    <code>
		///   if T == qint8: in[i] += (range(T) + 1)/ 2.0
		///   out[i] = min_range + (in[i]* (max_range - min_range) / range(T))
		///    </code>
		///   here <c>range(T) = numeric_limits&amp;lt;T&amp;gt;::max() - numeric_limits&amp;lt;T&amp;gt;::min()</c>
		///   
		///   *MIN_COMBINED Mode Example*
		///   
		///   If the input comes from a QuantizedRelu6, the output type is
		///   quint8 (range of 0-255) but the possible range of QuantizedRelu6 is
		///   0-6.  The min_range and max_range values are therefore 0.0 and 6.0.
		///   Dequantize on quint8 will take each value, cast to float, and multiply
		///   by 6 / 255.
		///   Note that if quantizedtype is qint8, the operation will additionally add
		///   each value by 128 prior to casting.
		///   
		///   If the mode is 'MIN_FIRST', then this approach is used:
		///   
		///    <code>
		///   num_discrete_values = 1 &amp;lt;&amp;lt; (# of bits in T)
		///   range_adjust = num_discrete_values / (num_discrete_values - 1)
		///   range = (range_max - range_min) * range_adjust
		///   range_scale = range / num_discrete_values
		///   const double offset_input = static_cast&amp;lt;double&amp;gt;(input) - lowest_quantized;
		///   result = range_min + ((input - numeric_limits&amp;lt;T&amp;gt;::min()) * range_scale)
		///    </code>
		///   
		///   *SCALED mode Example*
		///   
		///   <c>SCALED</c> mode matches the quantization approach used in
		///   <c>QuantizeAndDequantize{V2|V3}</c>.
		///   
		///   If the mode is <c>SCALED</c>, we do not use the full range of the output type,
		///   choosing to elide the lowest possible value for symmetry (e.g., output range is
		///   -127 to 127, not -128 to 127 for signed 8 bit quantization), so that 0.0 maps to
		///   0.
		///   
		///   We first find the range of values in our tensor. The
		///   range we use is always centered on 0, so we find m such that
		///    <code>
		///   m = max(abs(input_min), abs(input_max))
		///    </code>
		///   
		///   Our input tensor range is then <c>[-m, m]</c>.
		///   
		///   Next, we choose our fixed-point quantization buckets, <c>[min_fixed, max_fixed]</c>.
		///   If T is signed, this is
		///    <code>
		///   num_bits = sizeof(T) * 8
		///   [min_fixed, max_fixed] =
		///   [-(1 &amp;lt;&amp;lt; (num_bits - 1) - 1), (1 &amp;lt;&amp;lt; (num_bits - 1)) - 1]
		///    </code>
		///   
		///   Otherwise, if T is unsigned, the fixed-point range is
		///    <code>
		///   [min_fixed, max_fixed] = [0, (1 &amp;lt;&amp;lt; num_bits) - 1]
		///    </code>
		///   
		///   From this we compute our scaling factor, s:
		///    <code>
		///   s = (2 * m) / (max_fixed - min_fixed)
		///    </code>
		///   
		///   Now we can dequantize the elements of our tensor:
		///    <code>
		///   result = input * s
		///    </code>
		/// </remarks>
		public TF_Output Dequantize (TF_Output input, TF_Output min_range, TF_Output max_range, string mode = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Dequantize", MakeName ("Dequantize", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, min_range);
			c_api.TF_AddInput(desc, max_range);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (mode != null)
				c_api.TF_SetAttrString (desc, "mode", mode);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Converts the given variant tensor to an iterator and stores it in the given resource.
		/// </summary>
		/// <param name="resource_handle">
		///   A handle to an iterator resource.
		/// </param>
		/// <param name="serialized">
		///   A variant tensor storing the state of the iterator contained in the
		///   resource.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DeserializeIterator'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation DeserializeIterator (TF_Output resource_handle, TF_Output serialized, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DeserializeIterator", MakeName ("DeserializeIterator", operName));
			c_api.TF_AddInput(desc, resource_handle);
			c_api.TF_AddInput(desc, serialized);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Deserialize and concatenate <c>SparseTensors</c> from a serialized minibatch.
		/// </summary>
		/// <param name="serialized_sparse">
		///   2-D, The <c>N</c> serialized <c>SparseTensor</c> objects.
		///   Must have 3 columns.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DeserializeManySparse'.
		/// </param>
		/// <param name="dtype">
		///   The <c>dtype</c> of the serialized <c>SparseTensor</c> objects.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sparse_indices:
		///   sparse_values:
		///   sparse_shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The input <c>serialized_sparse</c> must be a string matrix of shape <c>[N x 3]</c> where
		///   <c>N</c> is the minibatch size and the rows correspond to packed outputs of
		///   <c>SerializeSparse</c>.  The ranks of the original <c>SparseTensor</c> objects
		///   must all match.  When the final <c>SparseTensor</c> is created, it has rank one
		///   higher than the ranks of the incoming <c>SparseTensor</c> objects
		///   (they have been concatenated along a new row dimension).
		///   
		///   The output <c>SparseTensor</c> object's shape values for all dimensions but the
		///   first are the max across the input <c>SparseTensor</c> objects' shape values
		///   for the corresponding dimensions.  Its first shape value is <c>N</c>, the minibatch
		///   size.
		///   
		///   The input <c>SparseTensor</c> objects' indices are assumed ordered in
		///   standard lexicographic order.  If this is not the case, after this
		///   step run <c>SparseReorder</c> to restore index ordering.
		///   
		///   For example, if the serialized input is a <c>[2 x 3]</c> matrix representing two
		///   original <c>SparseTensor</c> objects:
		///   
		///   index = [ 0]
		///   [10]
		///   [20]
		///   values = [1, 2, 3]
		///   shape = [50]
		///   
		///   and
		///   
		///   index = [ 2]
		///   [10]
		///   values = [4, 5]
		///   shape = [30]
		///   
		///   then the final deserialized <c>SparseTensor</c> will be:
		///   
		///   index = [0  0]
		///   [0 10]
		///   [0 20]
		///   [1  2]
		///   [1 10]
		///   values = [1, 2, 3, 4, 5]
		///   shape = [2 50]
		/// </remarks>
		public (TF_Output sparse_indices, TF_Output sparse_values, TF_Output sparse_shape) DeserializeManySparse (TF_Output serialized_sparse, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DeserializeManySparse", MakeName ("DeserializeManySparse", operName));
			c_api.TF_AddInput(desc, serialized_sparse);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var sparse_indices = new TF_Output (op, _idx++);
			var sparse_values = new TF_Output (op, _idx++);
			var sparse_shape = new TF_Output (op, _idx++);
			return (sparse_indices, sparse_values, sparse_shape);
		}

		/// <summary>
		///   Deserialize <c>SparseTensor</c> objects.
		/// </summary>
		/// <param name="serialized_sparse">
		///   The serialized <c>SparseTensor</c> objects. The last dimension
		///   must have 3 columns.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DeserializeSparse'.
		/// </param>
		/// <param name="dtype">
		///   The <c>dtype</c> of the serialized <c>SparseTensor</c> objects.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sparse_indices:
		///   sparse_values:
		///   sparse_shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The input <c>serialized_sparse</c> must have the shape <c>[?, ?, ..., ?, 3]</c> where
		///   the last dimension stores serialized <c>SparseTensor</c> objects and the other N
		///   dimensions (N &amp;gt;= 0) correspond to a batch. The ranks of the original
		///   <c>SparseTensor</c> objects must all match. When the final <c>SparseTensor</c> is
		///   created, its rank is the rank of the incoming <c>SparseTensor</c> objects plus N;
		///   the sparse tensors have been concatenated along new dimensions, one for each
		///   batch.
		///   
		///   The output <c>SparseTensor</c> object's shape values for the original dimensions
		///   are the max across the input <c>SparseTensor</c> objects' shape values for the
		///   corresponding dimensions. The new dimensions match the size of the batch.
		///   
		///   The input <c>SparseTensor</c> objects' indices are assumed ordered in
		///   standard lexicographic order.  If this is not the case, after this
		///   step run <c>SparseReorder</c> to restore index ordering.
		///   
		///   For example, if the serialized input is a <c>[2 x 3]</c> matrix representing two
		///   original <c>SparseTensor</c> objects:
		///   
		///   index = [ 0]
		///   [10]
		///   [20]
		///   values = [1, 2, 3]
		///   shape = [50]
		///   
		///   and
		///   
		///   index = [ 2]
		///   [10]
		///   values = [4, 5]
		///   shape = [30]
		///   
		///   then the final deserialized <c>SparseTensor</c> will be:
		///   
		///   index = [0  0]
		///   [0 10]
		///   [0 20]
		///   [1  2]
		///   [1 10]
		///   values = [1, 2, 3, 4, 5]
		///   shape = [2 50]
		/// </remarks>
		public (TF_Output sparse_indices, TF_Output sparse_values, TF_Output sparse_shape) DeserializeSparse (TF_Output serialized_sparse, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DeserializeSparse", MakeName ("DeserializeSparse", operName));
			c_api.TF_AddInput(desc, serialized_sparse);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var sparse_indices = new TF_Output (op, _idx++);
			var sparse_values = new TF_Output (op, _idx++);
			var sparse_shape = new TF_Output (op, _idx++);
			return (sparse_indices, sparse_values, sparse_shape);
		}

		/// <summary>
		///   Deletes the resource specified by the handle.
		/// </summary>
		/// <param name="resource">
		///   handle to the resource to delete.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DestroyResourceOp'.
		/// </param>
		/// <param name="ignore_lookup_error">
		///   Optional argument
		///   whether to ignore the error when the resource
		///   doesn't exist.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   All subsequent operations using the resource will result in a NotFound
		///   error status.
		/// </remarks>
		public TF_Operation DestroyResourceOp (TF_Output resource, bool? ignore_lookup_error = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DestroyResourceOp", MakeName ("DestroyResourceOp", operName));
			c_api.TF_AddInput(desc, resource);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (ignore_lookup_error.HasValue)
				c_api.TF_SetAttrBool (desc, "ignore_lookup_error", Convert.ToByte(ignore_lookup_error.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Destroys the temporary variable and returns its final value.
		/// </summary>
		/// <param name="reference">
		///   A reference to the temporary variable tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DestroyTemporaryVariable'.
		/// </param>
		/// <param name="var_name">
		///   Name of the temporary variable, usually the name of the matching
		///   'TemporaryVariable' op.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Sets output to the value of the Tensor pointed to by 'ref', then destroys
		///   the temporary variable called 'var_name'.
		///   All other uses of 'ref' *must* have executed before this op.
		///   This is typically achieved by chaining the ref through each assign op, or by
		///   using control dependencies.
		///   
		///   Outputs the final value of the tensor pointed to by 'ref'.
		/// </remarks>
		public TF_Output DestroyTemporaryVariable (TF_Output reference, string var_name, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DestroyTemporaryVariable", MakeName ("DestroyTemporaryVariable", operName));
			c_api.TF_AddInput(desc, reference);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "var_name", var_name);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			return value;
		}

		/// <summary>
		///   Returns a diagonal tensor with a given diagonal values.
		/// </summary>
		/// <param name="diagonal">
		///   Rank k tensor where k is at most 1.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Diag'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given a <c>diagonal</c>, this operation returns a tensor with the <c>diagonal</c> and
		///   everything else padded with zeros. The diagonal is computed as follows:
		///   
		///   Assume <c>diagonal</c> has dimensions [D1,..., Dk], then the output is a tensor of
		///   rank 2k with dimensions [D1,..., Dk, D1,..., Dk] where:
		///   
		///   <c>output[i1,..., ik, i1,..., ik] = diagonal[i1, ..., ik]</c> and 0 everywhere else.
		///   
		///   For example:
		///   
		///    <code>
		///   # 'diagonal' is [1, 2, 3, 4]
		///   tf.diag(diagonal) ==&amp;gt; [[1, 0, 0, 0]
		///   [0, 2, 0, 0]
		///   [0, 0, 3, 0]
		///   [0, 0, 0, 4]]
		///    </code>
		/// </remarks>
		public TF_Output Diag (TF_Output diagonal, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Diag", MakeName ("Diag", operName));
			c_api.TF_AddInput(desc, diagonal);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns the diagonal part of the tensor.
		/// </summary>
		/// <param name="input">
		///   Rank k tensor where k is even and not zero.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DiagPart'.
		/// </param>
		/// <returns>
		///   The extracted diagonal.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation returns a tensor with the <c>diagonal</c> part
		///   of the <c>input</c>. The <c>diagonal</c> part is computed as follows:
		///   
		///   Assume <c>input</c> has dimensions <c>[D1,..., Dk, D1,..., Dk]</c>, then the output is a
		///   tensor of rank <c>k</c> with dimensions <c>[D1,..., Dk]</c> where:
		///   
		///   <c>diagonal[i1,..., ik] = input[i1, ..., ik, i1,..., ik]</c>.
		///   
		///   For example:
		///   
		///    <code>
		///   # 'input' is [[1, 0, 0, 0]
		///   [0, 2, 0, 0]
		///   [0, 0, 3, 0]
		///   [0, 0, 0, 4]]
		///   
		///   tf.diag_part(input) ==&amp;gt; [1, 2, 3, 4]
		///    </code>
		/// </remarks>
		public TF_Output DiagPart (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DiagPart", MakeName ("DiagPart", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var diagonal = new TF_Output (op, _idx++);
			return diagonal;
		}

		/// <summary>
		///   Computes Psi, the derivative of Lgamma (the log of the absolute value of
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Digamma'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   <c>Gamma(x)</c>), element-wise.
		/// </remarks>
		public TF_Output Digamma (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Digamma", MakeName ("Digamma", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes the grayscale dilation of 4-D <c>input</c> and 3-D <c>filter</c> tensors.
		/// </summary>
		/// <param name="input">
		///   4-D with shape <c>[batch, in_height, in_width, depth]</c>.
		/// </param>
		/// <param name="filter">
		///   3-D with shape <c>[filter_height, filter_width, depth]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Dilation2D'.
		/// </param>
		/// <param name="strides">
		///   The stride of the sliding window for each dimension of the input
		///   tensor. Must be: <c>[1, stride_height, stride_width, 1]</c>.
		/// </param>
		/// <param name="rates">
		///   The input stride for atrous morphological dilation. Must be:
		///   <c>[1, rate_height, rate_width, 1]</c>.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   4-D with shape <c>[batch, out_height, out_width, depth]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The <c>input</c> tensor has shape <c>[batch, in_height, in_width, depth]</c> and the
		///   <c>filter</c> tensor has shape <c>[filter_height, filter_width, depth]</c>, i.e., each
		///   input channel is processed independently of the others with its own structuring
		///   function. The <c>output</c> tensor has shape
		///   <c>[batch, out_height, out_width, depth]</c>. The spatial dimensions of the output
		///   tensor depend on the <c>padding</c> algorithm. We currently only support the default
		///   "NHWC" <c>data_format</c>.
		///   
		///   In detail, the grayscale morphological 2-D dilation is the max-sum correlation
		///   (for consistency with <c>conv2d</c>, we use unmirrored filters):
		///   
		///   output[b, y, x, c] =
		///   max_{dy, dx} input[b,
		///   strides[1] * y + rates[1] * dy,
		///   strides[2] * x + rates[2] * dx,
		///   c] +
		///   filter[dy, dx, c]
		///   
		///   Max-pooling is a special case when the filter has size equal to the pooling
		///   kernel size and contains all zeros.
		///   
		///   Note on duality: The dilation of <c>input</c> by the <c>filter</c> is equal to the
		///   negation of the erosion of <c>-input</c> by the reflected <c>filter</c>.
		/// </remarks>
		public TF_Output Dilation2D (TF_Output input, TF_Output filter, long[] strides, long[] rates, string padding, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Dilation2D", MakeName ("Dilation2D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrIntList (desc, "rates", ref rates[0], rates.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the gradient of morphological 2-D dilation with respect to the filter.
		/// </summary>
		/// <param name="input">
		///   4-D with shape <c>[batch, in_height, in_width, depth]</c>.
		/// </param>
		/// <param name="filter">
		///   3-D with shape <c>[filter_height, filter_width, depth]</c>.
		/// </param>
		/// <param name="out_backprop">
		///   4-D with shape <c>[batch, out_height, out_width, depth]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Dilation2DBackpropFilter'.
		/// </param>
		/// <param name="strides">
		///   1-D of length 4. The stride of the sliding window for each dimension of
		///   the input tensor. Must be: <c>[1, stride_height, stride_width, 1]</c>.
		/// </param>
		/// <param name="rates">
		///   1-D of length 4. The input stride for atrous morphological dilation.
		///   Must be: <c>[1, rate_height, rate_width, 1]</c>.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   3-D with shape <c>[filter_height, filter_width, depth]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Dilation2DBackpropFilter (TF_Output input, TF_Output filter, TF_Output out_backprop, long[] strides, long[] rates, string padding, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Dilation2DBackpropFilter", MakeName ("Dilation2DBackpropFilter", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrIntList (desc, "rates", ref rates[0], rates.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var filter_backprop = new TF_Output (op, _idx++);
			return filter_backprop;
		}

		/// <summary>
		///   Computes the gradient of morphological 2-D dilation with respect to the input.
		/// </summary>
		/// <param name="input">
		///   4-D with shape <c>[batch, in_height, in_width, depth]</c>.
		/// </param>
		/// <param name="filter">
		///   3-D with shape <c>[filter_height, filter_width, depth]</c>.
		/// </param>
		/// <param name="out_backprop">
		///   4-D with shape <c>[batch, out_height, out_width, depth]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Dilation2DBackpropInput'.
		/// </param>
		/// <param name="strides">
		///   1-D of length 4. The stride of the sliding window for each dimension of
		///   the input tensor. Must be: <c>[1, stride_height, stride_width, 1]</c>.
		/// </param>
		/// <param name="rates">
		///   1-D of length 4. The input stride for atrous morphological dilation.
		///   Must be: <c>[1, rate_height, rate_width, 1]</c>.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   4-D with shape <c>[batch, in_height, in_width, depth]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Dilation2DBackpropInput (TF_Output input, TF_Output filter, TF_Output out_backprop, long[] strides, long[] rates, string padding, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Dilation2DBackpropInput", MakeName ("Dilation2DBackpropInput", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, out_backprop);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrIntList (desc, "rates", ref rates[0], rates.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var in_backprop = new TF_Output (op, _idx++);
			return in_backprop;
		}

		/// <summary>
		///   A substitute for <c>InterleaveDataset</c> on a fixed list of <c>N</c> datasets.
		/// </summary>
		/// <param name="selector_input_dataset">
		///   A dataset of scalar <c>DT_INT64</c> elements that determines which of the
		///   <c>N</c> data inputs should produce the next output element.
		/// </param>
		/// <param name="data_input_datasets">
		///   <c>N</c> datasets with the same type that will be interleaved according to
		///   the values of <c>selector_input_dataset</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DirectedInterleaveDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output DirectedInterleaveDataset (TF_Output selector_input_dataset, TF_Output[] data_input_datasets, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DirectedInterleaveDataset", MakeName ("DirectedInterleaveDataset", operName));
			c_api.TF_AddInput(desc, selector_input_dataset);
			c_api.TF_AddInputList(desc, data_input_datasets[0], data_input_datasets.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Returns x / y element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Div'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   *NOTE*: <c>Div</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output Div (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Div", MakeName ("Div", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Returns 0 if the denominator is zero.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DivNoNan'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   
		///   *NOTE*: <c>DivNoNan</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output DivNoNan (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DivNoNan", MakeName ("DivNoNan", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Draw bounding boxes on a batch of images.
		/// </summary>
		/// <param name="images">
		///   4-D with shape <c>[batch, height, width, depth]</c>. A batch of images.
		/// </param>
		/// <param name="boxes">
		///   3-D with shape <c>[batch, num_bounding_boxes, 4]</c> containing bounding
		///   boxes.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DrawBoundingBoxes'.
		/// </param>
		/// <returns>
		///   4-D with the same shape as <c>images</c>. The batch of input images with
		///   bounding boxes drawn on the images.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Outputs a copy of <c>images</c> but draws on top of the pixels zero or more bounding
		///   boxes specified by the locations in <c>boxes</c>. The coordinates of the each
		///   bounding box in <c>boxes</c> are encoded as <c>[y_min, x_min, y_max, x_max]</c>. The
		///   bounding box coordinates are floats in <c>[0.0, 1.0]</c> relative to the width and
		///   height of the underlying image.
		///   
		///   For example, if an image is 100 x 200 pixels (height x width) and the bounding
		///   box is <c>[0.1, 0.2, 0.5, 0.9]</c>, the upper-left and bottom-right coordinates of
		///   the bounding box will be <c>(40, 10)</c> to <c>(180, 50)</c> (in (x,y) coordinates).
		///   
		///   Parts of the bounding box may fall outside the image.
		/// </remarks>
		public TF_Output DrawBoundingBoxes (TF_Output images, TF_Output boxes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DrawBoundingBoxes", MakeName ("DrawBoundingBoxes", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, boxes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Draw bounding boxes on a batch of images.
		/// </summary>
		/// <param name="images">
		///   4-D with shape <c>[batch, height, width, depth]</c>. A batch of images.
		/// </param>
		/// <param name="boxes">
		///   3-D with shape <c>[batch, num_bounding_boxes, 4]</c> containing bounding
		///   boxes.
		/// </param>
		/// <param name="colors">
		///   2-D. A list of RGBA colors to cycle through for the boxes.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DrawBoundingBoxesV2'.
		/// </param>
		/// <returns>
		///   4-D with the same shape as <c>images</c>. The batch of input images with
		///   bounding boxes drawn on the images.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Outputs a copy of <c>images</c> but draws on top of the pixels zero or more bounding
		///   boxes specified by the locations in <c>boxes</c>. The coordinates of the each
		///   bounding box in <c>boxes</c> are encoded as <c>[y_min, x_min, y_max, x_max]</c>. The
		///   bounding box coordinates are floats in <c>[0.0, 1.0]</c> relative to the width and
		///   height of the underlying image.
		///   
		///   For example, if an image is 100 x 200 pixels (height x width) and the bounding
		///   box is <c>[0.1, 0.2, 0.5, 0.9]</c>, the upper-left and bottom-right coordinates of
		///   the bounding box will be <c>(40, 10)</c> to <c>(100, 50)</c> (in (x,y) coordinates).
		///   
		///   Parts of the bounding box may fall outside the image.
		/// </remarks>
		public TF_Output DrawBoundingBoxesV2 (TF_Output images, TF_Output boxes, TF_Output colors, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DrawBoundingBoxesV2", MakeName ("DrawBoundingBoxesV2", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, boxes);
			c_api.TF_AddInput(desc, colors);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Partitions <c>data</c> into <c>num_partitions</c> tensors using indices from <c>partitions</c>.
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="partitions">
		///   Any shape.  Indices in the range <c>[0, num_partitions)</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DynamicPartition'.
		/// </param>
		/// <param name="num_partitions">
		///   The number of partitions to output.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   For each index tuple <c>js</c> of size <c>partitions.ndim</c>, the slice <c>data[js, ...]</c>
		///   becomes part of <c>outputs[partitions[js]]</c>.  The slices with <c>partitions[js] = i</c>
		///   are placed in <c>outputs[i]</c> in lexicographic order of <c>js</c>, and the first
		///   dimension of <c>outputs[i]</c> is the number of entries in <c>partitions</c> equal to <c>i</c>.
		///   In detail,
		///   
		///    <code>
		///   outputs[i].shape = [sum(partitions == i)] + data.shape[partitions.ndim:]
		///   
		///   outputs[i] = pack([data[js, ...] for js if partitions[js] == i])
		///    </code>
		///   
		///   <c>data.shape</c> must start with <c>partitions.shape</c>.
		///   
		///   For example:
		///   
		///    <code>
		///   # Scalar partitions.
		///   partitions = 1
		///   num_partitions = 2
		///   data = [10, 20]
		///   outputs[0] = []  # Empty with shape [0, 2]
		///   outputs[1] = [[10, 20]]
		///   
		///   # Vector partitions.
		///   partitions = [0, 0, 1, 1, 0]
		///   num_partitions = 2
		///   data = [10, 20, 30, 40, 50]
		///   outputs[0] = [10, 20, 50]
		///   outputs[1] = [30, 40]
		///    </code>
		///   
		///   See <c>dynamic_stitch</c> for an example on how to merge partitions back.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/DynamicPartition.png" alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		/// </remarks>
		public TF_Output[] DynamicPartition (TF_Output data, TF_Output partitions, long num_partitions, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DynamicPartition", MakeName ("DynamicPartition", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, partitions);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_partitions", num_partitions);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "outputs", status);
			var outputs = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				outputs [i] = new TF_Output (op, _idx++);
			
			return outputs;
		}

		/// <summary>
		///   Interleave the values from the <c>data</c> tensors into a single tensor.
		/// </summary>
		/// <param name="indices">
		/// </param>
		/// <param name="data">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'DynamicStitch'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Builds a merged tensor such that
		///   
		///    <code>
		///   merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]
		///    </code>
		///   
		///   For example, if each <c>indices[m]</c> is scalar or vector, we have
		///   
		///    <code>
		///   # Scalar indices:
		///   merged[indices[m], ...] = data[m][...]
		///   
		///   # Vector indices:
		///   merged[indices[m][i], ...] = data[m][i, ...]
		///    </code>
		///   
		///   Each <c>data[i].shape</c> must start with the corresponding <c>indices[i].shape</c>,
		///   and the rest of <c>data[i].shape</c> must be constant w.r.t. <c>i</c>.  That is, we
		///   must have <c>data[i].shape = indices[i].shape + constant</c>.  In terms of this
		///   <c>constant</c>, the output shape is
		///   
		///   merged.shape = [max(indices)] + constant
		///   
		///   Values are merged in order, so if an index appears in both <c>indices[m][i]</c> and
		///   <c>indices[n][j]</c> for <c>(m,i) &amp;lt; (n,j)</c> the slice <c>data[n][j]</c> will appear in the
		///   merged result. If you do not need this guarantee, ParallelDynamicStitch might
		///   perform better on some devices.
		///   
		///   For example:
		///   
		///    <code>
		///   indices[0] = 6
		///   indices[1] = [4, 1]
		///   indices[2] = [[5, 2], [0, 3]]
		///   data[0] = [61, 62]
		///   data[1] = [[41, 42], [11, 12]]
		///   data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]
		///   merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],
		///   [51, 52], [61, 62]]
		///    </code>
		///   
		///   This method can be used to merge partitions created by <c>dynamic_partition</c>
		///   as illustrated on the following example:
		///   
		///    <code>
		///   # Apply function (increments x_i) on elements for which a certain condition
		///   # apply (x_i != -1 in this example).
		///   x=tf.constant([0.1, -1., 5.2, 4.3, -1., 7.4])
		///   condition_mask=tf.not_equal(x,tf.constant(-1.))
		///   partitioned_data = tf.dynamic_partition(
		///   x, tf.cast(condition_mask, tf.int32) , 2)
		///   partitioned_data[1] = partitioned_data[1] + 1.0
		///   condition_indices = tf.dynamic_partition(
		///   tf.range(tf.shape(x)[0]), tf.cast(condition_mask, tf.int32) , 2)
		///   x = tf.dynamic_stitch(condition_indices, partitioned_data)
		///   # Here x=[1.1, -1., 6.2, 5.3, -1, 8.4], the -1. values remain
		///   # unchanged.
		///    </code>
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/DynamicStitch.png" alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		/// </remarks>
		public TF_Output DynamicStitch (TF_Output[] indices, TF_Output[] data, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "DynamicStitch", MakeName ("DynamicStitch", operName));
			c_api.TF_AddInputList(desc, indices[0], indices.Length);
			c_api.TF_AddInputList(desc, data[0], data.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var merged = new TF_Output (op, _idx++);
			return merged;
		}

		/// <summary>
		///   Eagerly executes a python function to compute func(input)-&amp;gt;output. The
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EagerPyFunc'.
		/// </param>
		/// <param name="token">
		/// </param>
		/// <param name="Tout">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   semantics of the input, output, and attributes are the same as those for
		///   PyFunc.
		/// </remarks>
		public TF_Output[] EagerPyFunc (TF_Output[] input, string token, TF_DataType[] Tout, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EagerPyFunc", MakeName ("EagerPyFunc", operName));
			c_api.TF_AddInputList(desc, input[0], input.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "token", token);
			c_api.TF_SetAttrTypeList (desc, "Tout", Tout);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		///   Computes the (possibly normalized) Levenshtein Edit Distance.
		/// </summary>
		/// <param name="hypothesis_indices">
		///   The indices of the hypothesis list SparseTensor.
		///   This is an N x R int64 matrix.
		/// </param>
		/// <param name="hypothesis_values">
		///   The values of the hypothesis list SparseTensor.
		///   This is an N-length vector.
		/// </param>
		/// <param name="hypothesis_shape">
		///   The shape of the hypothesis list SparseTensor.
		///   This is an R-length vector.
		/// </param>
		/// <param name="truth_indices">
		///   The indices of the truth list SparseTensor.
		///   This is an M x R int64 matrix.
		/// </param>
		/// <param name="truth_values">
		///   The values of the truth list SparseTensor.
		///   This is an M-length vector.
		/// </param>
		/// <param name="truth_shape">
		///   truth indices, vector.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EditDistance'.
		/// </param>
		/// <param name="normalize">
		///   Optional argument
		///   boolean (if true, edit distances are normalized by length of truth).
		///   
		///   The output is:
		/// </param>
		/// <returns>
		///   A dense float tensor with rank R - 1.
		///   
		///   For the example input:
		///   
		///   // hypothesis represents a 2x1 matrix with variable-length values:
		///   //   (0,0) = ["a"]
		///   //   (1,0) = ["b"]
		///   hypothesis_indices = [[0, 0, 0],
		///   [1, 0, 0]]
		///   hypothesis_values = ["a", "b"]
		///   hypothesis_shape = [2, 1, 1]
		///   
		///   // truth represents a 2x2 matrix with variable-length values:
		///   //   (0,0) = []
		///   //   (0,1) = ["a"]
		///   //   (1,0) = ["b", "c"]
		///   //   (1,1) = ["a"]
		///   truth_indices = [[0, 1, 0],
		///   [1, 0, 0],
		///   [1, 0, 1],
		///   [1, 1, 0]]
		///   truth_values = ["a", "b", "c", "a"]
		///   truth_shape = [2, 2, 2]
		///   normalize = true
		///   
		///   The output will be:
		///   
		///   // output is a 2x2 matrix with edit distances normalized by truth lengths.
		///   output = [[inf, 1.0],  // (0,0): no truth, (0,1): no hypothesis
		///   [0.5, 1.0]]  // (1,0): addition, (1,1): no hypothesis
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The inputs are variable-length sequences provided by SparseTensors
		///   (hypothesis_indices, hypothesis_values, hypothesis_shape)
		///   and
		///   (truth_indices, truth_values, truth_shape).
		///   
		///   The inputs are:
		/// </remarks>
		public TF_Output EditDistance (TF_Output hypothesis_indices, TF_Output hypothesis_values, TF_Output hypothesis_shape, TF_Output truth_indices, TF_Output truth_values, TF_Output truth_shape, bool? normalize = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EditDistance", MakeName ("EditDistance", operName));
			c_api.TF_AddInput(desc, hypothesis_indices);
			c_api.TF_AddInput(desc, hypothesis_values);
			c_api.TF_AddInput(desc, hypothesis_shape);
			c_api.TF_AddInput(desc, truth_indices);
			c_api.TF_AddInput(desc, truth_values);
			c_api.TF_AddInput(desc, truth_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (normalize.HasValue)
				c_api.TF_SetAttrBool (desc, "normalize", Convert.ToByte(normalize.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Tensor contraction according to Einstein summation convention.
		/// </summary>
		/// <param name="inputs">
		///   List of 1 or 2 Tensors.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Einsum'.
		/// </param>
		/// <param name="equation">
		///   String describing the Einstein Summation operation; in the format of np.einsum.
		/// </param>
		/// <returns>
		///   Output Tensor with shape depending upon <c>equation</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Implements generalized Tensor contraction and reduction. Each input Tensor must
		///   have a corresponding input subscript appearing in the comma-separated left-hand
		///   side of the equation. The right-hand side of the equation consists of the
		///   output subscript. The input subscripts and the output subscript should consist
		///   of zero or more named axis labels and at most one ellipsis (<c>...</c>).
		///   
		///   The named axis labels may be any single character other than those having
		///   special meaning, namely <c>,.-&amp;gt;</c>. The behavior of this Op is undefined if it
		///   receives an ill-formatted equation; since the validation is done at
		///   graph-building time, we omit format validation checks at runtime.
		///   
		///   Note: This Op is *not* intended to be called by the user; instead users should
		///   call <c>tf.einsum</c> directly. It is a hidden Op used by <c>tf.einsum</c>.
		///   
		///   Operations are applied to the input(s) according to the following rules:
		///   
		///   (a) Generalized Diagonals: For input dimensions corresponding to axis labels
		///   appearing more than once in the same input subscript, we take the
		///   generalized (<c>k</c>-dimensional) diagonal.
		///   For example, in the equation <c>iii-&amp;gt;i</c> with input shape <c>[3, 3, 3]</c>, the
		///   generalized diagonal would consist of <c>3</c> elements at indices <c>(0, 0, 0)</c>,
		///   <c>(1, 1, 1)</c> and <c>(2, 2, 2)</c> to create a Tensor of shape <c>[3]</c>.
		///   
		///   (b) Reduction: Axes corresponding to labels appearing only in one input
		///   subscript but not in the output subscript are summed over prior to Tensor
		///   contraction.
		///   For example, in the equation <c>ab,bc-&amp;gt;b</c>, the axis labels <c>a</c> and <c>c</c> are
		///   the reduction axis labels.
		///   
		///   (c) Batch Dimensions: Axes corresponding to labels appearing in each of the
		///   input subscripts and also in the output subscript make up the batch
		///   dimensions in Tensor contraction. Unnamed axis labels corresponding to
		///   ellipsis (<c>...</c>) also correspond to batch dimensions.
		///   For example, for the equation denoting batch matrix multiplication,
		///   <c>bij,bjk-&amp;gt;bik</c>, the axis label <c>b</c> corresponds to a batch dimension.
		///   
		///   (d) Contraction: In case of binary einsum, axes corresponding to labels
		///   appearing in two different inputs (and not in the output) are contracted
		///   against each other.
		///   Considering the batch matrix multiplication equation again
		///   (<c>bij,bjk-&amp;gt;bik</c>), the contracted axis label is <c>j</c>.
		///   
		///   (e) Expand Diagonal: If the output subcripts contain repeated (explicit) axis
		///   labels, the opposite operation of (a) is applied. For example, in the
		///   equation <c>i-&amp;gt;iii</c>, and input shape <c>[3]</c>, the output of shape <c>[3, 3, 3]</c>
		///   are all zeros, except for the (generalized) diagonal which is populated
		///   with values from the input.
		///   Note: This operation is not supported by <c>np.einsum</c> or <c>tf.einsum</c>; it is
		///   provided to enable computing the symbolic gradient of <c>tf.einsum</c>.
		///   
		///   The output subcripts must contain only labels appearing in at least one of the
		///   input subscripts. Furthermore, all dimensions mapping to the same axis label
		///   must be equal.
		///   
		///   Any of the input and output subscripts may contain at most a single ellipsis
		///   (<c>...</c>). These ellipsis are mapped against dimensions not corresponding to any
		///   named axis label. If two inputs contain ellipsis, then they are broadcasted
		///   according to standard NumPy broadcasting
		///   [rules](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html).
		///   
		///   The broadcasted dimensions are placed in the corresponding location of the
		///   ellipsis in the output subscript. If the broadcasted dimensions are non-empty
		///   and the output subcripts do not contain ellipsis, then an InvalidArgument error
		///   is raised.
		///   
		///   @compatibility(numpy)
		///   Similar to [<c>numpy.einsum</c>](https://docs.scipy.org/doc/numpy/reference/generated/numpy.einsum.html).
		///   
		///   Comparison with <c>numpy.einsum</c>:
		///   
		///   * This Op only supports unary and binary forms of <c>numpy.einsum</c>.
		///   * This Op does not support implicit form. (i.e. equations without <c>-&amp;gt;</c>).
		///   * This Op also supports repeated indices in the output subscript, which is not
		///   supported by <c>numpy.einsum</c>.
		///   @end_compatibility
		///   
		/// </remarks>
		public TF_Output Einsum (TF_Output[] inputs, string equation, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Einsum", MakeName ("Einsum", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "equation", equation);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes exponential linear: <c>exp(features) - 1</c> if &amp;lt; 0, <c>features</c> otherwise.
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Elu'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   See [Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)
		///   ](http://arxiv.org/abs/1511.07289)
		/// </remarks>
		public TF_Output Elu (TF_Output features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Elu", MakeName ("Elu", operName));
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var activations = new TF_Output (op, _idx++);
			return activations;
		}

		/// <summary>
		///   Computes gradients for the exponential linear (Elu) operation.
		/// </summary>
		/// <param name="gradients">
		///   The backpropagated gradients to the corresponding Elu operation.
		/// </param>
		/// <param name="outputs">
		///   The outputs of the corresponding Elu operation.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EluGrad'.
		/// </param>
		/// <returns>
		///   The gradients: <c>gradients * (outputs + 1)</c> if outputs &amp;lt; 0,
		///   <c>gradients</c> otherwise.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output EluGrad (TF_Output gradients, TF_Output outputs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EluGrad", MakeName ("EluGrad", operName));
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, outputs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var backprops = new TF_Output (op, _idx++);
			return backprops;
		}

		/// <summary>
		///   Creates a tensor with the given shape.
		///   
		///   This operation creates a tensor of <c>shape</c> and <c>dtype</c>.
		/// </summary>
		/// <param name="shape">
		///   1-D. Represents the shape of the output tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Empty'.
		/// </param>
		/// <param name="init">
		///   Optional argument
		///   If True, initialize the returned tensor with the default value of dtype.  Otherwise, the implementation is free not to initializethe tensor's content.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   A <c>Tensor</c> of type <c>T</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Empty (TF_Output shape, TF_DataType dtype, bool? init = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Empty", MakeName ("Empty", operName));
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (init.HasValue)
				c_api.TF_SetAttrBool (desc, "init", Convert.ToByte(init.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates and returns an empty tensor list.
		/// </summary>
		/// <param name="element_shape">
		/// </param>
		/// <param name="max_num_elements">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EmptyTensorList'.
		/// </param>
		/// <param name="element_dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   All list elements must be tensors of dtype element_dtype and shape compatible
		///   with element_shape.
		///   
		///   handle: an empty tensor list.
		///   element_dtype: the type of elements in the list.
		///   element_shape: a shape compatible with that of elements in the list.
		/// </remarks>
		public TF_Output EmptyTensorList (TF_Output element_shape, TF_Output max_num_elements, TF_DataType element_dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EmptyTensorList", MakeName ("EmptyTensorList", operName));
			c_api.TF_AddInput(desc, element_shape);
			c_api.TF_AddInput(desc, max_num_elements);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "element_dtype", element_dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Encode strings into web-safe base64 format.
		/// </summary>
		/// <param name="input">
		///   Strings to be encoded.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodeBase64'.
		/// </param>
		/// <param name="pad">
		///   Optional argument
		///   Bool whether padding is applied at the ends.
		/// </param>
		/// <returns>
		///   Input strings encoded in base64.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Refer to the following article for more information on base64 format:
		///   en.wikipedia.org/wiki/Base64. Base64 strings may have padding with '=' at the
		///   end so that the encoded has length multiple of 4. See Padding section of the
		///   link above.
		///   
		///   Web-safe means that the encoder uses - and _ instead of + and /.
		/// </remarks>
		public TF_Output EncodeBase64 (TF_Output input, bool? pad = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EncodeBase64", MakeName ("EncodeBase64", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (pad.HasValue)
				c_api.TF_SetAttrBool (desc, "pad", Convert.ToByte(pad.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   JPEG-encode an image.
		/// </summary>
		/// <param name="image">
		///   3-D with shape <c>[height, width, channels]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodeJpeg'.
		/// </param>
		/// <param name="format">
		///   Optional argument
		///   Per pixel image format.
		/// </param>
		/// <param name="quality">
		///   Optional argument
		///   Quality of the compression from 0 to 100 (higher is better and slower).
		/// </param>
		/// <param name="progressive">
		///   Optional argument
		///   If True, create a JPEG that loads progressively (coarse to fine).
		/// </param>
		/// <param name="optimize_size">
		///   Optional argument
		///   If True, spend CPU/RAM to reduce size with no quality change.
		/// </param>
		/// <param name="chroma_downsampling">
		///   Optional argument
		///   See http://en.wikipedia.org/wiki/Chroma_subsampling.
		/// </param>
		/// <param name="density_unit">
		///   Optional argument
		///   Unit used to specify <c>x_density</c> and <c>y_density</c>:
		///   pixels per inch (<c>'in'</c>) or centimeter (<c>'cm'</c>).
		/// </param>
		/// <param name="x_density">
		///   Optional argument
		///   Horizontal pixels per density unit.
		/// </param>
		/// <param name="y_density">
		///   Optional argument
		///   Vertical pixels per density unit.
		/// </param>
		/// <param name="xmp_metadata">
		///   Optional argument
		///   If not empty, embed this XMP metadata in the image header.
		/// </param>
		/// <returns>
		///   0-D. JPEG-encoded image.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   <c>image</c> is a 3-D uint8 Tensor of shape <c>[height, width, channels]</c>.
		///   
		///   The attr <c>format</c> can be used to override the color format of the encoded
		///   output.  Values can be:
		///   
		///   *   <c>''</c>: Use a default format based on the number of channels in the image.
		///   *   <c>grayscale</c>: Output a grayscale JPEG image.  The <c>channels</c> dimension
		///   of <c>image</c> must be 1.
		///   *   <c>rgb</c>: Output an RGB JPEG image. The <c>channels</c> dimension
		///   of <c>image</c> must be 3.
		///   
		///   If <c>format</c> is not specified or is the empty string, a default format is picked
		///   in function of the number of channels in <c>image</c>:
		///   
		///   *   1: Output a grayscale image.
		///   *   3: Output an RGB image.
		/// </remarks>
		public TF_Output EncodeJpeg (TF_Output image, string format = null, long? quality = null, bool? progressive = null, bool? optimize_size = null, bool? chroma_downsampling = null, string density_unit = null, long? x_density = null, long? y_density = null, string xmp_metadata = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EncodeJpeg", MakeName ("EncodeJpeg", operName));
			c_api.TF_AddInput(desc, image);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (format != null)
				c_api.TF_SetAttrString (desc, "format", format);
			
			if (quality.HasValue)
				c_api.TF_SetAttrInt (desc, "quality", quality.Value);
			
			if (progressive.HasValue)
				c_api.TF_SetAttrBool (desc, "progressive", Convert.ToByte(progressive.Value));
			
			if (optimize_size.HasValue)
				c_api.TF_SetAttrBool (desc, "optimize_size", Convert.ToByte(optimize_size.Value));
			
			if (chroma_downsampling.HasValue)
				c_api.TF_SetAttrBool (desc, "chroma_downsampling", Convert.ToByte(chroma_downsampling.Value));
			
			if (density_unit != null)
				c_api.TF_SetAttrString (desc, "density_unit", density_unit);
			
			if (x_density.HasValue)
				c_api.TF_SetAttrInt (desc, "x_density", x_density.Value);
			
			if (y_density.HasValue)
				c_api.TF_SetAttrInt (desc, "y_density", y_density.Value);
			
			if (xmp_metadata != null)
				c_api.TF_SetAttrString (desc, "xmp_metadata", xmp_metadata);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var contents = new TF_Output (op, _idx++);
			return contents;
		}

		/// <summary>
		///   JPEG encode input image with provided compression quality.
		/// </summary>
		/// <param name="images">
		///   Images to adjust.  At least 3-D.
		/// </param>
		/// <param name="quality">
		///   An int quality to encode to.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodeJpegVariableQuality'.
		/// </param>
		/// <returns>
		///   0-D. JPEG-encoded image.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   <c>image</c> is a 3-D uint8 Tensor of shape <c>[height, width, channels]</c>.
		///   <c>quality</c> is an int32 jpeg compression quality value between 0 and 100.
		///   
		/// </remarks>
		public TF_Output EncodeJpegVariableQuality (TF_Output images, TF_Output quality, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EncodeJpegVariableQuality", MakeName ("EncodeJpegVariableQuality", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, quality);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var contents = new TF_Output (op, _idx++);
			return contents;
		}

		/// <summary>
		///   PNG-encode an image.
		/// </summary>
		/// <param name="image">
		///   3-D with shape <c>[height, width, channels]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodePng'.
		/// </param>
		/// <param name="compression">
		///   Optional argument
		///   Compression level.
		/// </param>
		/// <returns>
		///   0-D. PNG-encoded image.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   <c>image</c> is a 3-D uint8 or uint16 Tensor of shape <c>[height, width, channels]</c>
		///   where <c>channels</c> is:
		///   
		///   *   1: for grayscale.
		///   *   2: for grayscale + alpha.
		///   *   3: for RGB.
		///   *   4: for RGBA.
		///   
		///   The ZLIB compression level, <c>compression</c>, can be -1 for the PNG-encoder
		///   default or a value from 0 to 9.  9 is the highest compression level, generating
		///   the smallest output, but is slower.
		/// </remarks>
		public TF_Output EncodePng (TF_Output image, long? compression = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EncodePng", MakeName ("EncodePng", operName));
			c_api.TF_AddInput(desc, image);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (compression.HasValue)
				c_api.TF_SetAttrInt (desc, "compression", compression.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var contents = new TF_Output (op, _idx++);
			return contents;
		}

		/// <summary>
		///   The op serializes protobuf messages provided in the input tensors.
		/// </summary>
		/// <param name="sizes">
		///   Tensor of int32 with shape <c>[batch_shape, len(field_names)]</c>.
		/// </param>
		/// <param name="values">
		///   List of tensors containing values for the corresponding field.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodeProto'.
		/// </param>
		/// <param name="descriptor_source">
		///   Optional argument
		/// </param>
		/// <param name="field_names">
		///   List of strings containing proto field names.
		/// </param>
		/// <param name="message_type">
		///   Name of the proto message type to decode.
		/// </param>
		/// <returns>
		///   Tensor of serialized protos with shape <c>batch_shape</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The types of the tensors in <c>values</c> must match the schema for the fields
		///   specified in <c>field_names</c>. All the tensors in <c>values</c> must have a common
		///   shape prefix, *batch_shape*.
		///   
		///   The <c>sizes</c> tensor specifies repeat counts for each field.  The repeat count
		///   (last dimension) of a each tensor in <c>values</c> must be greater than or equal
		///   to corresponding repeat count in <c>sizes</c>.
		///   
		///   A <c>message_type</c> name must be provided to give context for the field names.
		///   The actual message descriptor can be looked up either in the linked-in
		///   descriptor pool or a filename provided by the caller using the
		///   <c>descriptor_source</c> attribute.
		///   
		///   For the most part, the mapping between Proto field types and TensorFlow dtypes
		///   is straightforward. However, there are a few special cases:
		///   
		///   - A proto field that contains a submessage or group can only be converted
		///   to <c>DT_STRING</c> (the serialized submessage). This is to reduce the complexity
		///   of the API. The resulting string can be used as input to another instance of
		///   the decode_proto op.
		///   
		///   - TensorFlow lacks support for unsigned integers. The ops represent uint64
		///   types as a <c>DT_INT64</c> with the same twos-complement bit pattern (the obvious
		///   way). Unsigned int32 values can be represented exactly by specifying type
		///   <c>DT_INT64</c>, or using twos-complement if the caller specifies <c>DT_INT32</c> in
		///   the <c>output_types</c> attribute.
		///   
		///   The <c>descriptor_source</c> attribute selects the source of protocol
		///   descriptors to consult when looking up <c>message_type</c>. This may be:
		///   
		///   - An empty string  or "local://", in which case protocol descriptors are
		///   created for C++ (not Python) proto definitions linked to the binary.
		///   
		///   - A file, in which case protocol descriptors are created from the file,
		///   which is expected to contain a <c>FileDescriptorSet</c> serialized as a string.
		///   NOTE: You can build a <c>descriptor_source</c> file using the <c>--descriptor_set_out</c>
		///   and <c>--include_imports</c> options to the protocol compiler <c>protoc</c>.
		///   
		///   - A "bytes://&amp;lt;bytes&amp;gt;", in which protocol descriptors are created from <c>&amp;lt;bytes&amp;gt;</c>,
		///   which is expected to be a <c>FileDescriptorSet</c> serialized as a string.
		/// </remarks>
		public TF_Output EncodeProto (TF_Output sizes, TF_Output[] values, string[] field_names, string message_type, string descriptor_source = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EncodeProto", MakeName ("EncodeProto", operName));
			c_api.TF_AddInput(desc, sizes);
			c_api.TF_AddInputList(desc, values[0], values.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrStringList (desc, "field_names", field_names);
			c_api.TF_SetAttrString (desc, "message_type", message_type);
			if (descriptor_source != null)
				c_api.TF_SetAttrString (desc, "descriptor_source", descriptor_source);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var bytes = new TF_Output (op, _idx++);
			return bytes;
		}

		/// <summary>
		///   Encode audio data using the WAV file format.
		/// </summary>
		/// <param name="audio">
		///   2-D with shape <c>[length, channels]</c>.
		/// </param>
		/// <param name="sample_rate">
		///   Scalar containing the sample frequency.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodeWav'.
		/// </param>
		/// <returns>
		///   0-D. WAV-encoded file contents.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation will generate a string suitable to be saved out to create a .wav
		///   audio file. It will be encoded in the 16-bit PCM format. It takes in float
		///   values in the range -1.0f to 1.0f, and any outside that value will be clamped to
		///   that range.
		///   
		///   <c>audio</c> is a 2-D float Tensor of shape <c>[length, channels]</c>.
		///   <c>sample_rate</c> is a scalar Tensor holding the rate to use (e.g. 44100).
		/// </remarks>
		public TF_Output EncodeWav (TF_Output audio, TF_Output sample_rate, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EncodeWav", MakeName ("EncodeWav", operName));
			c_api.TF_AddInput(desc, audio);
			c_api.TF_AddInput(desc, sample_rate);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var contents = new TF_Output (op, _idx++);
			return contents;
		}

		/// <summary>
		///   An op that enqueues a list of input batch tensors to TPUEmbedding.
		/// </summary>
		/// <param name="batch">
		///   A list of 1D tensors, one for each embedding table, containing the
		///   indices into the tables.
		/// </param>
		/// <param name="mode_override">
		///   A string input that overrides the mode specified in the
		///   TPUEmbeddingConfiguration. Supported values are {'unspecified', 'inference',
		///   'training', 'backward_pass_only'}. When set to 'unspecified', the mode set
		///   in TPUEmbeddingConfiguration is used, otherwise mode_override is used.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EnqueueTPUEmbeddingIntegerBatch'.
		/// </param>
		/// <param name="device_ordinal">
		///   Optional argument
		///   The TPU device to use. Should be &amp;gt;= 0 and less than the number
		///   of TPU cores in the task on which the node is placed.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation EnqueueTPUEmbeddingIntegerBatch (TF_Output[] batch, TF_Output mode_override, long? device_ordinal = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EnqueueTPUEmbeddingIntegerBatch", MakeName ("EnqueueTPUEmbeddingIntegerBatch", operName));
			c_api.TF_AddInputList(desc, batch[0], batch.Length);
			c_api.TF_AddInput(desc, mode_override);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (device_ordinal.HasValue)
				c_api.TF_SetAttrInt (desc, "device_ordinal", device_ordinal.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   An op that enqueues TPUEmbedding input indices from a SparseTensor.
		/// </summary>
		/// <param name="sample_indices">
		///   A list of rank 1 Tensors specifying the training example and
		///   feature to which the corresponding embedding_indices and aggregation_weights
		///   values belong. sample_indices[i] must equal b * nf + f, where nf is the
		///   number of features from the corresponding table, f is in [0, nf), and
		///   b is in [0, batch size).
		/// </param>
		/// <param name="embedding_indices">
		///   A list of rank 1 Tensors, indices into the embedding tables.
		/// </param>
		/// <param name="aggregation_weights">
		///   A list of rank 1 Tensors containing per sample -- i.e. per
		///   (training example, feature) -- aggregation weights.
		/// </param>
		/// <param name="mode_override">
		///   A string input that overrides the mode specified in the
		///   TPUEmbeddingConfiguration. Supported values are {'unspecified', 'inference',
		///   'training', 'backward_pass_only'}. When set to 'unspecified', the mode set
		///   in TPUEmbeddingConfiguration is used, otherwise mode_override is used.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EnqueueTPUEmbeddingSparseBatch'.
		/// </param>
		/// <param name="device_ordinal">
		///   Optional argument
		///   The TPU device to use. Should be &amp;gt;= 0 and less than the number
		///   of TPU cores in the task on which the node is placed.
		/// </param>
		/// <param name="combiners">
		///   Optional argument
		///   A list of string scalars, one for each embedding table that specify
		///   how to normalize the embedding activations after weighted summation.
		///   Supported combiners are 'mean', 'sum', or 'sqrtn'. It is invalid to have
		///   the sum of the weights be 0 for 'mean' or the sum of the squared weights be
		///   0 for 'sqrtn'. If combiners isn't passed, the default is to use 'sum' for
		///   all tables.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   This Op eases the porting of code that uses embedding_lookup_sparse(),
		///   although some Python preprocessing of the SparseTensor arguments to
		///   embedding_lookup_sparse() is required to produce the arguments to this Op,
		///   since only a single EnqueueTPUEmbeddingSparseBatch Op is allowed per training
		///   step.
		///   
		///   The tensors at corresponding positions in the three input lists
		///   must have the same shape, i.e. rank 1 with dim_size() equal to the total
		///   number of lookups into the table described by the corresponding table_id.
		/// </remarks>
		public TF_Operation EnqueueTPUEmbeddingSparseBatch (TF_Output[] sample_indices, TF_Output[] embedding_indices, TF_Output[] aggregation_weights, TF_Output mode_override, long? device_ordinal = null, string[] combiners = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EnqueueTPUEmbeddingSparseBatch", MakeName ("EnqueueTPUEmbeddingSparseBatch", operName));
			c_api.TF_AddInputList(desc, sample_indices[0], sample_indices.Length);
			c_api.TF_AddInputList(desc, embedding_indices[0], embedding_indices.Length);
			c_api.TF_AddInputList(desc, aggregation_weights[0], aggregation_weights.Length);
			c_api.TF_AddInput(desc, mode_override);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (device_ordinal.HasValue)
				c_api.TF_SetAttrInt (desc, "device_ordinal", device_ordinal.Value);
			
			if (combiners != null)
				c_api.TF_SetAttrStringList (desc, "combiners", combiners);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Eases the porting of code that uses tf.nn.embedding_lookup_sparse().
		/// </summary>
		/// <param name="sample_indices">
		///   A list of rank 1 Tensors specifying the training example to
		///   which the corresponding embedding_indices and aggregation_weights values
		///   belong. It corresponds to sp_ids.indices[:,0] in  embedding_lookup_sparse().
		/// </param>
		/// <param name="embedding_indices">
		///   A list of rank 1 Tensors, indices into the embedding tables.
		///   It corresponds to sp_ids.values in embedding_lookup_sparse().
		/// </param>
		/// <param name="aggregation_weights">
		///   A list of rank 1 Tensors containing per training example
		///   aggregation weights. It corresponds to sp_weights.values in
		///   embedding_lookup_sparse().
		/// </param>
		/// <param name="mode_override">
		///   A string input that overrides the mode specified in the
		///   TPUEmbeddingConfiguration. Supported values are {'unspecified', 'inference',
		///   'training', 'backward_pass_only'}. When set to 'unspecified', the mode set
		///   in TPUEmbeddingConfiguration is used, otherwise mode_override is used.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EnqueueTPUEmbeddingSparseTensorBatch'.
		/// </param>
		/// <param name="device_ordinal">
		///   Optional argument
		///   The TPU device to use. Should be &amp;gt;= 0 and less than the number
		///   of TPU cores in the task on which the node is placed.
		/// </param>
		/// <param name="combiners">
		///   Optional argument
		///   A list of string scalars, one for each embedding table that specify
		///   how to normalize the embedding activations after weighted summation.
		///   Supported combiners are 'mean', 'sum', or 'sqrtn'. It is invalid to have
		///   the sum of the weights be 0 for 'mean' or the sum of the squared weights be
		///   0 for 'sqrtn'. If combiners isn't passed, the default is to use 'sum' for
		///   all tables.
		/// </param>
		/// <param name="max_sequence_lengths">
		///   Optional argument
		/// </param>
		/// <param name="table_ids">
		///   A list of integers specifying the identifier of the embedding table
		///   (offset of TableDescriptor in the TPUEmbeddingConfiguration) to lookup the
		///   corresponding input. The ith input is looked up using table_ids[i]. The size
		///   of the table_ids list must be equal to that of sample_indices,
		///   embedding_indices and aggregation_weights.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   sample_indices[i], embedding_indices[i] and aggregation_weights[i] correspond
		///   to the ith feature. table_ids[i] indicates which embedding table to look up ith
		///   feature.
		///   
		///   The tensors at corresponding positions in the three input lists (sample_indices,
		///   embedding_indices and aggregation_weights) must have the same shape, i.e. rank 1
		///   with dim_size() equal to the total number of lookups into the table described by
		///   the corresponding feature.
		/// </remarks>
		public TF_Operation EnqueueTPUEmbeddingSparseTensorBatch (TF_Output[] sample_indices, TF_Output[] embedding_indices, TF_Output[] aggregation_weights, TF_Output mode_override, long[] table_ids, long? device_ordinal = null, string[] combiners = null, long[] max_sequence_lengths = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EnqueueTPUEmbeddingSparseTensorBatch", MakeName ("EnqueueTPUEmbeddingSparseTensorBatch", operName));
			c_api.TF_AddInputList(desc, sample_indices[0], sample_indices.Length);
			c_api.TF_AddInputList(desc, embedding_indices[0], embedding_indices.Length);
			c_api.TF_AddInputList(desc, aggregation_weights[0], aggregation_weights.Length);
			c_api.TF_AddInput(desc, mode_override);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "table_ids", ref table_ids[0], table_ids.Length);
			if (device_ordinal.HasValue)
				c_api.TF_SetAttrInt (desc, "device_ordinal", device_ordinal.Value);
			
			if (combiners != null)
				c_api.TF_SetAttrStringList (desc, "combiners", combiners);
			
			if (max_sequence_lengths != null)
				c_api.TF_SetAttrIntList (desc, "max_sequence_lengths", ref max_sequence_lengths[0], max_sequence_lengths.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Ensures that the tensor's shape matches the expected shape.
		/// </summary>
		/// <param name="input">
		///   A tensor, whose shape is to be validated.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EnsureShape'.
		/// </param>
		/// <param name="shape">
		///   The expected (possibly partially specified) shape of the input tensor.
		/// </param>
		/// <returns>
		///   A tensor with the same shape and contents as the input tensor or value.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Raises an error if the input tensor's shape does not match the specified shape.
		///   Returns the input tensor otherwise.
		/// </remarks>
		public TF_Output EnsureShape (TF_Output input, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EnsureShape", MakeName ("EnsureShape", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates or finds a child frame, and makes <c>data</c> available to the child frame.
		/// </summary>
		/// <param name="data">
		///   The tensor to be made available to the child frame.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Enter'.
		/// </param>
		/// <param name="is_constant">
		///   Optional argument
		///   If true, the output is constant within the child frame.
		/// </param>
		/// <param name="parallel_iterations">
		///   Optional argument
		///   The number of iterations allowed to run in parallel.
		/// </param>
		/// <param name="frame_name">
		///   The name of the child frame.
		/// </param>
		/// <returns>
		///   The same tensor as <c>data</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op is used together with <c>Exit</c> to create loops in the graph.
		///   The unique <c>frame_name</c> is used by the <c>Executor</c> to identify frames. If
		///   <c>is_constant</c> is true, <c>output</c> is a constant in the child frame; otherwise
		///   it may be changed in the child frame. At most <c>parallel_iterations</c> iterations
		///   are run in parallel in the child frame.
		/// </remarks>
		public TF_Output Enter (TF_Output data, string frame_name, bool? is_constant = null, long? parallel_iterations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Enter", MakeName ("Enter", operName));
			c_api.TF_AddInput(desc, data);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "frame_name", frame_name);
			if (is_constant.HasValue)
				c_api.TF_SetAttrBool (desc, "is_constant", Convert.ToByte(is_constant.Value));
			
			if (parallel_iterations.HasValue)
				c_api.TF_SetAttrInt (desc, "parallel_iterations", parallel_iterations.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns the truth value of (x == y) element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Equal'.
		/// </param>
		/// <param name="incompatible_shape_error">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   *NOTE*: <c>Equal</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		///   
		///    <code>
		///   x = tf.constant([2, 4])
		///   y = tf.constant(2)
		///   tf.math.equal(x, y) ==&amp;gt; array([True, False])
		///   
		///   x = tf.constant([2, 4])
		///   y = tf.constant([2, 4])
		///   tf.math.equal(x, y) ==&amp;gt; array([True,  True])
		///    </code>
		/// </remarks>
		public TF_Output Equal (TF_Output x, TF_Output y, bool? incompatible_shape_error = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Equal", MakeName ("Equal", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (incompatible_shape_error.HasValue)
				c_api.TF_SetAttrBool (desc, "incompatible_shape_error", Convert.ToByte(incompatible_shape_error.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Computes the Gauss error function of <c>x</c> element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Erf'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Erf (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Erf", MakeName ("Erf", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes the complementary error function of <c>x</c> element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Erfc'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Erfc (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Erfc", MakeName ("Erfc", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes the euclidean norm of elements across dimensions of a tensor.
		/// </summary>
		/// <param name="input">
		///   The tensor to reduce.
		/// </param>
		/// <param name="reduction_indices">
		///   The dimensions to reduce. Must be in the range
		///   <c>[-rank(input), rank(input))</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'EuclideanNorm'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		///   If true, retain reduced dimensions with length 1.
		/// </param>
		/// <returns>
		///   The reduced tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Reduces <c>input</c> along the dimensions given in <c>axis</c>. Unless
		///   <c>keep_dims</c> is true, the rank of the tensor is reduced by 1 for each entry in
		///   <c>axis</c>. If <c>keep_dims</c> is true, the reduced dimensions are
		///   retained with length 1.
		/// </remarks>
		public TF_Output EuclideanNorm (TF_Output input, TF_Output reduction_indices, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "EuclideanNorm", MakeName ("EuclideanNorm", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, reduction_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Exits the current frame to its parent frame.
		/// </summary>
		/// <param name="data">
		///   The tensor to be made available to the parent frame.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Exit'.
		/// </param>
		/// <returns>
		///   The same tensor as <c>data</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Exit makes its input <c>data</c> available to the parent frame.
		/// </remarks>
		public TF_Output Exit (TF_Output data, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Exit", MakeName ("Exit", operName));
			c_api.TF_AddInput(desc, data);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes exponential of x element-wise.  \\(y = e^x\\).
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Exp'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This function computes the exponential of every element in the input tensor.
		///   i.e. <c>exp(x)</c> or <c>e^(x)</c>, where <c>x</c> is the input tensor.
		///   <c>e</c> denotes Euler's number and is approximately equal to 2.718281.
		///   Output is positive for any real input.
		///   
		///    <code>
		///   x = tf.constant(2.0)
		///   tf.math.exp(x) ==&amp;gt; 7.389056
		///   
		///   x = tf.constant([2.0, 8.0])
		///   tf.math.exp(x) ==&amp;gt; array([7.389056, 2980.958], dtype=float32)
		///    </code>
		///   
		///   For complex numbers, the exponential value is calculated as follows:
		///   
		///    <code>
		///   e^(x+iy) = e^x * e^iy = e^x * (cos y + i sin y)
		///    </code>
		///   
		///   Let's consider complex number 1+1j as an example.
		///   e^1 * (cos 1 + i sin 1) = 2.7182818284590 * (0.54030230586+0.8414709848j)
		///   
		///    <code>
		///   x = tf.constant(1 + 1j)
		///   tf.math.exp(x) ==&amp;gt; 1.4686939399158851+2.2873552871788423j
		///    </code>
		/// </remarks>
		public TF_Output Exp (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Exp", MakeName ("Exp", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Inserts a dimension of 1 into a tensor's shape.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="dim">
		///   0-D (scalar). Specifies the dimension index at which to
		///   expand the shape of <c>input</c>. Must be in the range
		///   <c>[-rank(input) - 1, rank(input)]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExpandDims'.
		/// </param>
		/// <returns>
		///   Contains the same data as <c>input</c>, but its shape has an additional
		///   dimension of size 1 added.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given a tensor <c>input</c>, this operation inserts a dimension of 1 at the
		///   dimension index <c>axis</c> of <c>input</c>'s shape. The dimension index <c>axis</c> starts at
		///   zero; if you specify a negative number for <c>axis</c> it is counted backward from
		///   the end.
		///   
		///   This operation is useful if you want to add a batch dimension to a single
		///   element. For example, if you have a single image of shape <c>[height, width,
		///   channels]</c>, you can make it a batch of 1 image with <c>expand_dims(image, 0)</c>,
		///   which will make the shape <c>[1, height, width, channels]</c>.
		///   
		///   Other examples:
		///   
		///    <code>
		///   # 't' is a tensor of shape [2]
		///   shape(expand_dims(t, 0)) ==&amp;gt; [1, 2]
		///   shape(expand_dims(t, 1)) ==&amp;gt; [2, 1]
		///   shape(expand_dims(t, -1)) ==&amp;gt; [2, 1]
		///   
		///   # 't2' is a tensor of shape [2, 3, 5]
		///   shape(expand_dims(t2, 0)) ==&amp;gt; [1, 2, 3, 5]
		///   shape(expand_dims(t2, 2)) ==&amp;gt; [2, 3, 1, 5]
		///   shape(expand_dims(t2, 3)) ==&amp;gt; [2, 3, 5, 1]
		///    </code>
		///   
		///   This operation requires that:
		///   
		///   <c>-1-input.dims() &amp;lt;= dim &amp;lt;= input.dims()</c>
		///   
		///   This operation is related to <c>squeeze()</c>, which removes dimensions of
		///   size 1.
		/// </remarks>
		public TF_Output ExpandDims (TF_Output input, TF_Output dim, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExpandDims", MakeName ("ExpandDims", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, dim);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="transformations">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalAssertNextDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalAssertNextDataset (TF_Output input_dataset, TF_Output transformations, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalAssertNextDataset", MakeName ("ExperimentalAssertNextDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, transformations);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that shards the input dataset.
		/// </summary>
		/// <param name="input_dataset">
		///   A variant tensor representing the input dataset.
		/// </param>
		/// <param name="num_workers">
		///   A scalar representing the number of workers to distribute this dataset across.
		/// </param>
		/// <param name="index">
		///   A scalar representing the index of the current worker out of num_workers.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalAutoShardDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Creates a dataset that shards the input dataset by num_workers, returning a
		///   sharded dataset for the index-th worker. This attempts to automatically shard
		///   a dataset by examining the Dataset graph and inserting a shard op before the
		///   inputs to a reader Dataset (e.g. CSVDataset, TFRecordDataset).
		///   
		///   This dataset will throw a NotFound error if we cannot shard the dataset
		///   automatically.
		/// </remarks>
		public TF_Output ExperimentalAutoShardDataset (TF_Output input_dataset, TF_Output num_workers, TF_Output index, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalAutoShardDataset", MakeName ("ExperimentalAutoShardDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, num_workers);
			c_api.TF_AddInput(desc, index);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Records the bytes size of each element of <c>input_dataset</c> in a StatsAggregator.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalBytesProducedStatsDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalBytesProducedStatsDataset (TF_Output input_dataset, TF_Output tag, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalBytesProducedStatsDataset", MakeName ("ExperimentalBytesProducedStatsDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, tag);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_datasets">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalChooseFastestDataset'.
		/// </param>
		/// <param name="num_experiments">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalChooseFastestDataset (TF_Output[] input_datasets, long num_experiments, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalChooseFastestDataset", MakeName ("ExperimentalChooseFastestDataset", operName));
			c_api.TF_AddInputList(desc, input_datasets[0], input_datasets.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_experiments", num_experiments);
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="filenames">
		/// </param>
		/// <param name="compression_type">
		/// </param>
		/// <param name="buffer_size">
		/// </param>
		/// <param name="header">
		/// </param>
		/// <param name="field_delim">
		/// </param>
		/// <param name="use_quote_delim">
		/// </param>
		/// <param name="na_value">
		/// </param>
		/// <param name="select_cols">
		/// </param>
		/// <param name="record_defaults">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalCSVDataset'.
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalCSVDataset (TF_Output filenames, TF_Output compression_type, TF_Output buffer_size, TF_Output header, TF_Output field_delim, TF_Output use_quote_delim, TF_Output na_value, TF_Output select_cols, TF_Output[] record_defaults, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalCSVDataset", MakeName ("ExperimentalCSVDataset", operName));
			c_api.TF_AddInput(desc, filenames);
			c_api.TF_AddInput(desc, compression_type);
			c_api.TF_AddInput(desc, buffer_size);
			c_api.TF_AddInput(desc, header);
			c_api.TF_AddInput(desc, field_delim);
			c_api.TF_AddInput(desc, use_quote_delim);
			c_api.TF_AddInput(desc, na_value);
			c_api.TF_AddInput(desc, select_cols);
			c_api.TF_AddInputList(desc, record_defaults[0], record_defaults.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Returns the cardinality of <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		///   A variant tensor representing the dataset to return cardinality for.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalDatasetCardinality'.
		/// </param>
		/// <returns>
		///   The cardinality of <c>input_dataset</c>. Named constants are used to represent
		///   infinite and unknown cardinality.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Returns the cardinality of <c>input_dataset</c>.
		/// </remarks>
		public TF_Output ExperimentalDatasetCardinality (TF_Output input_dataset, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalDatasetCardinality", MakeName ("ExperimentalDatasetCardinality", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var cardinality = new TF_Output (op, _idx++);
			return cardinality;
		}

		/// <summary>
		///   Writes the given dataset to the given file using the TFRecord format.
		/// </summary>
		/// <param name="input_dataset">
		///   A variant tensor representing the dataset to write.
		/// </param>
		/// <param name="filename">
		///   A scalar string tensor representing the filename to use.
		/// </param>
		/// <param name="compression_type">
		///   A scalar string tensor containing either (i) the empty string (no
		///   compression), (ii) "ZLIB", or (iii) "GZIP".
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalDatasetToTFRecord'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ExperimentalDatasetToTFRecord (TF_Output input_dataset, TF_Output filename, TF_Output compression_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalDatasetToTFRecord", MakeName ("ExperimentalDatasetToTFRecord", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, filename);
			c_api.TF_AddInput(desc, compression_type);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Creates a dataset that batches input elements into a SparseTensor.
		/// </summary>
		/// <param name="input_dataset">
		///   A handle to an input dataset. Must have a single component.
		/// </param>
		/// <param name="batch_size">
		///   A scalar representing the number of elements to accumulate in a
		///   batch.
		/// </param>
		/// <param name="row_shape">
		///   A vector representing the dense shape of each row in the produced
		///   SparseTensor. The shape may be partially specified, using <c>-1</c> to indicate
		///   that a particular dimension should use the maximum size of all batch elements.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalDenseToSparseBatchDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalDenseToSparseBatchDataset (TF_Output input_dataset, TF_Output batch_size, TF_Output row_shape, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalDenseToSparseBatchDataset", MakeName ("ExperimentalDenseToSparseBatchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, batch_size);
			c_api.TF_AddInput(desc, row_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   A substitute for <c>InterleaveDataset</c> on a fixed list of <c>N</c> datasets.
		/// </summary>
		/// <param name="selector_input_dataset">
		///   A dataset of scalar <c>DT_INT64</c> elements that determines which of the
		///   <c>N</c> data inputs should produce the next output element.
		/// </param>
		/// <param name="data_input_datasets">
		///   <c>N</c> datasets with the same type that will be interleaved according to
		///   the values of <c>selector_input_dataset</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalDirectedInterleaveDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalDirectedInterleaveDataset (TF_Output selector_input_dataset, TF_Output[] data_input_datasets, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalDirectedInterleaveDataset", MakeName ("ExperimentalDirectedInterleaveDataset", operName));
			c_api.TF_AddInput(desc, selector_input_dataset);
			c_api.TF_AddInputList(desc, data_input_datasets[0], data_input_datasets.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that computes a group-by on <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		///   A variant tensor representing the input dataset.
		/// </param>
		/// <param name="key_func_other_arguments">
		///   A list of tensors, typically values that were captured when
		///   building a closure for <c>key_func</c>.
		/// </param>
		/// <param name="init_func_other_arguments">
		///   A list of tensors, typically values that were captured when
		///   building a closure for <c>init_func</c>.
		/// </param>
		/// <param name="reduce_func_other_arguments">
		///   A list of tensors, typically values that were captured when
		///   building a closure for <c>reduce_func</c>.
		/// </param>
		/// <param name="finalize_func_other_arguments">
		///   A list of tensors, typically values that were captured when
		///   building a closure for <c>finalize_func</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalGroupByReducerDataset'.
		/// </param>
		/// <param name="key_func">
		///   A function mapping an element of <c>input_dataset</c>, concatenated
		///   with <c>key_func_other_arguments</c> to a scalar value of type DT_INT64.
		/// </param>
		/// <param name="init_func">
		///   A function mapping a key of type DT_INT64, concatenated with
		///   <c>init_func_other_arguments</c> to the initial reducer state.
		/// </param>
		/// <param name="reduce_func">
		///   A function mapping the current reducer state and an element of <c>input_dataset</c>,
		///   concatenated with <c>reduce_func_other_arguments</c> to a new reducer state.
		/// </param>
		/// <param name="finalize_func">
		///   A function mapping the final reducer state to an output element.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Creates a dataset that computes a group-by on <c>input_dataset</c>.
		/// </remarks>
		public TF_Output ExperimentalGroupByReducerDataset (TF_Output input_dataset, TF_Output[] key_func_other_arguments, TF_Output[] init_func_other_arguments, TF_Output[] reduce_func_other_arguments, TF_Output[] finalize_func_other_arguments, TF_Function key_func, TF_Function init_func, TF_Function reduce_func, TF_Function finalize_func, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalGroupByReducerDataset", MakeName ("ExperimentalGroupByReducerDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInputList(desc, key_func_other_arguments[0], key_func_other_arguments.Length);
			c_api.TF_AddInputList(desc, init_func_other_arguments[0], init_func_other_arguments.Length);
			c_api.TF_AddInputList(desc, reduce_func_other_arguments[0], reduce_func_other_arguments.Length);
			c_api.TF_AddInputList(desc, finalize_func_other_arguments[0], finalize_func_other_arguments.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "key_func", c_api.TF_FunctionName(key_func));
			c_api.TF_SetAttrFuncName (desc, "init_func", c_api.TF_FunctionName(init_func));
			c_api.TF_SetAttrFuncName (desc, "reduce_func", c_api.TF_FunctionName(reduce_func));
			c_api.TF_SetAttrFuncName (desc, "finalize_func", c_api.TF_FunctionName(finalize_func));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that computes a windowed group-by on <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="key_func_other_arguments">
		/// </param>
		/// <param name="reduce_func_other_arguments">
		/// </param>
		/// <param name="window_size_func_other_arguments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalGroupByWindowDataset'.
		/// </param>
		/// <param name="key_func">
		///   A function mapping an element of <c>input_dataset</c>, concatenated
		///   with <c>key_func_other_arguments</c> to a scalar value of type DT_INT64.
		/// </param>
		/// <param name="reduce_func">
		/// </param>
		/// <param name="window_size_func">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   // TODO(mrry): Support non-int64 keys.
		/// </remarks>
		public TF_Output ExperimentalGroupByWindowDataset (TF_Output input_dataset, TF_Output[] key_func_other_arguments, TF_Output[] reduce_func_other_arguments, TF_Output[] window_size_func_other_arguments, TF_Function key_func, TF_Function reduce_func, TF_Function window_size_func, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalGroupByWindowDataset", MakeName ("ExperimentalGroupByWindowDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInputList(desc, key_func_other_arguments[0], key_func_other_arguments.Length);
			c_api.TF_AddInputList(desc, reduce_func_other_arguments[0], reduce_func_other_arguments.Length);
			c_api.TF_AddInputList(desc, window_size_func_other_arguments[0], window_size_func_other_arguments.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "key_func", c_api.TF_FunctionName(key_func));
			c_api.TF_SetAttrFuncName (desc, "reduce_func", c_api.TF_FunctionName(reduce_func));
			c_api.TF_SetAttrFuncName (desc, "window_size_func", c_api.TF_FunctionName(window_size_func));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that contains the elements of <c>input_dataset</c> ignoring errors.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalIgnoreErrorsDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalIgnoreErrorsDataset (TF_Output input_dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalIgnoreErrorsDataset", MakeName ("ExperimentalIgnoreErrorsDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Returns the name of the device on which <c>resource</c> has been placed.
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalIteratorGetDevice'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalIteratorGetDevice (TF_Output resource, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalIteratorGetDevice", MakeName ("ExperimentalIteratorGetDevice", operName));
			c_api.TF_AddInput(desc, resource);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var device = new TF_Output (op, _idx++);
			return device;
		}

		/// <summary>
		///   Records the latency of producing <c>input_dataset</c> elements in a StatsAggregator.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalLatencyStatsDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalLatencyStatsDataset (TF_Output input_dataset, TF_Output tag, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalLatencyStatsDataset", MakeName ("ExperimentalLatencyStatsDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, tag);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="filenames">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalLMDBDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalLMDBDataset (TF_Output filenames, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalLMDBDataset", MakeName ("ExperimentalLMDBDataset", operName));
			c_api.TF_AddInput(desc, filenames);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that fuses mapping with batching.
		/// </summary>
		/// <param name="input_dataset">
		///   A variant tensor representing the input dataset.
		/// </param>
		/// <param name="other_arguments">
		///   A list of tensors, typically values that were captured when building a closure
		///   for <c>f</c>.
		/// </param>
		/// <param name="batch_size">
		///   A scalar representing the number of elements to accumulate in a
		///   batch. It determines the number of concurrent invocations of <c>f</c> that process
		///   elements from <c>input_dataset</c> in parallel.
		/// </param>
		/// <param name="num_parallel_calls">
		///   A scalar representing the maximum number of parallel invocations of the <c>map_fn</c>
		///   function. Applying the <c>map_fn</c> on consecutive input elements in parallel has
		///   the potential to improve input pipeline throughput.
		/// </param>
		/// <param name="drop_remainder">
		///   A scalar representing whether the last batch should be dropped in case its size
		///   is smaller than desired.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalMapAndBatchDataset'.
		/// </param>
		/// <param name="preserve_cardinality">
		///   Optional argument
		/// </param>
		/// <param name="f">
		///   A function to apply to the outputs of <c>input_dataset</c>.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Creates a dataset that applies <c>f</c> to the outputs of <c>input_dataset</c> and then
		///   batches <c>batch_size</c> of them.
		///   
		///   Unlike a "MapDataset", which applies <c>f</c> sequentially, this dataset invokes up
		///   to <c>batch_size * num_parallel_batches</c> copies of <c>f</c> in parallel.
		/// </remarks>
		public TF_Output ExperimentalMapAndBatchDataset (TF_Output input_dataset, TF_Output[] other_arguments, TF_Output batch_size, TF_Output num_parallel_calls, TF_Output drop_remainder, TF_Function f, TF_DataType[] output_types, long[][] output_shapes, bool? preserve_cardinality = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalMapAndBatchDataset", MakeName ("ExperimentalMapAndBatchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInputList(desc, other_arguments[0], other_arguments.Length);
			c_api.TF_AddInput(desc, batch_size);
			c_api.TF_AddInput(desc, num_parallel_calls);
			c_api.TF_AddInput(desc, drop_remainder);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "f", c_api.TF_FunctionName(f));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (preserve_cardinality.HasValue)
				c_api.TF_SetAttrBool (desc, "preserve_cardinality", Convert.ToByte(preserve_cardinality.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that applies <c>f</c> to the outputs of <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="other_arguments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalMapDataset'.
		/// </param>
		/// <param name="use_inter_op_parallelism">
		///   Optional argument
		/// </param>
		/// <param name="preserve_cardinality">
		///   Optional argument
		/// </param>
		/// <param name="f">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalMapDataset (TF_Output input_dataset, TF_Output[] other_arguments, TF_Function f, TF_DataType[] output_types, long[][] output_shapes, bool? use_inter_op_parallelism = null, bool? preserve_cardinality = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalMapDataset", MakeName ("ExperimentalMapDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInputList(desc, other_arguments[0], other_arguments.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "f", c_api.TF_FunctionName(f));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (use_inter_op_parallelism.HasValue)
				c_api.TF_SetAttrBool (desc, "use_inter_op_parallelism", Convert.ToByte(use_inter_op_parallelism.Value));
			
			if (preserve_cardinality.HasValue)
				c_api.TF_SetAttrBool (desc, "preserve_cardinality", Convert.ToByte(preserve_cardinality.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="patterns">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalMatchingFilesDataset'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalMatchingFilesDataset (TF_Output patterns, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalMatchingFilesDataset", MakeName ("ExperimentalMatchingFilesDataset", operName));
			c_api.TF_AddInput(desc, patterns);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that overrides the maximum intra-op parallelism.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="max_intra_op_parallelism">
		///   Identifies the maximum intra-op parallelism to use.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalMaxIntraOpParallelismDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalMaxIntraOpParallelismDataset (TF_Output input_dataset, TF_Output max_intra_op_parallelism, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalMaxIntraOpParallelismDataset", MakeName ("ExperimentalMaxIntraOpParallelismDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, max_intra_op_parallelism);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalNonSerializableDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalNonSerializableDataset (TF_Output input_dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalNonSerializableDataset", MakeName ("ExperimentalNonSerializableDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that applies <c>f</c> to the outputs of <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="other_arguments">
		/// </param>
		/// <param name="cycle_length">
		/// </param>
		/// <param name="block_length">
		/// </param>
		/// <param name="sloppy">
		/// </param>
		/// <param name="buffer_output_elements">
		/// </param>
		/// <param name="prefetch_input_elements">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalParallelInterleaveDataset'.
		/// </param>
		/// <param name="f">
		///   A function mapping elements of <c>input_dataset</c>, concatenated with
		///   <c>other_arguments</c>, to a Dataset variant that contains elements matching
		///   <c>output_types</c> and <c>output_shapes</c>.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The resulting dataset is similar to the <c>InterleaveDataset</c>, with the exception
		///   that if retrieving the next value from a dataset would cause the requester to
		///   block, it will skip that input dataset. This dataset is especially useful
		///   when loading data from a variable-latency datastores (e.g. HDFS, GCS), as it
		///   allows the training step to proceed so long as some data is available.
		///   
		///   !! WARNING !! This dataset is not deterministic!
		/// </remarks>
		public TF_Output ExperimentalParallelInterleaveDataset (TF_Output input_dataset, TF_Output[] other_arguments, TF_Output cycle_length, TF_Output block_length, TF_Output sloppy, TF_Output buffer_output_elements, TF_Output prefetch_input_elements, TF_Function f, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalParallelInterleaveDataset", MakeName ("ExperimentalParallelInterleaveDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInputList(desc, other_arguments[0], other_arguments.Length);
			c_api.TF_AddInput(desc, cycle_length);
			c_api.TF_AddInput(desc, block_length);
			c_api.TF_AddInput(desc, sloppy);
			c_api.TF_AddInput(desc, buffer_output_elements);
			c_api.TF_AddInput(desc, prefetch_input_elements);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "f", c_api.TF_FunctionName(f));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Transforms <c>input_dataset</c> containing <c>Example</c> protos as vectors of DT_STRING into a dataset of <c>Tensor</c> or <c>SparseTensor</c> objects representing the parsed features.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="num_parallel_calls">
		/// </param>
		/// <param name="dense_defaults">
		///   A dict mapping string keys to <c>Tensor</c>s.
		///   The keys of the dict must match the dense_keys of the feature.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalParseExampleDataset'.
		/// </param>
		/// <param name="sloppy">
		///   Optional argument
		/// </param>
		/// <param name="sparse_keys">
		///   A list of string keys in the examples features.
		///   The results for these keys will be returned as <c>SparseTensor</c> objects.
		/// </param>
		/// <param name="dense_keys">
		///   A list of Ndense string Tensors (scalars).
		///   The keys expected in the Examples features associated with dense values.
		/// </param>
		/// <param name="sparse_types">
		///   A list of <c>DTypes</c> of the same length as <c>sparse_keys</c>.
		///   Only <c>tf.float32</c> (<c>FloatList</c>), <c>tf.int64</c> (<c>Int64List</c>),
		///   and <c>tf.string</c> (<c>BytesList</c>) are supported.
		/// </param>
		/// <param name="dense_shapes">
		///   List of tuples with the same length as <c>dense_keys</c>.
		///   The shape of the data for each dense feature referenced by <c>dense_keys</c>.
		///   Required for any input tensors identified by <c>dense_keys</c>.  Must be
		///   either fully defined, or may contain an unknown first dimension.
		///   An unknown first dimension means the feature is treated as having
		///   a variable number of blocks, and the output shape along this dimension
		///   is considered unknown at graph build time.  Padding is applied for
		///   minibatch elements smaller than the maximum number of blocks for the
		///   given feature along this dimension.
		/// </param>
		/// <param name="output_types">
		///   The type list for the return values.
		/// </param>
		/// <param name="output_shapes">
		///   The list of shapes being produced.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalParseExampleDataset (TF_Output input_dataset, TF_Output num_parallel_calls, TF_Output[] dense_defaults, string[] sparse_keys, string[] dense_keys, TF_DataType[] sparse_types, long[][] dense_shapes, TF_DataType[] output_types, long[][] output_shapes, bool? sloppy = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalParseExampleDataset", MakeName ("ExperimentalParseExampleDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, num_parallel_calls);
			c_api.TF_AddInputList(desc, dense_defaults[0], dense_defaults.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrStringList (desc, "sparse_keys", sparse_keys);
			c_api.TF_SetAttrStringList (desc, "dense_keys", dense_keys);
			c_api.TF_SetAttrTypeList (desc, "sparse_types", sparse_types);
			c_api.TF_SetAttrShapeList (desc, "dense_shapes", dense_shapes);
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (sloppy.HasValue)
				c_api.TF_SetAttrBool (desc, "sloppy", Convert.ToByte(sloppy.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that uses a custom thread pool to compute <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="num_threads">
		///   Identifies the number of threads to use for the private threadpool.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalPrivateThreadPoolDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalPrivateThreadPoolDataset (TF_Output input_dataset, TF_Output num_threads, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalPrivateThreadPoolDataset", MakeName ("ExperimentalPrivateThreadPoolDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, num_threads);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a Dataset that returns pseudorandom numbers.
		/// </summary>
		/// <param name="seed">
		///   A scalar seed for the random number generator. If either seed or
		///   seed2 is set to be non-zero, the random number generator is seeded
		///   by the given seed.  Otherwise, a random seed is used.
		/// </param>
		/// <param name="seed2">
		///   A second scalar seed to avoid seed collision.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalRandomDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalRandomDataset (TF_Output seed, TF_Output seed2, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalRandomDataset", MakeName ("ExperimentalRandomDataset", operName));
			c_api.TF_AddInput(desc, seed);
			c_api.TF_AddInput(desc, seed2);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that changes the batch size.
		/// </summary>
		/// <param name="input_dataset">
		///   A variant tensor representing the input dataset.
		/// </param>
		/// <param name="num_replicas">
		///   A scalar representing the number of replicas to distribute this batch across. As
		///   a result of this transformation the current batch size would end up being
		///   divided  by this parameter.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalRebatchDataset'.
		/// </param>
		/// <param name="use_fallback">
		///   Optional argument
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Creates a dataset that changes the batch size of the dataset to current batch
		///   size // num_replicas.
		/// </remarks>
		public TF_Output ExperimentalRebatchDataset (TF_Output input_dataset, TF_Output num_replicas, TF_DataType[] output_types, long[][] output_shapes, bool? use_fallback = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalRebatchDataset", MakeName ("ExperimentalRebatchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, num_replicas);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (use_fallback.HasValue)
				c_api.TF_SetAttrBool (desc, "use_fallback", Convert.ToByte(use_fallback.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset successively reduces <c>f</c> over the elements of <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="initial_state">
		/// </param>
		/// <param name="other_arguments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalScanDataset'.
		/// </param>
		/// <param name="preserve_cardinality">
		///   Optional argument
		/// </param>
		/// <param name="f">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalScanDataset (TF_Output input_dataset, TF_Output[] initial_state, TF_Output[] other_arguments, TF_Function f, TF_DataType[] output_types, long[][] output_shapes, bool? preserve_cardinality = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalScanDataset", MakeName ("ExperimentalScanDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInputList(desc, initial_state[0], initial_state.Length);
			c_api.TF_AddInputList(desc, other_arguments[0], other_arguments.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "f", c_api.TF_FunctionName(f));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (preserve_cardinality.HasValue)
				c_api.TF_SetAttrBool (desc, "preserve_cardinality", Convert.ToByte(preserve_cardinality.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="stats_aggregator">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="counter_prefix">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalSetStatsAggregatorDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalSetStatsAggregatorDataset (TF_Output input_dataset, TF_Output stats_aggregator, TF_Output tag, TF_Output counter_prefix, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalSetStatsAggregatorDataset", MakeName ("ExperimentalSetStatsAggregatorDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, stats_aggregator);
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, counter_prefix);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="sleep_microseconds">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalSleepDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalSleepDataset (TF_Output input_dataset, TF_Output sleep_microseconds, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalSleepDataset", MakeName ("ExperimentalSleepDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, sleep_microseconds);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that passes a sliding window over <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="window_size">
		///   A scalar representing the number of elements in the
		///   sliding window.
		/// </param>
		/// <param name="window_shift">
		///   A scalar representing the steps moving the sliding window
		///   forward in one iteration. It must be positive.
		/// </param>
		/// <param name="window_stride">
		///   A scalar representing the stride of the input elements of the sliding window.
		///   It must be positive.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalSlidingWindowDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalSlidingWindowDataset (TF_Output input_dataset, TF_Output window_size, TF_Output window_shift, TF_Output window_stride, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalSlidingWindowDataset", MakeName ("ExperimentalSlidingWindowDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, window_size);
			c_api.TF_AddInput(desc, window_shift);
			c_api.TF_AddInput(desc, window_stride);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that executes a SQL query and emits rows of the result set.
		/// </summary>
		/// <param name="driver_name">
		///   The database type. Currently, the only supported type is 'sqlite'.
		/// </param>
		/// <param name="data_source_name">
		///   A connection string to connect to the database.
		/// </param>
		/// <param name="query">
		///   A SQL query to execute.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalSqlDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalSqlDataset (TF_Output driver_name, TF_Output data_source_name, TF_Output query, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalSqlDataset", MakeName ("ExperimentalSqlDataset", operName));
			c_api.TF_AddInput(desc, driver_name);
			c_api.TF_AddInput(desc, data_source_name);
			c_api.TF_AddInput(desc, query);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a statistics manager resource.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalStatsAggregatorHandle'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalStatsAggregatorHandle (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalStatsAggregatorHandle", MakeName ("ExperimentalStatsAggregatorHandle", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Produces a summary of any statistics recorded by the given statistics manager.
		/// </summary>
		/// <param name="iterator">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalStatsAggregatorSummary'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalStatsAggregatorSummary (TF_Output iterator, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalStatsAggregatorSummary", MakeName ("ExperimentalStatsAggregatorSummary", operName));
			c_api.TF_AddInput(desc, iterator);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var summary = new TF_Output (op, _idx++);
			return summary;
		}

		/// <summary>
		///   Creates a dataset that stops iteration when predicate<c> is false.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="other_arguments">
		///   A list of tensors, typically values that were captured when
		///   building a closure for <c>predicate</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalTakeWhileDataset'.
		/// </param>
		/// <param name="predicate">
		///   A function returning a scalar boolean.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The <c>predicate</c> function must return a scalar boolean and accept the
		///   following arguments:
		///   
		///   * One tensor for each component of an element of <c>input_dataset</c>.
		///   * One tensor for each value in <c>other_arguments</c>.
		/// </remarks>
		public TF_Output ExperimentalTakeWhileDataset (TF_Output input_dataset, TF_Output[] other_arguments, TF_Function predicate, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalTakeWhileDataset", MakeName ("ExperimentalTakeWhileDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInputList(desc, other_arguments[0], other_arguments.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "predicate", c_api.TF_FunctionName(predicate));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that uses a custom thread pool to compute <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="thread_pool">
		///   A resource produced by the ThreadPoolHandle op.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalThreadPoolDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalThreadPoolDataset (TF_Output input_dataset, TF_Output thread_pool, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalThreadPoolDataset", MakeName ("ExperimentalThreadPoolDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, thread_pool);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that uses a custom thread pool to compute <c>input_dataset</c>.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalThreadPoolHandle'.
		/// </param>
		/// <param name="max_intra_op_parallelism">
		///   Optional argument
		///   The maximum degree of parallelism to use within operations that execute on this
		///   threadpool.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="num_threads">
		///   The number of threads in the thread pool.
		/// </param>
		/// <param name="display_name">
		///   A human-readable name for the threads that may be visible in some
		///   visualizations.
		///   threadpool.
		/// </param>
		/// <returns>
		///   A resource that can be consumed by one or more ExperimentalThreadPoolDataset
		///   ops.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalThreadPoolHandle (long num_threads, string display_name, long? max_intra_op_parallelism = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalThreadPoolHandle", MakeName ("ExperimentalThreadPoolHandle", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_threads", num_threads);
			c_api.TF_SetAttrString (desc, "display_name", display_name);
			if (max_intra_op_parallelism.HasValue)
				c_api.TF_SetAttrInt (desc, "max_intra_op_parallelism", max_intra_op_parallelism.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   A dataset that splits the elements of its input into multiple elements.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalUnbatchDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalUnbatchDataset (TF_Output input_dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalUnbatchDataset", MakeName ("ExperimentalUnbatchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that contains the unique elements of <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalUniqueDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExperimentalUniqueDataset (TF_Output input_dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExperimentalUniqueDataset", MakeName ("ExperimentalUniqueDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Computes <c>exp(x) - 1</c> element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Expm1'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   i.e. <c>exp(x) - 1</c> or <c>e^(x) - 1</c>, where <c>x</c> is the input tensor.
		///   <c>e</c> denotes Euler's number and is approximately equal to 2.718281.
		///   
		///    <code>
		///   x = tf.constant(2.0)
		///   tf.math.expm1(x) ==&amp;gt; 6.389056
		///   
		///   x = tf.constant([2.0, 8.0])
		///   tf.math.expm1(x) ==&amp;gt; array([6.389056, 2979.958], dtype=float32)
		///   
		///   x = tf.constant(1 + 1j)
		///   tf.math.expm1(x) ==&amp;gt; (0.46869393991588515+2.2873552871788423j)
		///    </code>
		/// </remarks>
		public TF_Output Expm1 (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Expm1", MakeName ("Expm1", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Extracts a glimpse from the input tensor.
		/// </summary>
		/// <param name="input">
		///   A 4-D float tensor of shape <c>[batch_size, height, width, channels]</c>.
		/// </param>
		/// <param name="size">
		///   A 1-D tensor of 2 elements containing the size of the glimpses
		///   to extract.  The glimpse height must be specified first, following
		///   by the glimpse width.
		/// </param>
		/// <param name="offsets">
		///   A 2-D integer tensor of shape <c>[batch_size, 2]</c> containing
		///   the y, x locations of the center of each window.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExtractGlimpse'.
		/// </param>
		/// <param name="centered">
		///   Optional argument
		///   indicates if the offset coordinates are centered relative to
		///   the image, in which case the (0, 0) offset is relative to the center
		///   of the input images. If false, the (0,0) offset corresponds to the
		///   upper left corner of the input images.
		/// </param>
		/// <param name="normalized">
		///   Optional argument
		///   indicates if the offset coordinates are normalized.
		/// </param>
		/// <param name="uniform_noise">
		///   Optional argument
		///   indicates if the noise should be generated using a
		///   uniform distribution or a Gaussian distribution.
		/// </param>
		/// <param name="noise">
		///   Optional argument
		///   indicates if the noise should <c>uniform</c>, <c>gaussian</c>, or
		///   <c>zero</c>. The default is <c>uniform</c> which means the the noise type
		///   will be decided by <c>uniform_noise</c>.
		/// </param>
		/// <returns>
		///   A tensor representing the glimpses <c>[batch_size,
		///   glimpse_height, glimpse_width, channels]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Returns a set of windows called glimpses extracted at location
		///   <c>offsets</c> from the input tensor. If the windows only partially
		///   overlaps the inputs, the non overlapping areas will be filled with
		///   random noise.
		///   
		///   The result is a 4-D tensor of shape <c>[batch_size, glimpse_height,
		///   glimpse_width, channels]</c>. The channels and batch dimensions are the
		///   same as that of the input tensor. The height and width of the output
		///   windows are specified in the <c>size</c> parameter.
		///   
		///   The argument <c>normalized</c> and <c>centered</c> controls how the windows are built:
		///   
		///   * If the coordinates are normalized but not centered, 0.0 and 1.0
		///   correspond to the minimum and maximum of each height and width
		///   dimension.
		///   * If the coordinates are both normalized and centered, they range from
		///   -1.0 to 1.0. The coordinates (-1.0, -1.0) correspond to the upper
		///   left corner, the lower right corner is located at (1.0, 1.0) and the
		///   center is at (0, 0).
		///   * If the coordinates are not normalized they are interpreted as
		///   numbers of pixels.
		/// </remarks>
		public TF_Output ExtractGlimpse (TF_Output input, TF_Output size, TF_Output offsets, bool? centered = null, bool? normalized = null, bool? uniform_noise = null, string noise = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExtractGlimpse", MakeName ("ExtractGlimpse", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, size);
			c_api.TF_AddInput(desc, offsets);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (centered.HasValue)
				c_api.TF_SetAttrBool (desc, "centered", Convert.ToByte(centered.Value));
			
			if (normalized.HasValue)
				c_api.TF_SetAttrBool (desc, "normalized", Convert.ToByte(normalized.Value));
			
			if (uniform_noise.HasValue)
				c_api.TF_SetAttrBool (desc, "uniform_noise", Convert.ToByte(uniform_noise.Value));
			
			if (noise != null)
				c_api.TF_SetAttrString (desc, "noise", noise);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var glimpse = new TF_Output (op, _idx++);
			return glimpse;
		}

		/// <summary>
		///   Extract <c>patches</c> from <c>images</c> and put them in the "depth" output dimension.
		/// </summary>
		/// <param name="images">
		///   4-D Tensor with shape <c>[batch, in_rows, in_cols, depth]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExtractImagePatches'.
		/// </param>
		/// <param name="ksizes">
		///   The size of the sliding window for each dimension of <c>images</c>.
		/// </param>
		/// <param name="strides">
		///   How far the centers of two consecutive patches are in
		///   the images. Must be: <c>[1, stride_rows, stride_cols, 1]</c>.
		/// </param>
		/// <param name="rates">
		///   Must be: <c>[1, rate_rows, rate_cols, 1]</c>. This is the
		///   input stride, specifying how far two consecutive patch samples are in the
		///   input. Equivalent to extracting patches with
		///   <c>patch_sizes_eff = patch_sizes + (patch_sizes - 1) * (rates - 1)</c>, followed by
		///   subsampling them spatially by a factor of <c>rates</c>. This is equivalent to
		///   <c>rate</c> in dilated (a.k.a. Atrous) convolutions.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   4-D Tensor with shape <c>[batch, out_rows, out_cols, ksize_rows *
		///   ksize_cols * depth]</c> containing image patches with size
		///   <c>ksize_rows x ksize_cols x depth</c> vectorized in the "depth" dimension. Note
		///   <c>out_rows</c> and <c>out_cols</c> are the dimensions of the output patches.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExtractImagePatches (TF_Output images, long[] ksizes, long[] strides, long[] rates, string padding, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExtractImagePatches", MakeName ("ExtractImagePatches", operName));
			c_api.TF_AddInput(desc, images);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksizes", ref ksizes[0], ksizes.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrIntList (desc, "rates", ref rates[0], rates.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var patches = new TF_Output (op, _idx++);
			return patches;
		}

		/// <summary>
		///   Extract the shape information of a JPEG-encoded image.
		/// </summary>
		/// <param name="contents">
		///   0-D. The JPEG-encoded image.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExtractJpegShape'.
		/// </param>
		/// <param name="output_type">
		///   Optional argument
		///   (Optional) The output type of the operation (int32 or int64).
		///   Defaults to int32.
		/// </param>
		/// <returns>
		///   1-D. The image shape with format [height, width, channels].
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op only parses the image header, so it is much faster than DecodeJpeg.
		/// </remarks>
		public TF_Output ExtractJpegShape (TF_Output contents, TF_DataType? output_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExtractJpegShape", MakeName ("ExtractJpegShape", operName));
			c_api.TF_AddInput(desc, contents);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (output_type.HasValue)
				c_api.TF_SetAttrType (desc, "output_type", output_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var image_shape = new TF_Output (op, _idx++);
			return image_shape;
		}

		/// <summary>
		///   Extract <c>patches</c> from <c>input</c> and put them in the "depth" output dimension. 3D extension of <c>extract_image_patches</c>.
		/// </summary>
		/// <param name="input">
		///   5-D Tensor with shape <c>[batch, in_planes, in_rows, in_cols, depth]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ExtractVolumePatches'.
		/// </param>
		/// <param name="ksizes">
		///   The size of the sliding window for each dimension of <c>input</c>.
		/// </param>
		/// <param name="strides">
		///   1-D of length 5. How far the centers of two consecutive patches are in
		///   <c>input</c>. Must be: <c>[1, stride_planes, stride_rows, stride_cols, 1]</c>.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		///   
		///   We specify the size-related attributes as:
		///   
		///    <code>
		///   ksizes = [1, ksize_planes, ksize_rows, ksize_cols, 1]
		///   strides = [1, stride_planes, strides_rows, strides_cols, 1]
		///    </code>
		/// </param>
		/// <returns>
		///   5-D Tensor with shape <c>[batch, out_planes, out_rows, out_cols,
		///   ksize_planes * ksize_rows * ksize_cols * depth]</c> containing patches
		///   with size <c>ksize_planes x ksize_rows x ksize_cols x depth</c> vectorized
		///   in the "depth" dimension. Note <c>out_planes</c>, <c>out_rows</c> and <c>out_cols</c>
		///   are the dimensions of the output patches.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ExtractVolumePatches (TF_Output input, long[] ksizes, long[] strides, string padding, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ExtractVolumePatches", MakeName ("ExtractVolumePatches", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksizes", ref ksizes[0], ksizes.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var patches = new TF_Output (op, _idx++);
			return patches;
		}

		/// <summary>
		///   Output a fact about factorials.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Fact'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Fact (string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Fact", MakeName ("Fact", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var fact = new TF_Output (op, _idx++);
			return fact;
		}

		/// <summary>
		///   This op is used as a placeholder in If branch functions. It doesn't provide a
		///   valid output when run, so must either be removed (e.g. replaced with a
		///   function input) or guaranteed not to be used (e.g. if mirroring an
		///   intermediate output needed for the gradient computation of the other branch).
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeParam'.
		/// </param>
		/// <param name="dtype">
		///   The type of the output.
		/// </param>
		/// <param name="shape">
		///   The purported shape of the output. This is only used for shape inference;
		///   the output will not necessarily have this shape. Can be a partial shape.
		/// </param>
		/// <returns>
		///   \"Fake\" output value. This should not be consumed by another op.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FakeParam (TF_DataType dtype, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FakeParam", MakeName ("FakeParam", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Fake-quantize the 'inputs' tensor, type float to 'outputs' tensor of same type.
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxArgs'.
		/// </param>
		/// <param name="min">
		///   Optional argument
		/// </param>
		/// <param name="max">
		///   Optional argument
		/// </param>
		/// <param name="num_bits">
		///   Optional argument
		/// </param>
		/// <param name="narrow_range">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Attributes <c>[min; max]</c> define the clamping range for the <c>inputs</c> data.
		///   <c>inputs</c> values are quantized into the quantization range (<c>[0; 2^num_bits - 1]</c>
		///   when <c>narrow_range</c> is false and <c>[1; 2^num_bits - 1]</c> when it is true) and
		///   then de-quantized and output as floats in <c>[min; max]</c> interval.
		///   <c>num_bits</c> is the bitwidth of the quantization; between 2 and 16, inclusive.
		///   
		///   Before quantization, <c>min</c> and <c>max</c> values are adjusted with the following
		///   logic.
		///   It is suggested to have <c>min &amp;lt;= 0 &amp;lt;= max</c>. If <c>0</c> is not in the range of values,
		///   the behavior can be unexpected:
		///   If <c>0 &amp;lt; min &amp;lt; max</c>: <c>min_adj = 0</c> and <c>max_adj = max - min</c>.
		///   If <c>min &amp;lt; max &amp;lt; 0</c>: <c>min_adj = min - max</c> and <c>max_adj = 0</c>.
		///   If <c>min &amp;lt;= 0 &amp;lt;= max</c>: <c>scale = (max - min) / (2^num_bits - 1) </c>,
		///   <c>min_adj = scale * round(min / scale)</c> and <c>max_adj = max + min_adj - min</c>.
		///   
		///   Quantization is called fake since the output is still in floating point.
		/// </remarks>
		public TF_Output FakeQuantWithMinMaxArgs (TF_Output inputs, float? min = null, float? max = null, long? num_bits = null, bool? narrow_range = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FakeQuantWithMinMaxArgs", MakeName ("FakeQuantWithMinMaxArgs", operName));
			c_api.TF_AddInput(desc, inputs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (min.HasValue)
				c_api.TF_SetAttrFloat (desc, "min", min.Value);
			
			if (max.HasValue)
				c_api.TF_SetAttrFloat (desc, "max", max.Value);
			
			if (num_bits.HasValue)
				c_api.TF_SetAttrInt (desc, "num_bits", num_bits.Value);
			
			if (narrow_range.HasValue)
				c_api.TF_SetAttrBool (desc, "narrow_range", Convert.ToByte(narrow_range.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var outputs = new TF_Output (op, _idx++);
			return outputs;
		}

		/// <summary>
		///   Compute gradients for a FakeQuantWithMinMaxArgs operation.
		/// </summary>
		/// <param name="gradients">
		///   Backpropagated gradients above the FakeQuantWithMinMaxArgs operation.
		/// </param>
		/// <param name="inputs">
		///   Values passed as inputs to the FakeQuantWithMinMaxArgs operation.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxArgsGradient'.
		/// </param>
		/// <param name="min">
		///   Optional argument
		/// </param>
		/// <param name="max">
		///   Optional argument
		/// </param>
		/// <param name="num_bits">
		///   Optional argument
		/// </param>
		/// <param name="narrow_range">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Backpropagated gradients below the FakeQuantWithMinMaxArgs operation:
		///   <c>gradients * (inputs &amp;gt;= min &amp;&amp; inputs &amp;lt;= max)</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FakeQuantWithMinMaxArgsGradient (TF_Output gradients, TF_Output inputs, float? min = null, float? max = null, long? num_bits = null, bool? narrow_range = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FakeQuantWithMinMaxArgsGradient", MakeName ("FakeQuantWithMinMaxArgsGradient", operName));
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, inputs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (min.HasValue)
				c_api.TF_SetAttrFloat (desc, "min", min.Value);
			
			if (max.HasValue)
				c_api.TF_SetAttrFloat (desc, "max", max.Value);
			
			if (num_bits.HasValue)
				c_api.TF_SetAttrInt (desc, "num_bits", num_bits.Value);
			
			if (narrow_range.HasValue)
				c_api.TF_SetAttrBool (desc, "narrow_range", Convert.ToByte(narrow_range.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var backprops = new TF_Output (op, _idx++);
			return backprops;
		}

		/// <summary>
		///   Fake-quantize the 'inputs' tensor of type float via global float scalars <c>min</c>
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="min">
		/// </param>
		/// <param name="max">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxVars'.
		/// </param>
		/// <param name="num_bits">
		///   Optional argument
		/// </param>
		/// <param name="narrow_range">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   and <c>max</c> to 'outputs' tensor of same shape as <c>inputs</c>.
		///   
		///   <c>[min; max]</c> define the clamping range for the <c>inputs</c> data.
		///   <c>inputs</c> values are quantized into the quantization range (<c>[0; 2^num_bits - 1]</c>
		///   when <c>narrow_range</c> is false and <c>[1; 2^num_bits - 1]</c> when it is true) and
		///   then de-quantized and output as floats in <c>[min; max]</c> interval.
		///   <c>num_bits</c> is the bitwidth of the quantization; between 2 and 16, inclusive.
		///   
		///   Before quantization, <c>min</c> and <c>max</c> values are adjusted with the following
		///   logic.
		///   It is suggested to have <c>min &amp;lt;= 0 &amp;lt;= max</c>. If <c>0</c> is not in the range of values,
		///   the behavior can be unexpected:
		///   If <c>0 &amp;lt; min &amp;lt; max</c>: <c>min_adj = 0</c> and <c>max_adj = max - min</c>.
		///   If <c>min &amp;lt; max &amp;lt; 0</c>: <c>min_adj = min - max</c> and <c>max_adj = 0</c>.
		///   If <c>min &amp;lt;= 0 &amp;lt;= max</c>: <c>scale = (max - min) / (2^num_bits - 1) </c>,
		///   <c>min_adj = scale * round(min / scale)</c> and <c>max_adj = max + min_adj - min</c>.
		///   
		///   This operation has a gradient and thus allows for training <c>min</c> and <c>max</c>
		///   values.
		/// </remarks>
		public TF_Output FakeQuantWithMinMaxVars (TF_Output inputs, TF_Output min, TF_Output max, long? num_bits = null, bool? narrow_range = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FakeQuantWithMinMaxVars", MakeName ("FakeQuantWithMinMaxVars", operName));
			c_api.TF_AddInput(desc, inputs);
			c_api.TF_AddInput(desc, min);
			c_api.TF_AddInput(desc, max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (num_bits.HasValue)
				c_api.TF_SetAttrInt (desc, "num_bits", num_bits.Value);
			
			if (narrow_range.HasValue)
				c_api.TF_SetAttrBool (desc, "narrow_range", Convert.ToByte(narrow_range.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var outputs = new TF_Output (op, _idx++);
			return outputs;
		}

		/// <summary>
		///   Compute gradients for a FakeQuantWithMinMaxVars operation.
		/// </summary>
		/// <param name="gradients">
		///   Backpropagated gradients above the FakeQuantWithMinMaxVars operation.
		/// </param>
		/// <param name="inputs">
		///   Values passed as inputs to the FakeQuantWithMinMaxVars operation.
		///   min, max: Quantization interval, scalar floats.
		/// </param>
		/// <param name="min">
		/// </param>
		/// <param name="max">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxVarsGradient'.
		/// </param>
		/// <param name="num_bits">
		///   Optional argument
		///   The bitwidth of the quantization; between 2 and 8, inclusive.
		/// </param>
		/// <param name="narrow_range">
		///   Optional argument
		///   Whether to quantize into 2^num_bits - 1 distinct values.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   backprops_wrt_input: Backpropagated gradients w.r.t. inputs:
		///   <c>gradients * (inputs &amp;gt;= min &amp;&amp; inputs &amp;lt;= max)</c>.
		///   backprop_wrt_min: Backpropagated gradients w.r.t. min parameter:
		///   <c>sum(gradients * (inputs &amp;lt; min))</c>.
		///   backprop_wrt_max: Backpropagated gradients w.r.t. max parameter:
		///   <c>sum(gradients * (inputs &amp;gt; max))</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output backprops_wrt_input, TF_Output backprop_wrt_min, TF_Output backprop_wrt_max) FakeQuantWithMinMaxVarsGradient (TF_Output gradients, TF_Output inputs, TF_Output min, TF_Output max, long? num_bits = null, bool? narrow_range = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FakeQuantWithMinMaxVarsGradient", MakeName ("FakeQuantWithMinMaxVarsGradient", operName));
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, inputs);
			c_api.TF_AddInput(desc, min);
			c_api.TF_AddInput(desc, max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (num_bits.HasValue)
				c_api.TF_SetAttrInt (desc, "num_bits", num_bits.Value);
			
			if (narrow_range.HasValue)
				c_api.TF_SetAttrBool (desc, "narrow_range", Convert.ToByte(narrow_range.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var backprops_wrt_input = new TF_Output (op, _idx++);
			var backprop_wrt_min = new TF_Output (op, _idx++);
			var backprop_wrt_max = new TF_Output (op, _idx++);
			return (backprops_wrt_input, backprop_wrt_min, backprop_wrt_max);
		}

		/// <summary>
		///   Fake-quantize the 'inputs' tensor of type float and one of the shapes: <c>[d]</c>,
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="min">
		/// </param>
		/// <param name="max">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxVarsPerChannel'.
		/// </param>
		/// <param name="num_bits">
		///   Optional argument
		/// </param>
		/// <param name="narrow_range">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   <c>[b, d]</c> <c>[b, h, w, d]</c> via per-channel floats <c>min</c> and <c>max</c> of shape <c>[d]</c>
		///   to 'outputs' tensor of same shape as <c>inputs</c>.
		///   
		///   <c>[min; max]</c> define the clamping range for the <c>inputs</c> data.
		///   <c>inputs</c> values are quantized into the quantization range (<c>[0; 2^num_bits - 1]</c>
		///   when <c>narrow_range</c> is false and <c>[1; 2^num_bits - 1]</c> when it is true) and
		///   then de-quantized and output as floats in <c>[min; max]</c> interval.
		///   <c>num_bits</c> is the bitwidth of the quantization; between 2 and 16, inclusive.
		///   
		///   Before quantization, <c>min</c> and <c>max</c> values are adjusted with the following
		///   logic.
		///   It is suggested to have <c>min &amp;lt;= 0 &amp;lt;= max</c>. If <c>0</c> is not in the range of values,
		///   the behavior can be unexpected:
		///   If <c>0 &amp;lt; min &amp;lt; max</c>: <c>min_adj = 0</c> and <c>max_adj = max - min</c>.
		///   If <c>min &amp;lt; max &amp;lt; 0</c>: <c>min_adj = min - max</c> and <c>max_adj = 0</c>.
		///   If <c>min &amp;lt;= 0 &amp;lt;= max</c>: <c>scale = (max - min) / (2^num_bits - 1) </c>,
		///   <c>min_adj = scale * round(min / scale)</c> and <c>max_adj = max + min_adj - min</c>.
		///   
		///   This operation has a gradient and thus allows for training <c>min</c> and <c>max</c>
		///   values.
		/// </remarks>
		public TF_Output FakeQuantWithMinMaxVarsPerChannel (TF_Output inputs, TF_Output min, TF_Output max, long? num_bits = null, bool? narrow_range = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FakeQuantWithMinMaxVarsPerChannel", MakeName ("FakeQuantWithMinMaxVarsPerChannel", operName));
			c_api.TF_AddInput(desc, inputs);
			c_api.TF_AddInput(desc, min);
			c_api.TF_AddInput(desc, max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (num_bits.HasValue)
				c_api.TF_SetAttrInt (desc, "num_bits", num_bits.Value);
			
			if (narrow_range.HasValue)
				c_api.TF_SetAttrBool (desc, "narrow_range", Convert.ToByte(narrow_range.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var outputs = new TF_Output (op, _idx++);
			return outputs;
		}

		/// <summary>
		///   Compute gradients for a FakeQuantWithMinMaxVarsPerChannel operation.
		/// </summary>
		/// <param name="gradients">
		///   Backpropagated gradients above the FakeQuantWithMinMaxVars operation,
		///   shape one of: <c>[d]</c>, <c>[b, d]</c>,  <c>[b, h, w, d]</c>.
		/// </param>
		/// <param name="inputs">
		///   Values passed as inputs to the FakeQuantWithMinMaxVars operation, shape
		///   same as <c>gradients</c>.
		///   min, max: Quantization interval, floats of shape <c>[d]</c>.
		/// </param>
		/// <param name="min">
		/// </param>
		/// <param name="max">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxVarsPerChannelGradient'.
		/// </param>
		/// <param name="num_bits">
		///   Optional argument
		///   The bitwidth of the quantization; between 2 and 16, inclusive.
		/// </param>
		/// <param name="narrow_range">
		///   Optional argument
		///   Whether to quantize into 2^num_bits - 1 distinct values.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   backprops_wrt_input: Backpropagated gradients w.r.t. inputs, shape same as
		///   <c>inputs</c>:
		///   <c>gradients * (inputs &amp;gt;= min &amp;&amp; inputs &amp;lt;= max)</c>.
		///   backprop_wrt_min: Backpropagated gradients w.r.t. min parameter, shape <c>[d]</c>:
		///   <c>sum_per_d(gradients * (inputs &amp;lt; min))</c>.
		///   backprop_wrt_max: Backpropagated gradients w.r.t. max parameter, shape <c>[d]</c>:
		///   <c>sum_per_d(gradients * (inputs &amp;gt; max))</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output backprops_wrt_input, TF_Output backprop_wrt_min, TF_Output backprop_wrt_max) FakeQuantWithMinMaxVarsPerChannelGradient (TF_Output gradients, TF_Output inputs, TF_Output min, TF_Output max, long? num_bits = null, bool? narrow_range = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FakeQuantWithMinMaxVarsPerChannelGradient", MakeName ("FakeQuantWithMinMaxVarsPerChannelGradient", operName));
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, inputs);
			c_api.TF_AddInput(desc, min);
			c_api.TF_AddInput(desc, max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (num_bits.HasValue)
				c_api.TF_SetAttrInt (desc, "num_bits", num_bits.Value);
			
			if (narrow_range.HasValue)
				c_api.TF_SetAttrBool (desc, "narrow_range", Convert.ToByte(narrow_range.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var backprops_wrt_input = new TF_Output (op, _idx++);
			var backprop_wrt_min = new TF_Output (op, _idx++);
			var backprop_wrt_max = new TF_Output (op, _idx++);
			return (backprops_wrt_input, backprop_wrt_min, backprop_wrt_max);
		}

		/// <summary>
		///   Deprecated. Do not use.
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQueue'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FakeQueue (TF_Output resource, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FakeQueue", MakeName ("FakeQueue", operName));
			c_api.TF_AddInput(desc, resource);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Fast Fourier transform.
		/// </summary>
		/// <param name="input">
		///   A complex tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FFT'.
		/// </param>
		/// <returns>
		///   A complex tensor of the same shape as <c>input</c>. The inner-most
		///   dimension of <c>input</c> is replaced with its 1D Fourier transform.
		///   
		///   @compatibility(numpy)
		///   Equivalent to np.fft.fft
		///   @end_compatibility
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Computes the 1-dimensional discrete Fourier transform over the inner-most
		///   dimension of <c>input</c>.
		/// </remarks>
		public TF_Output FFT (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FFT", MakeName ("FFT", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   2D fast Fourier transform.
		/// </summary>
		/// <param name="input">
		///   A complex tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FFT2D'.
		/// </param>
		/// <returns>
		///   A complex tensor of the same shape as <c>input</c>. The inner-most 2
		///   dimensions of <c>input</c> are replaced with their 2D Fourier transform.
		///   
		///   @compatibility(numpy)
		///   Equivalent to np.fft.fft2
		///   @end_compatibility
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Computes the 2-dimensional discrete Fourier transform over the inner-most
		///   2 dimensions of <c>input</c>.
		/// </remarks>
		public TF_Output FFT2D (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FFT2D", MakeName ("FFT2D", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   3D fast Fourier transform.
		/// </summary>
		/// <param name="input">
		///   A complex64 tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FFT3D'.
		/// </param>
		/// <returns>
		///   A complex64 tensor of the same shape as <c>input</c>. The inner-most 3
		///   dimensions of <c>input</c> are replaced with their 3D Fourier transform.
		///   
		///   @compatibility(numpy)
		///   Equivalent to np.fft.fftn with 3 dimensions.
		///   @end_compatibility
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Computes the 3-dimensional discrete Fourier transform over the inner-most 3
		///   dimensions of <c>input</c>.
		/// </remarks>
		public TF_Output FFT3D (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FFT3D", MakeName ("FFT3D", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   A queue that produces elements in first-in first-out order.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FIFOQueue'.
		/// </param>
		/// <param name="shapes">
		///   Optional argument
		///   The shape of each component in a value. The length of this attr must
		///   be either 0 or the same as the length of component_types. If the length of
		///   this attr is 0, the shapes of queue elements are not constrained, and
		///   only one element may be dequeued at a time.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		///   The upper bound on the number of elements in this queue.
		///   Negative numbers mean no limit.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this queue is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this queue will be shared under the given name
		///   across multiple sessions.
		/// </param>
		/// <param name="component_types">
		///   The type of each component in a value.
		/// </param>
		/// <returns>
		///   The handle to the queue.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FIFOQueue (TF_DataType[] component_types, long[][] shapes = null, long? capacity = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FIFOQueue", MakeName ("FIFOQueue", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (shapes != null)
				c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   A queue that produces elements in first-in first-out order.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FIFOQueueV2'.
		/// </param>
		/// <param name="shapes">
		///   Optional argument
		///   The shape of each component in a value. The length of this attr must
		///   be either 0 or the same as the length of component_types. If the length of
		///   this attr is 0, the shapes of queue elements are not constrained, and
		///   only one element may be dequeued at a time.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		///   The upper bound on the number of elements in this queue.
		///   Negative numbers mean no limit.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this queue is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this queue will be shared under the given name
		///   across multiple sessions.
		/// </param>
		/// <param name="component_types">
		///   The type of each component in a value.
		/// </param>
		/// <returns>
		///   The handle to the queue.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FIFOQueueV2 (TF_DataType[] component_types, long[][] shapes = null, long? capacity = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FIFOQueueV2", MakeName ("FIFOQueueV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (shapes != null)
				c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a tensor filled with a scalar value.
		/// </summary>
		/// <param name="dims">
		///   1-D. Represents the shape of the output tensor.
		/// </param>
		/// <param name="value">
		///   0-D (scalar). Value to fill the returned tensor.
		///   
		///   @compatibility(numpy)
		///   Equivalent to np.full
		///   @end_compatibility
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Fill'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation creates a tensor of shape <c>dims</c> and fills it with <c>value</c>.
		///   
		///   For example:
		///   
		///    <code>
		///   # Output tensor has shape [2, 3].
		///   fill([2, 3], 9) ==&amp;gt; [[9, 9, 9]
		///   [9, 9, 9]]
		///    </code>
		///   
		///   <c>tf.fill</c> differs from <c>tf.constant</c> in a few ways:
		///   
		///   *   <c>tf.fill</c> only supports scalar contents, whereas <c>tf.constant</c> supports
		///   Tensor values.
		///   *   <c>tf.fill</c> creates an Op in the computation graph that constructs the actual
		///   Tensor value at runtime. This is in contrast to <c>tf.constant</c> which embeds
		///   the entire Tensor into the graph with a <c>Const</c> node.
		///   *   Because <c>tf.fill</c> evaluates at graph runtime, it supports dynamic shapes
		///   based on other runtime Tensors, unlike <c>tf.constant</c>.
		/// </remarks>
		public TF_Output Fill (TF_Output dims, TF_Output value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Fill", MakeName ("Fill", operName));
			c_api.TF_AddInput(desc, dims);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates a dataset containing elements of first component of <c>input_dataset</c> having true in the last component.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FilterByLastComponentDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FilterByLastComponentDataset (TF_Output input_dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FilterByLastComponentDataset", MakeName ("FilterByLastComponentDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates a dataset containing elements of <c>input_dataset</c> matching <c>predicate</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="other_arguments">
		///   A list of tensors, typically values that were captured when
		///   building a closure for <c>predicate</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FilterDataset'.
		/// </param>
		/// <param name="predicate">
		///   A function returning a scalar boolean.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The <c>predicate</c> function must return a scalar boolean and accept the
		///   following arguments:
		///   
		///   * One tensor for each component of an element of <c>input_dataset</c>.
		///   * One tensor for each value in <c>other_arguments</c>.
		/// </remarks>
		public TF_Output FilterDataset (TF_Output input_dataset, TF_Output[] other_arguments, TF_Function predicate, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FilterDataset", MakeName ("FilterDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInputList(desc, other_arguments[0], other_arguments.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "predicate", c_api.TF_FunctionName(predicate));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Generates fingerprint values.
		/// </summary>
		/// <param name="data">
		///   Must have rank 1 or higher.
		/// </param>
		/// <param name="method">
		///   Fingerprint method used by this op. Currently available method is
		///   <c>farmhash::fingerprint64</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Fingerprint'.
		/// </param>
		/// <returns>
		///   A two-dimensional <c>Tensor</c> of type <c>tf.uint8</c>. The first dimension equals to
		///   <c>data</c>'s first dimension, and the second dimension size depends on the
		///   fingerprint algorithm.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Generates fingerprint values of <c>data</c>.
		///   
		///   Fingerprint op considers the first dimension of <c>data</c> as the batch dimension,
		///   and <c>output[i]</c> contains the fingerprint value generated from contents in
		///   <c>data[i, ...]</c> for all <c>i</c>.
		///   
		///   Fingerprint op writes fingerprint values as byte arrays. For example, the
		///   default method <c>farmhash64</c> generates a 64-bit fingerprint value at a time.
		///   This 8-byte value is written out as an <c>uint8</c> array of size 8, in little-endian
		///   order.
		///   
		///   For example, suppose that <c>data</c> has data type <c>DT_INT32</c> and shape (2, 3, 4),
		///   and that the fingerprint method is <c>farmhash64</c>. In this case, the output shape
		///   is (2, 8), where 2 is the batch dimension size of <c>data</c>, and 8 is the size of
		///   each fingerprint value in bytes. <c>output[0, :]</c> is generated from 12 integers in
		///   <c>data[0, :, :]</c> and similarly <c>output[1, :]</c> is generated from other 12 integers
		///   in <c>data[1, :, :]</c>.
		///   
		///   Note that this op fingerprints the raw underlying buffer, and it does not
		///   fingerprint Tensor's metadata such as data type and/or shape. For example, the
		///   fingerprint values are invariant under reshapes and bitcasts as long as the
		///   batch dimension remain the same:
		///   
		///    <code>
		///   Fingerprint(data) == Fingerprint(Reshape(data, ...))
		///   Fingerprint(data) == Fingerprint(Bitcast(data, ...))
		///    </code>
		///   
		///   For string data, one should expect <c>Fingerprint(data) !=
		///   Fingerprint(ReduceJoin(data))</c> in general.
		/// </remarks>
		public TF_Output Fingerprint (TF_Output data, TF_Output method, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Fingerprint", MakeName ("Fingerprint", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, method);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var fingerprint = new TF_Output (op, _idx++);
			return fingerprint;
		}

		/// <summary>
		///   Creates a dataset that emits the records from one or more binary files.
		/// </summary>
		/// <param name="filenames">
		///   A scalar or a vector containing the name(s) of the file(s) to be
		///   read.
		/// </param>
		/// <param name="header_bytes">
		///   A scalar representing the number of bytes to skip at the
		///   beginning of a file.
		/// </param>
		/// <param name="record_bytes">
		///   A scalar representing the number of bytes in each record.
		/// </param>
		/// <param name="footer_bytes">
		///   A scalar representing the number of bytes to skip at the end
		///   of a file.
		/// </param>
		/// <param name="buffer_size">
		///   A scalar representing the number of bytes to buffer. Must be &amp;gt; 0.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FixedLengthRecordDataset'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FixedLengthRecordDataset (TF_Output filenames, TF_Output header_bytes, TF_Output record_bytes, TF_Output footer_bytes, TF_Output buffer_size, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FixedLengthRecordDataset", MakeName ("FixedLengthRecordDataset", operName));
			c_api.TF_AddInput(desc, filenames);
			c_api.TF_AddInput(desc, header_bytes);
			c_api.TF_AddInput(desc, record_bytes);
			c_api.TF_AddInput(desc, footer_bytes);
			c_api.TF_AddInput(desc, buffer_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="filenames">
		/// </param>
		/// <param name="header_bytes">
		/// </param>
		/// <param name="record_bytes">
		/// </param>
		/// <param name="footer_bytes">
		/// </param>
		/// <param name="buffer_size">
		/// </param>
		/// <param name="compression_type">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FixedLengthRecordDatasetV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FixedLengthRecordDatasetV2 (TF_Output filenames, TF_Output header_bytes, TF_Output record_bytes, TF_Output footer_bytes, TF_Output buffer_size, TF_Output compression_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FixedLengthRecordDatasetV2", MakeName ("FixedLengthRecordDatasetV2", operName));
			c_api.TF_AddInput(desc, filenames);
			c_api.TF_AddInput(desc, header_bytes);
			c_api.TF_AddInput(desc, record_bytes);
			c_api.TF_AddInput(desc, footer_bytes);
			c_api.TF_AddInput(desc, buffer_size);
			c_api.TF_AddInput(desc, compression_type);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   A Reader that outputs fixed-length records from a file.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FixedLengthRecordReader'.
		/// </param>
		/// <param name="header_bytes">
		///   Optional argument
		///   Number of bytes in the header, defaults to 0.
		/// </param>
		/// <param name="footer_bytes">
		///   Optional argument
		///   Number of bytes in the footer, defaults to 0.
		/// </param>
		/// <param name="hop_bytes">
		///   Optional argument
		///   Number of bytes to hop before each read. Default of 0 means using
		///   record_bytes.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this reader is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this reader is named in the given bucket
		///   with this shared_name. Otherwise, the node name is used instead.
		/// </param>
		/// <param name="record_bytes">
		///   Number of bytes in the record.
		/// </param>
		/// <returns>
		///   The handle to reference the Reader.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FixedLengthRecordReader (long record_bytes, long? header_bytes = null, long? footer_bytes = null, long? hop_bytes = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FixedLengthRecordReader", MakeName ("FixedLengthRecordReader", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "record_bytes", record_bytes);
			if (header_bytes.HasValue)
				c_api.TF_SetAttrInt (desc, "header_bytes", header_bytes.Value);
			
			if (footer_bytes.HasValue)
				c_api.TF_SetAttrInt (desc, "footer_bytes", footer_bytes.Value);
			
			if (hop_bytes.HasValue)
				c_api.TF_SetAttrInt (desc, "hop_bytes", hop_bytes.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		///   A Reader that outputs fixed-length records from a file.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FixedLengthRecordReaderV2'.
		/// </param>
		/// <param name="header_bytes">
		///   Optional argument
		///   Number of bytes in the header, defaults to 0.
		/// </param>
		/// <param name="footer_bytes">
		///   Optional argument
		///   Number of bytes in the footer, defaults to 0.
		/// </param>
		/// <param name="hop_bytes">
		///   Optional argument
		///   Number of bytes to hop before each read. Default of 0 means using
		///   record_bytes.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this reader is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this reader is named in the given bucket
		///   with this shared_name. Otherwise, the node name is used instead.
		/// </param>
		/// <param name="encoding">
		///   Optional argument
		///   The type of encoding for the file. Currently ZLIB and GZIP
		///   are supported. Defaults to none.
		/// </param>
		/// <param name="record_bytes">
		///   Number of bytes in the record.
		/// </param>
		/// <returns>
		///   The handle to reference the Reader.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FixedLengthRecordReaderV2 (long record_bytes, long? header_bytes = null, long? footer_bytes = null, long? hop_bytes = null, string container = null, string shared_name = null, string encoding = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FixedLengthRecordReaderV2", MakeName ("FixedLengthRecordReaderV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "record_bytes", record_bytes);
			if (header_bytes.HasValue)
				c_api.TF_SetAttrInt (desc, "header_bytes", header_bytes.Value);
			
			if (footer_bytes.HasValue)
				c_api.TF_SetAttrInt (desc, "footer_bytes", footer_bytes.Value);
			
			if (hop_bytes.HasValue)
				c_api.TF_SetAttrInt (desc, "hop_bytes", hop_bytes.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (encoding != null)
				c_api.TF_SetAttrString (desc, "encoding", encoding);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		///   Generates labels for candidate sampling with a learned unigram distribution.
		/// </summary>
		/// <param name="true_classes">
		///   A batch_size * num_true matrix, in which each row contains the
		///   IDs of the num_true target_classes in the corresponding original label.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FixedUnigramCandidateSampler'.
		/// </param>
		/// <param name="vocab_file">
		///   Optional argument
		///   Each valid line in this file (which should have a CSV-like format)
		///   corresponds to a valid word ID. IDs are in sequential order, starting from
		///   num_reserved_ids. The last entry in each line is expected to be a value
		///   corresponding to the count or relative probability. Exactly one of vocab_file
		///   and unigrams needs to be passed to this op.
		/// </param>
		/// <param name="distortion">
		///   Optional argument
		///   The distortion is used to skew the unigram probability distribution.
		///   Each weight is first raised to the distortion's power before adding to the
		///   internal unigram distribution. As a result, distortion = 1.0 gives regular
		///   unigram sampling (as defined by the vocab file), and distortion = 0.0 gives
		///   a uniform distribution.
		/// </param>
		/// <param name="num_reserved_ids">
		///   Optional argument
		///   Optionally some reserved IDs can be added in the range [0,
		///   ..., num_reserved_ids) by the users. One use case is that a special unknown
		///   word token is used as ID 0. These IDs will have a sampling probability of 0.
		/// </param>
		/// <param name="num_shards">
		///   Optional argument
		///   A sampler can be used to sample from a subset of the original range
		///   in order to speed up the whole computation through parallelism. This parameter
		///   (together with 'shard') indicates the number of partitions that are being
		///   used in the overall computation.
		/// </param>
		/// <param name="shard">
		///   Optional argument
		///   A sampler can be used to sample from a subset of the original range
		///   in order to speed up the whole computation through parallelism. This parameter
		///   (together with 'num_shards') indicates the particular partition number of a
		///   sampler op, when partitioning is being used.
		/// </param>
		/// <param name="unigrams">
		///   Optional argument
		///   A list of unigram counts or probabilities, one per ID in sequential
		///   order. Exactly one of vocab_file and unigrams should be passed to this op.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either seed or seed2 are set to be non-zero, the random number
		///   generator is seeded by the given seed.  Otherwise, it is seeded by a
		///   random seed.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   An second seed to avoid seed collision.
		/// </param>
		/// <param name="num_true">
		///   Number of true labels per context.
		/// </param>
		/// <param name="num_sampled">
		///   Number of candidates to randomly sample.
		/// </param>
		/// <param name="unique">
		///   If unique is true, we sample with rejection, so that all sampled
		///   candidates in a batch are unique. This requires some approximation to
		///   estimate the post-rejection sampling probabilities.
		/// </param>
		/// <param name="range_max">
		///   The sampler will sample integers from the interval [0, range_max).
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sampled_candidates: A vector of length num_sampled, in which each element is
		///   the ID of a sampled candidate.
		///   true_expected_count: A batch_size * num_true matrix, representing
		///   the number of times each candidate is expected to occur in a batch
		///   of sampled candidates. If unique=true, then this is a probability.
		///   sampled_expected_count: A vector of length num_sampled, for each sampled
		///   candidate representing the number of times the candidate is expected
		///   to occur in a batch of sampled candidates.  If unique=true, then this is a
		///   probability.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   A unigram sampler could use a fixed unigram distribution read from a
		///   file or passed in as an in-memory array instead of building up the distribution
		///   from data on the fly. There is also an option to skew the distribution by
		///   applying a distortion power to the weights.
		///   
		///   The vocabulary file should be in CSV-like format, with the last field
		///   being the weight associated with the word.
		///   
		///   For each batch, this op picks a single set of sampled candidate labels.
		///   
		///   The advantages of sampling candidates per-batch are simplicity and the
		///   possibility of efficient dense matrix multiplication. The disadvantage is that
		///   the sampled candidates must be chosen independently of the context and of the
		///   true labels.
		/// </remarks>
		public (TF_Output sampled_candidates, TF_Output true_expected_count, TF_Output sampled_expected_count) FixedUnigramCandidateSampler (TF_Output true_classes, long num_true, long num_sampled, bool unique, long range_max, string vocab_file = null, float? distortion = null, long? num_reserved_ids = null, long? num_shards = null, long? shard = null, float[] unigrams = null, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FixedUnigramCandidateSampler", MakeName ("FixedUnigramCandidateSampler", operName));
			c_api.TF_AddInput(desc, true_classes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_true", num_true);
			c_api.TF_SetAttrInt (desc, "num_sampled", num_sampled);
			c_api.TF_SetAttrBool (desc, "unique", Convert.ToByte(unique));
			c_api.TF_SetAttrInt (desc, "range_max", range_max);
			if (vocab_file != null)
				c_api.TF_SetAttrString (desc, "vocab_file", vocab_file);
			
			if (distortion.HasValue)
				c_api.TF_SetAttrFloat (desc, "distortion", distortion.Value);
			
			if (num_reserved_ids.HasValue)
				c_api.TF_SetAttrInt (desc, "num_reserved_ids", num_reserved_ids.Value);
			
			if (num_shards.HasValue)
				c_api.TF_SetAttrInt (desc, "num_shards", num_shards.Value);
			
			if (shard.HasValue)
				c_api.TF_SetAttrInt (desc, "shard", shard.Value);
			
			if (unigrams != null)
				c_api.TF_SetAttrFloatList (desc, "unigrams", ref unigrams[0], unigrams.Length);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var sampled_candidates = new TF_Output (op, _idx++);
			var true_expected_count = new TF_Output (op, _idx++);
			var sampled_expected_count = new TF_Output (op, _idx++);
			return (sampled_candidates, true_expected_count, sampled_expected_count);
		}

		/// <summary>
		///   Creates a dataset that applies <c>f</c> to the outputs of <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="other_arguments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FlatMapDataset'.
		/// </param>
		/// <param name="f">
		///   A function mapping elements of <c>input_dataset</c>, concatenated with
		///   <c>other_arguments</c>, to a Dataset variant that contains elements matching
		///   <c>output_types</c> and <c>output_shapes</c>.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Unlike MapDataset, the <c>f</c> in FlatMapDataset is expected to return a
		///   Dataset variant, and FlatMapDataset will flatten successive results
		///   into a single Dataset.
		/// </remarks>
		public TF_Output FlatMapDataset (TF_Output input_dataset, TF_Output[] other_arguments, TF_Function f, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FlatMapDataset", MakeName ("FlatMapDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInputList(desc, other_arguments[0], other_arguments.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "f", c_api.TF_FunctionName(f));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Returns element-wise largest integer not greater than x.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Floor'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Floor (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Floor", MakeName ("Floor", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Returns x // y element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FloorDiv'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   *NOTE*: <c>FloorDiv</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output FloorDiv (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FloorDiv", MakeName ("FloorDiv", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Returns element-wise remainder of division. When <c>x &amp;lt; 0</c> xor <c>y &amp;lt; 0</c> is
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FloorMod'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   true, this follows Python semantics in that the result here is consistent
		///   with a flooring divide. E.g. <c>floor(x / y) * y + mod(x, y) = x</c>.
		///   
		///   *NOTE*: <c>FloorMod</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output FloorMod (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FloorMod", MakeName ("FloorMod", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FlushSummaryWriter'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation FlushSummaryWriter (TF_Output writer, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FlushSummaryWriter", MakeName ("FlushSummaryWriter", operName));
			c_api.TF_AddInput(desc, writer);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///    <code>
		///   output = input;
		///   for i in range(start, limit, delta)
		///   output = body(i, output);
		///    </code>
		/// </summary>
		/// <param name="start">
		///   The lower bound. An int32
		/// </param>
		/// <param name="limit">
		///   The upper bound. An int32
		/// </param>
		/// <param name="delta">
		///   The increment. An int32
		/// </param>
		/// <param name="input">
		///   A list of input tensors whose types are T.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'For'.
		/// </param>
		/// <param name="body">
		///   A function that takes a list of tensors (int32, T) and returns another
		///   list of tensors (T).
		/// </param>
		/// <returns>
		///   A list of output tensors whose types are T.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] For (TF_Output start, TF_Output limit, TF_Output delta, TF_Output[] input, TF_Function body, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "For", MakeName ("For", operName));
			c_api.TF_AddInput(desc, start);
			c_api.TF_AddInput(desc, limit);
			c_api.TF_AddInput(desc, delta);
			c_api.TF_AddInputList(desc, input[0], input.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "body", c_api.TF_FunctionName(body));
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		///   Performs fractional average pooling on the input.
		/// </summary>
		/// <param name="value">
		///   4-D with shape <c>[batch, height, width, channels]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FractionalAvgPool'.
		/// </param>
		/// <param name="pseudo_random">
		///   Optional argument
		///   When set to True, generates the pooling sequence in a
		///   pseudorandom fashion, otherwise, in a random fashion. Check paper [Benjamin
		///   Graham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071) for
		///   difference between pseudorandom and random.
		/// </param>
		/// <param name="overlapping">
		///   Optional argument
		///   When set to True, it means when pooling, the values at the boundary
		///   of adjacent pooling cells are used by both cells. For example:
		///   
		///   <c>index  0  1  2  3  4</c>
		///   
		///   <c>value  20 5  16 3  7</c>
		///   
		///   If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.
		///   The result would be [41/3, 26/3] for fractional avg pooling.
		/// </param>
		/// <param name="deterministic">
		///   Optional argument
		///   When set to True, a fixed pooling region will be used when
		///   iterating over a FractionalAvgPool node in the computation graph. Mainly used
		///   in unit test to make FractionalAvgPool deterministic.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either seed or seed2 are set to be non-zero, the random number
		///   generator is seeded by the given seed.  Otherwise, it is seeded by a
		///   random seed.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   An second seed to avoid seed collision.
		/// </param>
		/// <param name="pooling_ratio">
		///   Pooling ratio for each dimension of <c>value</c>, currently only
		///   supports row and col dimension and should be &amp;gt;= 1.0. For example, a valid
		///   pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements
		///   must be 1.0 because we don't allow pooling on batch and channels
		///   dimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions
		///   respectively.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output: output tensor after fractional avg pooling.
		///   row_pooling_sequence: row pooling sequence, needed to calculate gradient.
		///   col_pooling_sequence: column pooling sequence, needed to calculate gradient.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Fractional average pooling is similar to Fractional max pooling in the pooling
		///   region generation step. The only difference is that after pooling regions are
		///   generated, a mean operation is performed instead of a max operation in each
		///   pooling region.
		/// </remarks>
		public (TF_Output output, TF_Output row_pooling_sequence, TF_Output col_pooling_sequence) FractionalAvgPool (TF_Output value, float[] pooling_ratio, bool? pseudo_random = null, bool? overlapping = null, bool? deterministic = null, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FractionalAvgPool", MakeName ("FractionalAvgPool", operName));
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFloatList (desc, "pooling_ratio", ref pooling_ratio[0], pooling_ratio.Length);
			if (pseudo_random.HasValue)
				c_api.TF_SetAttrBool (desc, "pseudo_random", Convert.ToByte(pseudo_random.Value));
			
			if (overlapping.HasValue)
				c_api.TF_SetAttrBool (desc, "overlapping", Convert.ToByte(overlapping.Value));
			
			if (deterministic.HasValue)
				c_api.TF_SetAttrBool (desc, "deterministic", Convert.ToByte(deterministic.Value));
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var row_pooling_sequence = new TF_Output (op, _idx++);
			var col_pooling_sequence = new TF_Output (op, _idx++);
			return (output, row_pooling_sequence, col_pooling_sequence);
		}

		/// <summary>
		///   Computes gradient of the FractionalAvgPool function.
		/// </summary>
		/// <param name="orig_input_tensor_shape">
		///   Original input tensor shape for <c>fractional_avg_pool</c>
		/// </param>
		/// <param name="out_backprop">
		///   4-D with shape <c>[batch, height, width, channels]</c>.  Gradients
		///   w.r.t. the output of <c>fractional_avg_pool</c>.
		/// </param>
		/// <param name="row_pooling_sequence">
		///   row pooling sequence, form pooling region with
		///   col_pooling_sequence.
		/// </param>
		/// <param name="col_pooling_sequence">
		///   column pooling sequence, form pooling region with
		///   row_pooling sequence.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FractionalAvgPoolGrad'.
		/// </param>
		/// <param name="overlapping">
		///   Optional argument
		///   When set to True, it means when pooling, the values at the boundary
		///   of adjacent pooling cells are used by both cells. For example:
		///   
		///   <c>index  0  1  2  3  4</c>
		///   
		///   <c>value  20 5  16 3  7</c>
		///   
		///   If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.
		///   The result would be [41/3, 26/3] for fractional avg pooling.
		/// </param>
		/// <returns>
		///   4-D.  Gradients w.r.t. the input of <c>fractional_avg_pool</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Unlike FractionalMaxPoolGrad, we don't need to find arg_max for
		///   FractionalAvgPoolGrad, we just need to evenly back-propagate each element of
		///   out_backprop to those indices that form the same pooling cell. Therefore, we
		///   just need to know the shape of original input tensor, instead of the whole
		///   tensor.
		/// </remarks>
		public TF_Output FractionalAvgPoolGrad (TF_Output orig_input_tensor_shape, TF_Output out_backprop, TF_Output row_pooling_sequence, TF_Output col_pooling_sequence, bool? overlapping = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FractionalAvgPoolGrad", MakeName ("FractionalAvgPoolGrad", operName));
			c_api.TF_AddInput(desc, orig_input_tensor_shape);
			c_api.TF_AddInput(desc, out_backprop);
			c_api.TF_AddInput(desc, row_pooling_sequence);
			c_api.TF_AddInput(desc, col_pooling_sequence);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (overlapping.HasValue)
				c_api.TF_SetAttrBool (desc, "overlapping", Convert.ToByte(overlapping.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Performs fractional max pooling on the input.
		/// </summary>
		/// <param name="value">
		///   4-D with shape <c>[batch, height, width, channels]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FractionalMaxPool'.
		/// </param>
		/// <param name="pseudo_random">
		///   Optional argument
		///   When set to True, generates the pooling sequence in a
		///   pseudorandom fashion, otherwise, in a random fashion. Check paper [Benjamin
		///   Graham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071) for
		///   difference between pseudorandom and random.
		/// </param>
		/// <param name="overlapping">
		///   Optional argument
		///   When set to True, it means when pooling, the values at the boundary
		///   of adjacent pooling cells are used by both cells. For example:
		///   
		///   <c>index  0  1  2  3  4</c>
		///   
		///   <c>value  20 5  16 3  7</c>
		///   
		///   If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.
		///   The result would be [20, 16] for fractional max pooling.
		/// </param>
		/// <param name="deterministic">
		///   Optional argument
		///   When set to True, a fixed pooling region will be used when
		///   iterating over a FractionalMaxPool node in the computation graph. Mainly used
		///   in unit test to make FractionalMaxPool deterministic.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either seed or seed2 are set to be non-zero, the random number
		///   generator is seeded by the given seed.  Otherwise, it is seeded by a
		///   random seed.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   An second seed to avoid seed collision.
		/// </param>
		/// <param name="pooling_ratio">
		///   Pooling ratio for each dimension of <c>value</c>, currently only
		///   supports row and col dimension and should be &amp;gt;= 1.0. For example, a valid
		///   pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements
		///   must be 1.0 because we don't allow pooling on batch and channels
		///   dimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions
		///   respectively.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output: output tensor after fractional max pooling.
		///   row_pooling_sequence: row pooling sequence, needed to calculate gradient.
		///   col_pooling_sequence: column pooling sequence, needed to calculate gradient.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Fractional max pooling is slightly different than regular max pooling.  In
		///   regular max pooling, you downsize an input set by taking the maximum value of
		///   smaller N x N subsections of the set (often 2x2), and try to reduce the set by
		///   a factor of N, where N is an integer.  Fractional max pooling, as you might
		///   expect from the word "fractional", means that the overall reduction ratio N
		///   does not have to be an integer.
		///   
		///   The sizes of the pooling regions are generated randomly but are fairly uniform.
		///   For example, let's look at the height dimension, and the constraints on the
		///   list of rows that will be pool boundaries.
		///   
		///   First we define the following:
		///   
		///   1.  input_row_length : the number of rows from the input set
		///   2.  output_row_length : which will be smaller than the input
		///   3.  alpha = input_row_length / output_row_length : our reduction ratio
		///   4.  K = floor(alpha)
		///   5.  row_pooling_sequence : this is the result list of pool boundary rows
		///   
		///   Then, row_pooling_sequence should satisfy:
		///   
		///   1.  a[0] = 0 : the first value of the sequence is 0
		///   2.  a[end] = input_row_length : the last value of the sequence is the size
		///   3.  K &amp;lt;= (a[i+1] - a[i]) &amp;lt;= K+1 : all intervals are K or K+1 size
		///   4.  length(row_pooling_sequence) = output_row_length+1
		///   
		///   For more details on fractional max pooling, see this paper:
		///   [Benjamin Graham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071)
		/// </remarks>
		public (TF_Output output, TF_Output row_pooling_sequence, TF_Output col_pooling_sequence) FractionalMaxPool (TF_Output value, float[] pooling_ratio, bool? pseudo_random = null, bool? overlapping = null, bool? deterministic = null, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FractionalMaxPool", MakeName ("FractionalMaxPool", operName));
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFloatList (desc, "pooling_ratio", ref pooling_ratio[0], pooling_ratio.Length);
			if (pseudo_random.HasValue)
				c_api.TF_SetAttrBool (desc, "pseudo_random", Convert.ToByte(pseudo_random.Value));
			
			if (overlapping.HasValue)
				c_api.TF_SetAttrBool (desc, "overlapping", Convert.ToByte(overlapping.Value));
			
			if (deterministic.HasValue)
				c_api.TF_SetAttrBool (desc, "deterministic", Convert.ToByte(deterministic.Value));
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var row_pooling_sequence = new TF_Output (op, _idx++);
			var col_pooling_sequence = new TF_Output (op, _idx++);
			return (output, row_pooling_sequence, col_pooling_sequence);
		}

		/// <summary>
		///   Computes gradient of the FractionalMaxPool function.
		/// </summary>
		/// <param name="orig_input">
		///   Original input for <c>fractional_max_pool</c>
		/// </param>
		/// <param name="orig_output">
		///   Original output for <c>fractional_max_pool</c>
		/// </param>
		/// <param name="out_backprop">
		///   4-D with shape <c>[batch, height, width, channels]</c>.  Gradients
		///   w.r.t. the output of <c>fractional_max_pool</c>.
		/// </param>
		/// <param name="row_pooling_sequence">
		///   row pooling sequence, form pooling region with
		///   col_pooling_sequence.
		/// </param>
		/// <param name="col_pooling_sequence">
		///   column pooling sequence, form pooling region with
		///   row_pooling sequence.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FractionalMaxPoolGrad'.
		/// </param>
		/// <param name="overlapping">
		///   Optional argument
		///   When set to True, it means when pooling, the values at the boundary
		///   of adjacent pooling cells are used by both cells. For example:
		///   
		///   <c>index  0  1  2  3  4</c>
		///   
		///   <c>value  20 5  16 3  7</c>
		///   
		///   If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.
		///   The result would be [20, 16] for fractional max pooling.
		/// </param>
		/// <returns>
		///   4-D.  Gradients w.r.t. the input of <c>fractional_max_pool</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output FractionalMaxPoolGrad (TF_Output orig_input, TF_Output orig_output, TF_Output out_backprop, TF_Output row_pooling_sequence, TF_Output col_pooling_sequence, bool? overlapping = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FractionalMaxPoolGrad", MakeName ("FractionalMaxPoolGrad", operName));
			c_api.TF_AddInput(desc, orig_input);
			c_api.TF_AddInput(desc, orig_output);
			c_api.TF_AddInput(desc, out_backprop);
			c_api.TF_AddInput(desc, row_pooling_sequence);
			c_api.TF_AddInput(desc, col_pooling_sequence);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (overlapping.HasValue)
				c_api.TF_SetAttrBool (desc, "overlapping", Convert.ToByte(overlapping.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Batch normalization.
		/// </summary>
		/// <param name="x">
		///   A 4D Tensor for input data.
		/// </param>
		/// <param name="scale">
		///   A 1D Tensor for scaling factor, to scale the normalized x.
		/// </param>
		/// <param name="offset">
		///   A 1D Tensor for offset, to shift to the normalized x.
		/// </param>
		/// <param name="mean">
		///   A 1D Tensor for population mean. Used for inference only;
		///   must be empty for training.
		/// </param>
		/// <param name="variance">
		///   A 1D Tensor for population variance. Used for inference only;
		///   must be empty for training.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedBatchNorm'.
		/// </param>
		/// <param name="epsilon">
		///   Optional argument
		///   A small float number added to the variance of x.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   The data format for x and y. Either "NHWC" (default) or "NCHW".
		/// </param>
		/// <param name="is_training">
		///   Optional argument
		///   A bool value to indicate the operation is for training (default)
		///   or inference.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   y: A 4D Tensor for output data.
		///   batch_mean: A 1D Tensor for the computed batch mean, to be used by TensorFlow
		///   to compute the running mean.
		///   batch_variance: A 1D Tensor for the computed batch variance, to be used by
		///   TensorFlow to compute the running variance.
		///   reserve_space_1: A 1D Tensor for the computed batch mean, to be reused
		///   in the gradient computation.
		///   reserve_space_2: A 1D Tensor for the computed batch variance (inverted variance
		///   in the cuDNN case), to be reused in the gradient computation.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Note that the size of 4D Tensors are defined by either "NHWC" or "NCHW".
		///   The size of 1D Tensors matches the dimension C of the 4D Tensors.
		/// </remarks>
		public (TF_Output y, TF_Output batch_mean, TF_Output batch_variance, TF_Output reserve_space_1, TF_Output reserve_space_2) FusedBatchNorm (TF_Output x, TF_Output scale, TF_Output offset, TF_Output mean, TF_Output variance, float? epsilon = null, string data_format = null, bool? is_training = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FusedBatchNorm", MakeName ("FusedBatchNorm", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, scale);
			c_api.TF_AddInput(desc, offset);
			c_api.TF_AddInput(desc, mean);
			c_api.TF_AddInput(desc, variance);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (epsilon.HasValue)
				c_api.TF_SetAttrFloat (desc, "epsilon", epsilon.Value);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (is_training.HasValue)
				c_api.TF_SetAttrBool (desc, "is_training", Convert.ToByte(is_training.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			var batch_mean = new TF_Output (op, _idx++);
			var batch_variance = new TF_Output (op, _idx++);
			var reserve_space_1 = new TF_Output (op, _idx++);
			var reserve_space_2 = new TF_Output (op, _idx++);
			return (y, batch_mean, batch_variance, reserve_space_1, reserve_space_2);
		}

		/// <summary>
		///   Gradient for batch normalization.
		/// </summary>
		/// <param name="y_backprop">
		///   A 4D Tensor for the gradient with respect to y.
		/// </param>
		/// <param name="x">
		///   A 4D Tensor for input data.
		/// </param>
		/// <param name="scale">
		///   A 1D Tensor for scaling factor, to scale the normalized x.
		/// </param>
		/// <param name="reserve_space_1">
		///   When is_training is True, a 1D Tensor for the computed batch
		///   mean to be reused in gradient computation. When is_training is
		///   False, a 1D Tensor for the population mean to be reused in both
		///   1st and 2nd order gradient computation.
		/// </param>
		/// <param name="reserve_space_2">
		///   When is_training is True, a 1D Tensor for the computed batch
		///   variance (inverted variance in the cuDNN case) to be reused in
		///   gradient computation. When is_training is False, a 1D Tensor
		///   for the population variance to be reused in both 1st and 2nd
		///   order gradient computation.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedBatchNormGrad'.
		/// </param>
		/// <param name="epsilon">
		///   Optional argument
		///   A small float number added to the variance of x.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   The data format for y_backprop, x, x_backprop.
		///   Either "NHWC" (default) or "NCHW".
		/// </param>
		/// <param name="is_training">
		///   Optional argument
		///   A bool value to indicate the operation is for training (default)
		///   or inference.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   x_backprop: A 4D Tensor for the gradient with respect to x.
		///   scale_backprop: A 1D Tensor for the gradient with respect to scale.
		///   offset_backprop: A 1D Tensor for the gradient with respect to offset.
		///   reserve_space_3: Unused placeholder to match the mean input in FusedBatchNorm.
		///   reserve_space_4: Unused placeholder to match the variance input
		///   in FusedBatchNorm.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Note that the size of 4D Tensors are defined by either "NHWC" or "NCHW".
		///   The size of 1D Tensors matches the dimension C of the 4D Tensors.
		/// </remarks>
		public (TF_Output x_backprop, TF_Output scale_backprop, TF_Output offset_backprop, TF_Output reserve_space_3, TF_Output reserve_space_4) FusedBatchNormGrad (TF_Output y_backprop, TF_Output x, TF_Output scale, TF_Output reserve_space_1, TF_Output reserve_space_2, float? epsilon = null, string data_format = null, bool? is_training = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FusedBatchNormGrad", MakeName ("FusedBatchNormGrad", operName));
			c_api.TF_AddInput(desc, y_backprop);
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, scale);
			c_api.TF_AddInput(desc, reserve_space_1);
			c_api.TF_AddInput(desc, reserve_space_2);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (epsilon.HasValue)
				c_api.TF_SetAttrFloat (desc, "epsilon", epsilon.Value);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (is_training.HasValue)
				c_api.TF_SetAttrBool (desc, "is_training", Convert.ToByte(is_training.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var x_backprop = new TF_Output (op, _idx++);
			var scale_backprop = new TF_Output (op, _idx++);
			var offset_backprop = new TF_Output (op, _idx++);
			var reserve_space_3 = new TF_Output (op, _idx++);
			var reserve_space_4 = new TF_Output (op, _idx++);
			return (x_backprop, scale_backprop, offset_backprop, reserve_space_3, reserve_space_4);
		}

		/// <summary>
		///   Gradient for batch normalization.
		/// </summary>
		/// <param name="y_backprop">
		///   A 4D Tensor for the gradient with respect to y.
		/// </param>
		/// <param name="x">
		///   A 4D Tensor for input data.
		/// </param>
		/// <param name="scale">
		///   A 1D Tensor for scaling factor, to scale the normalized x.
		/// </param>
		/// <param name="reserve_space_1">
		///   When is_training is True, a 1D Tensor for the computed batch
		///   mean to be reused in gradient computation. When is_training is
		///   False, a 1D Tensor for the population mean to be reused in both
		///   1st and 2nd order gradient computation.
		/// </param>
		/// <param name="reserve_space_2">
		///   When is_training is True, a 1D Tensor for the computed batch
		///   variance (inverted variance in the cuDNN case) to be reused in
		///   gradient computation. When is_training is False, a 1D Tensor
		///   for the population variance to be reused in both 1st and 2nd
		///   order gradient computation.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedBatchNormGradV2'.
		/// </param>
		/// <param name="epsilon">
		///   Optional argument
		///   A small float number added to the variance of x.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   The data format for y_backprop, x, x_backprop.
		///   Either "NHWC" (default) or "NCHW".
		/// </param>
		/// <param name="is_training">
		///   Optional argument
		///   A bool value to indicate the operation is for training (default)
		///   or inference.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   x_backprop: A 4D Tensor for the gradient with respect to x.
		///   scale_backprop: A 1D Tensor for the gradient with respect to scale.
		///   offset_backprop: A 1D Tensor for the gradient with respect to offset.
		///   reserve_space_3: Unused placeholder to match the mean input in FusedBatchNorm.
		///   reserve_space_4: Unused placeholder to match the variance input
		///   in FusedBatchNorm.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Note that the size of 4D Tensors are defined by either "NHWC" or "NCHW".
		///   The size of 1D Tensors matches the dimension C of the 4D Tensors.
		/// </remarks>
		public (TF_Output x_backprop, TF_Output scale_backprop, TF_Output offset_backprop, TF_Output reserve_space_3, TF_Output reserve_space_4) FusedBatchNormGradV2 (TF_Output y_backprop, TF_Output x, TF_Output scale, TF_Output reserve_space_1, TF_Output reserve_space_2, float? epsilon = null, string data_format = null, bool? is_training = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FusedBatchNormGradV2", MakeName ("FusedBatchNormGradV2", operName));
			c_api.TF_AddInput(desc, y_backprop);
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, scale);
			c_api.TF_AddInput(desc, reserve_space_1);
			c_api.TF_AddInput(desc, reserve_space_2);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (epsilon.HasValue)
				c_api.TF_SetAttrFloat (desc, "epsilon", epsilon.Value);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (is_training.HasValue)
				c_api.TF_SetAttrBool (desc, "is_training", Convert.ToByte(is_training.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var x_backprop = new TF_Output (op, _idx++);
			var scale_backprop = new TF_Output (op, _idx++);
			var offset_backprop = new TF_Output (op, _idx++);
			var reserve_space_3 = new TF_Output (op, _idx++);
			var reserve_space_4 = new TF_Output (op, _idx++);
			return (x_backprop, scale_backprop, offset_backprop, reserve_space_3, reserve_space_4);
		}

		/// <summary>
		///   Gradient for batch normalization.
		/// </summary>
		/// <param name="y_backprop">
		///   A 4D Tensor for the gradient with respect to y.
		/// </param>
		/// <param name="x">
		///   A 4D Tensor for input data.
		/// </param>
		/// <param name="scale">
		///   A 1D Tensor for scaling factor, to scale the normalized x.
		/// </param>
		/// <param name="reserve_space_1">
		///   When is_training is True, a 1D Tensor for the computed batch
		///   mean to be reused in gradient computation. When is_training is
		///   False, a 1D Tensor for the population mean to be reused in both
		///   1st and 2nd order gradient computation.
		/// </param>
		/// <param name="reserve_space_2">
		///   When is_training is True, a 1D Tensor for the computed batch
		///   variance (inverted variance in the cuDNN case) to be reused in
		///   gradient computation. When is_training is False, a 1D Tensor
		///   for the population variance to be reused in both 1st and 2nd
		///   order gradient computation.
		/// </param>
		/// <param name="reserve_space_3">
		///   When is_training is True, a 1D Tensor for some intermediate results to be reused
		///   in gradient computation. When is_training is False, a dummy empty Tensor will be
		///   created.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedBatchNormGradV3'.
		/// </param>
		/// <param name="epsilon">
		///   Optional argument
		///   A small float number added to the variance of x.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   The data format for y_backprop, x, x_backprop.
		///   Either "NHWC" (default) or "NCHW".
		/// </param>
		/// <param name="is_training">
		///   Optional argument
		///   A bool value to indicate the operation is for training (default)
		///   or inference.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   x_backprop: A 4D Tensor for the gradient with respect to x.
		///   scale_backprop: A 1D Tensor for the gradient with respect to scale.
		///   offset_backprop: A 1D Tensor for the gradient with respect to offset.
		///   reserve_space_4: Unused placeholder to match the mean input in FusedBatchNorm.
		///   reserve_space_5: Unused placeholder to match the variance input
		///   in FusedBatchNorm.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Note that the size of 4D Tensors are defined by either "NHWC" or "NCHW".
		///   The size of 1D Tensors matches the dimension C of the 4D Tensors.
		/// </remarks>
		public (TF_Output x_backprop, TF_Output scale_backprop, TF_Output offset_backprop, TF_Output reserve_space_4, TF_Output reserve_space_5) FusedBatchNormGradV3 (TF_Output y_backprop, TF_Output x, TF_Output scale, TF_Output reserve_space_1, TF_Output reserve_space_2, TF_Output reserve_space_3, float? epsilon = null, string data_format = null, bool? is_training = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FusedBatchNormGradV3", MakeName ("FusedBatchNormGradV3", operName));
			c_api.TF_AddInput(desc, y_backprop);
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, scale);
			c_api.TF_AddInput(desc, reserve_space_1);
			c_api.TF_AddInput(desc, reserve_space_2);
			c_api.TF_AddInput(desc, reserve_space_3);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (epsilon.HasValue)
				c_api.TF_SetAttrFloat (desc, "epsilon", epsilon.Value);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (is_training.HasValue)
				c_api.TF_SetAttrBool (desc, "is_training", Convert.ToByte(is_training.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var x_backprop = new TF_Output (op, _idx++);
			var scale_backprop = new TF_Output (op, _idx++);
			var offset_backprop = new TF_Output (op, _idx++);
			var reserve_space_4 = new TF_Output (op, _idx++);
			var reserve_space_5 = new TF_Output (op, _idx++);
			return (x_backprop, scale_backprop, offset_backprop, reserve_space_4, reserve_space_5);
		}

		/// <summary>
		///   Batch normalization.
		/// </summary>
		/// <param name="x">
		///   A 4D Tensor for input data.
		/// </param>
		/// <param name="scale">
		///   A 1D Tensor for scaling factor, to scale the normalized x.
		/// </param>
		/// <param name="offset">
		///   A 1D Tensor for offset, to shift to the normalized x.
		/// </param>
		/// <param name="mean">
		///   A 1D Tensor for population mean. Used for inference only;
		///   must be empty for training.
		/// </param>
		/// <param name="variance">
		///   A 1D Tensor for population variance. Used for inference only;
		///   must be empty for training.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedBatchNormV2'.
		/// </param>
		/// <param name="epsilon">
		///   Optional argument
		///   A small float number added to the variance of x.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   The data format for x and y. Either "NHWC" (default) or "NCHW".
		/// </param>
		/// <param name="is_training">
		///   Optional argument
		///   A bool value to indicate the operation is for training (default)
		///   or inference.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   y: A 4D Tensor for output data.
		///   batch_mean: A 1D Tensor for the computed batch mean, to be used by TensorFlow
		///   to compute the running mean.
		///   batch_variance: A 1D Tensor for the computed batch variance, to be used by
		///   TensorFlow to compute the running variance.
		///   reserve_space_1: A 1D Tensor for the computed batch mean, to be reused
		///   in the gradient computation.
		///   reserve_space_2: A 1D Tensor for the computed batch variance (inverted variance
		///   in the cuDNN case), to be reused in the gradient computation.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Note that the size of 4D Tensors are defined by either "NHWC" or "NCHW".
		///   The size of 1D Tensors matches the dimension C of the 4D Tensors.
		/// </remarks>
		public (TF_Output y, TF_Output batch_mean, TF_Output batch_variance, TF_Output reserve_space_1, TF_Output reserve_space_2) FusedBatchNormV2 (TF_Output x, TF_Output scale, TF_Output offset, TF_Output mean, TF_Output variance, float? epsilon = null, string data_format = null, bool? is_training = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FusedBatchNormV2", MakeName ("FusedBatchNormV2", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, scale);
			c_api.TF_AddInput(desc, offset);
			c_api.TF_AddInput(desc, mean);
			c_api.TF_AddInput(desc, variance);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (epsilon.HasValue)
				c_api.TF_SetAttrFloat (desc, "epsilon", epsilon.Value);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (is_training.HasValue)
				c_api.TF_SetAttrBool (desc, "is_training", Convert.ToByte(is_training.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			var batch_mean = new TF_Output (op, _idx++);
			var batch_variance = new TF_Output (op, _idx++);
			var reserve_space_1 = new TF_Output (op, _idx++);
			var reserve_space_2 = new TF_Output (op, _idx++);
			return (y, batch_mean, batch_variance, reserve_space_1, reserve_space_2);
		}

		/// <summary>
		///   Batch normalization.
		/// </summary>
		/// <param name="x">
		///   A 4D Tensor for input data.
		/// </param>
		/// <param name="scale">
		///   A 1D Tensor for scaling factor, to scale the normalized x.
		/// </param>
		/// <param name="offset">
		///   A 1D Tensor for offset, to shift to the normalized x.
		/// </param>
		/// <param name="mean">
		///   A 1D Tensor for population mean. Used for inference only;
		///   must be empty for training.
		/// </param>
		/// <param name="variance">
		///   A 1D Tensor for population variance. Used for inference only;
		///   must be empty for training.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedBatchNormV3'.
		/// </param>
		/// <param name="epsilon">
		///   Optional argument
		///   A small float number added to the variance of x.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   The data format for x and y. Either "NHWC" (default) or "NCHW".
		/// </param>
		/// <param name="is_training">
		///   Optional argument
		///   A bool value to indicate the operation is for training (default)
		///   or inference.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   y: A 4D Tensor for output data.
		///   batch_mean: A 1D Tensor for the computed batch mean, to be used by TensorFlow
		///   to compute the running mean.
		///   batch_variance: A 1D Tensor for the computed batch variance, to be used by
		///   TensorFlow to compute the running variance.
		///   reserve_space_1: A 1D Tensor for the computed batch mean, to be reused
		///   in the gradient computation.
		///   reserve_space_2: A 1D Tensor for the computed batch variance (inverted variance
		///   in the cuDNN case), to be reused in the gradient computation.
		///   reserve_space_3: A 1D Tensor for some intermediate results, to be reused in the gradient
		///   computation for better efficiency.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Note that the size of 4D Tensors are defined by either "NHWC" or "NCHW".
		///   The size of 1D Tensors matches the dimension C of the 4D Tensors.
		/// </remarks>
		public (TF_Output y, TF_Output batch_mean, TF_Output batch_variance, TF_Output reserve_space_1, TF_Output reserve_space_2, TF_Output reserve_space_3) FusedBatchNormV3 (TF_Output x, TF_Output scale, TF_Output offset, TF_Output mean, TF_Output variance, float? epsilon = null, string data_format = null, bool? is_training = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FusedBatchNormV3", MakeName ("FusedBatchNormV3", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, scale);
			c_api.TF_AddInput(desc, offset);
			c_api.TF_AddInput(desc, mean);
			c_api.TF_AddInput(desc, variance);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (epsilon.HasValue)
				c_api.TF_SetAttrFloat (desc, "epsilon", epsilon.Value);
			
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			if (is_training.HasValue)
				c_api.TF_SetAttrBool (desc, "is_training", Convert.ToByte(is_training.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			var batch_mean = new TF_Output (op, _idx++);
			var batch_variance = new TF_Output (op, _idx++);
			var reserve_space_1 = new TF_Output (op, _idx++);
			var reserve_space_2 = new TF_Output (op, _idx++);
			var reserve_space_3 = new TF_Output (op, _idx++);
			return (y, batch_mean, batch_variance, reserve_space_1, reserve_space_2, reserve_space_3);
		}

		/// <summary>
		///   Performs a padding as a preprocess during a convolution.
		/// </summary>
		/// <param name="input">
		///   4-D with shape <c>[batch, in_height, in_width, in_channels]</c>.
		/// </param>
		/// <param name="paddings">
		///   A two-column matrix specifying the padding sizes. The number of
		///   rows must be the same as the rank of <c>input</c>.
		/// </param>
		/// <param name="filter">
		///   4-D with shape
		///   <c>[filter_height, filter_width, in_channels, out_channels]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedPadConv2D'.
		/// </param>
		/// <param name="mode">
		/// </param>
		/// <param name="strides">
		///   1-D of length 4.  The stride of the sliding window for each dimension
		///   of <c>input</c>. Must be in the same order as the dimension specified with format.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Similar to FusedResizeAndPadConv2d, this op allows for an optimized
		///   implementation where the spatial padding transformation stage is fused with the
		///   im2col lookup, but in this case without the bilinear filtering required for
		///   resizing. Fusing the padding prevents the need to write out the intermediate
		///   results as whole tensors, reducing memory pressure, and we can get some latency
		///   gains by merging the transformation calculations.
		///   The data_format attribute for Conv2D isn't supported by this op, and 'NHWC'
		///   order is used instead.
		///   Internally this op uses a single per-graph scratch buffer, which means that it
		///   will block if multiple versions are being run in parallel. This is because this
		///   operator is primarily an optimization to minimize memory usage.
		/// </remarks>
		public TF_Output FusedPadConv2D (TF_Output input, TF_Output paddings, TF_Output filter, string mode, long[] strides, string padding, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FusedPadConv2D", MakeName ("FusedPadConv2D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, paddings);
			c_api.TF_AddInput(desc, filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "mode", mode);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Performs a resize and padding as a preprocess during a convolution.
		/// </summary>
		/// <param name="input">
		///   4-D with shape <c>[batch, in_height, in_width, in_channels]</c>.
		/// </param>
		/// <param name="size">
		///   A 1-D int32 Tensor of 2 elements: <c>new_height, new_width</c>.  The
		///   new size for the images.
		/// </param>
		/// <param name="paddings">
		///   A two-column matrix specifying the padding sizes. The number of
		///   rows must be the same as the rank of <c>input</c>.
		/// </param>
		/// <param name="filter">
		///   4-D with shape
		///   <c>[filter_height, filter_width, in_channels, out_channels]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedResizeAndPadConv2D'.
		/// </param>
		/// <param name="resize_align_corners">
		///   Optional argument
		///   If true, the centers of the 4 corner pixels of the input and output tensors are
		///   aligned, preserving the values at the corner pixels. Defaults to false.
		/// </param>
		/// <param name="mode">
		/// </param>
		/// <param name="strides">
		///   1-D of length 4.  The stride of the sliding window for each dimension
		///   of <c>input</c>. Must be in the same order as the dimension specified with format.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   It's often possible to do spatial transformations more efficiently as part of
		///   the packing stage of a convolution, so this op allows for an optimized
		///   implementation where these stages are fused together. This prevents the need to
		///   write out the intermediate results as whole tensors, reducing memory pressure,
		///   and we can get some latency gains by merging the transformation calculations.
		///   The data_format attribute for Conv2D isn't supported by this op, and defaults to
		///   'NHWC' order.
		///   Internally this op uses a single per-graph scratch buffer, which means that it
		///   will block if multiple versions are being run in parallel. This is because this
		///   operator is primarily an optimization to minimize memory usage.
		/// </remarks>
		public TF_Output FusedResizeAndPadConv2D (TF_Output input, TF_Output size, TF_Output paddings, TF_Output filter, string mode, long[] strides, string padding, bool? resize_align_corners = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "FusedResizeAndPadConv2D", MakeName ("FusedResizeAndPadConv2D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, size);
			c_api.TF_AddInput(desc, paddings);
			c_api.TF_AddInput(desc, filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "mode", mode);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (resize_align_corners.HasValue)
				c_api.TF_SetAttrBool (desc, "resize_align_corners", Convert.ToByte(resize_align_corners.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Gather slices from <c>params</c> according to <c>indices</c>.
		/// </summary>
		/// <param name="parameters">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Gather'.
		/// </param>
		/// <param name="validate_indices">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   <c>indices</c> must be an integer tensor of any dimension (usually 0-D or 1-D).
		///   Produces an output tensor with shape <c>indices.shape + params.shape[1:]</c> where:
		///   
		///    <code>
		///   # Scalar indices
		///   output[:, ..., :] = params[indices, :, ... :]
		///   
		///   # Vector indices
		///   output[i, :, ..., :] = params[indices[i], :, ... :]
		///   
		///   # Higher rank indices
		///   output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]
		///    </code>
		///   
		///   If <c>indices</c> is a permutation and <c>len(indices) == params.shape[0]</c> then
		///   this operation will permute <c>params</c> accordingly.
		///   
		///   <c>validate_indices</c>: DEPRECATED. If this operation is assigned to CPU, values in
		///   <c>indices</c> are always validated to be within range. If assigned to GPU,
		///   out-of-bound indices result in safe but unspecified behavior, which may include
		///   raising an error.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/Gather.png" alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		/// </remarks>
		public TF_Output Gather (TF_Output parameters, TF_Output indices, bool? validate_indices = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Gather", MakeName ("Gather", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (validate_indices.HasValue)
				c_api.TF_SetAttrBool (desc, "validate_indices", Convert.ToByte(validate_indices.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Gather slices from <c>params</c> into a Tensor with shape specified by <c>indices</c>.
		/// </summary>
		/// <param name="parameters">
		///   The tensor from which to gather values.
		/// </param>
		/// <param name="indices">
		///   Index tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GatherNd'.
		/// </param>
		/// <returns>
		///   Values from <c>params</c> gathered from indices given by <c>indices</c>, with
		///   shape <c>indices.shape[:-1] + params.shape[indices.shape[-1]:]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   <c>indices</c> is a K-dimensional integer tensor, best thought of as a
		///   (K-1)-dimensional tensor of indices into <c>params</c>, where each element defines a
		///   slice of <c>params</c>:
		///   
		///   output[\\(i_0, ..., i_{K-2}\\)] = params[indices[\\(i_0, ..., i_{K-2}\\)]]
		///   
		///   Whereas in <c>tf.gather</c> <c>indices</c> defines slices into the first
		///   dimension of <c>params</c>, in <c>tf.gather_nd</c>, <c>indices</c> defines slices into the
		///   first <c>N</c> dimensions of <c>params</c>, where <c>N = indices.shape[-1]</c>.
		///   
		///   The last dimension of <c>indices</c> can be at most the rank of
		///   <c>params</c>:
		///   
		///   indices.shape[-1] &amp;lt;= params.rank
		///   
		///   The last dimension of <c>indices</c> corresponds to elements
		///   (if <c>indices.shape[-1] == params.rank</c>) or slices
		///   (if <c>indices.shape[-1] &amp;lt; params.rank</c>) along dimension <c>indices.shape[-1]</c>
		///   of <c>params</c>.  The output tensor has shape
		///   
		///   indices.shape[:-1] + params.shape[indices.shape[-1]:]
		///   
		///   Note that on CPU, if an out of bound index is found, an error is returned.
		///   On GPU, if an out of bound index is found, a 0 is stored in the
		///   corresponding output value.
		///   
		///   Some examples below.
		///   
		///   Simple indexing into a matrix:
		///   
		///    <code>
		///   indices = [[0, 0], [1, 1]]
		///   params = [['a', 'b'], ['c', 'd']]
		///   output = ['a', 'd']
		///    </code>
		///   
		///   Slice indexing into a matrix:
		///   
		///    <code>
		///   indices = [[1], [0]]
		///   params = [['a', 'b'], ['c', 'd']]
		///   output = [['c', 'd'], ['a', 'b']]
		///    </code>
		///   
		///   Indexing into a 3-tensor:
		///   
		///    <code>
		///   indices = [[1]]
		///   params = [[['a0', 'b0'], ['c0', 'd0']],
		///   [['a1', 'b1'], ['c1', 'd1']]]
		///   output = [[['a1', 'b1'], ['c1', 'd1']]]
		///   
		///   
		///   indices = [[0, 1], [1, 0]]
		///   params = [[['a0', 'b0'], ['c0', 'd0']],
		///   [['a1', 'b1'], ['c1', 'd1']]]
		///   output = [['c0', 'd0'], ['a1', 'b1']]
		///   
		///   
		///   indices = [[0, 0, 1], [1, 0, 1]]
		///   params = [[['a0', 'b0'], ['c0', 'd0']],
		///   [['a1', 'b1'], ['c1', 'd1']]]
		///   output = ['b0', 'b1']
		///    </code>
		///   
		///   Batched indexing into a matrix:
		///   
		///    <code>
		///   indices = [[[0, 0]], [[0, 1]]]
		///   params = [['a', 'b'], ['c', 'd']]
		///   output = [['a'], ['b']]
		///    </code>
		///   
		///   Batched slice indexing into a matrix:
		///   
		///    <code>
		///   indices = [[[1]], [[0]]]
		///   params = [['a', 'b'], ['c', 'd']]
		///   output = [[['c', 'd']], [['a', 'b']]]
		///    </code>
		///   
		///   Batched indexing into a 3-tensor:
		///   
		///    <code>
		///   indices = [[[1]], [[0]]]
		///   params = [[['a0', 'b0'], ['c0', 'd0']],
		///   [['a1', 'b1'], ['c1', 'd1']]]
		///   output = [[[['a1', 'b1'], ['c1', 'd1']]],
		///   [[['a0', 'b0'], ['c0', 'd0']]]]
		///   
		///   indices = [[[0, 1], [1, 0]], [[0, 0], [1, 1]]]
		///   params = [[['a0', 'b0'], ['c0', 'd0']],
		///   [['a1', 'b1'], ['c1', 'd1']]]
		///   output = [[['c0', 'd0'], ['a1', 'b1']],
		///   [['a0', 'b0'], ['c1', 'd1']]]
		///   
		///   
		///   indices = [[[0, 0, 1], [1, 0, 1]], [[0, 1, 1], [1, 1, 0]]]
		///   params = [[['a0', 'b0'], ['c0', 'd0']],
		///   [['a1', 'b1'], ['c1', 'd1']]]
		///   output = [['b0', 'b1'], ['d0', 'c1']]
		///    </code>
		///   
		///   See also <c>tf.gather</c> and <c>tf.batch_gather</c>.
		/// </remarks>
		public TF_Output GatherNd (TF_Output parameters, TF_Output indices, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GatherNd", MakeName ("GatherNd", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Gather slices from <c>params</c> axis <c>axis</c> according to <c>indices</c>.
		/// </summary>
		/// <param name="parameters">
		///   The tensor from which to gather values. Must be at least rank
		///   <c>axis + 1</c>.
		/// </param>
		/// <param name="indices">
		///   Index tensor. Must be in range <c>[0, params.shape[axis])</c>.
		/// </param>
		/// <param name="axis">
		///   The axis in <c>params</c> to gather <c>indices</c> from. Defaults to the first
		///   dimension. Supports negative indexes.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GatherV2'.
		/// </param>
		/// <param name="batch_dims">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Values from <c>params</c> gathered from indices given by <c>indices</c>, with
		///   shape <c>params.shape[:axis] + indices.shape + params.shape[axis + 1:]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   <c>indices</c> must be an integer tensor of any dimension (usually 0-D or 1-D).
		///   Produces an output tensor with shape <c>params.shape[:axis] + indices.shape +
		///   params.shape[axis + 1:]</c> where:
		///   
		///    <code>
		///   # Scalar indices (output is rank(params) - 1).
		///   output[a_0, ..., a_n, b_0, ..., b_n] =
		///   params[a_0, ..., a_n, indices, b_0, ..., b_n]
		///   
		///   # Vector indices (output is rank(params)).
		///   output[a_0, ..., a_n, i, b_0, ..., b_n] =
		///   params[a_0, ..., a_n, indices[i], b_0, ..., b_n]
		///   
		///   # Higher rank indices (output is rank(params) + rank(indices) - 1).
		///   output[a_0, ..., a_n, i, ..., j, b_0, ... b_n] =
		///   params[a_0, ..., a_n, indices[i, ..., j], b_0, ..., b_n]
		///    </code>
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/Gather.png" alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		///   
		///   Note that on CPU, if an out of bound index is found, an error is returned.
		///   On GPU, if an out of bound index is found, a 0 is stored in the
		///   corresponding output value.
		///   
		///   See also <c>tf.batch_gather</c> and <c>tf.gather_nd</c>.
		/// </remarks>
		public TF_Output GatherV2 (TF_Output parameters, TF_Output indices, TF_Output axis, long? batch_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GatherV2", MakeName ("GatherV2", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, axis);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (batch_dims.HasValue)
				c_api.TF_SetAttrInt (desc, "batch_dims", batch_dims.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Given a path to new and old vocabulary files, returns a remapping Tensor of
		/// </summary>
		/// <param name="new_vocab_file">
		///   Path to the new vocab file.
		/// </param>
		/// <param name="old_vocab_file">
		///   Path to the old vocab file.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GenerateVocabRemapping'.
		/// </param>
		/// <param name="old_vocab_size">
		///   Optional argument
		///   Number of entries in the old vocab file to consider.  If -1,
		///   use the entire old vocabulary.
		/// </param>
		/// <param name="new_vocab_offset">
		///   How many entries into the new vocab file to start reading.
		/// </param>
		/// <param name="num_new_vocab">
		///   Number of entries in the new vocab file to remap.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   remapping: A Tensor of length num_new_vocab where the element at index i
		///   is equal to the old ID that maps to the new ID i.  This element is -1 for any
		///   new ID that is not found in the old vocabulary.
		///   num_present: Number of new vocab entries found in old vocab.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   length <c>num_new_vocab</c>, where <c>remapping[i]</c> contains the row number in the old
		///   vocabulary that corresponds to row <c>i</c> in the new vocabulary (starting at line
		///   <c>new_vocab_offset</c> and up to <c>num_new_vocab</c> entities), or <c>-1</c> if entry <c>i</c>
		///   in the new vocabulary is not in the old vocabulary.  The old vocabulary is
		///   constrained to the first <c>old_vocab_size</c> entries if <c>old_vocab_size</c> is not the
		///   default value of -1.
		///   
		///   <c>num_vocab_offset</c> enables
		///   use in the partitioned variable case, and should generally be set through
		///   examining partitioning info.  The format of the files should be a text file,
		///   with each line containing a single entity within the vocabulary.
		///   
		///   For example, with <c>new_vocab_file</c> a text file containing each of the following
		///   elements on a single line: <c>[f0, f1, f2, f3]</c>, old_vocab_file = [f1, f0, f3],
		///   <c>num_new_vocab = 3, new_vocab_offset = 1</c>, the returned remapping would be
		///   <c>[0, -1, 2]</c>.
		///   
		///   The op also returns a count of how many entries in the new vocabulary
		///   were present in the old vocabulary, which is used to calculate the number of
		///   values to initialize in a weight matrix remapping
		///   
		///   This functionality can be used to remap both row vocabularies (typically,
		///   features) and column vocabularies (typically, classes) from TensorFlow
		///   checkpoints.  Note that the partitioning logic relies on contiguous vocabularies
		///   corresponding to div-partitioned variables.  Moreover, the underlying remapping
		///   uses an IndexTable (as opposed to an inexact CuckooTable), so client code should
		///   use the corresponding index_table_from_file() as the FeatureColumn framework
		///   does (as opposed to tf.feature_to_id(), which uses a CuckooTable).
		/// </remarks>
		public (TF_Output remapping, TF_Output num_present) GenerateVocabRemapping (TF_Output new_vocab_file, TF_Output old_vocab_file, long new_vocab_offset, long num_new_vocab, long? old_vocab_size = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GenerateVocabRemapping", MakeName ("GenerateVocabRemapping", operName));
			c_api.TF_AddInput(desc, new_vocab_file);
			c_api.TF_AddInput(desc, old_vocab_file);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "new_vocab_offset", new_vocab_offset);
			c_api.TF_SetAttrInt (desc, "num_new_vocab", num_new_vocab);
			if (old_vocab_size.HasValue)
				c_api.TF_SetAttrInt (desc, "old_vocab_size", old_vocab_size.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var remapping = new TF_Output (op, _idx++);
			var num_present = new TF_Output (op, _idx++);
			return (remapping, num_present);
		}

		/// <summary>
		///   Creates a dataset that invokes a function to generate elements.
		/// </summary>
		/// <param name="init_func_other_args">
		/// </param>
		/// <param name="next_func_other_args">
		/// </param>
		/// <param name="finalize_func_other_args">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GeneratorDataset'.
		/// </param>
		/// <param name="init_func">
		/// </param>
		/// <param name="next_func">
		/// </param>
		/// <param name="finalize_func">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output GeneratorDataset (TF_Output[] init_func_other_args, TF_Output[] next_func_other_args, TF_Output[] finalize_func_other_args, TF_Function init_func, TF_Function next_func, TF_Function finalize_func, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GeneratorDataset", MakeName ("GeneratorDataset", operName));
			c_api.TF_AddInputList(desc, init_func_other_args[0], init_func_other_args.Length);
			c_api.TF_AddInputList(desc, next_func_other_args[0], next_func_other_args.Length);
			c_api.TF_AddInputList(desc, finalize_func_other_args[0], finalize_func_other_args.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "init_func", c_api.TF_FunctionName(init_func));
			c_api.TF_SetAttrFuncName (desc, "next_func", c_api.TF_FunctionName(next_func));
			c_api.TF_SetAttrFuncName (desc, "finalize_func", c_api.TF_FunctionName(finalize_func));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Store the input tensor in the state of the current session.
		/// </summary>
		/// <param name="value">
		///   The tensor to be stored.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GetSessionHandle'.
		/// </param>
		/// <returns>
		///   The handle for the tensor stored in the session state, represented
		///   as a string.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output GetSessionHandle (TF_Output value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GetSessionHandle", MakeName ("GetSessionHandle", operName));
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Store the input tensor in the state of the current session.
		/// </summary>
		/// <param name="value">
		///   The tensor to be stored.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GetSessionHandleV2'.
		/// </param>
		/// <returns>
		///   The handle for the tensor stored in the session state, represented
		///   as a ResourceHandle object.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output GetSessionHandleV2 (TF_Output value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GetSessionHandleV2", MakeName ("GetSessionHandleV2", operName));
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Get the value of the tensor specified by its handle.
		/// </summary>
		/// <param name="handle">
		///   The handle for a tensor stored in the session state.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GetSessionTensor'.
		/// </param>
		/// <param name="dtype">
		///   The type of the output value.
		/// </param>
		/// <returns>
		///   The tensor for the given handle.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output GetSessionTensor (TF_Output handle, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GetSessionTensor", MakeName ("GetSessionTensor", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			return value;
		}

		/// <summary>
		///   Returns the truth value of (x &amp;gt; y) element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Greater'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   *NOTE*: <c>Greater</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output Greater (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Greater", MakeName ("Greater", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Returns the truth value of (x &amp;gt;= y) element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GreaterEqual'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   *NOTE*: <c>GreaterEqual</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output GreaterEqual (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GreaterEqual", MakeName ("GreaterEqual", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Creates a dataset that computes a group-by on <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		///   A variant tensor representing the input dataset.
		/// </param>
		/// <param name="key_func_other_arguments">
		///   A list of tensors, typically values that were captured when
		///   building a closure for <c>key_func</c>.
		/// </param>
		/// <param name="init_func_other_arguments">
		///   A list of tensors, typically values that were captured when
		///   building a closure for <c>init_func</c>.
		/// </param>
		/// <param name="reduce_func_other_arguments">
		///   A list of tensors, typically values that were captured when
		///   building a closure for <c>reduce_func</c>.
		/// </param>
		/// <param name="finalize_func_other_arguments">
		///   A list of tensors, typically values that were captured when
		///   building a closure for <c>finalize_func</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GroupByReducerDataset'.
		/// </param>
		/// <param name="key_func">
		///   A function mapping an element of <c>input_dataset</c>, concatenated
		///   with <c>key_func_other_arguments</c> to a scalar value of type DT_INT64.
		/// </param>
		/// <param name="init_func">
		///   A function mapping a key of type DT_INT64, concatenated with
		///   <c>init_func_other_arguments</c> to the initial reducer state.
		/// </param>
		/// <param name="reduce_func">
		///   A function mapping the current reducer state and an element of <c>input_dataset</c>,
		///   concatenated with <c>reduce_func_other_arguments</c> to a new reducer state.
		/// </param>
		/// <param name="finalize_func">
		///   A function mapping the final reducer state to an output element.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Creates a dataset that computes a group-by on <c>input_dataset</c>.
		/// </remarks>
		public TF_Output GroupByReducerDataset (TF_Output input_dataset, TF_Output[] key_func_other_arguments, TF_Output[] init_func_other_arguments, TF_Output[] reduce_func_other_arguments, TF_Output[] finalize_func_other_arguments, TF_Function key_func, TF_Function init_func, TF_Function reduce_func, TF_Function finalize_func, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GroupByReducerDataset", MakeName ("GroupByReducerDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInputList(desc, key_func_other_arguments[0], key_func_other_arguments.Length);
			c_api.TF_AddInputList(desc, init_func_other_arguments[0], init_func_other_arguments.Length);
			c_api.TF_AddInputList(desc, reduce_func_other_arguments[0], reduce_func_other_arguments.Length);
			c_api.TF_AddInputList(desc, finalize_func_other_arguments[0], finalize_func_other_arguments.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "key_func", c_api.TF_FunctionName(key_func));
			c_api.TF_SetAttrFuncName (desc, "init_func", c_api.TF_FunctionName(init_func));
			c_api.TF_SetAttrFuncName (desc, "reduce_func", c_api.TF_FunctionName(reduce_func));
			c_api.TF_SetAttrFuncName (desc, "finalize_func", c_api.TF_FunctionName(finalize_func));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that computes a windowed group-by on <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="key_func_other_arguments">
		/// </param>
		/// <param name="reduce_func_other_arguments">
		/// </param>
		/// <param name="window_size_func_other_arguments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GroupByWindowDataset'.
		/// </param>
		/// <param name="key_func">
		///   A function mapping an element of <c>input_dataset</c>, concatenated
		///   with <c>key_func_other_arguments</c> to a scalar value of type DT_INT64.
		/// </param>
		/// <param name="reduce_func">
		/// </param>
		/// <param name="window_size_func">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   // TODO(mrry): Support non-int64 keys.
		/// </remarks>
		public TF_Output GroupByWindowDataset (TF_Output input_dataset, TF_Output[] key_func_other_arguments, TF_Output[] reduce_func_other_arguments, TF_Output[] window_size_func_other_arguments, TF_Function key_func, TF_Function reduce_func, TF_Function window_size_func, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GroupByWindowDataset", MakeName ("GroupByWindowDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInputList(desc, key_func_other_arguments[0], key_func_other_arguments.Length);
			c_api.TF_AddInputList(desc, reduce_func_other_arguments[0], reduce_func_other_arguments.Length);
			c_api.TF_AddInputList(desc, window_size_func_other_arguments[0], window_size_func_other_arguments.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "key_func", c_api.TF_FunctionName(key_func));
			c_api.TF_SetAttrFuncName (desc, "reduce_func", c_api.TF_FunctionName(reduce_func));
			c_api.TF_SetAttrFuncName (desc, "window_size_func", c_api.TF_FunctionName(window_size_func));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Computes the GRU cell forward propagation for 1 time step.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="h_prev">
		/// </param>
		/// <param name="w_ru">
		/// </param>
		/// <param name="w_c">
		/// </param>
		/// <param name="b_ru">
		/// </param>
		/// <param name="b_c">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GRUBlockCell'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   r:
		///   u:
		///   c:
		///   h:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Args
		///   x: Input to the GRU cell.
		///   h_prev: State input from the previous GRU cell.
		///   w_ru: Weight matrix for the reset and update gate.
		///   w_c: Weight matrix for the cell connection gate.
		///   b_ru: Bias vector for the reset and update gate.
		///   b_c: Bias vector for the cell connection gate.
		///   
		///   Returns
		///   r: Output of the reset gate.
		///   u: Output of the update gate.
		///   c: Output of the cell connection gate.
		///   h: Current state of the GRU cell.
		///   
		///   Note on notation of the variables:
		///   
		///   Concatenation of a and b is represented by a_b
		///   Element-wise dot product of a and b is represented by ab
		///   Element-wise dot product is represented by \circ
		///   Matrix multiplication is represented by *
		///   
		///   Biases are initialized with :
		///   <c>b_ru</c> - constant_initializer(1.0)
		///   <c>b_c</c> - constant_initializer(0.0)
		///   
		///   This kernel op implements the following mathematical equations:
		///   
		///    <code>
		///   x_h_prev = [x, h_prev]
		///   
		///   [r_bar u_bar] = x_h_prev * w_ru + b_ru
		///   
		///   r = sigmoid(r_bar)
		///   u = sigmoid(u_bar)
		///   
		///   h_prevr = h_prev \circ r
		///   
		///   x_h_prevr = [x h_prevr]
		///   
		///   c_bar = x_h_prevr * w_c + b_c
		///   c = tanh(c_bar)
		///   
		///   h = (1-u) \circ c + u \circ h_prev
		///    </code>
		/// </remarks>
		public (TF_Output r, TF_Output u, TF_Output c, TF_Output h) GRUBlockCell (TF_Output x, TF_Output h_prev, TF_Output w_ru, TF_Output w_c, TF_Output b_ru, TF_Output b_c, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GRUBlockCell", MakeName ("GRUBlockCell", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, h_prev);
			c_api.TF_AddInput(desc, w_ru);
			c_api.TF_AddInput(desc, w_c);
			c_api.TF_AddInput(desc, b_ru);
			c_api.TF_AddInput(desc, b_c);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var r = new TF_Output (op, _idx++);
			var u = new TF_Output (op, _idx++);
			var c = new TF_Output (op, _idx++);
			var h = new TF_Output (op, _idx++);
			return (r, u, c, h);
		}

		/// <summary>
		///   Computes the GRU cell back-propagation for 1 time step.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="h_prev">
		/// </param>
		/// <param name="w_ru">
		/// </param>
		/// <param name="w_c">
		/// </param>
		/// <param name="b_ru">
		/// </param>
		/// <param name="b_c">
		/// </param>
		/// <param name="r">
		/// </param>
		/// <param name="u">
		/// </param>
		/// <param name="c">
		/// </param>
		/// <param name="d_h">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GRUBlockCellGrad'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   d_x:
		///   d_h_prev:
		///   d_c_bar:
		///   d_r_bar_u_bar:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Args
		///   x: Input to the GRU cell.
		///   h_prev: State input from the previous GRU cell.
		///   w_ru: Weight matrix for the reset and update gate.
		///   w_c: Weight matrix for the cell connection gate.
		///   b_ru: Bias vector for the reset and update gate.
		///   b_c: Bias vector for the cell connection gate.
		///   r: Output of the reset gate.
		///   u: Output of the update gate.
		///   c: Output of the cell connection gate.
		///   d_h: Gradients of the h_new wrt to objective function.
		///   
		///   Returns
		///   d_x: Gradients of the x wrt to objective function.
		///   d_h_prev: Gradients of the h wrt to objective function.
		///   d_c_bar Gradients of the c_bar wrt to objective function.
		///   d_r_bar_u_bar Gradients of the r_bar &amp; u_bar wrt to objective function.
		///   
		///   This kernel op implements the following mathematical equations:
		///   
		///   Note on notation of the variables:
		///   
		///   Concatenation of a and b is represented by a_b
		///   Element-wise dot product of a and b is represented by ab
		///   Element-wise dot product is represented by \circ
		///   Matrix multiplication is represented by *
		///   
		///   Additional notes for clarity:
		///   
		///   <c>w_ru</c> can be segmented into 4 different matrices.
		///    <code>
		///   w_ru = [w_r_x w_u_x
		///   w_r_h_prev w_u_h_prev]
		///    </code>
		///   Similarly, <c>w_c</c> can be segmented into 2 different matrices.
		///    <code>
		///   w_c = [w_c_x w_c_h_prevr]
		///    </code>
		///   Same goes for biases.
		///    <code>
		///   b_ru = [b_ru_x b_ru_h]
		///   b_c = [b_c_x b_c_h]
		///    </code>
		///   Another note on notation:
		///    <code>
		///   d_x = d_x_component_1 + d_x_component_2
		///   
		///   where d_x_component_1 = d_r_bar * w_r_x^T + d_u_bar * w_r_x^T
		///   and d_x_component_2 = d_c_bar * w_c_x^T
		///   
		///   d_h_prev = d_h_prev_component_1 + d_h_prevr \circ r + d_h \circ u
		///   where d_h_prev_componenet_1 = d_r_bar * w_r_h_prev^T + d_u_bar * w_r_h_prev^T
		///    </code>
		///   
		///   Mathematics behind the Gradients below:
		///    <code>
		///   d_c_bar = d_h \circ (1-u) \circ (1-c \circ c)
		///   d_u_bar = d_h \circ (h-c) \circ u \circ (1-u)
		///   
		///   d_r_bar_u_bar = [d_r_bar d_u_bar]
		///   
		///   [d_x_component_1 d_h_prev_component_1] = d_r_bar_u_bar * w_ru^T
		///   
		///   [d_x_component_2 d_h_prevr] = d_c_bar * w_c^T
		///   
		///   d_x = d_x_component_1 + d_x_component_2
		///   
		///   d_h_prev = d_h_prev_component_1 + d_h_prevr \circ r + u
		///    </code>
		///   Below calculation is performed in the python wrapper for the Gradients
		///   (not in the gradient kernel.)
		///    <code>
		///   d_w_ru = x_h_prevr^T * d_c_bar
		///   
		///   d_w_c = x_h_prev^T * d_r_bar_u_bar
		///   
		///   d_b_ru = sum of d_r_bar_u_bar along axis = 0
		///   
		///   d_b_c = sum of d_c_bar along axis = 0
		///    </code>
		/// </remarks>
		public (TF_Output d_x, TF_Output d_h_prev, TF_Output d_c_bar, TF_Output d_r_bar_u_bar) GRUBlockCellGrad (TF_Output x, TF_Output h_prev, TF_Output w_ru, TF_Output w_c, TF_Output b_ru, TF_Output b_c, TF_Output r, TF_Output u, TF_Output c, TF_Output d_h, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GRUBlockCellGrad", MakeName ("GRUBlockCellGrad", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, h_prev);
			c_api.TF_AddInput(desc, w_ru);
			c_api.TF_AddInput(desc, w_c);
			c_api.TF_AddInput(desc, b_ru);
			c_api.TF_AddInput(desc, b_c);
			c_api.TF_AddInput(desc, r);
			c_api.TF_AddInput(desc, u);
			c_api.TF_AddInput(desc, c);
			c_api.TF_AddInput(desc, d_h);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var d_x = new TF_Output (op, _idx++);
			var d_h_prev = new TF_Output (op, _idx++);
			var d_c_bar = new TF_Output (op, _idx++);
			var d_r_bar_u_bar = new TF_Output (op, _idx++);
			return (d_x, d_h_prev, d_c_bar, d_r_bar_u_bar);
		}

		/// <summary>
		///   Gives a guarantee to the TF runtime that the input tensor is a constant.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'GuaranteeConst'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The runtime is then free to make optimizations based on this.
		///   
		///   Only accepts value typed tensors as inputs and rejects resource variable handles
		///   as input.
		///   
		///   Returns the input tensor without modification.
		/// </remarks>
		public TF_Output GuaranteeConst (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "GuaranteeConst", MakeName ("GuaranteeConst", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates a non-initialized hash table.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'HashTable'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this table is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this table is shared under the given name across
		///   multiple sessions.
		/// </param>
		/// <param name="use_node_name_sharing">
		///   Optional argument
		///   If true and shared_name is empty, the table is shared
		///   using the node name.
		/// </param>
		/// <param name="key_dtype">
		///   Type of the table keys.
		/// </param>
		/// <param name="value_dtype">
		///   Type of the table values.
		/// </param>
		/// <returns>
		///   Handle to a table.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op creates a hash table, specifying the type of its keys and values.
		///   Before using the table you will have to initialize it.  After initialization the
		///   table will be immutable.
		/// </remarks>
		public TF_Output HashTable (TF_DataType key_dtype, TF_DataType value_dtype, string container = null, string shared_name = null, bool? use_node_name_sharing = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "HashTable", MakeName ("HashTable", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "key_dtype", key_dtype);
			c_api.TF_SetAttrType (desc, "value_dtype", value_dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (use_node_name_sharing.HasValue)
				c_api.TF_SetAttrBool (desc, "use_node_name_sharing", Convert.ToByte(use_node_name_sharing.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var table_handle = new TF_Output (op, _idx++);
			return table_handle;
		}

		/// <summary>
		///   Creates a non-initialized hash table.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'HashTableV2'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this table is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this table is shared under the given name across
		///   multiple sessions.
		/// </param>
		/// <param name="use_node_name_sharing">
		///   Optional argument
		///   If true and shared_name is empty, the table is shared
		///   using the node name.
		/// </param>
		/// <param name="key_dtype">
		///   Type of the table keys.
		/// </param>
		/// <param name="value_dtype">
		///   Type of the table values.
		/// </param>
		/// <returns>
		///   Handle to a table.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op creates a hash table, specifying the type of its keys and values.
		///   Before using the table you will have to initialize it.  After initialization the
		///   table will be immutable.
		/// </remarks>
		public TF_Output HashTableV2 (TF_DataType key_dtype, TF_DataType value_dtype, string container = null, string shared_name = null, bool? use_node_name_sharing = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "HashTableV2", MakeName ("HashTableV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "key_dtype", key_dtype);
			c_api.TF_SetAttrType (desc, "value_dtype", value_dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (use_node_name_sharing.HasValue)
				c_api.TF_SetAttrBool (desc, "use_node_name_sharing", Convert.ToByte(use_node_name_sharing.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var table_handle = new TF_Output (op, _idx++);
			return table_handle;
		}

		/// <summary>
		///   Return histogram of values.
		/// </summary>
		/// <param name="values">
		///   Numeric <c>Tensor</c>.
		/// </param>
		/// <param name="value_range">
		///   Shape [2] <c>Tensor</c> of same <c>dtype</c> as <c>values</c>.
		///   values &amp;lt;= value_range[0] will be mapped to hist[0],
		///   values &amp;gt;= value_range[1] will be mapped to hist[-1].
		/// </param>
		/// <param name="nbins">
		///   Scalar <c>int32 Tensor</c>.  Number of histogram bins.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'HistogramFixedWidth'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   A 1-D <c>Tensor</c> holding histogram of values.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given the tensor <c>values</c>, this operation returns a rank 1 histogram counting
		///   the number of entries in <c>values</c> that fall into every bin.  The bins are
		///   equal width and determined by the arguments <c>value_range</c> and <c>nbins</c>.
		///   
		///    <code>
		///   # Bins will be:  (-inf, 1), [1, 2), [2, 3), [3, 4), [4, inf)
		///   nbins = 5
		///   value_range = [0.0, 5.0]
		///   new_values = [-1.0, 0.0, 1.5, 2.0, 5.0, 15]
		///   
		///   with tf.get_default_session() as sess:
		///   hist = tf.histogram_fixed_width(new_values, value_range, nbins=5)
		///   variables.global_variables_initializer().run()
		///   sess.run(hist) =&amp;gt; [2, 1, 1, 0, 2]
		///    </code>
		/// </remarks>
		public TF_Output HistogramFixedWidth (TF_Output values, TF_Output value_range, TF_Output nbins, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "HistogramFixedWidth", MakeName ("HistogramFixedWidth", operName));
			c_api.TF_AddInput(desc, values);
			c_api.TF_AddInput(desc, value_range);
			c_api.TF_AddInput(desc, nbins);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Outputs a <c>Summary</c> protocol buffer with a histogram.
		/// </summary>
		/// <param name="tag">
		///   Scalar.  Tag to use for the <c>Summary.Value</c>.
		/// </param>
		/// <param name="values">
		///   Any shape. Values to use to build the histogram.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'HistogramSummary'.
		/// </param>
		/// <returns>
		///   Scalar. Serialized <c>Summary</c> protocol buffer.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The generated
		///   [<c>Summary</c>](https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto)
		///   has one summary value containing a histogram for <c>values</c>.
		///   
		///   This op reports an <c>InvalidArgument</c> error if any value is not finite.
		/// </remarks>
		public TF_Output HistogramSummary (TF_Output tag, TF_Output values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "HistogramSummary", MakeName ("HistogramSummary", operName));
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var summary = new TF_Output (op, _idx++);
			return summary;
		}

		/// <summary>
		///   Returns a constant tensor on the host. Only for writing C++ tests.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'HostConst'.
		/// </param>
		/// <param name="value">
		///   Attr <c>value</c> is the tensor to return.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output HostConst (TF_Tensor value, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "HostConst", MakeName ("HostConst", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTensor (desc, "value", value, status);
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Convert one or more images from HSV to RGB.
		/// </summary>
		/// <param name="images">
		///   1-D or higher rank. HSV data to convert. Last dimension must be size 3.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'HSVToRGB'.
		/// </param>
		/// <returns>
		///   <c>images</c> converted to RGB.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Outputs a tensor of the same shape as the <c>images</c> tensor, containing the RGB
		///   value of the pixels. The output is only well defined if the value in <c>images</c>
		///   are in <c>[0,1]</c>.
		///   
		///   See <c>rgb_to_hsv</c> for a description of the HSV encoding.
		/// </remarks>
		public TF_Output HSVToRGB (TF_Output images, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "HSVToRGB", MakeName ("HSVToRGB", operName));
			c_api.TF_AddInput(desc, images);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Return a tensor with the same shape and contents as the input tensor or value.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Identity'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Identity (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Identity", MakeName ("Identity", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns a list of tensors with the same shapes and contents as the input
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IdentityN'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   tensors.
		///   
		///   This op can be used to override the gradient for complicated functions. For
		///   example, suppose y = f(x) and we wish to apply a custom function g for backprop
		///   such that dx = g(dy). In Python,
		///   
		///    <code>
		///   with tf.get_default_graph().gradient_override_map(
		///   {'IdentityN': 'OverrideGradientWithG'}):
		///   y, _ = identity_n([f(x), x])
		///   
		///   @tf.RegisterGradient('OverrideGradientWithG')
		///   def ApplyG(op, dy, _):
		///   return [None, g(dy)]  # Do not backprop to f(x).
		///    </code>
		/// </remarks>
		public TF_Output[] IdentityN (TF_Output[] input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IdentityN", MakeName ("IdentityN", operName));
			c_api.TF_AddInputList(desc, input[0], input.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		///   A Reader that outputs the queued work as both the key and value.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IdentityReader'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this reader is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this reader is named in the given bucket
		///   with this shared_name. Otherwise, the node name is used instead.
		/// </param>
		/// <returns>
		///   The handle to reference the Reader.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   To use, enqueue strings in a Queue.  ReaderRead will take the front
		///   work string and output (work, work).
		/// </remarks>
		public TF_Output IdentityReader (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IdentityReader", MakeName ("IdentityReader", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		///   A Reader that outputs the queued work as both the key and value.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IdentityReaderV2'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this reader is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this reader is named in the given bucket
		///   with this shared_name. Otherwise, the node name is used instead.
		/// </param>
		/// <returns>
		///   The handle to reference the Reader.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   To use, enqueue strings in a Queue.  ReaderRead will take the front
		///   work string and output (work, work).
		/// </remarks>
		public TF_Output IdentityReaderV2 (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IdentityReaderV2", MakeName ("IdentityReaderV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		///   output = cond ? then_branch(input) : else_branch(input)
		/// </summary>
		/// <param name="cond">
		///   A Tensor. If the tensor is a scalar of non-boolean type, the
		///   scalar is converted to a boolean according to the
		///   following rule: if the scalar is a numerical value, non-zero means
		///   <c>True</c> and zero means False; if the scalar is a string, non-empty
		///   means <c>True</c> and empty means <c>False</c>. If the tensor is not a scalar,
		///   being empty means False and being non-empty means True.
		/// </param>
		/// <param name="input">
		///   A list of input tensors.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'If'.
		/// </param>
		/// <param name="output_shapes">
		///   Optional argument
		/// </param>
		/// <param name="Tout">
		///   A list of output types.
		/// </param>
		/// <param name="then_branch">
		///   A function that takes 'inputs' and returns a list of tensors, whose
		///   types are the same as what else_branch returns.
		/// </param>
		/// <param name="else_branch">
		///   A function that takes 'inputs' and returns a list of tensors, whose
		///   types are the same as what then_branch returns.
		/// </param>
		/// <returns>
		///   A list of return values.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] If (TF_Output cond, TF_Output[] input, TF_DataType[] Tout, TF_Function then_branch, TF_Function else_branch, long[][] output_shapes = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "If", MakeName ("If", operName));
			c_api.TF_AddInput(desc, cond);
			c_api.TF_AddInputList(desc, input[0], input.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "Tout", Tout);
			c_api.TF_SetAttrFuncName (desc, "then_branch", c_api.TF_FunctionName(then_branch));
			c_api.TF_SetAttrFuncName (desc, "else_branch", c_api.TF_FunctionName(else_branch));
			if (output_shapes != null)
				c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		///   Inverse fast Fourier transform.
		/// </summary>
		/// <param name="input">
		///   A complex tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IFFT'.
		/// </param>
		/// <returns>
		///   A complex tensor of the same shape as <c>input</c>. The inner-most
		///   dimension of <c>input</c> is replaced with its inverse 1D Fourier transform.
		///   
		///   @compatibility(numpy)
		///   Equivalent to np.fft.ifft
		///   @end_compatibility
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Computes the inverse 1-dimensional discrete Fourier transform over the
		///   inner-most dimension of <c>input</c>.
		/// </remarks>
		public TF_Output IFFT (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IFFT", MakeName ("IFFT", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Inverse 2D fast Fourier transform.
		/// </summary>
		/// <param name="input">
		///   A complex tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IFFT2D'.
		/// </param>
		/// <returns>
		///   A complex tensor of the same shape as <c>input</c>. The inner-most 2
		///   dimensions of <c>input</c> are replaced with their inverse 2D Fourier transform.
		///   
		///   @compatibility(numpy)
		///   Equivalent to np.fft.ifft2
		///   @end_compatibility
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Computes the inverse 2-dimensional discrete Fourier transform over the
		///   inner-most 2 dimensions of <c>input</c>.
		/// </remarks>
		public TF_Output IFFT2D (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IFFT2D", MakeName ("IFFT2D", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Inverse 3D fast Fourier transform.
		/// </summary>
		/// <param name="input">
		///   A complex64 tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IFFT3D'.
		/// </param>
		/// <returns>
		///   A complex64 tensor of the same shape as <c>input</c>. The inner-most 3
		///   dimensions of <c>input</c> are replaced with their inverse 3D Fourier transform.
		///   
		///   @compatibility(numpy)
		///   Equivalent to np.fft.ifftn with 3 dimensions.
		///   @end_compatibility
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Computes the inverse 3-dimensional discrete Fourier transform over the
		///   inner-most 3 dimensions of <c>input</c>.
		/// </remarks>
		public TF_Output IFFT3D (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IFFT3D", MakeName ("IFFT3D", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Compute the lower regularized incomplete Gamma function <c>P(a, x)</c>.
		/// </summary>
		/// <param name="a">
		/// </param>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Igamma'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The lower regularized incomplete Gamma function is defined as:
		///   
		///   
		///   \\(P(a, x) = gamma(a, x) / Gamma(a) = 1 - Q(a, x)\\)
		///   
		///   where
		///   
		///   \\(gamma(a, x) = \\int_{0}^{x} t^{a-1} exp(-t) dt\\)
		///   
		///   is the lower incomplete Gamma function.
		///   
		///   Note, above <c>Q(a, x)</c> (<c>Igammac</c>) is the upper regularized complete
		///   Gamma function.
		/// </remarks>
		public TF_Output Igamma (TF_Output a, TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Igamma", MakeName ("Igamma", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Compute the upper regularized incomplete Gamma function <c>Q(a, x)</c>.
		/// </summary>
		/// <param name="a">
		/// </param>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Igammac'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The upper regularized incomplete Gamma function is defined as:
		///   
		///   \\(Q(a, x) = Gamma(a, x) / Gamma(a) = 1 - P(a, x)\\)
		///   
		///   where
		///   
		///   \\(Gamma(a, x) = int_{x}^{\infty} t^{a-1} exp(-t) dt\\)
		///   
		///   is the upper incomplete Gama function.
		///   
		///   Note, above <c>P(a, x)</c> (<c>Igamma</c>) is the lower regularized complete
		///   Gamma function.
		/// </remarks>
		public TF_Output Igammac (TF_Output a, TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Igammac", MakeName ("Igammac", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Computes the gradient of <c>igamma(a, x)</c> wrt <c>a</c>.
		/// </summary>
		/// <param name="a">
		/// </param>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IgammaGradA'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IgammaGradA (TF_Output a, TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IgammaGradA", MakeName ("IgammaGradA", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Creates a dataset that contains the elements of <c>input_dataset</c> ignoring errors.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IgnoreErrorsDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IgnoreErrorsDataset (TF_Output input_dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IgnoreErrorsDataset", MakeName ("IgnoreErrorsDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Returns the imaginary part of a complex number.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Imag'.
		/// </param>
		/// <param name="Tout">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given a tensor <c>input</c> of complex numbers, this operation returns a tensor of
		///   type <c>float</c> that is the imaginary part of each element in <c>input</c>. All
		///   elements in <c>input</c> must be complex numbers of the form \\(a + bj\\), where *a*
		///   is the real part and *b* is the imaginary part returned by this operation.
		///   
		///   For example:
		///   
		///    <code>
		///   # tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]
		///   tf.imag(input) ==&amp;gt; [4.75, 5.75]
		///    </code>
		/// </remarks>
		public TF_Output Imag (TF_Output input, TF_DataType? Tout = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Imag", MakeName ("Imag", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Tout.HasValue)
				c_api.TF_SetAttrType (desc, "Tout", Tout.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Outputs a <c>Summary</c> protocol buffer with images.
		/// </summary>
		/// <param name="tag">
		///   Scalar. Used to build the <c>tag</c> attribute of the summary values.
		/// </param>
		/// <param name="tensor">
		///   4-D of shape <c>[batch_size, height, width, channels]</c> where
		///   <c>channels</c> is 1, 3, or 4.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ImageSummary'.
		/// </param>
		/// <param name="max_images">
		///   Optional argument
		///   Max number of batch elements to generate images for.
		/// </param>
		/// <param name="bad_color">
		///   Optional argument
		///   Color to use for pixels with non-finite values.
		/// </param>
		/// <returns>
		///   Scalar. Serialized <c>Summary</c> protocol buffer.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The summary has up to <c>max_images</c> summary values containing images. The
		///   images are built from <c>tensor</c> which must be 4-D with shape <c>[batch_size,
		///   height, width, channels]</c> and where <c>channels</c> can be:
		///   
		///   *  1: <c>tensor</c> is interpreted as Grayscale.
		///   *  3: <c>tensor</c> is interpreted as RGB.
		///   *  4: <c>tensor</c> is interpreted as RGBA.
		///   
		///   The images have the same number of channels as the input tensor. For float
		///   input, the values are normalized one image at a time to fit in the range
		///   <c>[0, 255]</c>.  <c>uint8</c> values are unchanged.  The op uses two different
		///   normalization algorithms:
		///   
		///   *  If the input values are all positive, they are rescaled so the largest one
		///   is 255.
		///   
		///   *  If any input value is negative, the values are shifted so input value 0.0
		///   is at 127.  They are then rescaled so that either the smallest value is 0,
		///   or the largest one is 255.
		///   
		///   The <c>tag</c> argument is a scalar <c>Tensor</c> of type <c>string</c>.  It is used to
		///   build the <c>tag</c> of the summary values:
		///   
		///   *  If <c>max_images</c> is 1, the summary value tag is '*tag*/image'.
		///   *  If <c>max_images</c> is greater than 1, the summary value tags are
		///   generated sequentially as '*tag*/image/0', '*tag*/image/1', etc.
		///   
		///   The <c>bad_color</c> argument is the color to use in the generated images for
		///   non-finite input values.  It is a <c>uint8</c> 1-D tensor of length <c>channels</c>.
		///   Each element must be in the range <c>[0, 255]</c> (It represents the value of a
		///   pixel in the output image).  Non-finite values in the input tensor are
		///   replaced by this tensor in the output image.  The default value is the color
		///   red.
		/// </remarks>
		public TF_Output ImageSummary (TF_Output tag, TF_Output tensor, long? max_images = null, TF_Tensor bad_color = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ImageSummary", MakeName ("ImageSummary", operName));
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (max_images.HasValue)
				c_api.TF_SetAttrInt (desc, "max_images", max_images.Value);
			
			if (bad_color != null)
				c_api.TF_SetAttrTensor (desc, "bad_color", bad_color, status);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var summary = new TF_Output (op, _idx++);
			return summary;
		}

		/// <summary>
		///   Returns immutable tensor from memory region.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ImmutableConst'.
		/// </param>
		/// <param name="dtype">
		///   Type of the returned tensor.
		/// </param>
		/// <param name="shape">
		///   Shape of the returned tensor.
		/// </param>
		/// <param name="memory_region_name">
		///   Name of readonly memory region used by the tensor, see
		///   NewReadOnlyMemoryRegionFromFile in tensorflow::Env.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The current implementation memmaps the tensor from a file.
		/// </remarks>
		public TF_Output ImmutableConst (TF_DataType dtype, long[] shape, string memory_region_name, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ImmutableConst", MakeName ("ImmutableConst", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			c_api.TF_SetAttrString (desc, "memory_region_name", memory_region_name);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var tensor = new TF_Output (op, _idx++);
			return tensor;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="evnt">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ImportEvent'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ImportEvent (TF_Output writer, TF_Output evnt, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ImportEvent", MakeName ("ImportEvent", operName));
			c_api.TF_AddInput(desc, writer);
			c_api.TF_AddInput(desc, evnt);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   A placeholder op for a value that will be fed into the computation.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InfeedDequeue'.
		/// </param>
		/// <param name="dtype">
		///   The type of elements in the tensor.
		/// </param>
		/// <param name="shape">
		///   The shape of the tensor.
		/// </param>
		/// <returns>
		///   A tensor that will be provided using the infeed mechanism.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output InfeedDequeue (TF_DataType dtype, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InfeedDequeue", MakeName ("InfeedDequeue", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Fetches multiple values from infeed as an XLA tuple.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InfeedDequeueTuple'.
		/// </param>
		/// <param name="dtypes">
		///   The element types of each element in <c>outputs</c>.
		/// </param>
		/// <param name="shapes">
		///   The shapes of each tensor in <c>outputs</c>.
		/// </param>
		/// <returns>
		///   A list of tensors that will be provided using the infeed mechanism.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] InfeedDequeueTuple (TF_DataType[] dtypes, long[][] shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InfeedDequeueTuple", MakeName ("InfeedDequeueTuple", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "outputs", status);
			var outputs = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				outputs [i] = new TF_Output (op, _idx++);
			
			return outputs;
		}

		/// <summary>
		///   An op which feeds a single Tensor value into the computation.
		/// </summary>
		/// <param name="input">
		///   A tensor that will be provided using the infeed mechanism.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InfeedEnqueue'.
		/// </param>
		/// <param name="shape">
		///   Optional argument
		///   The shape of the tensor.
		/// </param>
		/// <param name="layout">
		///   Optional argument
		///   A vector holding the requested layout in minor-to-major sequence.
		///   If a layout attribute is passed, but its values are all -1, the layout will
		///   be computed by the infeed operation.
		/// </param>
		/// <param name="device_ordinal">
		///   Optional argument
		///   The TPU device to use. This should be -1 when the Op
		///   is running on a TPU device, and &amp;gt;= 0 when the Op is running on the CPU
		///   device.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation InfeedEnqueue (TF_Output input, long[] shape = null, long[] layout = null, long? device_ordinal = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InfeedEnqueue", MakeName ("InfeedEnqueue", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (shape != null)
				c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			
			if (layout != null)
				c_api.TF_SetAttrIntList (desc, "layout", ref layout[0], layout.Length);
			
			if (device_ordinal.HasValue)
				c_api.TF_SetAttrInt (desc, "device_ordinal", device_ordinal.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   An op which enqueues prelinearized buffer into TPU infeed.
		/// </summary>
		/// <param name="input">
		///   A variant tensor representing linearized output.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InfeedEnqueuePrelinearizedBuffer'.
		/// </param>
		/// <param name="device_ordinal">
		///   Optional argument
		///   The TPU device to use. This should be -1 when the Op is running on a TPU device
		///   and = 0 when the Op is running on the CPU device.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation InfeedEnqueuePrelinearizedBuffer (TF_Output input, long? device_ordinal = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InfeedEnqueuePrelinearizedBuffer", MakeName ("InfeedEnqueuePrelinearizedBuffer", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (device_ordinal.HasValue)
				c_api.TF_SetAttrInt (desc, "device_ordinal", device_ordinal.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Feeds multiple Tensor values into the computation as an XLA tuple.
		/// </summary>
		/// <param name="inputs">
		///   A list of tensors that will be provided using the infeed mechanism.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InfeedEnqueueTuple'.
		/// </param>
		/// <param name="layouts">
		///   Optional argument
		///   A vector holding the requested layout in minor-to-major sequence for
		///   all the tuple shapes, in the order the shapes appear in the "shapes" input.
		///   The layout elements for a sub-shape can be set to -1, in which case the
		///   corresponding layout will be computed by the infeed operation.
		/// </param>
		/// <param name="device_ordinal">
		///   Optional argument
		///   The TPU device to use. This should be -1 when the Op
		///   is running on a TPU device, and &amp;gt;= 0 when the Op is running on the CPU
		///   device.
		/// </param>
		/// <param name="shapes">
		///   The shapes of each tensor in <c>inputs</c>.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation InfeedEnqueueTuple (TF_Output[] inputs, long[][] shapes, long[] layouts = null, long? device_ordinal = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InfeedEnqueueTuple", MakeName ("InfeedEnqueueTuple", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			if (layouts != null)
				c_api.TF_SetAttrIntList (desc, "layouts", ref layouts[0], layouts.Length);
			
			if (device_ordinal.HasValue)
				c_api.TF_SetAttrInt (desc, "device_ordinal", device_ordinal.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Table initializer that takes two tensors for keys and values respectively.
		/// </summary>
		/// <param name="table_handle">
		///   Handle to a table which will be initialized.
		/// </param>
		/// <param name="keys">
		///   Keys of type Tkey.
		/// </param>
		/// <param name="values">
		///   Values of type Tval.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InitializeTable'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation InitializeTable (TF_Output table_handle, TF_Output keys, TF_Output values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InitializeTable", MakeName ("InitializeTable", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, keys);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Initializes a table from a text file.
		/// </summary>
		/// <param name="table_handle">
		///   Handle to a table which will be initialized.
		/// </param>
		/// <param name="filename">
		///   Filename of a vocabulary text file.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InitializeTableFromTextFile'.
		/// </param>
		/// <param name="vocab_size">
		///   Optional argument
		///   Number of elements of the file, use -1 if unknown.
		/// </param>
		/// <param name="delimiter">
		///   Optional argument
		///   Delimiter to separate fields in a line.
		/// </param>
		/// <param name="key_index">
		///   Column index in a line to get the table <c>key</c> values from.
		/// </param>
		/// <param name="value_index">
		///   Column index that represents information of a line to get the table
		///   <c>value</c> values from.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   It inserts one key-value pair into the table for each line of the file.
		///   The key and value is extracted from the whole line content, elements from the
		///   split line based on <c>delimiter</c> or the line number (starting from zero).
		///   Where to extract the key and value from a line is specified by <c>key_index</c> and
		///   <c>value_index</c>.
		///   
		///   - A value of -1 means use the line number(starting from zero), expects <c>int64</c>.
		///   - A value of -2 means use the whole line content, expects <c>string</c>.
		///   - A value &amp;gt;= 0 means use the index (starting at zero) of the split line based
		///   on <c>delimiter</c>.
		/// </remarks>
		public TF_Operation InitializeTableFromTextFile (TF_Output table_handle, TF_Output filename, long key_index, long value_index, long? vocab_size = null, string delimiter = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InitializeTableFromTextFile", MakeName ("InitializeTableFromTextFile", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, filename);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "key_index", key_index);
			c_api.TF_SetAttrInt (desc, "value_index", value_index);
			if (vocab_size.HasValue)
				c_api.TF_SetAttrInt (desc, "vocab_size", vocab_size.Value);
			
			if (delimiter != null)
				c_api.TF_SetAttrString (desc, "delimiter", delimiter);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Initializes a table from a text file.
		/// </summary>
		/// <param name="table_handle">
		///   Handle to a table which will be initialized.
		/// </param>
		/// <param name="filename">
		///   Filename of a vocabulary text file.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InitializeTableFromTextFileV2'.
		/// </param>
		/// <param name="vocab_size">
		///   Optional argument
		///   Number of elements of the file, use -1 if unknown.
		/// </param>
		/// <param name="delimiter">
		///   Optional argument
		///   Delimiter to separate fields in a line.
		/// </param>
		/// <param name="key_index">
		///   Column index in a line to get the table <c>key</c> values from.
		/// </param>
		/// <param name="value_index">
		///   Column index that represents information of a line to get the table
		///   <c>value</c> values from.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   It inserts one key-value pair into the table for each line of the file.
		///   The key and value is extracted from the whole line content, elements from the
		///   split line based on <c>delimiter</c> or the line number (starting from zero).
		///   Where to extract the key and value from a line is specified by <c>key_index</c> and
		///   <c>value_index</c>.
		///   
		///   - A value of -1 means use the line number(starting from zero), expects <c>int64</c>.
		///   - A value of -2 means use the whole line content, expects <c>string</c>.
		///   - A value &amp;gt;= 0 means use the index (starting at zero) of the split line based
		///   on <c>delimiter</c>.
		/// </remarks>
		public TF_Operation InitializeTableFromTextFileV2 (TF_Output table_handle, TF_Output filename, long key_index, long value_index, long? vocab_size = null, string delimiter = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InitializeTableFromTextFileV2", MakeName ("InitializeTableFromTextFileV2", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, filename);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "key_index", key_index);
			c_api.TF_SetAttrInt (desc, "value_index", value_index);
			if (vocab_size.HasValue)
				c_api.TF_SetAttrInt (desc, "vocab_size", vocab_size.Value);
			
			if (delimiter != null)
				c_api.TF_SetAttrString (desc, "delimiter", delimiter);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Table initializer that takes two tensors for keys and values respectively.
		/// </summary>
		/// <param name="table_handle">
		///   Handle to a table which will be initialized.
		/// </param>
		/// <param name="keys">
		///   Keys of type Tkey.
		/// </param>
		/// <param name="values">
		///   Values of type Tval.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InitializeTableV2'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation InitializeTableV2 (TF_Output table_handle, TF_Output keys, TF_Output values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InitializeTableV2", MakeName ("InitializeTableV2", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, keys);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Adds v into specified rows of x.
		///   
		///   Computes y = x; y[i, :] += v; return y.
		/// </summary>
		/// <param name="x">
		///   A <c>Tensor</c> of type T.
		/// </param>
		/// <param name="i">
		///   A vector. Indices into the left-most dimension of <c>x</c>.
		/// </param>
		/// <param name="v">
		///   A <c>Tensor</c> of type T. Same dimension sizes as x except the first dimension, which must be the same as i's size.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InplaceAdd'.
		/// </param>
		/// <returns>
		///   A <c>Tensor</c> of type T. An alias of <c>x</c>. The content of <c>y</c> is undefined if there are duplicates in <c>i</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output InplaceAdd (TF_Output x, TF_Output i, TF_Output v, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InplaceAdd", MakeName ("InplaceAdd", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, i);
			c_api.TF_AddInput(desc, v);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Subtracts <c>v</c> into specified rows of <c>x</c>.
		///   
		///   Computes y = x; y[i, :] -= v; return y.
		/// </summary>
		/// <param name="x">
		///   A <c>Tensor</c> of type T.
		/// </param>
		/// <param name="i">
		///   A vector. Indices into the left-most dimension of <c>x</c>.
		/// </param>
		/// <param name="v">
		///   A <c>Tensor</c> of type T. Same dimension sizes as x except the first dimension, which must be the same as i's size.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InplaceSub'.
		/// </param>
		/// <returns>
		///   A <c>Tensor</c> of type T. An alias of <c>x</c>. The content of <c>y</c> is undefined if there are duplicates in <c>i</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output InplaceSub (TF_Output x, TF_Output i, TF_Output v, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InplaceSub", MakeName ("InplaceSub", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, i);
			c_api.TF_AddInput(desc, v);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Updates specified rows with values in <c>v</c>.
		///   
		///   Computes <c>x[i, :] = v; return x</c>.
		/// </summary>
		/// <param name="x">
		///   A tensor of type <c>T</c>.
		/// </param>
		/// <param name="i">
		///   A vector. Indices into the left-most dimension of <c>x</c>.
		/// </param>
		/// <param name="v">
		///   A <c>Tensor</c> of type T. Same dimension sizes as x except the first dimension, which must be the same as i's size.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InplaceUpdate'.
		/// </param>
		/// <returns>
		///   A <c>Tensor</c> of type T. An alias of <c>x</c>. The content of <c>y</c> is undefined if there are duplicates in <c>i</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output InplaceUpdate (TF_Output x, TF_Output i, TF_Output v, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InplaceUpdate", MakeName ("InplaceUpdate", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, i);
			c_api.TF_AddInput(desc, v);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Creates a dataset that applies <c>f</c> to the outputs of <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="other_arguments">
		/// </param>
		/// <param name="cycle_length">
		/// </param>
		/// <param name="block_length">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InterleaveDataset'.
		/// </param>
		/// <param name="f">
		///   A function mapping elements of <c>input_dataset</c>, concatenated with
		///   <c>other_arguments</c>, to a Dataset variant that contains elements matching
		///   <c>output_types</c> and <c>output_shapes</c>.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Unlike MapDataset, the <c>f</c> in InterleaveDataset is expected to return
		///   a Dataset variant, and InterleaveDataset will flatten successive
		///   results into a single Dataset. Unlike FlatMapDataset,
		///   InterleaveDataset will interleave sequences of up to <c>block_length</c>
		///   consecutive elements from <c>cycle_length</c> input elements.
		/// </remarks>
		public TF_Output InterleaveDataset (TF_Output input_dataset, TF_Output[] other_arguments, TF_Output cycle_length, TF_Output block_length, TF_Function f, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InterleaveDataset", MakeName ("InterleaveDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInputList(desc, other_arguments[0], other_arguments.Length);
			c_api.TF_AddInput(desc, cycle_length);
			c_api.TF_AddInput(desc, block_length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "f", c_api.TF_FunctionName(f));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Says whether the targets are in the top <c>K</c> predictions.
		/// </summary>
		/// <param name="predictions">
		///   A <c>batch_size</c> x <c>classes</c> tensor.
		/// </param>
		/// <param name="targets">
		///   A <c>batch_size</c> vector of class ids.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InTopK'.
		/// </param>
		/// <param name="k">
		///   Number of top elements to look at for computing precision.
		/// </param>
		/// <returns>
		///   Computed Precision at <c>k</c> as a <c>bool Tensor</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This outputs a <c>batch_size</c> bool array, an entry <c>out[i]</c> is <c>true</c> if the
		///   prediction for the target class is among the top <c>k</c> predictions among
		///   all predictions for example <c>i</c>. Note that the behavior of <c>InTopK</c> differs
		///   from the <c>TopK</c> op in its handling of ties; if multiple classes have the
		///   same prediction value and straddle the top-<c>k</c> boundary, all of those
		///   classes are considered to be in the top <c>k</c>.
		///   
		///   More formally, let
		///   
		///   \\(predictions_i\\) be the predictions for all classes for example <c>i</c>,
		///   \\(targets_i\\) be the target class for example <c>i</c>,
		///   \\(out_i\\) be the output for example <c>i</c>,
		///   
		///   $$out_i = predictions_{i, targets_i} \in TopKIncludingTies(predictions_i)$$
		/// </remarks>
		public TF_Output InTopK (TF_Output predictions, TF_Output targets, long k, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InTopK", MakeName ("InTopK", operName));
			c_api.TF_AddInput(desc, predictions);
			c_api.TF_AddInput(desc, targets);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "k", k);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var precision = new TF_Output (op, _idx++);
			return precision;
		}

		/// <summary>
		///   Says whether the targets are in the top <c>K</c> predictions.
		/// </summary>
		/// <param name="predictions">
		///   A <c>batch_size</c> x <c>classes</c> tensor.
		/// </param>
		/// <param name="targets">
		///   A <c>batch_size</c> vector of class ids.
		/// </param>
		/// <param name="k">
		///   Number of top elements to look at for computing precision.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InTopKV2'.
		/// </param>
		/// <returns>
		///   Computed precision at <c>k</c> as a <c>bool Tensor</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This outputs a <c>batch_size</c> bool array, an entry <c>out[i]</c> is <c>true</c> if the
		///   prediction for the target class is among the top <c>k</c> predictions among
		///   all predictions for example <c>i</c>. Note that the behavior of <c>InTopK</c> differs
		///   from the <c>TopK</c> op in its handling of ties; if multiple classes have the
		///   same prediction value and straddle the top-<c>k</c> boundary, all of those
		///   classes are considered to be in the top <c>k</c>.
		///   
		///   More formally, let
		///   
		///   \\(predictions_i\\) be the predictions for all classes for example <c>i</c>,
		///   \\(targets_i\\) be the target class for example <c>i</c>,
		///   \\(out_i\\) be the output for example <c>i</c>,
		///   
		///   $$out_i = predictions_{i, targets_i} \in TopKIncludingTies(predictions_i)$$
		/// </remarks>
		public TF_Output InTopKV2 (TF_Output predictions, TF_Output targets, TF_Output k, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InTopKV2", MakeName ("InTopKV2", operName));
			c_api.TF_AddInput(desc, predictions);
			c_api.TF_AddInput(desc, targets);
			c_api.TF_AddInput(desc, k);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var precision = new TF_Output (op, _idx++);
			return precision;
		}

		/// <summary>
		///   Computes the reciprocal of x element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Inv'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   I.e., \\(y = 1 / x\\).
		/// </remarks>
		public TF_Output Inv (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Inv", MakeName ("Inv", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Invert (flip) each bit of supported types; for example, type <c>uint8</c> value 01010101 becomes 10101010.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Invert'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Flip each bit of supported types.  For example, type <c>int8</c> (decimal 2) binary 00000010 becomes (decimal -3) binary 11111101.
		///   This operation is performed on each element of the tensor argument <c>x</c>.
		///   
		///   Example:
		///    <code>
		///   import tensorflow as tf
		///   from tensorflow.python.ops import bitwise_ops
		///   
		///   # flip 2 (00000010) to -3 (11111101)
		///   tf.assert_equal(-3, bitwise_ops.invert(2))
		///   
		///   dtype_list = [dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64,
		///   dtypes.uint8, dtypes.uint16, dtypes.uint32, dtypes.uint64]
		///   
		///   inputs = [0, 5, 3, 14]
		///   for dtype in dtype_list:
		///   # Because of issues with negative numbers, let's test this indirectly.
		///   # 1. invert(a) and a = 0
		///   # 2. invert(a) or a = invert(0)
		///   input_tensor = tf.constant([0, 5, 3, 14], dtype=dtype)
		///   not_a_and_a, not_a_or_a, not_0 = [bitwise_ops.bitwise_and(
		///   input_tensor, bitwise_ops.invert(input_tensor)),
		///   bitwise_ops.bitwise_or(
		///   input_tensor, bitwise_ops.invert(input_tensor)),
		///   bitwise_ops.invert(
		///   tf.constant(0, dtype=dtype))]
		///   
		///   expected = tf.constant([0, 0, 0, 0], dtype=tf.float32)
		///   tf.assert_equal(tf.cast(not_a_and_a, tf.float32), expected)
		///   
		///   expected = tf.cast([not_0] * 4, tf.float32)
		///   tf.assert_equal(tf.cast(not_a_or_a, tf.float32), expected)
		///   
		///   # For unsigned dtypes let's also check the result directly.
		///   if dtype.is_unsigned:
		///   inverted = bitwise_ops.invert(input_tensor)
		///   expected = tf.constant([dtype.max - x for x in inputs], dtype=tf.float32)
		///   tf.assert_equal(tf.cast(inverted, tf.float32), tf.cast(expected, tf.float32))
		///    </code>
		/// </remarks>
		public TF_Output Invert (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Invert", MakeName ("Invert", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes the inverse permutation of a tensor.
		/// </summary>
		/// <param name="x">
		///   1-D.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InvertPermutation'.
		/// </param>
		/// <returns>
		///   1-D.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation computes the inverse of an index permutation. It takes a 1-D
		///   integer tensor <c>x</c>, which represents the indices of a zero-based array, and
		///   swaps each value with its index position. In other words, for an output tensor
		///   <c>y</c> and an input tensor <c>x</c>, this operation computes the following:
		///   
		///   <c>y[x[i]] = i for i in [0, 1, ..., len(x) - 1]</c>
		///   
		///   The values must include 0. There can be no duplicate values or negative values.
		///   
		///   For example:
		///   
		///    <code>
		///   # tensor <c>x</c> is [3, 4, 0, 2, 1]
		///   invert_permutation(x) ==&amp;gt; [2, 4, 3, 0, 1]
		///    </code>
		/// </remarks>
		public TF_Output InvertPermutation (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InvertPermutation", MakeName ("InvertPermutation", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes the gradient for the inverse of <c>x</c> wrt its input.
		/// </summary>
		/// <param name="y">
		/// </param>
		/// <param name="dy">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'InvGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Specifically, <c>grad = -dy * y*y</c>, where <c>y = 1/x</c>, and <c>dy</c>
		///   is the corresponding input gradient.
		/// </remarks>
		public TF_Output InvGrad (TF_Output y, TF_Output dy, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "InvGrad", MakeName ("InvGrad", operName));
			c_api.TF_AddInput(desc, y);
			c_api.TF_AddInput(desc, dy);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Inverse real-valued fast Fourier transform.
		/// </summary>
		/// <param name="input">
		///   A complex64 tensor.
		/// </param>
		/// <param name="fft_length">
		///   An int32 tensor of shape [1]. The FFT length.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IRFFT'.
		/// </param>
		/// <returns>
		///   A float32 tensor of the same rank as <c>input</c>. The inner-most
		///   dimension of <c>input</c> is replaced with the <c>fft_length</c> samples of its inverse
		///   1D Fourier transform.
		///   
		///   @compatibility(numpy)
		///   Equivalent to np.fft.irfft
		///   @end_compatibility
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Computes the inverse 1-dimensional discrete Fourier transform of a real-valued
		///   signal over the inner-most dimension of <c>input</c>.
		///   
		///   The inner-most dimension of <c>input</c> is assumed to be the result of <c>RFFT</c>: the
		///   <c>fft_length / 2 + 1</c> unique components of the DFT of a real-valued signal. If
		///   <c>fft_length</c> is not provided, it is computed from the size of the inner-most
		///   dimension of <c>input</c> (<c>fft_length = 2 * (inner - 1)</c>). If the FFT length used to
		///   compute <c>input</c> is odd, it should be provided since it cannot be inferred
		///   properly.
		///   
		///   Along the axis <c>IRFFT</c> is computed on, if <c>fft_length / 2 + 1</c> is smaller
		///   than the corresponding dimension of <c>input</c>, the dimension is cropped. If it is
		///   larger, the dimension is padded with zeros.
		/// </remarks>
		public TF_Output IRFFT (TF_Output input, TF_Output fft_length, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IRFFT", MakeName ("IRFFT", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, fft_length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Inverse 2D real-valued fast Fourier transform.
		/// </summary>
		/// <param name="input">
		///   A complex64 tensor.
		/// </param>
		/// <param name="fft_length">
		///   An int32 tensor of shape [2]. The FFT length for each dimension.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IRFFT2D'.
		/// </param>
		/// <returns>
		///   A float32 tensor of the same rank as <c>input</c>. The inner-most 2
		///   dimensions of <c>input</c> are replaced with the <c>fft_length</c> samples of their
		///   inverse 2D Fourier transform.
		///   
		///   @compatibility(numpy)
		///   Equivalent to np.fft.irfft2
		///   @end_compatibility
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Computes the inverse 2-dimensional discrete Fourier transform of a real-valued
		///   signal over the inner-most 2 dimensions of <c>input</c>.
		///   
		///   The inner-most 2 dimensions of <c>input</c> are assumed to be the result of <c>RFFT2D</c>:
		///   The inner-most dimension contains the <c>fft_length / 2 + 1</c> unique components of
		///   the DFT of a real-valued signal. If <c>fft_length</c> is not provided, it is computed
		///   from the size of the inner-most 2 dimensions of <c>input</c>. If the FFT length used
		///   to compute <c>input</c> is odd, it should be provided since it cannot be inferred
		///   properly.
		///   
		///   Along each axis <c>IRFFT2D</c> is computed on, if <c>fft_length</c> (or
		///   <c>fft_length / 2 + 1</c> for the inner-most dimension) is smaller than the
		///   corresponding dimension of <c>input</c>, the dimension is cropped. If it is larger,
		///   the dimension is padded with zeros.
		/// </remarks>
		public TF_Output IRFFT2D (TF_Output input, TF_Output fft_length, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IRFFT2D", MakeName ("IRFFT2D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, fft_length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Inverse 3D real-valued fast Fourier transform.
		/// </summary>
		/// <param name="input">
		///   A complex64 tensor.
		/// </param>
		/// <param name="fft_length">
		///   An int32 tensor of shape [3]. The FFT length for each dimension.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IRFFT3D'.
		/// </param>
		/// <returns>
		///   A float32 tensor of the same rank as <c>input</c>. The inner-most 3
		///   dimensions of <c>input</c> are replaced with the <c>fft_length</c> samples of their
		///   inverse 3D real Fourier transform.
		///   
		///   @compatibility(numpy)
		///   Equivalent to np.irfftn with 3 dimensions.
		///   @end_compatibility
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Computes the inverse 3-dimensional discrete Fourier transform of a real-valued
		///   signal over the inner-most 3 dimensions of <c>input</c>.
		///   
		///   The inner-most 3 dimensions of <c>input</c> are assumed to be the result of <c>RFFT3D</c>:
		///   The inner-most dimension contains the <c>fft_length / 2 + 1</c> unique components of
		///   the DFT of a real-valued signal. If <c>fft_length</c> is not provided, it is computed
		///   from the size of the inner-most 3 dimensions of <c>input</c>. If the FFT length used
		///   to compute <c>input</c> is odd, it should be provided since it cannot be inferred
		///   properly.
		///   
		///   Along each axis <c>IRFFT3D</c> is computed on, if <c>fft_length</c> (or
		///   <c>fft_length / 2 + 1</c> for the inner-most dimension) is smaller than the
		///   corresponding dimension of <c>input</c>, the dimension is cropped. If it is larger,
		///   the dimension is padded with zeros.
		/// </remarks>
		public TF_Output IRFFT3D (TF_Output input, TF_Output fft_length, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IRFFT3D", MakeName ("IRFFT3D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, fft_length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Checks whether a tree ensemble has been initialized.
		/// </summary>
		/// <param name="tree_ensemble_handle">
		///   Handle to the tree ensemble resouce.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IsBoostedTreesEnsembleInitialized'.
		/// </param>
		/// <returns>
		///   output boolean on whether it is initialized or not.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IsBoostedTreesEnsembleInitialized (TF_Output tree_ensemble_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IsBoostedTreesEnsembleInitialized", MakeName ("IsBoostedTreesEnsembleInitialized", operName));
			c_api.TF_AddInput(desc, tree_ensemble_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var is_initialized = new TF_Output (op, _idx++);
			return is_initialized;
		}

		/// <summary>
		///   Checks whether a quantile stream has been initialized.
		/// </summary>
		/// <param name="quantile_stream_resource_handle">
		///   resource; The reference to quantile stream resource handle.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IsBoostedTreesQuantileStreamResourceInitialized'.
		/// </param>
		/// <returns>
		///   bool; True if the resource is initialized, False otherwise.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   An Op that checks if quantile stream resource is initialized.
		/// </remarks>
		public TF_Output IsBoostedTreesQuantileStreamResourceInitialized (TF_Output quantile_stream_resource_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IsBoostedTreesQuantileStreamResourceInitialized", MakeName ("IsBoostedTreesQuantileStreamResourceInitialized", operName));
			c_api.TF_AddInput(desc, quantile_stream_resource_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var is_initialized = new TF_Output (op, _idx++);
			return is_initialized;
		}

		/// <summary>
		///   Returns which elements of x are finite.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IsFinite'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   @compatibility(numpy)
		///   Equivalent to np.isfinite
		///   @end_compatibility
		/// </remarks>
		public TF_Output IsFinite (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IsFinite", MakeName ("IsFinite", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Returns which elements of x are Inf.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IsInf'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   @compatibility(numpy)
		///   Equivalent to np.isinf
		///   @end_compatibility
		/// </remarks>
		public TF_Output IsInf (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IsInf", MakeName ("IsInf", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Returns which elements of x are NaN.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IsNan'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   @compatibility(numpy)
		///   Equivalent to np.isnan
		///   @end_compatibility
		/// </remarks>
		public TF_Output IsNan (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IsNan", MakeName ("IsNan", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Checks whether a tensor has been initialized.
		/// </summary>
		/// <param name="reference">
		///   Should be from a <c>Variable</c> node. May be uninitialized.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IsVariableInitialized'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Outputs boolean scalar indicating whether the tensor has been initialized.
		/// </remarks>
		public TF_Output IsVariableInitialized (TF_Output reference, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IsVariableInitialized", MakeName ("IsVariableInitialized", operName));
			c_api.TF_AddInput(desc, reference);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var is_initialized = new TF_Output (op, _idx++);
			return is_initialized;
		}

		/// <summary>
		///   A container for an iterator resource.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Iterator'.
		/// </param>
		/// <param name="shared_name">
		/// </param>
		/// <param name="container">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   A handle to the iterator that can be passed to a "MakeIterator"
		///   or "IteratorGetNext" op.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Iterator (string shared_name, string container, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Iterator", MakeName ("Iterator", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			c_api.TF_SetAttrString (desc, "container", container);
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Converts the given string representing a handle to an iterator to a resource.
		/// </summary>
		/// <param name="string_handle">
		///   A string representation of the given handle.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorFromStringHandle'.
		/// </param>
		/// <param name="output_types">
		///   Optional argument
		///   If specified, defines the type of each tuple component in an
		///   element produced by the resulting iterator.
		/// </param>
		/// <param name="output_shapes">
		///   Optional argument
		///   If specified, defines the shape of each tuple component in an
		///   element produced by the resulting iterator.
		/// </param>
		/// <returns>
		///   A handle to an iterator resource.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IteratorFromStringHandle (TF_Output string_handle, TF_DataType[] output_types = null, long[][] output_shapes = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IteratorFromStringHandle", MakeName ("IteratorFromStringHandle", operName));
			c_api.TF_AddInput(desc, string_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (output_types != null)
				c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			
			if (output_shapes != null)
				c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var resource_handle = new TF_Output (op, _idx++);
			return resource_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="string_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorFromStringHandleV2'.
		/// </param>
		/// <param name="output_types">
		///   Optional argument
		/// </param>
		/// <param name="output_shapes">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IteratorFromStringHandleV2 (TF_Output string_handle, TF_DataType[] output_types = null, long[][] output_shapes = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IteratorFromStringHandleV2", MakeName ("IteratorFromStringHandleV2", operName));
			c_api.TF_AddInput(desc, string_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (output_types != null)
				c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			
			if (output_shapes != null)
				c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var resource_handle = new TF_Output (op, _idx++);
			return resource_handle;
		}

		/// <summary>
		///   Returns the name of the device on which <c>resource</c> has been placed.
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorGetDevice'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IteratorGetDevice (TF_Output resource, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IteratorGetDevice", MakeName ("IteratorGetDevice", operName));
			c_api.TF_AddInput(desc, resource);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var device = new TF_Output (op, _idx++);
			return device;
		}

		/// <summary>
		///   Gets the next output from the given iterator .
		/// </summary>
		/// <param name="iterator">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorGetNext'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] IteratorGetNext (TF_Output iterator, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IteratorGetNext", MakeName ("IteratorGetNext", operName));
			c_api.TF_AddInput(desc, iterator);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "components", status);
			var components = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				components [i] = new TF_Output (op, _idx++);
			
			return components;
		}

		/// <summary>
		///   Gets the next output from the given iterator as an Optional variant.
		/// </summary>
		/// <param name="iterator">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorGetNextAsOptional'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IteratorGetNextAsOptional (TF_Output iterator, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IteratorGetNextAsOptional", MakeName ("IteratorGetNextAsOptional", operName));
			c_api.TF_AddInput(desc, iterator);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var optional = new TF_Output (op, _idx++);
			return optional;
		}

		/// <summary>
		///   Gets the next output from the given iterator.
		/// </summary>
		/// <param name="iterator">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorGetNextSync'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation is a synchronous version IteratorGetNext. It should only be used
		///   in situations where the iterator does not block the calling thread, or where
		///   the calling thread is not a member of the thread pool used to execute parallel
		///   operations (e.g. in eager mode).
		/// </remarks>
		public TF_Output[] IteratorGetNextSync (TF_Output iterator, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IteratorGetNextSync", MakeName ("IteratorGetNextSync", operName));
			c_api.TF_AddInput(desc, iterator);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "components", status);
			var components = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				components [i] = new TF_Output (op, _idx++);
			
			return components;
		}

		/// <summary>
		///   Converts the given <c>resource_handle</c> representing an iterator to a string.
		/// </summary>
		/// <param name="resource_handle">
		///   A handle to an iterator resource.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorToStringHandle'.
		/// </param>
		/// <returns>
		///   A string representation of the given handle.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IteratorToStringHandle (TF_Output resource_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IteratorToStringHandle", MakeName ("IteratorToStringHandle", operName));
			c_api.TF_AddInput(desc, resource_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var string_handle = new TF_Output (op, _idx++);
			return string_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorV2'.
		/// </param>
		/// <param name="shared_name">
		/// </param>
		/// <param name="container">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output IteratorV2 (string shared_name, string container, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "IteratorV2", MakeName ("IteratorV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			c_api.TF_SetAttrString (desc, "container", container);
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Returns the index of a data point that should be added to the seed set.
		/// </summary>
		/// <param name="distances">
		///   Vector with squared distances to the closest previously sampled cluster center
		///   for each candidate point.
		/// </param>
		/// <param name="seed">
		///   Scalar. Seed for initializing the random number generator.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'KMC2ChainInitialization'.
		/// </param>
		/// <returns>
		///   Scalar with the index of the sampled point.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Entries in distances are assumed to be squared distances of candidate points to
		///   the already sampled centers in the seed set. The op constructs one Markov chain
		///   of the k-MC^2 algorithm and returns the index of one candidate point to be added
		///   as an additional cluster center.
		/// </remarks>
		public TF_Output KMC2ChainInitialization (TF_Output distances, TF_Output seed, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "KMC2ChainInitialization", MakeName ("KMC2ChainInitialization", operName));
			c_api.TF_AddInput(desc, distances);
			c_api.TF_AddInput(desc, seed);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var index = new TF_Output (op, _idx++);
			return index;
		}

		/// <summary>
		///   Selects num_to_sample rows of input using the KMeans++ criterion.
		/// </summary>
		/// <param name="points">
		///   Matrix of shape (n, d). Rows are assumed to be input points.
		/// </param>
		/// <param name="num_to_sample">
		///   Scalar. The number of rows to sample. This value must not be larger than n.
		/// </param>
		/// <param name="seed">
		///   Scalar. Seed for initializing the random number generator.
		/// </param>
		/// <param name="num_retries_per_sample">
		///   Scalar. For each row that is sampled, this parameter
		///   specifies the number of additional points to draw from the current
		///   distribution before selecting the best. If a negative value is specified, a
		///   heuristic is used to sample O(log(num_to_sample)) additional points.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'KmeansPlusPlusInitialization'.
		/// </param>
		/// <returns>
		///   Matrix of shape (num_to_sample, d). The sampled rows.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Rows of points are assumed to be input points. One row is selected at random.
		///   Subsequent rows are sampled with probability proportional to the squared L2
		///   distance from the nearest row selected thus far till num_to_sample rows have
		///   been sampled.
		/// </remarks>
		public TF_Output KmeansPlusPlusInitialization (TF_Output points, TF_Output num_to_sample, TF_Output seed, TF_Output num_retries_per_sample, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "KmeansPlusPlusInitialization", MakeName ("KmeansPlusPlusInitialization", operName));
			c_api.TF_AddInput(desc, points);
			c_api.TF_AddInput(desc, num_to_sample);
			c_api.TF_AddInput(desc, seed);
			c_api.TF_AddInput(desc, num_retries_per_sample);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var samples = new TF_Output (op, _idx++);
			return samples;
		}

		/// <summary>
		///   L2 Loss.
		/// </summary>
		/// <param name="t">
		///   Typically 2-D, but may have any dimensions.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'L2Loss'.
		/// </param>
		/// <returns>
		///   0-D.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Computes half the L2 norm of a tensor without the <c>sqrt</c>:
		///   
		///   output = sum(t ** 2) / 2
		/// </remarks>
		public TF_Output L2Loss (TF_Output t, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "L2Loss", MakeName ("L2Loss", operName));
			c_api.TF_AddInput(desc, t);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Records the latency of producing <c>input_dataset</c> elements in a StatsAggregator.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LatencyStatsDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LatencyStatsDataset (TF_Output input_dataset, TF_Output tag, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LatencyStatsDataset", MakeName ("LatencyStatsDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, tag);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Computes rectified linear: <c>max(features, features * alpha)</c>.
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LeakyRelu'.
		/// </param>
		/// <param name="alpha">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LeakyRelu (TF_Output features, float? alpha = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LeakyRelu", MakeName ("LeakyRelu", operName));
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (alpha.HasValue)
				c_api.TF_SetAttrFloat (desc, "alpha", alpha.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var activations = new TF_Output (op, _idx++);
			return activations;
		}

		/// <summary>
		///   Computes rectified linear gradients for a LeakyRelu operation.
		/// </summary>
		/// <param name="gradients">
		///   The backpropagated gradients to the corresponding LeakyRelu operation.
		/// </param>
		/// <param name="features">
		///   The features passed as input to the corresponding LeakyRelu operation,
		///   OR the outputs of that operation (both work equivalently).
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LeakyReluGrad'.
		/// </param>
		/// <param name="alpha">
		///   Optional argument
		/// </param>
		/// <returns>
		///   <c>gradients * (features &amp;gt; 0) + alpha * gradients * (features &amp;lt;= 0)</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LeakyReluGrad (TF_Output gradients, TF_Output features, float? alpha = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LeakyReluGrad", MakeName ("LeakyReluGrad", operName));
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (alpha.HasValue)
				c_api.TF_SetAttrFloat (desc, "alpha", alpha.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var backprops = new TF_Output (op, _idx++);
			return backprops;
		}

		/// <summary>
		///   Generates labels for candidate sampling with a learned unigram distribution.
		/// </summary>
		/// <param name="true_classes">
		///   A batch_size * num_true matrix, in which each row contains the
		///   IDs of the num_true target_classes in the corresponding original label.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LearnedUnigramCandidateSampler'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either seed or seed2 are set to be non-zero, the random number
		///   generator is seeded by the given seed.  Otherwise, it is seeded by a
		///   random seed.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   An second seed to avoid seed collision.
		/// </param>
		/// <param name="num_true">
		///   Number of true labels per context.
		/// </param>
		/// <param name="num_sampled">
		///   Number of candidates to randomly sample.
		/// </param>
		/// <param name="unique">
		///   If unique is true, we sample with rejection, so that all sampled
		///   candidates in a batch are unique. This requires some approximation to
		///   estimate the post-rejection sampling probabilities.
		/// </param>
		/// <param name="range_max">
		///   The sampler will sample integers from the interval [0, range_max).
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sampled_candidates: A vector of length num_sampled, in which each element is
		///   the ID of a sampled candidate.
		///   true_expected_count: A batch_size * num_true matrix, representing
		///   the number of times each candidate is expected to occur in a batch
		///   of sampled candidates. If unique=true, then this is a probability.
		///   sampled_expected_count: A vector of length num_sampled, for each sampled
		///   candidate representing the number of times the candidate is expected
		///   to occur in a batch of sampled candidates.  If unique=true, then this is a
		///   probability.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   See explanations of candidate sampling and the data formats at
		///   go/candidate-sampling.
		///   
		///   For each batch, this op picks a single set of sampled candidate labels.
		///   
		///   The advantages of sampling candidates per-batch are simplicity and the
		///   possibility of efficient dense matrix multiplication. The disadvantage is that
		///   the sampled candidates must be chosen independently of the context and of the
		///   true labels.
		/// </remarks>
		public (TF_Output sampled_candidates, TF_Output true_expected_count, TF_Output sampled_expected_count) LearnedUnigramCandidateSampler (TF_Output true_classes, long num_true, long num_sampled, bool unique, long range_max, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LearnedUnigramCandidateSampler", MakeName ("LearnedUnigramCandidateSampler", operName));
			c_api.TF_AddInput(desc, true_classes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_true", num_true);
			c_api.TF_SetAttrInt (desc, "num_sampled", num_sampled);
			c_api.TF_SetAttrBool (desc, "unique", Convert.ToByte(unique));
			c_api.TF_SetAttrInt (desc, "range_max", range_max);
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var sampled_candidates = new TF_Output (op, _idx++);
			var true_expected_count = new TF_Output (op, _idx++);
			var sampled_expected_count = new TF_Output (op, _idx++);
			return (sampled_candidates, true_expected_count, sampled_expected_count);
		}

		/// <summary>
		///   Elementwise computes the bitwise left-shift of <c>x</c> and <c>y</c>.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LeftShift'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   If <c>y</c> is negative, or greater than or equal to the width of <c>x</c> in bits the
		///   result is implementation defined.
		///   
		///   Example:
		///   
		///    <code>
		///   import tensorflow as tf
		///   from tensorflow.python.ops import bitwise_ops
		///   import numpy as np
		///   dtype_list = [tf.int8, tf.int16, tf.int32, tf.int64]
		///   
		///   for dtype in dtype_list:
		///   lhs = tf.constant([-1, -5, -3, -14], dtype=dtype)
		///   rhs = tf.constant([5, 0, 7, 11], dtype=dtype)
		///   
		///   left_shift_result = bitwise_ops.left_shift(lhs, rhs)
		///   
		///   print(left_shift_result)
		///   
		///   # This will print:
		///   # tf.Tensor([ -32   -5 -128    0], shape=(4,), dtype=int8)
		///   # tf.Tensor([   -32     -5   -384 -28672], shape=(4,), dtype=int16)
		///   # tf.Tensor([   -32     -5   -384 -28672], shape=(4,), dtype=int32)
		///   # tf.Tensor([   -32     -5   -384 -28672], shape=(4,), dtype=int64)
		///   
		///   lhs = np.array([-2, 64, 101, 32], dtype=np.int8)
		///   rhs = np.array([-1, -5, -3, -14], dtype=np.int8)
		///   bitwise_ops.left_shift(lhs, rhs)
		///   # &amp;lt;tf.Tensor: id=139, shape=(4,), dtype=int8, numpy=array([ -2,  64, 101,  32], dtype=int8)&amp;gt;
		///    </code>
		///   
		/// </remarks>
		public TF_Output LeftShift (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LeftShift", MakeName ("LeftShift", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Returns the truth value of (x &amp;lt; y) element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Less'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   *NOTE*: <c>Less</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output Less (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Less", MakeName ("Less", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Returns the truth value of (x &amp;lt;= y) element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LessEqual'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   *NOTE*: <c>LessEqual</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output LessEqual (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LessEqual", MakeName ("LessEqual", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Computes the log of the absolute value of <c>Gamma(x)</c> element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Lgamma'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Lgamma (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Lgamma", MakeName ("Lgamma", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Generates values in an interval.
		/// </summary>
		/// <param name="start">
		///   0-D tensor. First entry in the range.
		/// </param>
		/// <param name="stop">
		///   0-D tensor. Last entry in the range.
		/// </param>
		/// <param name="num">
		///   0-D tensor. Number of values to generate.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LinSpace'.
		/// </param>
		/// <returns>
		///   1-D. The generated values.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   A sequence of <c>num</c> evenly-spaced values are generated beginning at <c>start</c>.
		///   If <c>num &amp;gt; 1</c>, the values in the sequence increase by <c>stop - start / num - 1</c>,
		///   so that the last one is exactly <c>stop</c>.
		///   
		///   For example:
		///   
		///    <code>
		///   tf.linspace(10.0, 12.0, 3, name="linspace") =&amp;gt; [ 10.0  11.0  12.0]
		///    </code>
		/// </remarks>
		public TF_Output LinSpace (TF_Output start, TF_Output stop, TF_Output num, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LinSpace", MakeName ("LinSpace", operName));
			c_api.TF_AddInput(desc, start);
			c_api.TF_AddInput(desc, stop);
			c_api.TF_AddInput(desc, num);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the difference between two lists of numbers or strings.
		/// </summary>
		/// <param name="x">
		///   1-D. Values to keep.
		/// </param>
		/// <param name="y">
		///   1-D. Values to remove.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ListDiff'.
		/// </param>
		/// <param name="out_idx">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output: 1-D. Values present in <c>x</c> but not in <c>y</c>.
		///   idx: 1-D. Positions of <c>x</c> values preserved in <c>out</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Given a list <c>x</c> and a list <c>y</c>, this operation returns a list <c>out</c> that
		///   represents all values that are in <c>x</c> but not in <c>y</c>. The returned list <c>out</c>
		///   is sorted in the same order that the numbers appear in <c>x</c> (duplicates are
		///   preserved). This operation also returns a list <c>idx</c> that represents the
		///   position of each <c>out</c> element in <c>x</c>. In other words:
		///   
		///   <c>out[i] = x[idx[i]] for i in [0, 1, ..., len(out) - 1]</c>
		///   
		///   For example, given this input:
		///   
		///    <code>
		///   x = [1, 2, 3, 4, 5, 6]
		///   y = [1, 3, 5]
		///    </code>
		///   
		///   This operation would return:
		///   
		///    <code>
		///   out ==&amp;gt; [2, 4, 6]
		///   idx ==&amp;gt; [1, 3, 5]
		///    </code>
		/// </remarks>
		public (TF_Output output, TF_Output idx) ListDiff (TF_Output x, TF_Output y, TF_DataType? out_idx = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ListDiff", MakeName ("ListDiff", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_idx.HasValue)
				c_api.TF_SetAttrType (desc, "out_idx", out_idx.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var idx = new TF_Output (op, _idx++);
			return (output, idx);
		}

		/// <summary>
		/// </summary>
		/// <param name="filenames">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LMDBDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LMDBDataset (TF_Output filenames, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LMDBDataset", MakeName ("LMDBDataset", operName));
			c_api.TF_AddInput(desc, filenames);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   A Reader that outputs the records from a LMDB file.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LMDBReader'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this reader is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this reader is named in the given bucket
		///   with this shared_name. Otherwise, the node name is used instead.
		/// </param>
		/// <returns>
		///   The handle to reference the Reader.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LMDBReader (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LMDBReader", MakeName ("LMDBReader", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		///   Loads a 2-D (matrix) <c>Tensor</c> with name <c>old_tensor_name</c> from the checkpoint
		/// </summary>
		/// <param name="ckpt_path">
		///   Path to the TensorFlow checkpoint (version 2, <c>TensorBundle</c>) from
		///   which the old matrix <c>Tensor</c> will be loaded.
		/// </param>
		/// <param name="old_tensor_name">
		///   Name of the 2-D <c>Tensor</c> to load from checkpoint.
		/// </param>
		/// <param name="row_remapping">
		///   An int <c>Tensor</c> of row remappings (generally created by
		///   <c>generate_vocab_remapping</c>).  Even if no row remapping is needed, this must
		///   still be an index-valued Tensor (e.g. [0, 1, 2, ...]), or a shifted
		///   index-valued <c>Tensor</c> (e.g. [8, 9, 10, ...], for partitioned <c>Variables</c>).
		/// </param>
		/// <param name="col_remapping">
		///   An int <c>Tensor</c> of column remappings (generally created by
		///   <c>generate_vocab_remapping</c>).  May be a size-0 <c>Tensor</c> if only row remapping
		///   is to be done (e.g. column ordering is the same).
		/// </param>
		/// <param name="initializing_values">
		///   A float <c>Tensor</c> containing  values to fill in for cells
		///   in the output matrix that are not loaded from the checkpoint. Length must be
		///   exactly the same as the number of missing / new cells.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadAndRemapMatrix'.
		/// </param>
		/// <param name="max_rows_in_memory">
		///   Optional argument
		///   The maximum number of rows to load from the checkpoint at
		///   once. If less than or equal to 0, the entire matrix will be loaded into
		///   memory. Setting this arg trades increased disk reads for lower memory usage.
		/// </param>
		/// <param name="num_rows">
		///   Number of rows (length of the 1st dimension) in the output matrix.
		/// </param>
		/// <param name="num_cols">
		///   Number of columns (length of the 2nd dimension) in the output matrix.
		/// </param>
		/// <returns>
		///   Output matrix containing existing values loaded from the
		///   checkpoint, and with any missing values filled in from initializing_values.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   at <c>ckpt_path</c> and potentially reorders its rows and columns using the
		///   specified remappings.
		///   
		///   Most users should use one of the wrapper initializers (such as
		///   <c>tf.contrib.framework.load_and_remap_matrix_initializer</c>) instead of this
		///   function directly.
		///   
		///   The remappings are 1-D tensors with the following properties:
		///   
		///   * <c>row_remapping</c> must have exactly <c>num_rows</c> entries. Row <c>i</c> of the output
		///   matrix will be initialized from the row corresponding to index
		///   <c>row_remapping[i]</c> in the old <c>Tensor</c> from the checkpoint.
		///   * <c>col_remapping</c> must have either 0 entries (indicating that no column
		///   reordering is needed) or <c>num_cols</c> entries. If specified, column <c>j</c> of the
		///   output matrix will be initialized from the column corresponding to index
		///   <c>col_remapping[j]</c> in the old <c>Tensor</c> from the checkpoint.
		///   * A value of -1 in either of the remappings signifies a "missing" entry. In that
		///   case, values from the <c>initializing_values</c> tensor will be used to fill that
		///   missing row or column. If <c>row_remapping</c> has <c>r</c> missing entries and
		///   <c>col_remapping</c> has <c>c</c> missing entries, then the following condition must be
		///   true:
		///   
		///   <c>(r * num_cols) + (c * num_rows) - (r * c) == len(initializing_values)</c>
		///   
		///   The remapping tensors can be generated using the GenerateVocabRemapping op.
		///   
		///   As an example, with row_remapping = [1, 0, -1], col_remapping = [0, 2, -1],
		///   initializing_values = [0.5, -0.5, 0.25, -0.25, 42], and w(i, j) representing
		///   the value from row i, column j of the old tensor in the checkpoint, the output
		///   matrix will look like the following:
		///   
		///   [[w(1, 0),  w(1, 2),  0.5],
		///   [w(0, 0),  w(0, 2), -0.5],
		///   [0.25,    -0.25,      42]]
		/// </remarks>
		public TF_Output LoadAndRemapMatrix (TF_Output ckpt_path, TF_Output old_tensor_name, TF_Output row_remapping, TF_Output col_remapping, TF_Output initializing_values, long num_rows, long num_cols, long? max_rows_in_memory = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadAndRemapMatrix", MakeName ("LoadAndRemapMatrix", operName));
			c_api.TF_AddInput(desc, ckpt_path);
			c_api.TF_AddInput(desc, old_tensor_name);
			c_api.TF_AddInput(desc, row_remapping);
			c_api.TF_AddInput(desc, col_remapping);
			c_api.TF_AddInput(desc, initializing_values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_rows", num_rows);
			c_api.TF_SetAttrInt (desc, "num_cols", num_cols);
			if (max_rows_in_memory.HasValue)
				c_api.TF_SetAttrInt (desc, "max_rows_in_memory", max_rows_in_memory.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_matrix = new TF_Output (op, _idx++);
			return output_matrix;
		}

		/// <summary>
		///   Load Adadelta embedding parameters.
		/// </summary>
		/// <param name="parameters">
		///   Value of parameters used in the Adadelta optimization algorithm.
		/// </param>
		/// <param name="accumulators">
		///   Value of accumulators used in the Adadelta optimization algorithm.
		/// </param>
		/// <param name="updates">
		///   Value of updates used in the Adadelta optimization algorithm.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingAdadeltaParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   An op that loads optimization parameters into HBM for embedding. Must be
		///   preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
		///   embedding table configuration. For example, this op is used to install
		///   parameters that are loaded from a checkpoint before a training loop is
		///   executed.
		/// </remarks>
		public TF_Operation LoadTPUEmbeddingAdadeltaParameters (TF_Output parameters, TF_Output accumulators, TF_Output updates, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingAdadeltaParameters", MakeName ("LoadTPUEmbeddingAdadeltaParameters", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, accumulators);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Load Adadelta parameters with debug support.
		/// </summary>
		/// <param name="parameters">
		///   Value of parameters used in the Adadelta optimization algorithm.
		/// </param>
		/// <param name="accumulators">
		///   Value of accumulators used in the Adadelta optimization algorithm.
		/// </param>
		/// <param name="updates">
		///   Value of updates used in the Adadelta optimization algorithm.
		/// </param>
		/// <param name="gradient_accumulators">
		///   Value of gradient_accumulators used in the Adadelta optimization algorithm.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingAdadeltaParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   An op that loads optimization parameters into HBM for embedding. Must be
		///   preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
		///   embedding table configuration. For example, this op is used to install
		///   parameters that are loaded from a checkpoint before a training loop is
		///   executed.
		/// </remarks>
		public TF_Operation LoadTPUEmbeddingAdadeltaParametersGradAccumDebug (TF_Output parameters, TF_Output accumulators, TF_Output updates, TF_Output gradient_accumulators, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingAdadeltaParametersGradAccumDebug", MakeName ("LoadTPUEmbeddingAdadeltaParametersGradAccumDebug", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, accumulators);
			c_api.TF_AddInput(desc, updates);
			c_api.TF_AddInput(desc, gradient_accumulators);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Load Adagrad embedding parameters.
		/// </summary>
		/// <param name="parameters">
		///   Value of parameters used in the Adagrad optimization algorithm.
		/// </param>
		/// <param name="accumulators">
		///   Value of accumulators used in the Adagrad optimization algorithm.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingAdagradParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   An op that loads optimization parameters into HBM for embedding. Must be
		///   preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
		///   embedding table configuration. For example, this op is used to install
		///   parameters that are loaded from a checkpoint before a training loop is
		///   executed.
		/// </remarks>
		public TF_Operation LoadTPUEmbeddingAdagradParameters (TF_Output parameters, TF_Output accumulators, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingAdagradParameters", MakeName ("LoadTPUEmbeddingAdagradParameters", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, accumulators);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Load Adagrad embedding parameters with debug support.
		/// </summary>
		/// <param name="parameters">
		///   Value of parameters used in the Adagrad optimization algorithm.
		/// </param>
		/// <param name="accumulators">
		///   Value of accumulators used in the Adagrad optimization algorithm.
		/// </param>
		/// <param name="gradient_accumulators">
		///   Value of gradient_accumulators used in the Adagrad optimization algorithm.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingAdagradParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   An op that loads optimization parameters into HBM for embedding. Must be
		///   preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
		///   embedding table configuration. For example, this op is used to install
		///   parameters that are loaded from a checkpoint before a training loop is
		///   executed.
		/// </remarks>
		public TF_Operation LoadTPUEmbeddingAdagradParametersGradAccumDebug (TF_Output parameters, TF_Output accumulators, TF_Output gradient_accumulators, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingAdagradParametersGradAccumDebug", MakeName ("LoadTPUEmbeddingAdagradParametersGradAccumDebug", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, accumulators);
			c_api.TF_AddInput(desc, gradient_accumulators);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Load ADAM embedding parameters.
		/// </summary>
		/// <param name="parameters">
		///   Value of parameters used in the ADAM optimization algorithm.
		/// </param>
		/// <param name="momenta">
		///   Value of momenta used in the ADAM optimization algorithm.
		/// </param>
		/// <param name="velocities">
		///   Value of velocities used in the ADAM optimization algorithm.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingADAMParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   An op that loads optimization parameters into HBM for embedding. Must be
		///   preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
		///   embedding table configuration. For example, this op is used to install
		///   parameters that are loaded from a checkpoint before a training loop is
		///   executed.
		/// </remarks>
		public TF_Operation LoadTPUEmbeddingADAMParameters (TF_Output parameters, TF_Output momenta, TF_Output velocities, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingADAMParameters", MakeName ("LoadTPUEmbeddingADAMParameters", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, momenta);
			c_api.TF_AddInput(desc, velocities);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Load ADAM embedding parameters with debug support.
		/// </summary>
		/// <param name="parameters">
		///   Value of parameters used in the ADAM optimization algorithm.
		/// </param>
		/// <param name="momenta">
		///   Value of momenta used in the ADAM optimization algorithm.
		/// </param>
		/// <param name="velocities">
		///   Value of velocities used in the ADAM optimization algorithm.
		/// </param>
		/// <param name="gradient_accumulators">
		///   Value of gradient_accumulators used in the ADAM optimization algorithm.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingADAMParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   An op that loads optimization parameters into HBM for embedding. Must be
		///   preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
		///   embedding table configuration. For example, this op is used to install
		///   parameters that are loaded from a checkpoint before a training loop is
		///   executed.
		/// </remarks>
		public TF_Operation LoadTPUEmbeddingADAMParametersGradAccumDebug (TF_Output parameters, TF_Output momenta, TF_Output velocities, TF_Output gradient_accumulators, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingADAMParametersGradAccumDebug", MakeName ("LoadTPUEmbeddingADAMParametersGradAccumDebug", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, momenta);
			c_api.TF_AddInput(desc, velocities);
			c_api.TF_AddInput(desc, gradient_accumulators);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Load centered RMSProp embedding parameters.
		/// </summary>
		/// <param name="parameters">
		///   Value of parameters used in the centered RMSProp optimization algorithm.
		/// </param>
		/// <param name="ms">
		///   Value of ms used in the centered RMSProp optimization algorithm.
		/// </param>
		/// <param name="mom">
		///   Value of mom used in the centered RMSProp optimization algorithm.
		/// </param>
		/// <param name="mg">
		///   Value of mg used in the centered RMSProp optimization algorithm.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingCenteredRMSPropParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   An op that loads optimization parameters into HBM for embedding. Must be
		///   preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
		///   embedding table configuration. For example, this op is used to install
		///   parameters that are loaded from a checkpoint before a training loop is
		///   executed.
		/// </remarks>
		public TF_Operation LoadTPUEmbeddingCenteredRMSPropParameters (TF_Output parameters, TF_Output ms, TF_Output mom, TF_Output mg, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingCenteredRMSPropParameters", MakeName ("LoadTPUEmbeddingCenteredRMSPropParameters", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			c_api.TF_AddInput(desc, mg);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Load FTRL embedding parameters.
		/// </summary>
		/// <param name="parameters">
		///   Value of parameters used in the FTRL optimization algorithm.
		/// </param>
		/// <param name="accumulators">
		///   Value of accumulators used in the FTRL optimization algorithm.
		/// </param>
		/// <param name="linears">
		///   Value of linears used in the FTRL optimization algorithm.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingFTRLParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   An op that loads optimization parameters into HBM for embedding. Must be
		///   preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
		///   embedding table configuration. For example, this op is used to install
		///   parameters that are loaded from a checkpoint before a training loop is
		///   executed.
		/// </remarks>
		public TF_Operation LoadTPUEmbeddingFTRLParameters (TF_Output parameters, TF_Output accumulators, TF_Output linears, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingFTRLParameters", MakeName ("LoadTPUEmbeddingFTRLParameters", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, accumulators);
			c_api.TF_AddInput(desc, linears);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Load FTRL embedding parameters with debug support.
		/// </summary>
		/// <param name="parameters">
		///   Value of parameters used in the FTRL optimization algorithm.
		/// </param>
		/// <param name="accumulators">
		///   Value of accumulators used in the FTRL optimization algorithm.
		/// </param>
		/// <param name="linears">
		///   Value of linears used in the FTRL optimization algorithm.
		/// </param>
		/// <param name="gradient_accumulators">
		///   Value of gradient_accumulators used in the FTRL optimization algorithm.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingFTRLParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   An op that loads optimization parameters into HBM for embedding. Must be
		///   preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
		///   embedding table configuration. For example, this op is used to install
		///   parameters that are loaded from a checkpoint before a training loop is
		///   executed.
		/// </remarks>
		public TF_Operation LoadTPUEmbeddingFTRLParametersGradAccumDebug (TF_Output parameters, TF_Output accumulators, TF_Output linears, TF_Output gradient_accumulators, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingFTRLParametersGradAccumDebug", MakeName ("LoadTPUEmbeddingFTRLParametersGradAccumDebug", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, accumulators);
			c_api.TF_AddInput(desc, linears);
			c_api.TF_AddInput(desc, gradient_accumulators);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Load MDL Adagrad Light embedding parameters.
		/// </summary>
		/// <param name="parameters">
		///   Value of parameters used in the MDL Adagrad Light optimization algorithm.
		/// </param>
		/// <param name="accumulators">
		///   Value of accumulators used in the MDL Adagrad Light optimization algorithm.
		/// </param>
		/// <param name="weights">
		///   Value of weights used in the MDL Adagrad Light optimization algorithm.
		/// </param>
		/// <param name="benefits">
		///   Value of benefits used in the MDL Adagrad Light optimization algorithm.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingMDLAdagradLightParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   An op that loads optimization parameters into HBM for embedding. Must be
		///   preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
		///   embedding table configuration. For example, this op is used to install
		///   parameters that are loaded from a checkpoint before a training loop is
		///   executed.
		/// </remarks>
		public TF_Operation LoadTPUEmbeddingMDLAdagradLightParameters (TF_Output parameters, TF_Output accumulators, TF_Output weights, TF_Output benefits, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingMDLAdagradLightParameters", MakeName ("LoadTPUEmbeddingMDLAdagradLightParameters", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, accumulators);
			c_api.TF_AddInput(desc, weights);
			c_api.TF_AddInput(desc, benefits);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Load Momentum embedding parameters.
		/// </summary>
		/// <param name="parameters">
		///   Value of parameters used in the Momentum optimization algorithm.
		/// </param>
		/// <param name="momenta">
		///   Value of momenta used in the Momentum optimization algorithm.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingMomentumParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   An op that loads optimization parameters into HBM for embedding. Must be
		///   preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
		///   embedding table configuration. For example, this op is used to install
		///   parameters that are loaded from a checkpoint before a training loop is
		///   executed.
		/// </remarks>
		public TF_Operation LoadTPUEmbeddingMomentumParameters (TF_Output parameters, TF_Output momenta, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingMomentumParameters", MakeName ("LoadTPUEmbeddingMomentumParameters", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, momenta);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Load Momentum embedding parameters with debug support.
		/// </summary>
		/// <param name="parameters">
		///   Value of parameters used in the Momentum optimization algorithm.
		/// </param>
		/// <param name="momenta">
		///   Value of momenta used in the Momentum optimization algorithm.
		/// </param>
		/// <param name="gradient_accumulators">
		///   Value of gradient_accumulators used in the Momentum optimization algorithm.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingMomentumParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   An op that loads optimization parameters into HBM for embedding. Must be
		///   preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
		///   embedding table configuration. For example, this op is used to install
		///   parameters that are loaded from a checkpoint before a training loop is
		///   executed.
		/// </remarks>
		public TF_Operation LoadTPUEmbeddingMomentumParametersGradAccumDebug (TF_Output parameters, TF_Output momenta, TF_Output gradient_accumulators, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingMomentumParametersGradAccumDebug", MakeName ("LoadTPUEmbeddingMomentumParametersGradAccumDebug", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, momenta);
			c_api.TF_AddInput(desc, gradient_accumulators);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Load proximal Adagrad embedding parameters.
		/// </summary>
		/// <param name="parameters">
		///   Value of parameters used in the proximal Adagrad optimization algorithm.
		/// </param>
		/// <param name="accumulators">
		///   Value of accumulators used in the proximal Adagrad optimization algorithm.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingProximalAdagradParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   An op that loads optimization parameters into HBM for embedding. Must be
		///   preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
		///   embedding table configuration. For example, this op is used to install
		///   parameters that are loaded from a checkpoint before a training loop is
		///   executed.
		/// </remarks>
		public TF_Operation LoadTPUEmbeddingProximalAdagradParameters (TF_Output parameters, TF_Output accumulators, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingProximalAdagradParameters", MakeName ("LoadTPUEmbeddingProximalAdagradParameters", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, accumulators);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Load proximal Adagrad embedding parameters with debug support.
		/// </summary>
		/// <param name="parameters">
		///   Value of parameters used in the proximal Adagrad optimization algorithm.
		/// </param>
		/// <param name="accumulators">
		///   Value of accumulators used in the proximal Adagrad optimization algorithm.
		/// </param>
		/// <param name="gradient_accumulators">
		///   Value of gradient_accumulators used in the proximal Adagrad optimization algorithm.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   An op that loads optimization parameters into HBM for embedding. Must be
		///   preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
		///   embedding table configuration. For example, this op is used to install
		///   parameters that are loaded from a checkpoint before a training loop is
		///   executed.
		/// </remarks>
		public TF_Operation LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug (TF_Output parameters, TF_Output accumulators, TF_Output gradient_accumulators, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug", MakeName ("LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, accumulators);
			c_api.TF_AddInput(desc, gradient_accumulators);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Load RMSProp embedding parameters.
		/// </summary>
		/// <param name="parameters">
		///   Value of parameters used in the RMSProp optimization algorithm.
		/// </param>
		/// <param name="ms">
		///   Value of ms used in the RMSProp optimization algorithm.
		/// </param>
		/// <param name="mom">
		///   Value of mom used in the RMSProp optimization algorithm.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingRMSPropParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   An op that loads optimization parameters into HBM for embedding. Must be
		///   preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
		///   embedding table configuration. For example, this op is used to install
		///   parameters that are loaded from a checkpoint before a training loop is
		///   executed.
		/// </remarks>
		public TF_Operation LoadTPUEmbeddingRMSPropParameters (TF_Output parameters, TF_Output ms, TF_Output mom, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingRMSPropParameters", MakeName ("LoadTPUEmbeddingRMSPropParameters", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Load RMSProp embedding parameters with debug support.
		/// </summary>
		/// <param name="parameters">
		///   Value of parameters used in the RMSProp optimization algorithm.
		/// </param>
		/// <param name="ms">
		///   Value of ms used in the RMSProp optimization algorithm.
		/// </param>
		/// <param name="mom">
		///   Value of mom used in the RMSProp optimization algorithm.
		/// </param>
		/// <param name="gradient_accumulators">
		///   Value of gradient_accumulators used in the RMSProp optimization algorithm.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingRMSPropParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   An op that loads optimization parameters into HBM for embedding. Must be
		///   preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
		///   embedding table configuration. For example, this op is used to install
		///   parameters that are loaded from a checkpoint before a training loop is
		///   executed.
		/// </remarks>
		public TF_Operation LoadTPUEmbeddingRMSPropParametersGradAccumDebug (TF_Output parameters, TF_Output ms, TF_Output mom, TF_Output gradient_accumulators, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingRMSPropParametersGradAccumDebug", MakeName ("LoadTPUEmbeddingRMSPropParametersGradAccumDebug", operName));
			c_api.TF_AddInput(desc, parameters);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			c_api.TF_AddInput(desc, gradient_accumulators);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Load SGD embedding parameters.
		/// </summary>
		/// <param name="parameters">
		///   Value of parameters used in the stochastic gradient descent optimization algorithm.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingStochasticGradientDescentParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   An op that loads optimization parameters into HBM for embedding. Must be
		///   preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
		///   embedding table configuration. For example, this op is used to install
		///   parameters that are loaded from a checkpoint before a training loop is
		///   executed.
		/// </remarks>
		public TF_Operation LoadTPUEmbeddingStochasticGradientDescentParameters (TF_Output parameters, long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoadTPUEmbeddingStochasticGradientDescentParameters", MakeName ("LoadTPUEmbeddingStochasticGradientDescentParameters", operName));
			c_api.TF_AddInput(desc, parameters);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Computes natural logarithm of x element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Log'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   I.e., \\(y = \log_e x\\).
		/// </remarks>
		public TF_Output Log (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Log", MakeName ("Log", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes natural logarithm of (1 + x) element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Log1p'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   I.e., \\(y = \log_e (1 + x)\\).
		/// </remarks>
		public TF_Output Log1p (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Log1p", MakeName ("Log1p", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Returns the truth value of x AND y element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LogicalAnd'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   *NOTE*: <c>LogicalAnd</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output LogicalAnd (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LogicalAnd", MakeName ("LogicalAnd", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Returns the truth value of NOT x element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LogicalNot'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LogicalNot (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LogicalNot", MakeName ("LogicalNot", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Returns the truth value of x OR y element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LogicalOr'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   *NOTE*: <c>LogicalOr</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output LogicalOr (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LogicalOr", MakeName ("LogicalOr", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Computes the sign and the log of the absolute value of the determinant of
		/// </summary>
		/// <param name="input">
		///   Shape is <c>[N, M, M]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LogMatrixDeterminant'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sign: The signs of the log determinants of the inputs. Shape is <c>[N]</c>.
		///   log_abs_determinant: The logs of the absolute values of the determinants
		///   of the N input matrices.  Shape is <c>[N]</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   one or more square matrices.
		///   
		///   The input is a tensor of shape <c>[N, M, M]</c> whose inner-most 2 dimensions
		///   form square matrices. The outputs are two tensors containing the signs and
		///   absolute values of the log determinants for all N input submatrices
		///   <c>[..., :, :]</c> such that the determinant = sign*exp(log_abs_determinant).
		///   The log_abs_determinant is computed as det(P)*sum(log(diag(LU))) where LU
		///   is the LU decomposition of the input and P is the corresponding
		///   permutation matrix.
		/// </remarks>
		public (TF_Output sign, TF_Output log_abs_determinant) LogMatrixDeterminant (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LogMatrixDeterminant", MakeName ("LogMatrixDeterminant", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var sign = new TF_Output (op, _idx++);
			var log_abs_determinant = new TF_Output (op, _idx++);
			return (sign, log_abs_determinant);
		}

		/// <summary>
		///   Computes log softmax activations.
		/// </summary>
		/// <param name="logits">
		///   2-D with shape <c>[batch_size, num_classes]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LogSoftmax'.
		/// </param>
		/// <returns>
		///   Same shape as <c>logits</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   For each batch <c>i</c> and class <c>j</c> we have
		///   
		///   logsoftmax[i, j] = logits[i, j] - log(sum(exp(logits[i])))
		/// </remarks>
		public TF_Output LogSoftmax (TF_Output logits, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LogSoftmax", MakeName ("LogSoftmax", operName));
			c_api.TF_AddInput(desc, logits);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var logsoftmax = new TF_Output (op, _idx++);
			return logsoftmax;
		}

		/// <summary>
		///   Generates labels for candidate sampling with a log-uniform distribution.
		/// </summary>
		/// <param name="true_classes">
		///   A batch_size * num_true matrix, in which each row contains the
		///   IDs of the num_true target_classes in the corresponding original label.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LogUniformCandidateSampler'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either seed or seed2 are set to be non-zero, the random number
		///   generator is seeded by the given seed.  Otherwise, it is seeded by a
		///   random seed.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   An second seed to avoid seed collision.
		/// </param>
		/// <param name="num_true">
		///   Number of true labels per context.
		/// </param>
		/// <param name="num_sampled">
		///   Number of candidates to randomly sample.
		/// </param>
		/// <param name="unique">
		///   If unique is true, we sample with rejection, so that all sampled
		///   candidates in a batch are unique. This requires some approximation to
		///   estimate the post-rejection sampling probabilities.
		/// </param>
		/// <param name="range_max">
		///   The sampler will sample integers from the interval [0, range_max).
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sampled_candidates: A vector of length num_sampled, in which each element is
		///   the ID of a sampled candidate.
		///   true_expected_count: A batch_size * num_true matrix, representing
		///   the number of times each candidate is expected to occur in a batch
		///   of sampled candidates. If unique=true, then this is a probability.
		///   sampled_expected_count: A vector of length num_sampled, for each sampled
		///   candidate representing the number of times the candidate is expected
		///   to occur in a batch of sampled candidates.  If unique=true, then this is a
		///   probability.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   See explanations of candidate sampling and the data formats at
		///   go/candidate-sampling.
		///   
		///   For each batch, this op picks a single set of sampled candidate labels.
		///   
		///   The advantages of sampling candidates per-batch are simplicity and the
		///   possibility of efficient dense matrix multiplication. The disadvantage is that
		///   the sampled candidates must be chosen independently of the context and of the
		///   true labels.
		/// </remarks>
		public (TF_Output sampled_candidates, TF_Output true_expected_count, TF_Output sampled_expected_count) LogUniformCandidateSampler (TF_Output true_classes, long num_true, long num_sampled, bool unique, long range_max, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LogUniformCandidateSampler", MakeName ("LogUniformCandidateSampler", operName));
			c_api.TF_AddInput(desc, true_classes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_true", num_true);
			c_api.TF_SetAttrInt (desc, "num_sampled", num_sampled);
			c_api.TF_SetAttrBool (desc, "unique", Convert.ToByte(unique));
			c_api.TF_SetAttrInt (desc, "range_max", range_max);
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var sampled_candidates = new TF_Output (op, _idx++);
			var true_expected_count = new TF_Output (op, _idx++);
			var sampled_expected_count = new TF_Output (op, _idx++);
			return (sampled_candidates, true_expected_count, sampled_expected_count);
		}

		/// <summary>
		///   Outputs all keys and values in the table.
		/// </summary>
		/// <param name="table_handle">
		///   Handle to the table.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableExport'.
		/// </param>
		/// <param name="Tkeys">
		/// </param>
		/// <param name="Tvalues">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   keys: Vector of all keys present in the table.
		///   values: Tensor of all values in the table. Indexed in parallel with <c>keys</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output keys, TF_Output values) LookupTableExport (TF_Output table_handle, TF_DataType Tkeys, TF_DataType Tvalues, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableExport", MakeName ("LookupTableExport", operName));
			c_api.TF_AddInput(desc, table_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "Tkeys", Tkeys);
			c_api.TF_SetAttrType (desc, "Tvalues", Tvalues);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var keys = new TF_Output (op, _idx++);
			var values = new TF_Output (op, _idx++);
			return (keys, values);
		}

		/// <summary>
		///   Outputs all keys and values in the table.
		/// </summary>
		/// <param name="table_handle">
		///   Handle to the table.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableExportV2'.
		/// </param>
		/// <param name="Tkeys">
		/// </param>
		/// <param name="Tvalues">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   keys: Vector of all keys present in the table.
		///   values: Tensor of all values in the table. Indexed in parallel with <c>keys</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output keys, TF_Output values) LookupTableExportV2 (TF_Output table_handle, TF_DataType Tkeys, TF_DataType Tvalues, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableExportV2", MakeName ("LookupTableExportV2", operName));
			c_api.TF_AddInput(desc, table_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "Tkeys", Tkeys);
			c_api.TF_SetAttrType (desc, "Tvalues", Tvalues);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var keys = new TF_Output (op, _idx++);
			var values = new TF_Output (op, _idx++);
			return (keys, values);
		}

		/// <summary>
		///   Looks up keys in a table, outputs the corresponding values.
		/// </summary>
		/// <param name="table_handle">
		///   Handle to the table.
		/// </param>
		/// <param name="keys">
		///   Any shape.  Keys to look up.
		/// </param>
		/// <param name="default_value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableFind'.
		/// </param>
		/// <returns>
		///   Same shape as <c>keys</c>.  Values found in the table, or <c>default_values</c>
		///   for missing keys.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The tensor <c>keys</c> must of the same type as the keys of the table.
		///   The output <c>values</c> is of the type of the table values.
		///   
		///   The scalar <c>default_value</c> is the value output for keys not present in the
		///   table. It must also be of the same type as the table values.
		/// </remarks>
		public TF_Output LookupTableFind (TF_Output table_handle, TF_Output keys, TF_Output default_value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableFind", MakeName ("LookupTableFind", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, keys);
			c_api.TF_AddInput(desc, default_value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var values = new TF_Output (op, _idx++);
			return values;
		}

		/// <summary>
		///   Looks up keys in a table, outputs the corresponding values.
		/// </summary>
		/// <param name="table_handle">
		///   Handle to the table.
		/// </param>
		/// <param name="keys">
		///   Any shape.  Keys to look up.
		/// </param>
		/// <param name="default_value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableFindV2'.
		/// </param>
		/// <returns>
		///   Same shape as <c>keys</c>.  Values found in the table, or <c>default_values</c>
		///   for missing keys.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The tensor <c>keys</c> must of the same type as the keys of the table.
		///   The output <c>values</c> is of the type of the table values.
		///   
		///   The scalar <c>default_value</c> is the value output for keys not present in the
		///   table. It must also be of the same type as the table values.
		/// </remarks>
		public TF_Output LookupTableFindV2 (TF_Output table_handle, TF_Output keys, TF_Output default_value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableFindV2", MakeName ("LookupTableFindV2", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, keys);
			c_api.TF_AddInput(desc, default_value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var values = new TF_Output (op, _idx++);
			return values;
		}

		/// <summary>
		///   Replaces the contents of the table with the specified keys and values.
		/// </summary>
		/// <param name="table_handle">
		///   Handle to the table.
		/// </param>
		/// <param name="keys">
		///   Any shape.  Keys to look up.
		/// </param>
		/// <param name="values">
		///   Values to associate with keys.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableImport'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   The tensor <c>keys</c> must be of the same type as the keys of the table.
		///   The tensor <c>values</c> must be of the type of the table values.
		/// </remarks>
		public TF_Operation LookupTableImport (TF_Output table_handle, TF_Output keys, TF_Output values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableImport", MakeName ("LookupTableImport", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, keys);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Replaces the contents of the table with the specified keys and values.
		/// </summary>
		/// <param name="table_handle">
		///   Handle to the table.
		/// </param>
		/// <param name="keys">
		///   Any shape.  Keys to look up.
		/// </param>
		/// <param name="values">
		///   Values to associate with keys.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableImportV2'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   The tensor <c>keys</c> must be of the same type as the keys of the table.
		///   The tensor <c>values</c> must be of the type of the table values.
		/// </remarks>
		public TF_Operation LookupTableImportV2 (TF_Output table_handle, TF_Output keys, TF_Output values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableImportV2", MakeName ("LookupTableImportV2", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, keys);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Updates the table to associates keys with values.
		/// </summary>
		/// <param name="table_handle">
		///   Handle to the table.
		/// </param>
		/// <param name="keys">
		///   Any shape.  Keys to look up.
		/// </param>
		/// <param name="values">
		///   Values to associate with keys.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableInsert'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   The tensor <c>keys</c> must be of the same type as the keys of the table.
		///   The tensor <c>values</c> must be of the type of the table values.
		/// </remarks>
		public TF_Operation LookupTableInsert (TF_Output table_handle, TF_Output keys, TF_Output values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableInsert", MakeName ("LookupTableInsert", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, keys);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Updates the table to associates keys with values.
		/// </summary>
		/// <param name="table_handle">
		///   Handle to the table.
		/// </param>
		/// <param name="keys">
		///   Any shape.  Keys to look up.
		/// </param>
		/// <param name="values">
		///   Values to associate with keys.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableInsertV2'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   The tensor <c>keys</c> must be of the same type as the keys of the table.
		///   The tensor <c>values</c> must be of the type of the table values.
		/// </remarks>
		public TF_Operation LookupTableInsertV2 (TF_Output table_handle, TF_Output keys, TF_Output values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableInsertV2", MakeName ("LookupTableInsertV2", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, keys);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Removes keys and its associated values from a table.
		/// </summary>
		/// <param name="table_handle">
		///   Handle to the table.
		/// </param>
		/// <param name="keys">
		///   Any shape.  Keys of the elements to remove.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableRemoveV2'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   The tensor <c>keys</c> must of the same type as the keys of the table. Keys not
		///   already in the table are silently ignored.
		/// </remarks>
		public TF_Operation LookupTableRemoveV2 (TF_Output table_handle, TF_Output keys, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableRemoveV2", MakeName ("LookupTableRemoveV2", operName));
			c_api.TF_AddInput(desc, table_handle);
			c_api.TF_AddInput(desc, keys);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Computes the number of elements in the given table.
		/// </summary>
		/// <param name="table_handle">
		///   Handle to the table.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableSize'.
		/// </param>
		/// <returns>
		///   Scalar that contains number of elements in the table.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LookupTableSize (TF_Output table_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableSize", MakeName ("LookupTableSize", operName));
			c_api.TF_AddInput(desc, table_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		///   Computes the number of elements in the given table.
		/// </summary>
		/// <param name="table_handle">
		///   Handle to the table.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableSizeV2'.
		/// </param>
		/// <returns>
		///   Scalar that contains number of elements in the table.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LookupTableSizeV2 (TF_Output table_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LookupTableSizeV2", MakeName ("LookupTableSizeV2", operName));
			c_api.TF_AddInput(desc, table_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		///   Forwards the input to the output.
		/// </summary>
		/// <param name="input">
		///   A boolean scalar, representing the branch predicate of the Switch op.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LoopCond'.
		/// </param>
		/// <returns>
		///   The same tensor as <c>input</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operator represents the loop termination condition used by the
		///   "pivot" switches of a loop.
		/// </remarks>
		public TF_Output LoopCond (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LoopCond", MakeName ("LoopCond", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Applies lower_bound(sorted_search_values, values) along each row.
		/// </summary>
		/// <param name="sorted_inputs">
		///   2-D Tensor where each row is ordered.
		/// </param>
		/// <param name="values">
		///   2-D Tensor with the same numbers of rows as <c>sorted_search_values</c>. Contains
		///   the values that will be searched for in <c>sorted_search_values</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LowerBound'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   A <c>Tensor</c> with the same shape as <c>values</c>.  It contains the first scalar index
		///   into the last dimension where values can be inserted without changing the
		///   ordered property.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Each set of rows with the same index in (sorted_inputs, values) is treated
		///   independently.  The resulting row is the equivalent of calling
		///   <c>np.searchsorted(sorted_inputs, values, side='left')</c>.
		///   
		///   The result is not a global index to the entire
		///   <c>Tensor</c>, but rather just the index in the last dimension.
		///   
		///   A 2-D example:
		///   sorted_sequence = [[0, 3, 9, 9, 10],
		///   [1, 2, 3, 4, 5]]
		///   values = [[2, 4, 9],
		///   [0, 2, 6]]
		///   
		///   result = LowerBound(sorted_sequence, values)
		///   
		///   result == [[1, 2, 2],
		///   [0, 1, 5]]
		/// </remarks>
		public TF_Output LowerBound (TF_Output sorted_inputs, TF_Output values, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LowerBound", MakeName ("LowerBound", operName));
			c_api.TF_AddInput(desc, sorted_inputs);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Local Response Normalization.
		/// </summary>
		/// <param name="input">
		///   4-D.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LRN'.
		/// </param>
		/// <param name="depth_radius">
		///   Optional argument
		///   0-D.  Half-width of the 1-D normalization window.
		/// </param>
		/// <param name="bias">
		///   Optional argument
		///   An offset (usually positive to avoid dividing by 0).
		/// </param>
		/// <param name="alpha">
		///   Optional argument
		///   A scale factor, usually positive.
		/// </param>
		/// <param name="beta">
		///   Optional argument
		///   An exponent.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The 4-D <c>input</c> tensor is treated as a 3-D array of 1-D vectors (along the last
		///   dimension), and each vector is normalized independently.  Within a given vector,
		///   each component is divided by the weighted, squared sum of inputs within
		///   <c>depth_radius</c>.  In detail,
		///   
		///   sqr_sum[a, b, c, d] =
		///   sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2)
		///   output = input / (bias + alpha * sqr_sum) ** beta
		///   
		///   For details, see [Krizhevsky et al., ImageNet classification with deep
		///   convolutional neural networks (NIPS 2012)](http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks).
		/// </remarks>
		public TF_Output LRN (TF_Output input, long? depth_radius = null, float? bias = null, float? alpha = null, float? beta = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LRN", MakeName ("LRN", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (depth_radius.HasValue)
				c_api.TF_SetAttrInt (desc, "depth_radius", depth_radius.Value);
			
			if (bias.HasValue)
				c_api.TF_SetAttrFloat (desc, "bias", bias.Value);
			
			if (alpha.HasValue)
				c_api.TF_SetAttrFloat (desc, "alpha", alpha.Value);
			
			if (beta.HasValue)
				c_api.TF_SetAttrFloat (desc, "beta", beta.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Gradients for Local Response Normalization.
		/// </summary>
		/// <param name="input_grads">
		///   4-D with shape <c>[batch, height, width, channels]</c>.
		/// </param>
		/// <param name="input_image">
		///   4-D with shape <c>[batch, height, width, channels]</c>.
		/// </param>
		/// <param name="output_image">
		///   4-D with shape <c>[batch, height, width, channels]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LRNGrad'.
		/// </param>
		/// <param name="depth_radius">
		///   Optional argument
		///   A depth radius.
		/// </param>
		/// <param name="bias">
		///   Optional argument
		///   An offset (usually &amp;gt; 0 to avoid dividing by 0).
		/// </param>
		/// <param name="alpha">
		///   Optional argument
		///   A scale factor, usually positive.
		/// </param>
		/// <param name="beta">
		///   Optional argument
		///   An exponent.
		/// </param>
		/// <returns>
		///   The gradients for LRN.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output LRNGrad (TF_Output input_grads, TF_Output input_image, TF_Output output_image, long? depth_radius = null, float? bias = null, float? alpha = null, float? beta = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LRNGrad", MakeName ("LRNGrad", operName));
			c_api.TF_AddInput(desc, input_grads);
			c_api.TF_AddInput(desc, input_image);
			c_api.TF_AddInput(desc, output_image);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (depth_radius.HasValue)
				c_api.TF_SetAttrInt (desc, "depth_radius", depth_radius.Value);
			
			if (bias.HasValue)
				c_api.TF_SetAttrFloat (desc, "bias", bias.Value);
			
			if (alpha.HasValue)
				c_api.TF_SetAttrFloat (desc, "alpha", alpha.Value);
			
			if (beta.HasValue)
				c_api.TF_SetAttrFloat (desc, "beta", beta.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the LSTM cell forward propagation for 1 time step.
		/// </summary>
		/// <param name="x">
		///   The input to the LSTM cell, shape (batch_size, num_inputs).
		/// </param>
		/// <param name="cs_prev">
		///   Value of the cell state at previous time step.
		/// </param>
		/// <param name="h_prev">
		///   Output of the previous cell at previous time step.
		/// </param>
		/// <param name="w">
		///   The weight matrix.
		/// </param>
		/// <param name="wci">
		///   The weight matrix for input gate peephole connection.
		/// </param>
		/// <param name="wcf">
		///   The weight matrix for forget gate peephole connection.
		/// </param>
		/// <param name="wco">
		///   The weight matrix for output gate peephole connection.
		/// </param>
		/// <param name="b">
		///   The bias vector.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LSTMBlockCell'.
		/// </param>
		/// <param name="forget_bias">
		///   Optional argument
		///   The forget gate bias.
		/// </param>
		/// <param name="cell_clip">
		///   Optional argument
		///   Value to clip the 'cs' value to.
		/// </param>
		/// <param name="use_peephole">
		///   Optional argument
		///   Whether to use peephole weights.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   i: The input gate.
		///   cs: The cell state before the tanh.
		///   f: The forget gate.
		///   o: The output gate.
		///   ci: The cell input.
		///   co: The cell after the tanh.
		///   h: The output h vector.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   This implementation uses 1 weight matrix and 1 bias vector, and there's an
		///   optional peephole connection.
		///   
		///   This kernel op implements the following mathematical equations:
		///   
		///    <code>
		///   xh = [x, h_prev]
		///   [i, f, ci, o] = xh * w + b
		///   f = f + forget_bias
		///   
		///   if not use_peephole:
		///   wci = wcf = wco = 0
		///   
		///   i = sigmoid(cs_prev * wci + i)
		///   f = sigmoid(cs_prev * wcf + f)
		///   ci = tanh(ci)
		///   
		///   cs = ci .* i + cs_prev .* f
		///   cs = clip(cs, cell_clip)
		///   
		///   o = sigmoid(cs * wco + o)
		///   co = tanh(cs)
		///   h = co .* o
		///    </code>
		/// </remarks>
		public (TF_Output i, TF_Output cs, TF_Output f, TF_Output o, TF_Output ci, TF_Output co, TF_Output h) LSTMBlockCell (TF_Output x, TF_Output cs_prev, TF_Output h_prev, TF_Output w, TF_Output wci, TF_Output wcf, TF_Output wco, TF_Output b, float? forget_bias = null, float? cell_clip = null, bool? use_peephole = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LSTMBlockCell", MakeName ("LSTMBlockCell", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, cs_prev);
			c_api.TF_AddInput(desc, h_prev);
			c_api.TF_AddInput(desc, w);
			c_api.TF_AddInput(desc, wci);
			c_api.TF_AddInput(desc, wcf);
			c_api.TF_AddInput(desc, wco);
			c_api.TF_AddInput(desc, b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (forget_bias.HasValue)
				c_api.TF_SetAttrFloat (desc, "forget_bias", forget_bias.Value);
			
			if (cell_clip.HasValue)
				c_api.TF_SetAttrFloat (desc, "cell_clip", cell_clip.Value);
			
			if (use_peephole.HasValue)
				c_api.TF_SetAttrBool (desc, "use_peephole", Convert.ToByte(use_peephole.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var i = new TF_Output (op, _idx++);
			var cs = new TF_Output (op, _idx++);
			var f = new TF_Output (op, _idx++);
			var o = new TF_Output (op, _idx++);
			var ci = new TF_Output (op, _idx++);
			var co = new TF_Output (op, _idx++);
			var h = new TF_Output (op, _idx++);
			return (i, cs, f, o, ci, co, h);
		}

		/// <summary>
		///   Computes the LSTM cell backward propagation for 1 timestep.
		/// </summary>
		/// <param name="x">
		///   The input to the LSTM cell, shape (batch_size, num_inputs).
		/// </param>
		/// <param name="cs_prev">
		///   The previous cell state.
		/// </param>
		/// <param name="h_prev">
		///   The previous h state.
		/// </param>
		/// <param name="w">
		///   The weight matrix.
		/// </param>
		/// <param name="wci">
		///   The weight matrix for input gate peephole connection.
		/// </param>
		/// <param name="wcf">
		///   The weight matrix for forget gate peephole connection.
		/// </param>
		/// <param name="wco">
		///   The weight matrix for output gate peephole connection.
		/// </param>
		/// <param name="b">
		///   The bias vector.
		/// </param>
		/// <param name="i">
		///   The input gate.
		/// </param>
		/// <param name="cs">
		///   The cell state before the tanh.
		/// </param>
		/// <param name="f">
		///   The forget gate.
		/// </param>
		/// <param name="o">
		///   The output gate.
		/// </param>
		/// <param name="ci">
		///   The cell input.
		/// </param>
		/// <param name="co">
		///   The cell after the tanh.
		/// </param>
		/// <param name="cs_grad">
		///   The current gradient of cs.
		/// </param>
		/// <param name="h_grad">
		///   The gradient of h vector.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'LSTMBlockCellGrad'.
		/// </param>
		/// <param name="use_peephole">
		///   Whether the cell uses peephole connections.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   cs_prev_grad: The gradient of cs to be back-propped.
		///   dicfo: The derivative wrt to [i, cs, f, o].
		///   wci_grad: The gradient for wci to be back-propped.
		///   wcf_grad: The gradient for wcf to be back-propped.
		///   wco_grad: The gradient for wco to be back-propped.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   This implementation is to be used in conjunction of LSTMBlockCell.
		/// </remarks>
		public (TF_Output cs_prev_grad, TF_Output dicfo, TF_Output wci_grad, TF_Output wcf_grad, TF_Output wco_grad) LSTMBlockCellGrad (TF_Output x, TF_Output cs_prev, TF_Output h_prev, TF_Output w, TF_Output wci, TF_Output wcf, TF_Output wco, TF_Output b, TF_Output i, TF_Output cs, TF_Output f, TF_Output o, TF_Output ci, TF_Output co, TF_Output cs_grad, TF_Output h_grad, bool use_peephole, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "LSTMBlockCellGrad", MakeName ("LSTMBlockCellGrad", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, cs_prev);
			c_api.TF_AddInput(desc, h_prev);
			c_api.TF_AddInput(desc, w);
			c_api.TF_AddInput(desc, wci);
			c_api.TF_AddInput(desc, wcf);
			c_api.TF_AddInput(desc, wco);
			c_api.TF_AddInput(desc, b);
			c_api.TF_AddInput(desc, i);
			c_api.TF_AddInput(desc, cs);
			c_api.TF_AddInput(desc, f);
			c_api.TF_AddInput(desc, o);
			c_api.TF_AddInput(desc, ci);
			c_api.TF_AddInput(desc, co);
			c_api.TF_AddInput(desc, cs_grad);
			c_api.TF_AddInput(desc, h_grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrBool (desc, "use_peephole", Convert.ToByte(use_peephole));
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var cs_prev_grad = new TF_Output (op, _idx++);
			var dicfo = new TF_Output (op, _idx++);
			var wci_grad = new TF_Output (op, _idx++);
			var wcf_grad = new TF_Output (op, _idx++);
			var wco_grad = new TF_Output (op, _idx++);
			return (cs_prev_grad, dicfo, wci_grad, wcf_grad, wco_grad);
		}

		/// <summary>
		///   Computes the LU decomposition of one or more square matrices.
		/// </summary>
		/// <param name="input">
		///   A tensor of shape <c>[..., M, M]</c> whose inner-most 2 dimensions form matrices of
		///   size <c>[M, M]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Lu'.
		/// </param>
		/// <param name="output_idx_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   lu: A tensor of shape <c>[..., M, M]</c> whose strictly lower triangular part denotes the
		///   lower triangular factor <c>L</c> with unit diagonal, and whose upper triangular part
		///   denotes the upper triangular factor <c>U</c>.
		///   p: Permutation of the rows encoded as a list of indices in <c>0..M-1</c>. Shape is
		///   <c>[..., M]</c>.
		///   @compatibility(scipy)
		///   Similar to <c>scipy.linalg.lu</c>, except the triangular factors <c>L</c> and <c>U</c> are
		///   packed into a single tensor, the permutation is applied to <c>input</c> instead of
		///   the right hand side and the permutation <c>P</c> is returned as a list of indices
		///   instead of a permutation matrix.
		///   @end_compatibility
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The input is a tensor of shape <c>[..., M, M]</c> whose inner-most 2 dimensions
		///   form square matrices.
		///   
		///   The input has to be invertible.
		///   
		///   The output consists of two tensors LU and P containing the LU decomposition
		///   of all input submatrices <c>[..., :, :]</c>. LU encodes the lower triangular and
		///   upper triangular factors.
		///   
		///   For each input submatrix of shape <c>[M, M]</c>, L is a lower triangular matrix of
		///   shape <c>[M, M]</c> with unit diagonal whose entries correspond to the strictly lower
		///   triangular part of LU. U is a upper triangular matrix of shape <c>[M, M]</c> whose
		///   entries correspond to the upper triangular part, including the diagonal, of LU.
		///   
		///   P represents a permutation matrix encoded as a list of indices each between <c>0</c>
		///   and <c>M-1</c>, inclusive. If P_mat denotes the permutation matrix corresponding to
		///   P, then the L, U and P satisfies P_mat * input = L * U.
		/// </remarks>
		public (TF_Output lu, TF_Output p) Lu (TF_Output input, TF_DataType? output_idx_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Lu", MakeName ("Lu", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (output_idx_type.HasValue)
				c_api.TF_SetAttrType (desc, "output_idx_type", output_idx_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var lu = new TF_Output (op, _idx++);
			var p = new TF_Output (op, _idx++);
			return (lu, p);
		}

		/// <summary>
		///   Makes a new iterator from the given <c>dataset</c> and stores it in <c>iterator</c>.
		/// </summary>
		/// <param name="dataset">
		/// </param>
		/// <param name="iterator">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MakeIterator'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   This operation may be executed multiple times. Each execution will reset the
		///   iterator in <c>iterator</c> to the first element of <c>dataset</c>.
		/// </remarks>
		public TF_Operation MakeIterator (TF_Output dataset, TF_Output iterator, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MakeIterator", MakeName ("MakeIterator", operName));
			c_api.TF_AddInput(desc, dataset);
			c_api.TF_AddInput(desc, iterator);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Creates a dataset that fuses mapping with batching.
		/// </summary>
		/// <param name="input_dataset">
		///   A variant tensor representing the input dataset.
		/// </param>
		/// <param name="other_arguments">
		///   A list of tensors, typically values that were captured when building a closure
		///   for <c>f</c>.
		/// </param>
		/// <param name="batch_size">
		///   A scalar representing the number of elements to accumulate in a
		///   batch. It determines the number of concurrent invocations of <c>f</c> that process
		///   elements from <c>input_dataset</c> in parallel.
		/// </param>
		/// <param name="num_parallel_calls">
		///   A scalar representing the maximum number of parallel invocations of the <c>map_fn</c>
		///   function. Applying the <c>map_fn</c> on consecutive input elements in parallel has
		///   the potential to improve input pipeline throughput.
		/// </param>
		/// <param name="drop_remainder">
		///   A scalar representing whether the last batch should be dropped in case its size
		///   is smaller than desired.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MapAndBatchDataset'.
		/// </param>
		/// <param name="preserve_cardinality">
		///   Optional argument
		/// </param>
		/// <param name="f">
		///   A function to apply to the outputs of <c>input_dataset</c>.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Creates a dataset that applies <c>f</c> to the outputs of <c>input_dataset</c> and then
		///   batches <c>batch_size</c> of them.
		///   
		///   Unlike a "MapDataset", which applies <c>f</c> sequentially, this dataset invokes up
		///   to <c>batch_size * num_parallel_batches</c> copies of <c>f</c> in parallel.
		/// </remarks>
		public TF_Output MapAndBatchDataset (TF_Output input_dataset, TF_Output[] other_arguments, TF_Output batch_size, TF_Output num_parallel_calls, TF_Output drop_remainder, TF_Function f, TF_DataType[] output_types, long[][] output_shapes, bool? preserve_cardinality = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MapAndBatchDataset", MakeName ("MapAndBatchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInputList(desc, other_arguments[0], other_arguments.Length);
			c_api.TF_AddInput(desc, batch_size);
			c_api.TF_AddInput(desc, num_parallel_calls);
			c_api.TF_AddInput(desc, drop_remainder);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "f", c_api.TF_FunctionName(f));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (preserve_cardinality.HasValue)
				c_api.TF_SetAttrBool (desc, "preserve_cardinality", Convert.ToByte(preserve_cardinality.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Op removes all elements in the underlying container.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MapClear'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation MapClear (TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MapClear", MakeName ("MapClear", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Creates a dataset that applies <c>f</c> to the outputs of <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="other_arguments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MapDataset'.
		/// </param>
		/// <param name="use_inter_op_parallelism">
		///   Optional argument
		/// </param>
		/// <param name="preserve_cardinality">
		///   Optional argument
		/// </param>
		/// <param name="f">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MapDataset (TF_Output input_dataset, TF_Output[] other_arguments, TF_Function f, TF_DataType[] output_types, long[][] output_shapes, bool? use_inter_op_parallelism = null, bool? preserve_cardinality = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MapDataset", MakeName ("MapDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInputList(desc, other_arguments[0], other_arguments.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "f", c_api.TF_FunctionName(f));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (use_inter_op_parallelism.HasValue)
				c_api.TF_SetAttrBool (desc, "use_inter_op_parallelism", Convert.ToByte(use_inter_op_parallelism.Value));
			
			if (preserve_cardinality.HasValue)
				c_api.TF_SetAttrBool (desc, "preserve_cardinality", Convert.ToByte(preserve_cardinality.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Maps a function on the list of tensors unpacked from arguments on dimension 0.
		///   The function given by <c>f</c> is assumed to be stateless, and is executed
		///   concurrently on all the slices; up to batch_size (i.e. the size of the 0th
		///   dimension of each argument) functions will be scheduled at once.
		///   
		///   The <c>max_intra_op_parallelism</c> attr, which defaults to 1, can be used to
		///   limit the intra op parallelism. To limit inter-op parallelism, a user can
		///   set a private threadpool on the dataset using <c>tf.data.Options</c>'s
		///   <c>ThreadingOptions</c>.
		///   
		///   Note that this op is not exposed to users directly, but is invoked in tf.data
		///   rewrites.
		/// </summary>
		/// <param name="arguments">
		///   A list of tensors whose types are <c>Targuments</c>, corresponding to the inputs
		///   the function should be mapped over.
		/// </param>
		/// <param name="captured_inputs">
		///   A list of tensors whose types are <c>Tcaptured</c>, corresponding to the captured
		///   inputs of the defun.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MapDefun'.
		/// </param>
		/// <param name="max_intra_op_parallelism">
		///   Optional argument
		/// </param>
		/// <param name="output_types">
		///   A list of types.
		/// </param>
		/// <param name="output_shapes">
		///   A list of shapes.
		/// </param>
		/// <param name="f">
		/// </param>
		/// <returns>
		///   A list of output tensors whose types are <c>output_types</c> and whose dimensions
		///   0 are the same as the dimensions 0 of the tensors in <c>arguments</c>, and whose
		///   remaining dimensions correspond to those in <c>output_shapes</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] MapDefun (TF_Output[] arguments, TF_Output[] captured_inputs, TF_DataType[] output_types, long[][] output_shapes, TF_Function f, long? max_intra_op_parallelism = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MapDefun", MakeName ("MapDefun", operName));
			c_api.TF_AddInputList(desc, arguments[0], arguments.Length);
			c_api.TF_AddInputList(desc, captured_inputs[0], captured_inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			c_api.TF_SetAttrFuncName (desc, "f", c_api.TF_FunctionName(f));
			if (max_intra_op_parallelism.HasValue)
				c_api.TF_SetAttrInt (desc, "max_intra_op_parallelism", max_intra_op_parallelism.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		///   Op returns the number of incomplete elements in the underlying container.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MapIncompleteSize'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MapIncompleteSize (TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MapIncompleteSize", MakeName ("MapIncompleteSize", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		///   Op peeks at the values at the specified key.  If the
		/// </summary>
		/// <param name="key">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MapPeek'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   underlying container does not contain this key
		///   this op will block until it does.
		/// </remarks>
		public TF_Output[] MapPeek (TF_Output key, TF_Output indices, TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MapPeek", MakeName ("MapPeek", operName));
			c_api.TF_AddInput(desc, key);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "values", status);
			var values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				values [i] = new TF_Output (op, _idx++);
			
			return values;
		}

		/// <summary>
		///   Op returns the number of elements in the underlying container.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MapSize'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MapSize (TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MapSize", MakeName ("MapSize", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		///   Stage (key, values) in the underlying container which behaves like a hashtable.
		/// </summary>
		/// <param name="key">
		///   int64
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="values">
		///   a list of tensors
		///   dtypes A list of data types that inserted values should adhere to.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MapStage'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		///   Maximum number of elements in the Staging Area. If &amp;gt; 0, inserts
		///   on the container will block when the capacity is reached.
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this queue is placed in the given container. Otherwise,
		///   a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   It is necessary to match this name to the matching Unstage Op.
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation MapStage (TF_Output key, TF_Output indices, TF_Output[] values, TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MapStage", MakeName ("MapStage", operName));
			c_api.TF_AddInput(desc, key);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInputList(desc, values[0], values.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Op removes and returns the values associated with the key
		/// </summary>
		/// <param name="key">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MapUnstage'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   from the underlying container.   If the underlying container
		///   does not contain this key, the op will block until it does.
		/// </remarks>
		public TF_Output[] MapUnstage (TF_Output key, TF_Output indices, TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MapUnstage", MakeName ("MapUnstage", operName));
			c_api.TF_AddInput(desc, key);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "values", status);
			var values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				values [i] = new TF_Output (op, _idx++);
			
			return values;
		}

		/// <summary>
		///   Op removes and returns a random (key, value)
		/// </summary>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MapUnstageNoKey'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   key:
		///   values:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   from the underlying container.   If the underlying container
		///   does not contain elements, the op will block until it does.
		/// </remarks>
		public (TF_Output key, TF_Output[] values) MapUnstageNoKey (TF_Output indices, TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MapUnstageNoKey", MakeName ("MapUnstageNoKey", operName));
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			var key = new TF_Output (op, _idx++);
			_n = c_api.TF_OperationOutputListLength(op, "values", status);
			var values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				values [i] = new TF_Output (op, _idx++);
			
			return (key, values);
		}

		/// <summary>
		///   Returns the set of files matching one or more glob patterns.
		/// </summary>
		/// <param name="pattern">
		///   Shell wildcard pattern(s). Scalar or vector of type string.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatchingFiles'.
		/// </param>
		/// <returns>
		///   A vector of matching filenames.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Note that this routine only supports wildcard characters in the
		///   basename portion of the pattern, not in the directory portion.
		///   Note also that the order of filenames returned is deterministic.
		/// </remarks>
		public TF_Output MatchingFiles (TF_Output pattern, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatchingFiles", MakeName ("MatchingFiles", operName));
			c_api.TF_AddInput(desc, pattern);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var filenames = new TF_Output (op, _idx++);
			return filenames;
		}

		/// <summary>
		/// </summary>
		/// <param name="patterns">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatchingFilesDataset'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MatchingFilesDataset (TF_Output patterns, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatchingFilesDataset", MakeName ("MatchingFilesDataset", operName));
			c_api.TF_AddInput(desc, patterns);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Multiply the matrix "a" by the matrix "b".
		/// </summary>
		/// <param name="a">
		/// </param>
		/// <param name="b">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatMul'.
		/// </param>
		/// <param name="transpose_a">
		///   Optional argument
		///   If true, "a" is transposed before multiplication.
		/// </param>
		/// <param name="transpose_b">
		///   Optional argument
		///   If true, "b" is transposed before multiplication.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The inputs must be two-dimensional matrices and the inner dimension of
		///   "a" (after being transposed if transpose_a is true) must match the
		///   outer dimension of "b" (after being transposed if transposed_b is
		///   true).
		///   
		///   *Note*: The default kernel implementation for MatMul on GPUs uses
		///   cublas.
		/// </remarks>
		public TF_Output MatMul (TF_Output a, TF_Output b, bool? transpose_a = null, bool? transpose_b = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatMul", MakeName ("MatMul", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (transpose_a.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_a", Convert.ToByte(transpose_a.Value));
			
			if (transpose_b.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_b", Convert.ToByte(transpose_b.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var product = new TF_Output (op, _idx++);
			return product;
		}

		/// <summary>
		///   Copy a tensor setting everything outside a central band in each innermost matrix
		/// </summary>
		/// <param name="input">
		///   Rank <c>k</c> tensor.
		/// </param>
		/// <param name="num_lower">
		///   0-D tensor. Number of subdiagonals to keep. If negative, keep entire
		///   lower triangle.
		/// </param>
		/// <param name="num_upper">
		///   0-D tensor. Number of superdiagonals to keep. If negative, keep
		///   entire upper triangle.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixBandPart'.
		/// </param>
		/// <returns>
		///   Rank <c>k</c> tensor of the same shape as input. The extracted banded tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   to zero.
		///   
		///   The <c>band</c> part is computed as follows:
		///   Assume <c>input</c> has <c>k</c> dimensions <c>[I, J, K, ..., M, N]</c>, then the output is a
		///   tensor with the same shape where
		///   
		///   <c>band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]</c>.
		///   
		///   The indicator function
		///   
		///   <c>in_band(m, n) = (num_lower &amp;lt; 0 || (m-n) &amp;lt;= num_lower)) &amp;&amp;
		///   (num_upper &amp;lt; 0 || (n-m) &amp;lt;= num_upper)</c>.
		///   
		///   For example:
		///   
		///    <code>
		///   # if 'input' is [[ 0,  1,  2, 3]
		///   [-1,  0,  1, 2]
		///   [-2, -1,  0, 1]
		///   [-3, -2, -1, 0]],
		///   
		///   tf.matrix_band_part(input, 1, -1) ==&amp;gt; [[ 0,  1,  2, 3]
		///   [-1,  0,  1, 2]
		///   [ 0, -1,  0, 1]
		///   [ 0,  0, -1, 0]],
		///   
		///   tf.matrix_band_part(input, 2, 1) ==&amp;gt; [[ 0,  1,  0, 0]
		///   [-1,  0,  1, 0]
		///   [-2, -1,  0, 1]
		///   [ 0, -2, -1, 0]]
		///    </code>
		///   
		///   Useful special cases:
		///   
		///    <code>
		///   tf.matrix_band_part(input, 0, -1) ==&amp;gt; Upper triangular part.
		///   tf.matrix_band_part(input, -1, 0) ==&amp;gt; Lower triangular part.
		///   tf.matrix_band_part(input, 0, 0) ==&amp;gt; Diagonal.
		///    </code>
		/// </remarks>
		public TF_Output MatrixBandPart (TF_Output input, TF_Output num_lower, TF_Output num_upper, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixBandPart", MakeName ("MatrixBandPart", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, num_lower);
			c_api.TF_AddInput(desc, num_upper);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var band = new TF_Output (op, _idx++);
			return band;
		}

		/// <summary>
		///   Computes the determinant of one or more square matrices.
		/// </summary>
		/// <param name="input">
		///   Shape is <c>[..., M, M]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixDeterminant'.
		/// </param>
		/// <returns>
		///   Shape is <c>[...]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The input is a tensor of shape <c>[..., M, M]</c> whose inner-most 2 dimensions
		///   form square matrices. The output is a tensor containing the determinants
		///   for all input submatrices <c>[..., :, :]</c>.
		/// </remarks>
		public TF_Output MatrixDeterminant (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixDeterminant", MakeName ("MatrixDeterminant", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns a batched diagonal tensor with a given batched diagonal values.
		/// </summary>
		/// <param name="diagonal">
		///   Rank <c>k</c>, where <c>k &amp;gt;= 1</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixDiag'.
		/// </param>
		/// <returns>
		///   Rank <c>k+1</c>, with <c>output.shape = diagonal.shape + [diagonal.shape[-1]]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given a <c>diagonal</c>, this operation returns a tensor with the <c>diagonal</c> and
		///   everything else padded with zeros. The diagonal is computed as follows:
		///   
		///   Assume <c>diagonal</c> has <c>k</c> dimensions <c>[I, J, K, ..., N]</c>, then the output is a
		///   tensor of rank <c>k+1</c> with dimensions [I, J, K, ..., N, N]<c> where:
		///   
		///   </c>output[i, j, k, ..., m, n] = 1{m=n} * diagonal[i, j, k, ..., n]<c>.
		///   
		///   For example:
		///   
		///    <code>
		///   # 'diagonal' is [[1, 2, 3, 4], [5, 6, 7, 8]]
		///   
		///   and diagonal.shape = (2, 4)
		///   
		///   tf.matrix_diag(diagonal) ==&amp;gt; [[[1, 0, 0, 0]
		///   [0, 2, 0, 0]
		///   [0, 0, 3, 0]
		///   [0, 0, 0, 4]],
		///   [[5, 0, 0, 0]
		///   [0, 6, 0, 0]
		///   [0, 0, 7, 0]
		///   [0, 0, 0, 8]]]
		///   
		///   which has shape (2, 4, 4)
		///    </code>
		/// </remarks>
		public TF_Output MatrixDiag (TF_Output diagonal, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixDiag", MakeName ("MatrixDiag", operName));
			c_api.TF_AddInput(desc, diagonal);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns the batched diagonal part of a batched tensor.
		/// </summary>
		/// <param name="input">
		///   Rank <c>k</c> tensor where <c>k &amp;gt;= 2</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixDiagPart'.
		/// </param>
		/// <returns>
		///   The extracted diagonal(s) having shape
		///   <c>diagonal.shape = input.shape[:-2] + [min(input.shape[-2:])]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation returns a tensor with the <c>diagonal</c> part
		///   of the batched <c>input</c>. The <c>diagonal</c> part is computed as follows:
		///   
		///   Assume <c>input</c> has <c>k</c> dimensions <c>[I, J, K, ..., M, N]</c>, then the output is a
		///   tensor of rank <c>k - 1</c> with dimensions <c>[I, J, K, ..., min(M, N)]</c> where:
		///   
		///   <c>diagonal[i, j, k, ..., n] = input[i, j, k, ..., n, n]</c>.
		///   
		///   The input must be at least a matrix.
		///   
		///   For example:
		///   
		///    <code>
		///   # 'input' is [[[1, 0, 0, 0]
		///   [0, 2, 0, 0]
		///   [0, 0, 3, 0]
		///   [0, 0, 0, 4]],
		///   [[5, 0, 0, 0]
		///   [0, 6, 0, 0]
		///   [0, 0, 7, 0]
		///   [0, 0, 0, 8]]]
		///   
		///   and input.shape = (2, 4, 4)
		///   
		///   tf.matrix_diag_part(input) ==&amp;gt; [[1, 2, 3, 4], [5, 6, 7, 8]]
		///   
		///   which has shape (2, 4)
		///    </code>
		/// </remarks>
		public TF_Output MatrixDiagPart (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixDiagPart", MakeName ("MatrixDiagPart", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var diagonal = new TF_Output (op, _idx++);
			return diagonal;
		}

		/// <summary>
		///   Returns the batched diagonal part of a batched tensor.
		/// </summary>
		/// <param name="input">
		///   Rank <c>r</c> tensor where <c>r &amp;gt;= 2</c>.
		/// </param>
		/// <param name="k">
		///   Diagonal offset(s). Positive value means superdiagonal, 0 refers to the main
		///   diagonal, and negative value means subdiagonals. <c>k</c> can be a single integer
		///   (for a single diagonal) or a pair of integers specifying the low and high ends
		///   of a matrix band. <c>k[0]</c> must not be larger than <c>k[1]</c>.
		/// </param>
		/// <param name="padding_value">
		///   The value to fill the area outside the specified diagonal band with.
		///   Default is 0.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixDiagPartV2'.
		/// </param>
		/// <returns>
		///   The extracted diagonal(s).
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Returns a tensor with the <c>k[0]</c>-th to <c>k[1]</c>-th diagonals of the batched
		///   <c>input</c>.
		///   
		///   Assume <c>input</c> has <c>r</c> dimensions <c>[I, J, ..., L, M, N]</c>.
		///   Let <c>max_diag_len</c> be the maximum length among all diagonals to be extracted,
		///   <c>max_diag_len = min(M + min(k[1], 0), N + min(-k[0], 0))</c>
		///   Let <c>num_diags</c> be the number of diagonals to extract,
		///   <c>num_diags = k[1] - k[0] + 1</c>.
		///   
		///   If <c>num_diags == 1</c>, the output tensor is of rank <c>r - 1</c> with shape
		///   <c>[I, J, ..., L, max_diag_len]</c> and values:
		///   
		///    <code>
		///   diagonal[i, j, ..., l, n]
		///   = input[i, j, ..., l, n+y, n+x] ; when 0 &amp;lt;= n-y &amp;lt; M and 0 &amp;lt;= n-x &amp;lt; N,
		///   0                             ; otherwise.
		///    </code>
		///   where <c>y = max(-k[1], 0)</c>, <c>x = max(k[1], 0)</c>.
		///   
		///   Otherwise, the output tensor has rank <c>r</c> with dimensions
		///   <c>[I, J, ..., L, num_diags, max_diag_len]</c> with values:
		///   
		///    <code>
		///   diagonal[i, j, ..., l, m, n]
		///   = input[i, j, ..., l, n+y, n+x] ; when 0 &amp;lt;= n-y &amp;lt; M and 0 &amp;lt;= n-x &amp;lt; N,
		///   0                             ; otherwise.
		///    </code>
		///   where <c>d = k[1] - m</c>, <c>y = max(-d, 0)</c>, and <c>x = max(d, 0)</c>.
		///   
		///   The input must be at least a matrix.
		///   
		///   For example:
		///   
		///    <code>
		///   input = np.array([[[1, 2, 3, 4],  # Input shape: (2, 3, 4)
		///   [5, 6, 7, 8],
		///   [9, 8, 7, 6]],
		///   [[5, 4, 3, 2],
		///   [1, 2, 3, 4],
		///   [5, 6, 7, 8]]])
		///   
		///   # A main diagonal from each batch.
		///   tf.matrix_diag_part(input) ==&amp;gt; [[1, 6, 7],  # Output shape: (2, 3)
		///   [5, 2, 7]]
		///   
		///   # A superdiagonal from each batch.
		///   tf.matrix_diag_part(input, k = 1)
		///   ==&amp;gt; [[2, 7, 6],  # Output shape: (2, 3)
		///   [4, 3, 8]]
		///   
		///   # A tridiagonal band from each batch.
		///   tf.matrix_diag_part(input, k = (-1, 1))
		///   ==&amp;gt; [[[2, 7, 6],  # Output shape: (2, 3, 3)
		///   [1, 6, 7],
		///   [5, 8, 0]],
		///   [[4, 3, 8],
		///   [5, 2, 7],
		///   [1, 6, 0]]]
		///   
		///   # Padding = 9
		///   tf.matrix_diag_part(input, k = (1, 3), padding = 9)
		///   ==&amp;gt; [[[4, 9, 9],  # Output shape: (2, 3, 3)
		///   [3, 8, 9],
		///   [2, 7, 6]],
		///   [[2, 9, 9],
		///   [3, 4, 9],
		///   [4, 3, 8]]]
		///    </code>
		/// </remarks>
		public TF_Output MatrixDiagPartV2 (TF_Output input, TF_Output k, TF_Output padding_value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixDiagPartV2", MakeName ("MatrixDiagPartV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, k);
			c_api.TF_AddInput(desc, padding_value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var diagonal = new TF_Output (op, _idx++);
			return diagonal;
		}

		/// <summary>
		///   Returns a batched diagonal tensor with given batched diagonal values.
		/// </summary>
		/// <param name="diagonal">
		///   Rank <c>r</c>, where <c>r &amp;gt;= 1</c>
		/// </param>
		/// <param name="k">
		///   Diagonal offset(s). Positive value means superdiagonal, 0 refers to the main
		///   diagonal, and negative value means subdiagonals. <c>k</c> can be a single integer
		///   (for a single diagonal) or a pair of integers specifying the low and high ends
		///   of a matrix band. <c>k[0]</c> must not be larger than <c>k[1]</c>.
		/// </param>
		/// <param name="num_rows">
		///   The number of rows of the output matrix. If it is not provided, the op assumes
		///   the output matrix is a square matrix and infers the matrix size from k and the
		///   innermost dimension of <c>diagonal</c>.
		/// </param>
		/// <param name="num_cols">
		///   The number of columns of the output matrix. If it is not provided, the op
		///   assumes the output matrix is a square matrix and infers the matrix size from
		///   k and the innermost dimension of <c>diagonal</c>.
		/// </param>
		/// <param name="padding_value">
		///   The number to fill the area outside the specified diagonal band with.
		///   Default is 0.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixDiagV2'.
		/// </param>
		/// <returns>
		///   Has rank <c>r+1</c> when <c>k</c> is an integer or <c>k[0] == k[1]</c>, rank <c>r</c> otherwise.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Returns a tensor with the contents in <c>diagonal</c> as <c>k[0]</c>-th to <c>k[1]</c>-th
		///   diagonals of a matrix, with everything else padded with <c>padding</c>. <c>num_rows</c>
		///   and <c>num_cols</c> specify the dimension of the innermost matrix of the output. If
		///   both are not specified, the op assumes the innermost matrix is square and infers
		///   its size from <c>k</c> and the innermost dimension of <c>diagonal</c>. If only one of them
		///   is specified, the op assumes the unspecified value is the smallest possible
		///   based on other criteria.
		///   
		///   Let <c>diagonal</c> have <c>r</c> dimensions <c>[I, J, ..., L, M, N]</c>. The output tensor has
		///   rank <c>r+1</c> with shape <c>[I, J, ..., L, M, num_rows, num_cols]</c> when only one
		///   diagonal is given (<c>k</c> is an integer or <c>k[0] == k[1]</c>). Otherwise, it has rank
		///   <c>r</c> with shape <c>[I, J, ..., L, num_rows, num_cols]</c>.
		///   
		///   The second innermost dimension of <c>diagonal</c> has double meaning.
		///   When <c>k</c> is scalar or <c>k[0] == k[1]</c>, <c>M</c> is part of the batch size
		///   [I, J, ..., M], and the output tensor is:
		///   
		///    <code>
		///   output[i, j, ..., l, m, n]
		///   = diagonal[i, j, ..., l, n-max(d_upper, 0)] ; if n - m == d_upper
		///   output[i, j, ..., l, m, n]                ; otherwise
		///    </code>
		///   
		///   Otherwise, <c>M</c> is treated as the number of diagonals for the matrix in the
		///   same batch (<c>M = k[1]-k[0]+1</c>), and the output tensor is:
		///   
		///    <code>
		///   output[i, j, ..., l, m, n]
		///   = diagonal[i, j, ..., l, k[1]-d, n-max(d, 0)] ; if d_lower &amp;lt;= d &amp;lt;= d_upper
		///   input[i, j, ..., l, m, n]                   ; otherwise
		///    </code>
		///   where <c>d = n - m</c>
		///   
		///   For example:
		///   
		///    <code>
		///   # The main diagonal.
		///   diagonal = np.array([[1, 2, 3, 4],            # Input shape: (2, 4)
		///   [5, 6, 7, 8]])
		///   tf.matrix_diag(diagonal) ==&amp;gt; [[[1, 0, 0, 0],  # Output shape: (2, 4, 4)
		///   [0, 2, 0, 0],
		///   [0, 0, 3, 0],
		///   [0, 0, 0, 4]],
		///   [[5, 0, 0, 0],
		///   [0, 6, 0, 0],
		///   [0, 0, 7, 0],
		///   [0, 0, 0, 8]]]
		///   
		///   # A superdiagonal (per batch).
		///   diagonal = np.array([[1, 2, 3],  # Input shape: (2, 3)
		///   [4, 5, 6]])
		///   tf.matrix_diag(diagonal, k = 1)
		///   ==&amp;gt; [[[0, 1, 0, 0],  # Output shape: (2, 4, 4)
		///   [0, 0, 2, 0],
		///   [0, 0, 0, 3],
		///   [0, 0, 0, 0]],
		///   [[0, 4, 0, 0],
		///   [0, 0, 5, 0],
		///   [0, 0, 0, 6],
		///   [0, 0, 0, 0]]]
		///   
		///   # A band of diagonals.
		///   diagonals = np.array([[[1, 2, 3],  # Input shape: (2, 2, 3)
		///   [4, 5, 0]],
		///   [[6, 7, 9],
		///   [9, 1, 0]]])
		///   tf.matrix_diag(diagonals, k = (-1, 0))
		///   ==&amp;gt; [[[1, 0, 0],  # Output shape: (2, 3, 3)
		///   [4, 2, 0],
		///   [0, 5, 3]],
		///   [[6, 0, 0],
		///   [9, 7, 0],
		///   [0, 1, 9]]]
		///   
		///   # Rectangular matrix.
		///   diagonal = np.array([1, 2])  # Input shape: (2)
		///   tf.matrix_diag(diagonal, k = -1, num_rows = 3, num_cols = 4)
		///   ==&amp;gt; [[0, 0, 0, 0],  # Output shape: (3, 4)
		///   [1, 0, 0, 0],
		///   [0, 2, 0, 0]]
		///   
		///   # Rectangular matrix with inferred num_cols and padding = 9.
		///   tf.matrix_diag(diagonal, k = -1, num_rows = 3, padding = 9)
		///   ==&amp;gt; [[9, 9],  # Output shape: (3, 2)
		///   [1, 9],
		///   [9, 2]]
		///    </code>
		/// </remarks>
		public TF_Output MatrixDiagV2 (TF_Output diagonal, TF_Output k, TF_Output num_rows, TF_Output num_cols, TF_Output padding_value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixDiagV2", MakeName ("MatrixDiagV2", operName));
			c_api.TF_AddInput(desc, diagonal);
			c_api.TF_AddInput(desc, k);
			c_api.TF_AddInput(desc, num_rows);
			c_api.TF_AddInput(desc, num_cols);
			c_api.TF_AddInput(desc, padding_value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Deprecated, use python implementation tf.linalg.matrix_exponential.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixExponential'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MatrixExponential (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixExponential", MakeName ("MatrixExponential", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the inverse of one or more square invertible matrices or their
		/// </summary>
		/// <param name="input">
		///   Shape is <c>[..., M, M]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixInverse'.
		/// </param>
		/// <param name="adjoint">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Shape is <c>[..., M, M]</c>.
		///   
		///   @compatibility(numpy)
		///   Equivalent to np.linalg.inv
		///   @end_compatibility
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   adjoints (conjugate transposes).
		///   
		///   The input is a tensor of shape <c>[..., M, M]</c> whose inner-most 2 dimensions
		///   form square matrices. The output is a tensor of the same shape as the input
		///   containing the inverse for all input submatrices <c>[..., :, :]</c>.
		///   
		///   The op uses LU decomposition with partial pivoting to compute the inverses.
		///   
		///   If a matrix is not invertible there is no guarantee what the op does. It
		///   may detect the condition and raise an exception or it may simply return a
		///   garbage result.
		/// </remarks>
		public TF_Output MatrixInverse (TF_Output input, bool? adjoint = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixInverse", MakeName ("MatrixInverse", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (adjoint.HasValue)
				c_api.TF_SetAttrBool (desc, "adjoint", Convert.ToByte(adjoint.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the matrix logarithm of one or more square matrices:
		/// </summary>
		/// <param name="input">
		///   Shape is <c>[..., M, M]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixLogarithm'.
		/// </param>
		/// <returns>
		///   Shape is <c>[..., M, M]</c>.
		///   
		///   @compatibility(scipy)
		///   Equivalent to scipy.linalg.logm
		///   @end_compatibility
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   
		///   \\(log(exp(A)) = A\\)
		///   
		///   This op is only defined for complex matrices. If A is positive-definite and
		///   real, then casting to a complex matrix, taking the logarithm and casting back
		///   to a real matrix will give the correct result.
		///   
		///   This function computes the matrix logarithm using the Schur-Parlett algorithm.
		///   Details of the algorithm can be found in Section 11.6.2 of:
		///   Nicholas J. Higham, Functions of Matrices: Theory and Computation, SIAM 2008.
		///   ISBN 978-0-898716-46-7.
		///   
		///   The input is a tensor of shape <c>[..., M, M]</c> whose inner-most 2 dimensions
		///   form square matrices. The output is a tensor of the same shape as the input
		///   containing the exponential for all input submatrices <c>[..., :, :]</c>.
		/// </remarks>
		public TF_Output MatrixLogarithm (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixLogarithm", MakeName ("MatrixLogarithm", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns a batched matrix tensor with new batched diagonal values.
		/// </summary>
		/// <param name="input">
		///   Rank <c>k+1</c>, where <c>k &amp;gt;= 1</c>.
		/// </param>
		/// <param name="diagonal">
		///   Rank <c>k</c>, where <c>k &amp;gt;= 1</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixSetDiag'.
		/// </param>
		/// <returns>
		///   Rank <c>k+1</c>, with <c>output.shape = input.shape</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given <c>input</c> and <c>diagonal</c>, this operation returns a tensor with the
		///   same shape and values as <c>input</c>, except for the main diagonal of the
		///   innermost matrices.  These will be overwritten by the values in <c>diagonal</c>.
		///   
		///   The output is computed as follows:
		///   
		///   Assume <c>input</c> has <c>k+1</c> dimensions <c>[I, J, K, ..., M, N]</c> and <c>diagonal</c> has
		///   <c>k</c> dimensions <c>[I, J, K, ..., min(M, N)]</c>.  Then the output is a
		///   tensor of rank <c>k+1</c> with dimensions <c>[I, J, K, ..., M, N]</c> where:
		///   
		///   * <c>output[i, j, k, ..., m, n] = diagonal[i, j, k, ..., n]</c> for <c>m == n</c>.
		///   * <c>output[i, j, k, ..., m, n] = input[i, j, k, ..., m, n]</c> for <c>m != n</c>.
		/// </remarks>
		public TF_Output MatrixSetDiag (TF_Output input, TF_Output diagonal, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixSetDiag", MakeName ("MatrixSetDiag", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, diagonal);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns a batched matrix tensor with new batched diagonal values.
		/// </summary>
		/// <param name="input">
		///   Rank <c>r+1</c>, where <c>r &amp;gt;= 1</c>.
		/// </param>
		/// <param name="diagonal">
		///   Rank <c>r</c> when <c>k</c> is an integer or <c>k[0] == k[1]</c>. Otherwise, it has rank <c>r+1</c>.
		///   <c>k &amp;gt;= 1</c>.
		/// </param>
		/// <param name="k">
		///   Diagonal offset(s). Positive value means superdiagonal, 0 refers to the main
		///   diagonal, and negative value means subdiagonals. <c>k</c> can be a single integer
		///   (for a single diagonal) or a pair of integers specifying the low and high ends
		///   of a matrix band. <c>k[0]</c> must not be larger than <c>k[1]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixSetDiagV2'.
		/// </param>
		/// <returns>
		///   Rank <c>r+1</c>, with <c>output.shape = input.shape</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given <c>input</c> and <c>diagonal</c>, this operation returns a tensor with the
		///   same shape and values as <c>input</c>, except for the specified diagonals of the
		///   innermost matrices. These will be overwritten by the values in <c>diagonal</c>.
		///   
		///   <c>input</c> has <c>r+1</c> dimensions <c>[I, J, ..., L, M, N]</c>. When <c>k</c> is scalar or
		///   <c>k[0] == k[1]</c>, <c>diagonal</c> has <c>r</c> dimensions <c>[I, J, ..., L, max_diag_len]</c>.
		///   Otherwise, it has <c>r+1</c> dimensions <c>[I, J, ..., L, num_diags, max_diag_len]</c>.
		///   <c>num_diags</c> is the number of diagonals, <c>num_diags = k[1] - k[0] + 1</c>.
		///   <c>max_diag_len</c> is the longest diagonal in the range <c>[k[0], k[1]]</c>,
		///   <c>max_diag_len = min(M + min(k[1], 0), N + min(-k[0], 0))</c>
		///   
		///   The output is a tensor of rank <c>k+1</c> with dimensions <c>[I, J, ..., L, M, N]</c>.
		///   If <c>k</c> is scalar or <c>k[0] == k[1]</c>:
		///   
		///    <code>
		///   output[i, j, ..., l, m, n]
		///   = diagonal[i, j, ..., l, n-max(k[1], 0)] ; if n - m == k[1]
		///   output[i, j, ..., l, m, n]             ; otherwise
		///    </code>
		///   
		///   Otherwise,
		///   
		///    <code>
		///   output[i, j, ..., l, m, n]
		///   = diagonal[i, j, ..., l, k[1]-d, n-max(d, 0)] ; if d_lower &amp;lt;= d &amp;lt;= d_upper
		///   input[i, j, ..., l, m, n]                   ; otherwise
		///    </code>
		///   where <c>d = n - m</c>
		///   
		///   For example:
		///   
		///    <code>
		///   # The main diagonal.
		///   input = np.array([[[7, 7, 7, 7],              # Input shape: (2, 3, 4)
		///   [7, 7, 7, 7],
		///   [7, 7, 7, 7]],
		///   [[7, 7, 7, 7],
		///   [7, 7, 7, 7],
		///   [7, 7, 7, 7]]])
		///   diagonal = np.array([[1, 2, 3],               # Diagonal shape: (2, 3)
		///   [4, 5, 6]])
		///   tf.matrix_diag(diagonal) ==&amp;gt; [[[1, 7, 7, 7],  # Output shape: (2, 3, 4)
		///   [7, 2, 7, 7],
		///   [7, 7, 3, 7]],
		///   [[4, 7, 7, 7],
		///   [7, 5, 7, 7],
		///   [7, 7, 6, 7]]]
		///   
		///   # A superdiagonal (per batch).
		///   tf.matrix_diag(diagonal, k = 1)
		///   ==&amp;gt; [[[7, 1, 7, 7],  # Output shape: (2, 3, 4)
		///   [7, 7, 2, 7],
		///   [7, 7, 7, 3]],
		///   [[7, 4, 7, 7],
		///   [7, 7, 5, 7],
		///   [7, 7, 7, 6]]]
		///   
		///   # A band of diagonals.
		///   diagonals = np.array([[[1, 2, 3],  # Diagonal shape: (2, 2, 3)
		///   [4, 5, 0]],
		///   [[6, 1, 2],
		///   [3, 4, 0]]])
		///   tf.matrix_diag(diagonals, k = (-1, 0))
		///   ==&amp;gt; [[[1, 7, 7, 7],  # Output shape: (2, 3, 4)
		///   [4, 2, 7, 7],
		///   [0, 5, 3, 7]],
		///   [[6, 7, 7, 7],
		///   [3, 1, 7, 7],
		///   [7, 4, 2, 7]]]
		///   
		///    </code>
		/// </remarks>
		public TF_Output MatrixSetDiagV2 (TF_Output input, TF_Output diagonal, TF_Output k, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixSetDiagV2", MakeName ("MatrixSetDiagV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, diagonal);
			c_api.TF_AddInput(desc, k);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Solves systems of linear equations.
		/// </summary>
		/// <param name="matrix">
		///   Shape is <c>[..., M, M]</c>.
		/// </param>
		/// <param name="rhs">
		///   Shape is <c>[..., M, K]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixSolve'.
		/// </param>
		/// <param name="adjoint">
		///   Optional argument
		///   Boolean indicating whether to solve with <c>matrix</c> or its (block-wise)
		///   adjoint.
		/// </param>
		/// <returns>
		///   Shape is <c>[..., M, K]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   <c>Matrix</c> is a tensor of shape <c>[..., M, M]</c> whose inner-most 2 dimensions
		///   form square matrices. <c>Rhs</c> is a tensor of shape <c>[..., M, K]</c>. The <c>output</c> is
		///   a tensor shape <c>[..., M, K]</c>.  If <c>adjoint</c> is <c>False</c> then each output matrix
		///   satisfies <c>matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]</c>.
		///   If <c>adjoint</c> is <c>True</c> then each output matrix satisfies
		///   <c>adjoint(matrix[..., :, :]) * output[..., :, :] = rhs[..., :, :]</c>.
		/// </remarks>
		public TF_Output MatrixSolve (TF_Output matrix, TF_Output rhs, bool? adjoint = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixSolve", MakeName ("MatrixSolve", operName));
			c_api.TF_AddInput(desc, matrix);
			c_api.TF_AddInput(desc, rhs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (adjoint.HasValue)
				c_api.TF_SetAttrBool (desc, "adjoint", Convert.ToByte(adjoint.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Solves one or more linear least-squares problems.
		/// </summary>
		/// <param name="matrix">
		///   Shape is <c>[..., M, N]</c>.
		/// </param>
		/// <param name="rhs">
		///   Shape is <c>[..., M, K]</c>.
		/// </param>
		/// <param name="l2_regularizer">
		///   Scalar tensor.
		///   
		///   @compatibility(numpy)
		///   Equivalent to np.linalg.lstsq
		///   @end_compatibility
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixSolveLs'.
		/// </param>
		/// <param name="fast">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Shape is <c>[..., N, K]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   <c>matrix</c> is a tensor of shape <c>[..., M, N]</c> whose inner-most 2 dimensions
		///   form real or complex matrices of size <c>[M, N]</c>. <c>Rhs</c> is a tensor of the same
		///   type as <c>matrix</c> and shape <c>[..., M, K]</c>.
		///   The output is a tensor shape <c>[..., N, K]</c> where each output matrix solves
		///   each of the equations
		///   <c>matrix[..., :, :]</c> * <c>output[..., :, :]</c> = <c>rhs[..., :, :]</c>
		///   in the least squares sense.
		///   
		///   We use the following notation for (complex) matrix and right-hand sides
		///   in the batch:
		///   
		///   <c>matrix</c>=\\(A \in \mathbb{C}^{m \times n}\\),
		///   <c>rhs</c>=\\(B  \in \mathbb{C}^{m \times k}\\),
		///   <c>output</c>=\\(X  \in \mathbb{C}^{n \times k}\\),
		///   <c>l2_regularizer</c>=\\(\lambda \in \mathbb{R}\\).
		///   
		///   If <c>fast</c> is <c>True</c>, then the solution is computed by solving the normal
		///   equations using Cholesky decomposition. Specifically, if \\(m \ge n\\) then
		///   \\(X = (A^H A + \lambda I)^{-1} A^H B\\), which solves the least-squares
		///   problem \\(X = \mathrm{argmin}_{Z \in \Re^{n \times k} } ||A Z - B||_F^2 + \lambda ||Z||_F^2\\).
		///   If \\(m \lt n\\) then <c>output</c> is computed as
		///   \\(X = A^H (A A^H + \lambda I)^{-1} B\\), which (for \\(\lambda = 0\\)) is the
		///   minimum-norm solution to the under-determined linear system, i.e.
		///   \\(X = \mathrm{argmin}_{Z \in \mathbb{C}^{n \times k} } ||Z||_F^2 \\),
		///   subject to \\(A Z = B\\). Notice that the fast path is only numerically stable
		///   when \\(A\\) is numerically full rank and has a condition number
		///   \\(\mathrm{cond}(A) \lt \frac{1}{\sqrt{\epsilon_{mach} } }\\) or \\(\lambda\\) is
		///   sufficiently large.
		///   
		///   If <c>fast</c> is <c>False</c> an algorithm based on the numerically robust complete
		///   orthogonal decomposition is used. This computes the minimum-norm
		///   least-squares solution, even when \\(A\\) is rank deficient. This path is
		///   typically 6-7 times slower than the fast path. If <c>fast</c> is <c>False</c> then
		///   <c>l2_regularizer</c> is ignored.
		/// </remarks>
		public TF_Output MatrixSolveLs (TF_Output matrix, TF_Output rhs, TF_Output l2_regularizer, bool? fast = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixSolveLs", MakeName ("MatrixSolveLs", operName));
			c_api.TF_AddInput(desc, matrix);
			c_api.TF_AddInput(desc, rhs);
			c_api.TF_AddInput(desc, l2_regularizer);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (fast.HasValue)
				c_api.TF_SetAttrBool (desc, "fast", Convert.ToByte(fast.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the matrix square root of one or more square matrices:
		/// </summary>
		/// <param name="input">
		///   Shape is <c>[..., M, M]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixSquareRoot'.
		/// </param>
		/// <returns>
		///   Shape is <c>[..., M, M]</c>.
		///   
		///   @compatibility(scipy)
		///   Equivalent to scipy.linalg.sqrtm
		///   @end_compatibility
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   matmul(sqrtm(A), sqrtm(A)) = A
		///   
		///   The input matrix should be invertible. If the input matrix is real, it should
		///   have no eigenvalues which are real and negative (pairs of complex conjugate
		///   eigenvalues are allowed).
		///   
		///   The matrix square root is computed by first reducing the matrix to
		///   quasi-triangular form with the real Schur decomposition. The square root
		///   of the quasi-triangular matrix is then computed directly. Details of
		///   the algorithm can be found in: Nicholas J. Higham, "Computing real
		///   square roots of a real matrix", Linear Algebra Appl., 1987.
		///   
		///   The input is a tensor of shape <c>[..., M, M]</c> whose inner-most 2 dimensions
		///   form square matrices. The output is a tensor of the same shape as the input
		///   containing the matrix square root for all input submatrices <c>[..., :, :]</c>.
		/// </remarks>
		public TF_Output MatrixSquareRoot (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixSquareRoot", MakeName ("MatrixSquareRoot", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Solves systems of linear equations with upper or lower triangular matrices by backsubstitution.
		/// </summary>
		/// <param name="matrix">
		///   Shape is <c>[..., M, M]</c>.
		/// </param>
		/// <param name="rhs">
		///   Shape is <c>[..., M, K]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixTriangularSolve'.
		/// </param>
		/// <param name="lower">
		///   Optional argument
		///   Boolean indicating whether the innermost matrices in <c>matrix</c> are
		///   lower or upper triangular.
		/// </param>
		/// <param name="adjoint">
		///   Optional argument
		///   Boolean indicating whether to solve with <c>matrix</c> or its (block-wise)
		///   adjoint.
		///   
		///   @compatibility(numpy)
		///   Equivalent to scipy.linalg.solve_triangular
		///   @end_compatibility
		/// </param>
		/// <returns>
		///   Shape is <c>[..., M, K]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   
		///   <c>matrix</c> is a tensor of shape <c>[..., M, M]</c> whose inner-most 2 dimensions form
		///   square matrices. If <c>lower</c> is <c>True</c> then the strictly upper triangular part
		///   of each inner-most matrix is assumed to be zero and not accessed.
		///   If <c>lower</c> is False then the strictly lower triangular part of each inner-most
		///   matrix is assumed to be zero and not accessed.
		///   <c>rhs</c> is a tensor of shape <c>[..., M, K]</c>.
		///   
		///   The output is a tensor of shape <c>[..., M, K]</c>. If <c>adjoint</c> is
		///   <c>True</c> then the innermost matrices in <c>output</c> satisfy matrix equations
		///   <c>matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]</c>.
		///   If <c>adjoint</c> is <c>False</c> then the strictly then the  innermost matrices in
		///   <c>output</c> satisfy matrix equations
		///   <c>adjoint(matrix[..., i, k]) * output[..., k, j] = rhs[..., i, j]</c>.
		///   
		///   Example:
		///    <code>
		///   
		///   a = tf.constant([[3,  0,  0,  0],
		///   [2,  1,  0,  0],
		///   [1,  0,  1,  0],
		///   [1,  1,  1,  1]], dtype=tf.float32)
		///   
		///   b = tf.constant([[4],
		///   [2],
		///   [4],
		///   [2]], dtype=tf.float32)
		///   
		///   x = tf.linalg.triangular_solve(a, b, lower=True)
		///   x
		///   # &amp;lt;tf.Tensor: id=257, shape=(4, 1), dtype=float32, numpy=
		///   # array([[ 1.3333334 ],
		///   #        [-0.66666675],
		///   #        [ 2.6666665 ],
		///   #        [-1.3333331 ]], dtype=float32)&amp;gt;
		///   
		///   # in python3 one can use <c>a@x</c>
		///   tf.matmul(a, x)
		///   # &amp;lt;tf.Tensor: id=263, shape=(4, 1), dtype=float32, numpy=
		///   # array([[4.       ],
		///   #        [2.       ],
		///   #        [4.       ],
		///   #        [1.9999999]], dtype=float32)&amp;gt;
		///    </code>
		/// </remarks>
		public TF_Output MatrixTriangularSolve (TF_Output matrix, TF_Output rhs, bool? lower = null, bool? adjoint = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MatrixTriangularSolve", MakeName ("MatrixTriangularSolve", operName));
			c_api.TF_AddInput(desc, matrix);
			c_api.TF_AddInput(desc, rhs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (lower.HasValue)
				c_api.TF_SetAttrBool (desc, "lower", Convert.ToByte(lower.Value));
			
			if (adjoint.HasValue)
				c_api.TF_SetAttrBool (desc, "adjoint", Convert.ToByte(adjoint.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the maximum of elements across dimensions of a tensor.
		/// </summary>
		/// <param name="input">
		///   The tensor to reduce.
		/// </param>
		/// <param name="reduction_indices">
		///   The dimensions to reduce. Must be in the range
		///   <c>[-rank(input), rank(input))</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Max'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		///   If true, retain reduced dimensions with length 1.
		/// </param>
		/// <returns>
		///   The reduced tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Reduces <c>input</c> along the dimensions given in <c>axis</c>. Unless
		///   <c>keep_dims</c> is true, the rank of the tensor is reduced by 1 for each entry in
		///   <c>axis</c>. If <c>keep_dims</c> is true, the reduced dimensions are
		///   retained with length 1.
		/// </remarks>
		public TF_Output Max (TF_Output input, TF_Output reduction_indices, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Max", MakeName ("Max", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, reduction_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns the max of x and y (i.e. x &amp;gt; y ? x : y) element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Maximum'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   *NOTE*: <c>Maximum</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output Maximum (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Maximum", MakeName ("Maximum", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Creates a dataset that overrides the maximum intra-op parallelism.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="max_intra_op_parallelism">
		///   Identifies the maximum intra-op parallelism to use.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxIntraOpParallelismDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxIntraOpParallelismDataset (TF_Output input_dataset, TF_Output max_intra_op_parallelism, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxIntraOpParallelismDataset", MakeName ("MaxIntraOpParallelismDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, max_intra_op_parallelism);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Performs max pooling on the input.
		/// </summary>
		/// <param name="input">
		///   4-D input to pool over.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPool'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   Specify the data format of the input and output data. With the
		///   default format "NHWC", the data is stored in the order of:
		///   [batch, in_height, in_width, in_channels].
		///   Alternatively, the format could be "NCHW", the data storage order of:
		///   [batch, in_channels, in_height, in_width].
		/// </param>
		/// <param name="ksize">
		///   The size of the window for each dimension of the input tensor.
		/// </param>
		/// <param name="strides">
		///   The stride of the sliding window for each dimension of the
		///   input tensor.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   The max pooled output tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPool (TF_Output input, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPool", MakeName ("MaxPool", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Performs 3D max pooling on the input.
		/// </summary>
		/// <param name="input">
		///   Shape <c>[batch, depth, rows, cols, channels]</c> tensor to pool over.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPool3D'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   The data format of the input and output data. With the
		///   default format "NDHWC", the data is stored in the order of:
		///   [batch, in_depth, in_height, in_width, in_channels].
		///   Alternatively, the format could be "NCDHW", the data storage order is:
		///   [batch, in_channels, in_depth, in_height, in_width].
		/// </param>
		/// <param name="ksize">
		///   1-D tensor of length 5. The size of the window for each dimension of
		///   the input tensor. Must have <c>ksize[0] = ksize[4] = 1</c>.
		/// </param>
		/// <param name="strides">
		///   1-D tensor of length 5. The stride of the sliding window for each
		///   dimension of <c>input</c>. Must have <c>strides[0] = strides[4] = 1</c>.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   The max pooled output tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPool3D (TF_Output input, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPool3D", MakeName ("MaxPool3D", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes gradients of max pooling function.
		/// </summary>
		/// <param name="orig_input">
		///   The original input tensor.
		/// </param>
		/// <param name="orig_output">
		///   The original output tensor.
		/// </param>
		/// <param name="grad">
		///   Output backprop of shape <c>[batch, depth, rows, cols, channels]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPool3DGrad'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   The data format of the input and output data. With the
		///   default format "NDHWC", the data is stored in the order of:
		///   [batch, in_depth, in_height, in_width, in_channels].
		///   Alternatively, the format could be "NCDHW", the data storage order is:
		///   [batch, in_channels, in_depth, in_height, in_width].
		/// </param>
		/// <param name="ksize">
		///   1-D tensor of length 5. The size of the window for each dimension of
		///   the input tensor. Must have <c>ksize[0] = ksize[4] = 1</c>.
		/// </param>
		/// <param name="strides">
		///   1-D tensor of length 5. The stride of the sliding window for each
		///   dimension of <c>input</c>. Must have <c>strides[0] = strides[4] = 1</c>.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPool3DGrad (TF_Output orig_input, TF_Output orig_output, TF_Output grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPool3DGrad", MakeName ("MaxPool3DGrad", operName));
			c_api.TF_AddInput(desc, orig_input);
			c_api.TF_AddInput(desc, orig_output);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes second-order gradients of the maxpooling function.
		/// </summary>
		/// <param name="orig_input">
		///   The original input tensor.
		/// </param>
		/// <param name="orig_output">
		///   The original output tensor.
		/// </param>
		/// <param name="grad">
		///   Output backprop of shape <c>[batch, depth, rows, cols, channels]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPool3DGradGrad'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   The data format of the input and output data. With the
		///   default format "NDHWC", the data is stored in the order of:
		///   [batch, in_depth, in_height, in_width, in_channels].
		///   Alternatively, the format could be "NCDHW", the data storage order is:
		///   [batch, in_channels, in_depth, in_height, in_width].
		/// </param>
		/// <param name="ksize">
		///   1-D tensor of length 5. The size of the window for each dimension of
		///   the input tensor. Must have <c>ksize[0] = ksize[4] = 1</c>.
		/// </param>
		/// <param name="strides">
		///   1-D tensor of length 5. The stride of the sliding window for each
		///   dimension of <c>input</c>. Must have <c>strides[0] = strides[4] = 1</c>.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   Gradients of gradients w.r.t. the input to <c>max_pool</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPool3DGradGrad (TF_Output orig_input, TF_Output orig_output, TF_Output grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPool3DGradGrad", MakeName ("MaxPool3DGradGrad", operName));
			c_api.TF_AddInput(desc, orig_input);
			c_api.TF_AddInput(desc, orig_output);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes gradients of the maxpooling function.
		/// </summary>
		/// <param name="orig_input">
		///   The original input tensor.
		/// </param>
		/// <param name="orig_output">
		///   The original output tensor.
		/// </param>
		/// <param name="grad">
		///   4-D.  Gradients w.r.t. the output of <c>max_pool</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGrad'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   Specify the data format of the input and output data. With the
		///   default format "NHWC", the data is stored in the order of:
		///   [batch, in_height, in_width, in_channels].
		///   Alternatively, the format could be "NCHW", the data storage order of:
		///   [batch, in_channels, in_height, in_width].
		/// </param>
		/// <param name="ksize">
		///   The size of the window for each dimension of the input tensor.
		/// </param>
		/// <param name="strides">
		///   The stride of the sliding window for each dimension of the
		///   input tensor.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   Gradients w.r.t. the input to <c>max_pool</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPoolGrad (TF_Output orig_input, TF_Output orig_output, TF_Output grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPoolGrad", MakeName ("MaxPoolGrad", operName));
			c_api.TF_AddInput(desc, orig_input);
			c_api.TF_AddInput(desc, orig_output);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes second-order gradients of the maxpooling function.
		/// </summary>
		/// <param name="orig_input">
		///   The original input tensor.
		/// </param>
		/// <param name="orig_output">
		///   The original output tensor.
		/// </param>
		/// <param name="grad">
		///   4-D.  Gradients of gradients w.r.t. the input of <c>max_pool</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGradGrad'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   Specify the data format of the input and output data. With the
		///   default format "NHWC", the data is stored in the order of:
		///   [batch, in_height, in_width, in_channels].
		///   Alternatively, the format could be "NCHW", the data storage order of:
		///   [batch, in_channels, in_height, in_width].
		/// </param>
		/// <param name="ksize">
		///   The size of the window for each dimension of the input tensor.
		/// </param>
		/// <param name="strides">
		///   The stride of the sliding window for each dimension of the
		///   input tensor.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   Gradients of gradients w.r.t. the input to <c>max_pool</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPoolGradGrad (TF_Output orig_input, TF_Output orig_output, TF_Output grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPoolGradGrad", MakeName ("MaxPoolGradGrad", operName));
			c_api.TF_AddInput(desc, orig_input);
			c_api.TF_AddInput(desc, orig_output);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes second-order gradients of the maxpooling function.
		/// </summary>
		/// <param name="orig_input">
		///   The original input tensor.
		/// </param>
		/// <param name="orig_output">
		///   The original output tensor.
		/// </param>
		/// <param name="grad">
		///   4-D.  Gradients of gradients w.r.t. the input of <c>max_pool</c>.
		/// </param>
		/// <param name="ksize">
		///   The size of the window for each dimension of the input tensor.
		/// </param>
		/// <param name="strides">
		///   The stride of the sliding window for each dimension of the
		///   input tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGradGradV2'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   Specify the data format of the input and output data. With the
		///   default format "NHWC", the data is stored in the order of:
		///   [batch, in_height, in_width, in_channels].
		///   Alternatively, the format could be "NCHW", the data storage order of:
		///   [batch, in_channels, in_height, in_width].
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   Gradients of gradients w.r.t. the input to <c>max_pool</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPoolGradGradV2 (TF_Output orig_input, TF_Output orig_output, TF_Output grad, TF_Output ksize, TF_Output strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPoolGradGradV2", MakeName ("MaxPoolGradGradV2", operName));
			c_api.TF_AddInput(desc, orig_input);
			c_api.TF_AddInput(desc, orig_output);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, ksize);
			c_api.TF_AddInput(desc, strides);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes second-order gradients of the maxpooling function.
		/// </summary>
		/// <param name="input">
		///   The original input.
		/// </param>
		/// <param name="grad">
		///   4-D with shape <c>[batch, height, width, channels]</c>.  Gradients w.r.t. the
		///   input of <c>max_pool</c>.
		/// </param>
		/// <param name="argmax">
		///   The indices of the maximum values chosen for each output of <c>max_pool</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGradGradWithArgmax'.
		/// </param>
		/// <param name="include_batch_in_index">
		///   Optional argument
		///   Whether to include batch dimension in flattened index of <c>argmax</c>.
		/// </param>
		/// <param name="ksize">
		///   The size of the window for each dimension of the input tensor.
		/// </param>
		/// <param name="strides">
		///   The stride of the sliding window for each dimension of the
		///   input tensor.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   Gradients of gradients w.r.t. the input of <c>max_pool</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPoolGradGradWithArgmax (TF_Output input, TF_Output grad, TF_Output argmax, long[] ksize, long[] strides, string padding, bool? include_batch_in_index = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPoolGradGradWithArgmax", MakeName ("MaxPoolGradGradWithArgmax", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, argmax);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (include_batch_in_index.HasValue)
				c_api.TF_SetAttrBool (desc, "include_batch_in_index", Convert.ToByte(include_batch_in_index.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes gradients of the maxpooling function.
		/// </summary>
		/// <param name="orig_input">
		///   The original input tensor.
		/// </param>
		/// <param name="orig_output">
		///   The original output tensor.
		/// </param>
		/// <param name="grad">
		///   4-D.  Gradients w.r.t. the output of <c>max_pool</c>.
		/// </param>
		/// <param name="ksize">
		///   The size of the window for each dimension of the input tensor.
		/// </param>
		/// <param name="strides">
		///   The stride of the sliding window for each dimension of the
		///   input tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGradV2'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   Specify the data format of the input and output data. With the
		///   default format "NHWC", the data is stored in the order of:
		///   [batch, in_height, in_width, in_channels].
		///   Alternatively, the format could be "NCHW", the data storage order of:
		///   [batch, in_channels, in_height, in_width].
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   Gradients w.r.t. the input to <c>max_pool</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPoolGradV2 (TF_Output orig_input, TF_Output orig_output, TF_Output grad, TF_Output ksize, TF_Output strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPoolGradV2", MakeName ("MaxPoolGradV2", operName));
			c_api.TF_AddInput(desc, orig_input);
			c_api.TF_AddInput(desc, orig_output);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, ksize);
			c_api.TF_AddInput(desc, strides);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes gradients of the maxpooling function.
		/// </summary>
		/// <param name="input">
		///   The original input.
		/// </param>
		/// <param name="grad">
		///   4-D with shape <c>[batch, height, width, channels]</c>.  Gradients w.r.t. the
		///   output of <c>max_pool</c>.
		/// </param>
		/// <param name="argmax">
		///   The indices of the maximum values chosen for each output of <c>max_pool</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGradWithArgmax'.
		/// </param>
		/// <param name="include_batch_in_index">
		///   Optional argument
		///   Whether to include batch dimension in flattened index of <c>argmax</c>.
		/// </param>
		/// <param name="ksize">
		///   The size of the window for each dimension of the input tensor.
		/// </param>
		/// <param name="strides">
		///   The stride of the sliding window for each dimension of the
		///   input tensor.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   Gradients w.r.t. the input of <c>max_pool</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPoolGradWithArgmax (TF_Output input, TF_Output grad, TF_Output argmax, long[] ksize, long[] strides, string padding, bool? include_batch_in_index = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPoolGradWithArgmax", MakeName ("MaxPoolGradWithArgmax", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, argmax);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (include_batch_in_index.HasValue)
				c_api.TF_SetAttrBool (desc, "include_batch_in_index", Convert.ToByte(include_batch_in_index.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Performs max pooling on the input.
		/// </summary>
		/// <param name="input">
		///   4-D input to pool over.
		/// </param>
		/// <param name="ksize">
		///   The size of the window for each dimension of the input tensor.
		/// </param>
		/// <param name="strides">
		///   The stride of the sliding window for each dimension of the
		///   input tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolV2'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		///   Specify the data format of the input and output data. With the
		///   default format "NHWC", the data is stored in the order of:
		///   [batch, in_height, in_width, in_channels].
		///   Alternatively, the format could be "NCHW", the data storage order of:
		///   [batch, in_channels, in_height, in_width].
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   The max pooled output tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MaxPoolV2 (TF_Output input, TF_Output ksize, TF_Output strides, string padding, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPoolV2", MakeName ("MaxPoolV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, ksize);
			c_api.TF_AddInput(desc, strides);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Performs max pooling on the input and outputs both max values and indices.
		/// </summary>
		/// <param name="input">
		///   4-D with shape <c>[batch, height, width, channels]</c>.  Input to pool over.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolWithArgmax'.
		/// </param>
		/// <param name="Targmax">
		///   Optional argument
		/// </param>
		/// <param name="include_batch_in_index">
		///   Optional argument
		///   Whether to include batch dimension in flattened index of <c>argmax</c>.
		/// </param>
		/// <param name="ksize">
		///   The size of the window for each dimension of the input tensor.
		/// </param>
		/// <param name="strides">
		///   The stride of the sliding window for each dimension of the
		///   input tensor.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output: The max pooled output tensor.
		///   argmax: 4-D.  The flattened indices of the max values chosen for each output.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The indices in <c>argmax</c> are flattened, so that a maximum value at position
		///   <c>[b, y, x, c]</c> becomes flattened index:
		///   <c>(y * width + x) * channels + c</c> if <c>include_batch_in_index</c> is False;
		///   <c>((b * height + y) * width + x) * channels + c</c> if <c>include_batch_in_index</c> is True.
		///   
		///   The indices returned are always in <c>[0, height) x [0, width)</c> before flattening,
		///   even if padding is involved and the mathematically correct answer is outside
		///   (either negative or too large).  This is a bug, but fixing it is difficult to do
		///   in a safe backwards compatible way, especially due to flattening.
		/// </remarks>
		public (TF_Output output, TF_Output argmax) MaxPoolWithArgmax (TF_Output input, long[] ksize, long[] strides, string padding, TF_DataType? Targmax = null, bool? include_batch_in_index = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MaxPoolWithArgmax", MakeName ("MaxPoolWithArgmax", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (Targmax.HasValue)
				c_api.TF_SetAttrType (desc, "Targmax", Targmax.Value);
			
			if (include_batch_in_index.HasValue)
				c_api.TF_SetAttrBool (desc, "include_batch_in_index", Convert.ToByte(include_batch_in_index.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var argmax = new TF_Output (op, _idx++);
			return (output, argmax);
		}

		/// <summary>
		///   Computes the mean of elements across dimensions of a tensor.
		/// </summary>
		/// <param name="input">
		///   The tensor to reduce.
		/// </param>
		/// <param name="reduction_indices">
		///   The dimensions to reduce. Must be in the range
		///   <c>[-rank(input), rank(input))</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Mean'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		///   If true, retain reduced dimensions with length 1.
		/// </param>
		/// <returns>
		///   The reduced tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Reduces <c>input</c> along the dimensions given in <c>axis</c>. Unless
		///   <c>keep_dims</c> is true, the rank of the tensor is reduced by 1 for each entry in
		///   <c>axis</c>. If <c>keep_dims</c> is true, the reduced dimensions are
		///   retained with length 1.
		/// </remarks>
		public TF_Output Mean (TF_Output input, TF_Output reduction_indices, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Mean", MakeName ("Mean", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, reduction_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Forwards the value of an available tensor from <c>inputs</c> to <c>output</c>.
		/// </summary>
		/// <param name="inputs">
		///   The input tensors, exactly one of which will become available.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Merge'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output: Will be set to the available input tensor.
		///   value_index: The index of the chosen input tensor in <c>inputs</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   <c>Merge</c> waits for at least one of the tensors in <c>inputs</c> to become available.
		///   It is usually combined with <c>Switch</c> to implement branching.
		///   
		///   <c>Merge</c> forwards the first tensor to become available to <c>output</c>, and sets
		///   <c>value_index</c> to its index in <c>inputs</c>.
		/// </remarks>
		public (TF_Output output, TF_Output value_index) Merge (TF_Output[] inputs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Merge", MakeName ("Merge", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var value_index = new TF_Output (op, _idx++);
			return (output, value_index);
		}

		/// <summary>
		///   Merges summaries.
		/// </summary>
		/// <param name="inputs">
		///   Can be of any shape.  Each must contain serialized <c>Summary</c> protocol
		///   buffers.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MergeSummary'.
		/// </param>
		/// <returns>
		///   Scalar. Serialized <c>Summary</c> protocol buffer.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op creates a
		///   [<c>Summary</c>](https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto)
		///   protocol buffer that contains the union of all the values in the input
		///   summaries.
		///   
		///   When the Op is run, it reports an <c>InvalidArgument</c> error if multiple values
		///   in the summaries to merge use the same tag.
		/// </remarks>
		public TF_Output MergeSummary (TF_Output[] inputs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MergeSummary", MakeName ("MergeSummary", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var summary = new TF_Output (op, _idx++);
			return summary;
		}

		/// <summary>
		///   V2 format specific: merges the metadata files of sharded checkpoints.  The
		/// </summary>
		/// <param name="checkpoint_prefixes">
		///   prefixes of V2 checkpoints to merge.
		/// </param>
		/// <param name="destination_prefix">
		///   scalar.  The desired final prefix.  Allowed to be the same
		///   as one of the checkpoint_prefixes.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MergeV2Checkpoints'.
		/// </param>
		/// <param name="delete_old_dirs">
		///   Optional argument
		///   see above.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   result is one logical checkpoint, with one physical metadata file and renamed
		///   data files.
		///   
		///   Intended for "grouping" multiple checkpoints in a sharded checkpoint setup.
		///   
		///   If delete_old_dirs is true, attempts to delete recursively the dirname of each
		///   path in the input checkpoint_prefixes.  This is useful when those paths are non
		///   user-facing temporary locations.
		/// </remarks>
		public TF_Operation MergeV2Checkpoints (TF_Output checkpoint_prefixes, TF_Output destination_prefix, bool? delete_old_dirs = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MergeV2Checkpoints", MakeName ("MergeV2Checkpoints", operName));
			c_api.TF_AddInput(desc, checkpoint_prefixes);
			c_api.TF_AddInput(desc, destination_prefix);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (delete_old_dirs.HasValue)
				c_api.TF_SetAttrBool (desc, "delete_old_dirs", Convert.ToByte(delete_old_dirs.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Transforms a spectrogram into a form that's useful for speech recognition.
		/// </summary>
		/// <param name="spectrogram">
		///   Typically produced by the Spectrogram op, with magnitude_squared
		///   set to true.
		/// </param>
		/// <param name="sample_rate">
		///   How many samples per second the source audio used.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Mfcc'.
		/// </param>
		/// <param name="upper_frequency_limit">
		///   Optional argument
		///   The highest frequency to use when calculating the
		///   ceptstrum.
		/// </param>
		/// <param name="lower_frequency_limit">
		///   Optional argument
		///   The lowest frequency to use when calculating the
		///   ceptstrum.
		/// </param>
		/// <param name="filterbank_channel_count">
		///   Optional argument
		///   Resolution of the Mel bank used internally.
		/// </param>
		/// <param name="dct_coefficient_count">
		///   Optional argument
		///   How many output channels to produce per time slice.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Mel Frequency Cepstral Coefficients are a way of representing audio data that's
		///   been effective as an input feature for machine learning. They are created by
		///   taking the spectrum of a spectrogram (a 'cepstrum'), and discarding some of the
		///   higher frequencies that are less significant to the human ear. They have a long
		///   history in the speech recognition world, and https://en.wikipedia.org/wiki/Mel-frequency_cepstrum
		///   is a good resource to learn more.
		/// </remarks>
		public TF_Output Mfcc (TF_Output spectrogram, TF_Output sample_rate, float? upper_frequency_limit = null, float? lower_frequency_limit = null, long? filterbank_channel_count = null, long? dct_coefficient_count = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Mfcc", MakeName ("Mfcc", operName));
			c_api.TF_AddInput(desc, spectrogram);
			c_api.TF_AddInput(desc, sample_rate);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (upper_frequency_limit.HasValue)
				c_api.TF_SetAttrFloat (desc, "upper_frequency_limit", upper_frequency_limit.Value);
			
			if (lower_frequency_limit.HasValue)
				c_api.TF_SetAttrFloat (desc, "lower_frequency_limit", lower_frequency_limit.Value);
			
			if (filterbank_channel_count.HasValue)
				c_api.TF_SetAttrInt (desc, "filterbank_channel_count", filterbank_channel_count.Value);
			
			if (dct_coefficient_count.HasValue)
				c_api.TF_SetAttrInt (desc, "dct_coefficient_count", dct_coefficient_count.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the minimum of elements across dimensions of a tensor.
		/// </summary>
		/// <param name="input">
		///   The tensor to reduce.
		/// </param>
		/// <param name="reduction_indices">
		///   The dimensions to reduce. Must be in the range
		///   <c>[-rank(input), rank(input))</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Min'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		///   If true, retain reduced dimensions with length 1.
		/// </param>
		/// <returns>
		///   The reduced tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Reduces <c>input</c> along the dimensions given in <c>axis</c>. Unless
		///   <c>keep_dims</c> is true, the rank of the tensor is reduced by 1 for each entry in
		///   <c>axis</c>. If <c>keep_dims</c> is true, the reduced dimensions are
		///   retained with length 1.
		/// </remarks>
		public TF_Output Min (TF_Output input, TF_Output reduction_indices, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Min", MakeName ("Min", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, reduction_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns the min of x and y (i.e. x &amp;lt; y ? x : y) element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Minimum'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   *NOTE*: <c>Minimum</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output Minimum (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Minimum", MakeName ("Minimum", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Pads a tensor with mirrored values.
		/// </summary>
		/// <param name="input">
		///   The input tensor to be padded.
		/// </param>
		/// <param name="paddings">
		///   A two-column matrix specifying the padding sizes. The number of
		///   rows must be the same as the rank of <c>input</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MirrorPad'.
		/// </param>
		/// <param name="mode">
		///   Either <c>REFLECT</c> or <c>SYMMETRIC</c>. In reflect mode the padded regions
		///   do not include the borders, while in symmetric mode the padded regions
		///   do include the borders. For example, if <c>input</c> is <c>[1, 2, 3]</c> and <c>paddings</c>
		///   is <c>[0, 2]</c>, then the output is <c>[1, 2, 3, 2, 1]</c> in reflect mode, and
		///   it is <c>[1, 2, 3, 3, 2]</c> in symmetric mode.
		/// </param>
		/// <returns>
		///   The padded tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation pads a <c>input</c> with mirrored values according to the <c>paddings</c>
		///   you specify. <c>paddings</c> is an integer tensor with shape <c>[n, 2]</c>, where n is
		///   the rank of <c>input</c>. For each dimension D of <c>input</c>, <c>paddings[D, 0]</c> indicates
		///   how many values to add before the contents of <c>input</c> in that dimension, and
		///   <c>paddings[D, 1]</c> indicates how many values to add after the contents of <c>input</c>
		///   in that dimension. Both <c>paddings[D, 0]</c> and <c>paddings[D, 1]</c> must be no greater
		///   than <c>input.dim_size(D)</c> (or <c>input.dim_size(D) - 1</c>) if <c>copy_border</c> is true
		///   (if false, respectively).
		///   
		///   The padded size of each dimension D of the output is:
		///   
		///   <c>paddings(D, 0) + input.dim_size(D) + paddings(D, 1)</c>
		///   
		///   For example:
		///   
		///    <code>
		///   # 't' is [[1, 2, 3], [4, 5, 6]].
		///   # 'paddings' is [[1, 1]], [2, 2]].
		///   # 'mode' is SYMMETRIC.
		///   # rank of 't' is 2.
		///   pad(t, paddings) ==&amp;gt; [[2, 1, 1, 2, 3, 3, 2]
		///   [2, 1, 1, 2, 3, 3, 2]
		///   [5, 4, 4, 5, 6, 6, 5]
		///   [5, 4, 4, 5, 6, 6, 5]]
		///    </code>
		/// </remarks>
		public TF_Output MirrorPad (TF_Output input, TF_Output paddings, string mode, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MirrorPad", MakeName ("MirrorPad", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, paddings);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "mode", mode);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Gradient op for <c>MirrorPad</c> op. This op folds a mirror-padded tensor.
		/// </summary>
		/// <param name="input">
		///   The input tensor to be folded.
		/// </param>
		/// <param name="paddings">
		///   A two-column matrix specifying the padding sizes. The number of
		///   rows must be the same as the rank of <c>input</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MirrorPadGrad'.
		/// </param>
		/// <param name="mode">
		///   The mode used in the <c>MirrorPad</c> op.
		/// </param>
		/// <returns>
		///   The folded tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation folds the padded areas of <c>input</c> by <c>MirrorPad</c> according to the
		///   <c>paddings</c> you specify. <c>paddings</c> must be the same as <c>paddings</c> argument
		///   given to the corresponding <c>MirrorPad</c> op.
		///   
		///   The folded size of each dimension D of the output is:
		///   
		///   <c>input.dim_size(D) - paddings(D, 0) - paddings(D, 1)</c>
		///   
		///   For example:
		///   
		///    <code>
		///   # 't' is [[1, 2, 3], [4, 5, 6], [7, 8, 9]].
		///   # 'paddings' is [[0, 1]], [0, 1]].
		///   # 'mode' is SYMMETRIC.
		///   # rank of 't' is 2.
		///   pad(t, paddings) ==&amp;gt; [[ 1,  5]
		///   [11, 28]]
		///    </code>
		/// </remarks>
		public TF_Output MirrorPadGrad (TF_Output input, TF_Output paddings, string mode, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MirrorPadGrad", MakeName ("MirrorPadGrad", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, paddings);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "mode", mode);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns element-wise remainder of division. This emulates C semantics in that
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Mod'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   the result here is consistent with a truncating divide. E.g.
		///   <c>tf.truncatediv(x, y) * y + truncate_mod(x, y) = x</c>.
		///   
		///   *NOTE*: <c>Mod</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output Mod (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Mod", MakeName ("Mod", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Identity transformation that models performance.
		/// </summary>
		/// <param name="input_dataset">
		///   A variant tensor representing the input dataset.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ModelDataset'.
		/// </param>
		/// <param name="algorithm">
		///   Optional argument
		/// </param>
		/// <param name="cpu_budget">
		///   Optional argument
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Identity transformation that models performance.
		/// </remarks>
		public TF_Output ModelDataset (TF_Output input_dataset, TF_DataType[] output_types, long[][] output_shapes, long? algorithm = null, long? cpu_budget = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ModelDataset", MakeName ("ModelDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (algorithm.HasValue)
				c_api.TF_SetAttrInt (desc, "algorithm", algorithm.Value);
			
			if (cpu_budget.HasValue)
				c_api.TF_SetAttrInt (desc, "cpu_budget", cpu_budget.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Returns x * y element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Mul'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   *NOTE*: <c>Multiply</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output Mul (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Mul", MakeName ("Mul", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Returns x * y element-wise. Returns zero if y is zero, even if x if infinite or NaN.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MulNoNan'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   *NOTE*: <c>MulNoNan</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output MulNoNan (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MulNoNan", MakeName ("MulNoNan", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Creates a MultiDeviceIterator resource.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MultiDeviceIterator'.
		/// </param>
		/// <param name="devices">
		///   A list of devices the iterator works across.
		/// </param>
		/// <param name="shared_name">
		///   If non-empty, this resource will be shared under the given name
		///   across multiple sessions.
		/// </param>
		/// <param name="container">
		///   If non-empty, this resource is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="output_types">
		///   The type list for the return values.
		/// </param>
		/// <param name="output_shapes">
		///   The list of shapes being produced.
		/// </param>
		/// <returns>
		///   Handle to the resource created.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MultiDeviceIterator (string[] devices, string shared_name, string container, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MultiDeviceIterator", MakeName ("MultiDeviceIterator", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrStringList (desc, "devices", devices);
			c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			c_api.TF_SetAttrString (desc, "container", container);
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Generates a MultiDeviceIterator resource from its provided string handle.
		/// </summary>
		/// <param name="string_handle">
		///   String representing the resource.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MultiDeviceIteratorFromStringHandle'.
		/// </param>
		/// <param name="output_types">
		///   Optional argument
		///   The type list for the return values.
		/// </param>
		/// <param name="output_shapes">
		///   Optional argument
		///   The list of shapes being produced.
		/// </param>
		/// <returns>
		///   A MultiDeviceIterator resource.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MultiDeviceIteratorFromStringHandle (TF_Output string_handle, TF_DataType[] output_types = null, long[][] output_shapes = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MultiDeviceIteratorFromStringHandle", MakeName ("MultiDeviceIteratorFromStringHandle", operName));
			c_api.TF_AddInput(desc, string_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (output_types != null)
				c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			
			if (output_shapes != null)
				c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var multi_device_iterator = new TF_Output (op, _idx++);
			return multi_device_iterator;
		}

		/// <summary>
		///   Gets next element for the provided shard number.
		/// </summary>
		/// <param name="multi_device_iterator">
		///   A MultiDeviceIterator resource.
		/// </param>
		/// <param name="shard_num">
		///   Integer representing which shard to fetch data for.
		/// </param>
		/// <param name="incarnation_id">
		///   Which incarnation of the MultiDeviceIterator is running.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MultiDeviceIteratorGetNextFromShard'.
		/// </param>
		/// <param name="output_types">
		///   The type list for the return values.
		/// </param>
		/// <param name="output_shapes">
		///   The list of shapes being produced.
		/// </param>
		/// <returns>
		///   Result of the get_next on the dataset.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] MultiDeviceIteratorGetNextFromShard (TF_Output multi_device_iterator, TF_Output shard_num, TF_Output incarnation_id, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MultiDeviceIteratorGetNextFromShard", MakeName ("MultiDeviceIteratorGetNextFromShard", operName));
			c_api.TF_AddInput(desc, multi_device_iterator);
			c_api.TF_AddInput(desc, shard_num);
			c_api.TF_AddInput(desc, incarnation_id);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "components", status);
			var components = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				components [i] = new TF_Output (op, _idx++);
			
			return components;
		}

		/// <summary>
		///   Initializes the multi device iterator with the given dataset.
		/// </summary>
		/// <param name="dataset">
		///   Dataset to be iterated upon.
		/// </param>
		/// <param name="multi_device_iterator">
		///   A MultiDeviceIteratorResource.
		/// </param>
		/// <param name="max_buffer_size">
		///   The maximum size of the host side per device buffer to keep.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MultiDeviceIteratorInit'.
		/// </param>
		/// <returns>
		///   An int64 indicating which incarnation of the MultiDeviceIterator
		///   is running.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MultiDeviceIteratorInit (TF_Output dataset, TF_Output multi_device_iterator, TF_Output max_buffer_size, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MultiDeviceIteratorInit", MakeName ("MultiDeviceIteratorInit", operName));
			c_api.TF_AddInput(desc, dataset);
			c_api.TF_AddInput(desc, multi_device_iterator);
			c_api.TF_AddInput(desc, max_buffer_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var incarnation_id = new TF_Output (op, _idx++);
			return incarnation_id;
		}

		/// <summary>
		///   Produces a string handle for the given MultiDeviceIterator.
		/// </summary>
		/// <param name="multi_device_iterator">
		///   A MultiDeviceIterator resource.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MultiDeviceIteratorToStringHandle'.
		/// </param>
		/// <returns>
		///   A string representing the resource.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MultiDeviceIteratorToStringHandle (TF_Output multi_device_iterator, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MultiDeviceIteratorToStringHandle", MakeName ("MultiDeviceIteratorToStringHandle", operName));
			c_api.TF_AddInput(desc, multi_device_iterator);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var string_handle = new TF_Output (op, _idx++);
			return string_handle;
		}

		/// <summary>
		///   Draws samples from a multinomial distribution.
		/// </summary>
		/// <param name="logits">
		///   2-D Tensor with shape <c>[batch_size, num_classes]</c>.  Each slice <c>[i, :]</c>
		///   represents the unnormalized log probabilities for all classes.
		/// </param>
		/// <param name="num_samples">
		///   0-D.  Number of independent samples to draw for each row slice.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Multinomial'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either seed or seed2 is set to be non-zero, the internal random number
		///   generator is seeded by the given seed.  Otherwise, a random seed is used.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   A second seed to avoid seed collision.
		/// </param>
		/// <param name="output_dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   2-D Tensor with shape <c>[batch_size, num_samples]</c>.  Each slice <c>[i, :]</c>
		///   contains the drawn class labels with range <c>[0, num_classes)</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Multinomial (TF_Output logits, TF_Output num_samples, long? seed = null, long? seed2 = null, TF_DataType? output_dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Multinomial", MakeName ("Multinomial", operName));
			c_api.TF_AddInput(desc, logits);
			c_api.TF_AddInput(desc, num_samples);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (output_dtype.HasValue)
				c_api.TF_SetAttrType (desc, "output_dtype", output_dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates an empty hash table that uses tensors as the backing store.
		/// </summary>
		/// <param name="empty_key">
		///   The key used to represent empty key buckets internally. Must not
		///   be used in insert or lookup operations.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableDenseHashTable'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this table is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this table is shared under the given name across
		///   multiple sessions.
		/// </param>
		/// <param name="use_node_name_sharing">
		///   Optional argument
		/// </param>
		/// <param name="value_shape">
		///   Optional argument
		///   The shape of each value.
		/// </param>
		/// <param name="initial_num_buckets">
		///   Optional argument
		///   The initial number of hash table buckets. Must be a power
		///   to 2.
		/// </param>
		/// <param name="max_load_factor">
		///   Optional argument
		///   The maximum ratio between number of entries and number of
		///   buckets before growing the table. Must be between 0 and 1.
		/// </param>
		/// <param name="value_dtype">
		///   Type of the table values.
		/// </param>
		/// <returns>
		///   Handle to a table.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   It uses "open addressing" with quadratic reprobing to resolve
		///   collisions.
		///   
		///   This op creates a mutable hash table, specifying the type of its keys and
		///   values. Each value must be a scalar. Data can be inserted into the table using
		///   the insert operations. It does not support the initialization operation.
		/// </remarks>
		public TF_Output MutableDenseHashTable (TF_Output empty_key, TF_DataType value_dtype, string container = null, string shared_name = null, bool? use_node_name_sharing = null, long[] value_shape = null, long? initial_num_buckets = null, float? max_load_factor = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MutableDenseHashTable", MakeName ("MutableDenseHashTable", operName));
			c_api.TF_AddInput(desc, empty_key);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "value_dtype", value_dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (use_node_name_sharing.HasValue)
				c_api.TF_SetAttrBool (desc, "use_node_name_sharing", Convert.ToByte(use_node_name_sharing.Value));
			
			if (value_shape != null)
				c_api.TF_SetAttrShape (desc, "value_shape", ref value_shape[0], value_shape.Length);
			
			if (initial_num_buckets.HasValue)
				c_api.TF_SetAttrInt (desc, "initial_num_buckets", initial_num_buckets.Value);
			
			if (max_load_factor.HasValue)
				c_api.TF_SetAttrFloat (desc, "max_load_factor", max_load_factor.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var table_handle = new TF_Output (op, _idx++);
			return table_handle;
		}

		/// <summary>
		///   Creates an empty hash table that uses tensors as the backing store.
		/// </summary>
		/// <param name="empty_key">
		///   The key used to represent empty key buckets internally. Must not
		///   be used in insert or lookup operations.
		/// </param>
		/// <param name="deleted_key">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableDenseHashTableV2'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this table is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this table is shared under the given name across
		///   multiple sessions.
		/// </param>
		/// <param name="use_node_name_sharing">
		///   Optional argument
		/// </param>
		/// <param name="value_shape">
		///   Optional argument
		///   The shape of each value.
		/// </param>
		/// <param name="initial_num_buckets">
		///   Optional argument
		///   The initial number of hash table buckets. Must be a power
		///   to 2.
		/// </param>
		/// <param name="max_load_factor">
		///   Optional argument
		///   The maximum ratio between number of entries and number of
		///   buckets before growing the table. Must be between 0 and 1.
		/// </param>
		/// <param name="value_dtype">
		///   Type of the table values.
		/// </param>
		/// <returns>
		///   Handle to a table.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   It uses "open addressing" with quadratic reprobing to resolve
		///   collisions.
		///   
		///   This op creates a mutable hash table, specifying the type of its keys and
		///   values. Each value must be a scalar. Data can be inserted into the table using
		///   the insert operations. It does not support the initialization operation.
		/// </remarks>
		public TF_Output MutableDenseHashTableV2 (TF_Output empty_key, TF_Output deleted_key, TF_DataType value_dtype, string container = null, string shared_name = null, bool? use_node_name_sharing = null, long[] value_shape = null, long? initial_num_buckets = null, float? max_load_factor = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MutableDenseHashTableV2", MakeName ("MutableDenseHashTableV2", operName));
			c_api.TF_AddInput(desc, empty_key);
			c_api.TF_AddInput(desc, deleted_key);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "value_dtype", value_dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (use_node_name_sharing.HasValue)
				c_api.TF_SetAttrBool (desc, "use_node_name_sharing", Convert.ToByte(use_node_name_sharing.Value));
			
			if (value_shape != null)
				c_api.TF_SetAttrShape (desc, "value_shape", ref value_shape[0], value_shape.Length);
			
			if (initial_num_buckets.HasValue)
				c_api.TF_SetAttrInt (desc, "initial_num_buckets", initial_num_buckets.Value);
			
			if (max_load_factor.HasValue)
				c_api.TF_SetAttrFloat (desc, "max_load_factor", max_load_factor.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var table_handle = new TF_Output (op, _idx++);
			return table_handle;
		}

		/// <summary>
		///   Creates an empty hash table.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableHashTable'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this table is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this table is shared under the given name across
		///   multiple sessions.
		/// </param>
		/// <param name="use_node_name_sharing">
		///   Optional argument
		///   If true and shared_name is empty, the table is shared
		///   using the node name.
		/// </param>
		/// <param name="key_dtype">
		///   Type of the table keys.
		/// </param>
		/// <param name="value_dtype">
		///   Type of the table values.
		/// </param>
		/// <returns>
		///   Handle to a table.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op creates a mutable hash table, specifying the type of its keys and
		///   values. Each value must be a scalar. Data can be inserted into the table using
		///   the insert operations. It does not support the initialization operation.
		/// </remarks>
		public TF_Output MutableHashTable (TF_DataType key_dtype, TF_DataType value_dtype, string container = null, string shared_name = null, bool? use_node_name_sharing = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MutableHashTable", MakeName ("MutableHashTable", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "key_dtype", key_dtype);
			c_api.TF_SetAttrType (desc, "value_dtype", value_dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (use_node_name_sharing.HasValue)
				c_api.TF_SetAttrBool (desc, "use_node_name_sharing", Convert.ToByte(use_node_name_sharing.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var table_handle = new TF_Output (op, _idx++);
			return table_handle;
		}

		/// <summary>
		///   Creates an empty hash table.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableHashTableOfTensors'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this table is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this table is shared under the given name across
		///   multiple sessions.
		/// </param>
		/// <param name="use_node_name_sharing">
		///   Optional argument
		/// </param>
		/// <param name="value_shape">
		///   Optional argument
		/// </param>
		/// <param name="key_dtype">
		///   Type of the table keys.
		/// </param>
		/// <param name="value_dtype">
		///   Type of the table values.
		/// </param>
		/// <returns>
		///   Handle to a table.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op creates a mutable hash table, specifying the type of its keys and
		///   values. Each value must be a vector. Data can be inserted into the table using
		///   the insert operations. It does not support the initialization operation.
		/// </remarks>
		public TF_Output MutableHashTableOfTensors (TF_DataType key_dtype, TF_DataType value_dtype, string container = null, string shared_name = null, bool? use_node_name_sharing = null, long[] value_shape = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MutableHashTableOfTensors", MakeName ("MutableHashTableOfTensors", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "key_dtype", key_dtype);
			c_api.TF_SetAttrType (desc, "value_dtype", value_dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (use_node_name_sharing.HasValue)
				c_api.TF_SetAttrBool (desc, "use_node_name_sharing", Convert.ToByte(use_node_name_sharing.Value));
			
			if (value_shape != null)
				c_api.TF_SetAttrShape (desc, "value_shape", ref value_shape[0], value_shape.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var table_handle = new TF_Output (op, _idx++);
			return table_handle;
		}

		/// <summary>
		///   Creates an empty hash table.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableHashTableOfTensorsV2'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this table is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this table is shared under the given name across
		///   multiple sessions.
		/// </param>
		/// <param name="use_node_name_sharing">
		///   Optional argument
		/// </param>
		/// <param name="value_shape">
		///   Optional argument
		/// </param>
		/// <param name="key_dtype">
		///   Type of the table keys.
		/// </param>
		/// <param name="value_dtype">
		///   Type of the table values.
		/// </param>
		/// <returns>
		///   Handle to a table.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op creates a mutable hash table, specifying the type of its keys and
		///   values. Each value must be a vector. Data can be inserted into the table using
		///   the insert operations. It does not support the initialization operation.
		/// </remarks>
		public TF_Output MutableHashTableOfTensorsV2 (TF_DataType key_dtype, TF_DataType value_dtype, string container = null, string shared_name = null, bool? use_node_name_sharing = null, long[] value_shape = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MutableHashTableOfTensorsV2", MakeName ("MutableHashTableOfTensorsV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "key_dtype", key_dtype);
			c_api.TF_SetAttrType (desc, "value_dtype", value_dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (use_node_name_sharing.HasValue)
				c_api.TF_SetAttrBool (desc, "use_node_name_sharing", Convert.ToByte(use_node_name_sharing.Value));
			
			if (value_shape != null)
				c_api.TF_SetAttrShape (desc, "value_shape", ref value_shape[0], value_shape.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var table_handle = new TF_Output (op, _idx++);
			return table_handle;
		}

		/// <summary>
		///   Creates an empty hash table.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableHashTableV2'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this table is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this table is shared under the given name across
		///   multiple sessions.
		/// </param>
		/// <param name="use_node_name_sharing">
		///   Optional argument
		///   If true and shared_name is empty, the table is shared
		///   using the node name.
		/// </param>
		/// <param name="key_dtype">
		///   Type of the table keys.
		/// </param>
		/// <param name="value_dtype">
		///   Type of the table values.
		/// </param>
		/// <returns>
		///   Handle to a table.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op creates a mutable hash table, specifying the type of its keys and
		///   values. Each value must be a scalar. Data can be inserted into the table using
		///   the insert operations. It does not support the initialization operation.
		/// </remarks>
		public TF_Output MutableHashTableV2 (TF_DataType key_dtype, TF_DataType value_dtype, string container = null, string shared_name = null, bool? use_node_name_sharing = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MutableHashTableV2", MakeName ("MutableHashTableV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "key_dtype", key_dtype);
			c_api.TF_SetAttrType (desc, "value_dtype", value_dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (use_node_name_sharing.HasValue)
				c_api.TF_SetAttrBool (desc, "use_node_name_sharing", Convert.ToByte(use_node_name_sharing.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var table_handle = new TF_Output (op, _idx++);
			return table_handle;
		}

		/// <summary>
		///   Locks a mutex resource.  The output is the lock.  So long as the lock tensor
		/// </summary>
		/// <param name="mutex">
		///   The mutex resource to lock.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MutexLock'.
		/// </param>
		/// <returns>
		///   A tensor that keeps a shared pointer to a lock on the mutex;
		///   when the Tensor is destroyed, the use count on the shared pointer is decreased
		///   by 1.  When it reaches 0, the lock is released.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   is alive, any other request to use <c>MutexLock</c> with this mutex will wait.
		///   
		///   This is particularly useful for creating a critical section when used in
		///   conjunction with <c>MutexLockIdentity</c>:
		///   
		///    <code>
		///   
		///   mutex = mutex_v2(
		///   shared_name=handle_name, container=container, name=name)
		///   
		///   def execute_in_critical_section(fn, *args, **kwargs):
		///   lock = gen_resource_variable_ops.mutex_lock(mutex)
		///   
		///   with ops.control_dependencies([lock]):
		///   r = fn(*args, **kwargs)
		///   
		///   with ops.control_dependencies(nest.flatten(r)):
		///   with ops.colocate_with(mutex):
		///   ensure_lock_exists = mutex_lock_identity(lock)
		///   
		///   # Make sure that if any element of r is accessed, all of
		///   # them are executed together.
		///   r = nest.map_structure(tf.identity, r)
		///   
		///   with ops.control_dependencies([ensure_lock_exists]):
		///   return nest.map_structure(tf.identity, r)
		///    </code>
		///   
		///   While <c>fn</c> is running in the critical section, no other functions which wish to
		///   use this critical section may run.
		///   
		///   Often the use case is that two executions of the same graph, in parallel,
		///   wish to run <c>fn</c>; and we wish to ensure that only one of them executes
		///   at a time.  This is especially important if <c>fn</c> modifies one or more
		///   variables at a time.
		///   
		///   It is also useful if two separate functions must share a resource, but we
		///   wish to ensure the usage is exclusive.
		/// </remarks>
		public TF_Output MutexLock (TF_Output mutex, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MutexLock", MakeName ("MutexLock", operName));
			c_api.TF_AddInput(desc, mutex);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var mutex_lock = new TF_Output (op, _idx++);
			return mutex_lock;
		}

		/// <summary>
		///   Creates a Mutex resource that can be locked by <c>MutexLock</c>.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'MutexV2'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this variable is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this variable is named in the given bucket
		///   with this shared_name. Otherwise, the node name is used instead.
		/// </param>
		/// <returns>
		///   The mutex resource.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output MutexV2 (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "MutexV2", MakeName ("MutexV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var resource = new TF_Output (op, _idx++);
			return resource;
		}

		/// <summary>
		///   Outputs a tensor containing the reduction across all input tensors.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NcclAllReduce'.
		/// </param>
		/// <param name="reduction">
		/// </param>
		/// <param name="num_devices">
		/// </param>
		/// <param name="shared_name">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Outputs a tensor containing the reduction across all input tensors passed to ops
		///   within the same <c>shared_name.
		///   
		///   The graph should be constructed so if one op runs with shared_name value </c>c<c>,
		///   then </c>num_devices<c> ops will run with shared_name value </c>c<c>.  Failure to do so
		///   will cause the graph execution to fail to complete.
		///   
		///   input: the input to the reduction
		///   data: the value of the reduction across all </c>num_devices<c> devices.
		///   reduction: the reduction operation to perform.
		///   num_devices: The number of devices participating in this reduction.
		///   shared_name: Identifier that shared between ops of the same reduction.
		/// </remarks>
		public TF_Output NcclAllReduce (TF_Output input, string reduction, long num_devices, string shared_name, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NcclAllReduce", MakeName ("NcclAllReduce", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "reduction", reduction);
			c_api.TF_SetAttrInt (desc, "num_devices", num_devices);
			c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var data = new TF_Output (op, _idx++);
			return data;
		}

		/// <summary>
		///   Sends <c>input</c> to all devices that are connected to the output.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NcclBroadcast'.
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Sends <c>input</c> to all devices that are connected to the output.
		///   
		///   The graph should be constructed so that all ops connected to the output have a
		///   valid device assignment, and the op itself is assigned one of these devices.
		///   
		///   input: The input to the broadcast.
		///   output: The same as input.
		///   shape: The shape of the input tensor.
		///   
		/// </remarks>
		public TF_Output NcclBroadcast (TF_Output input, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NcclBroadcast", MakeName ("NcclBroadcast", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Reduces <c>input</c> from <c>num_devices</c> using <c>reduction</c> to a single device.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NcclReduce'.
		/// </param>
		/// <param name="reduction">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Reduces <c>input</c> from <c>num_devices</c> using <c>reduction</c> to a single device.
		///   
		///   The graph should be constructed so that all inputs have a valid device
		///   assignment, and the op itself is assigned one of these devices.
		///   
		///   input: The input to the reduction.
		///   data: the value of the reduction across all <c>num_devices</c> devices.
		///   reduction: the reduction operation to perform.
		/// </remarks>
		public TF_Output NcclReduce (TF_Output[] input, string reduction, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NcclReduce", MakeName ("NcclReduce", operName));
			c_api.TF_AddInputList(desc, input[0], input.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "reduction", reduction);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var data = new TF_Output (op, _idx++);
			return data;
		}

		/// <summary>
		///   Selects the k nearest centers for each point.
		/// </summary>
		/// <param name="points">
		///   Matrix of shape (n, d). Rows are assumed to be input points.
		/// </param>
		/// <param name="centers">
		///   Matrix of shape (m, d). Rows are assumed to be centers.
		/// </param>
		/// <param name="k">
		///   Number of nearest centers to return for each point. If k is larger than m, then
		///   only m centers are returned.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NearestNeighbors'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   nearest_center_indices: Matrix of shape (n, min(m, k)). Each row contains the indices of the centers
		///   closest to the corresponding point, ordered by increasing distance.
		///   nearest_center_distances: Matrix of shape (n, min(m, k)). Each row contains the squared L2 distance to the
		///   corresponding center in nearest_center_indices.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Rows of points are assumed to be input points. Rows of centers are assumed to be
		///   the list of candidate centers. For each point, the k centers that have least L2
		///   distance to it are computed.
		/// </remarks>
		public (TF_Output nearest_center_indices, TF_Output nearest_center_distances) NearestNeighbors (TF_Output points, TF_Output centers, TF_Output k, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NearestNeighbors", MakeName ("NearestNeighbors", operName));
			c_api.TF_AddInput(desc, points);
			c_api.TF_AddInput(desc, centers);
			c_api.TF_AddInput(desc, k);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var nearest_center_indices = new TF_Output (op, _idx++);
			var nearest_center_distances = new TF_Output (op, _idx++);
			return (nearest_center_indices, nearest_center_distances);
		}

		/// <summary>
		///   Computes numerical negative value element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Neg'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   I.e., \\(y = -x\\).
		/// </remarks>
		public TF_Output Neg (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Neg", MakeName ("Neg", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Training via negative sampling.
		/// </summary>
		/// <param name="w_in">
		///   input word embedding.
		/// </param>
		/// <param name="w_out">
		///   output word embedding.
		/// </param>
		/// <param name="examples">
		///   A vector of word ids.
		/// </param>
		/// <param name="labels">
		///   A vector of word ids.
		/// </param>
		/// <param name="lr">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NegTrain'.
		/// </param>
		/// <param name="vocab_count">
		///   Count of words in the vocabulary.
		/// </param>
		/// <param name="num_negative_samples">
		///   Number of negative samples per example.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation NegTrain (TF_Output w_in, TF_Output w_out, TF_Output examples, TF_Output labels, TF_Output lr, long[] vocab_count, long num_negative_samples, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NegTrain", MakeName ("NegTrain", operName));
			c_api.TF_AddInput(desc, w_in);
			c_api.TF_AddInput(desc, w_out);
			c_api.TF_AddInput(desc, examples);
			c_api.TF_AddInput(desc, labels);
			c_api.TF_AddInput(desc, lr);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "vocab_count", ref vocab_count[0], vocab_count.Length);
			c_api.TF_SetAttrInt (desc, "num_negative_samples", num_negative_samples);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Returns the next representable value of <c>x1</c> in the direction of <c>x2</c>, element-wise.
		/// </summary>
		/// <param name="x1">
		/// </param>
		/// <param name="x2">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NextAfter'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation returns the same result as the C++ std::nextafter function.
		///   
		///   It can also return a subnormal number.
		///   
		///   @compatibility(cpp)
		///   Equivalent to C++ std::nextafter function.
		///   @end_compatibility
		/// </remarks>
		public TF_Output NextAfter (TF_Output x1, TF_Output x2, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NextAfter", MakeName ("NextAfter", operName));
			c_api.TF_AddInput(desc, x1);
			c_api.TF_AddInput(desc, x2);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Makes its input available to the next iteration.
		/// </summary>
		/// <param name="data">
		///   The tensor to be made available to the next iteration.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NextIteration'.
		/// </param>
		/// <returns>
		///   The same tensor as <c>data</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output NextIteration (TF_Output data, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NextIteration", MakeName ("NextIteration", operName));
			c_api.TF_AddInput(desc, data);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Non-deterministically generates some integers.
		/// </summary>
		/// <param name="shape">
		///   The shape of the output tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NonDeterministicInts'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		///   The type of the output.
		/// </param>
		/// <returns>
		///   Non-deterministic integer values with specified shape.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op may use some OS-provided source of non-determinism (e.g. an RNG), so each execution will give different results.
		/// </remarks>
		public TF_Output NonDeterministicInts (TF_Output shape, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NonDeterministicInts", MakeName ("NonDeterministicInts", operName));
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Greedily selects a subset of bounding boxes in descending order of score,
		/// </summary>
		/// <param name="boxes">
		///   A 2-D float tensor of shape <c>[num_boxes, 4]</c>.
		/// </param>
		/// <param name="scores">
		///   A 1-D float tensor of shape <c>[num_boxes]</c> representing a single
		///   score corresponding to each box (each row of boxes).
		/// </param>
		/// <param name="max_output_size">
		///   A scalar integer tensor representing the maximum number of
		///   boxes to be selected by non max suppression.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NonMaxSuppression'.
		/// </param>
		/// <param name="iou_threshold">
		///   Optional argument
		///   A float representing the threshold for deciding whether boxes
		///   overlap too much with respect to IOU.
		/// </param>
		/// <returns>
		///   A 1-D integer tensor of shape <c>[M]</c> representing the selected
		///   indices from the boxes tensor, where <c>M &amp;lt;= max_output_size</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   pruning away boxes that have high intersection-over-union (IOU) overlap
		///   with previously selected boxes.  Bounding boxes are supplied as
		///   [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any
		///   diagonal pair of box corners and the coordinates can be provided as normalized
		///   (i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm
		///   is agnostic to where the origin is in the coordinate system.  Note that this
		///   algorithm is invariant to orthogonal transformations and translations
		///   of the coordinate system; thus translating or reflections of the coordinate
		///   system result in the same boxes being selected by the algorithm.
		///   The output of this operation is a set of integers indexing into the input
		///   collection of bounding boxes representing the selected boxes.  The bounding
		///   box coordinates corresponding to the selected indices can then be obtained
		///   using the <c>tf.gather operation</c>.  For example:
		///   selected_indices = tf.image.non_max_suppression(
		///   boxes, scores, max_output_size, iou_threshold)
		///   selected_boxes = tf.gather(boxes, selected_indices)
		/// </remarks>
		public TF_Output NonMaxSuppression (TF_Output boxes, TF_Output scores, TF_Output max_output_size, float? iou_threshold = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NonMaxSuppression", MakeName ("NonMaxSuppression", operName));
			c_api.TF_AddInput(desc, boxes);
			c_api.TF_AddInput(desc, scores);
			c_api.TF_AddInput(desc, max_output_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (iou_threshold.HasValue)
				c_api.TF_SetAttrFloat (desc, "iou_threshold", iou_threshold.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var selected_indices = new TF_Output (op, _idx++);
			return selected_indices;
		}

		/// <summary>
		///   Greedily selects a subset of bounding boxes in descending order of score,
		/// </summary>
		/// <param name="boxes">
		///   A 2-D float tensor of shape <c>[num_boxes, 4]</c>.
		/// </param>
		/// <param name="scores">
		///   A 1-D float tensor of shape <c>[num_boxes]</c> representing a single
		///   score corresponding to each box (each row of boxes).
		/// </param>
		/// <param name="max_output_size">
		///   A scalar integer tensor representing the maximum number of
		///   boxes to be selected by non max suppression.
		/// </param>
		/// <param name="iou_threshold">
		///   A 0-D float tensor representing the threshold for deciding whether
		///   boxes overlap too much with respect to IOU.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NonMaxSuppressionV2'.
		/// </param>
		/// <returns>
		///   A 1-D integer tensor of shape <c>[M]</c> representing the selected
		///   indices from the boxes tensor, where <c>M &amp;lt;= max_output_size</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   pruning away boxes that have high intersection-over-union (IOU) overlap
		///   with previously selected boxes.  Bounding boxes are supplied as
		///   [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any
		///   diagonal pair of box corners and the coordinates can be provided as normalized
		///   (i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm
		///   is agnostic to where the origin is in the coordinate system.  Note that this
		///   algorithm is invariant to orthogonal transformations and translations
		///   of the coordinate system; thus translating or reflections of the coordinate
		///   system result in the same boxes being selected by the algorithm.
		///   
		///   The output of this operation is a set of integers indexing into the input
		///   collection of bounding boxes representing the selected boxes.  The bounding
		///   box coordinates corresponding to the selected indices can then be obtained
		///   using the <c>tf.gather operation</c>.  For example:
		///   
		///   selected_indices = tf.image.non_max_suppression_v2(
		///   boxes, scores, max_output_size, iou_threshold)
		///   selected_boxes = tf.gather(boxes, selected_indices)
		/// </remarks>
		public TF_Output NonMaxSuppressionV2 (TF_Output boxes, TF_Output scores, TF_Output max_output_size, TF_Output iou_threshold, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NonMaxSuppressionV2", MakeName ("NonMaxSuppressionV2", operName));
			c_api.TF_AddInput(desc, boxes);
			c_api.TF_AddInput(desc, scores);
			c_api.TF_AddInput(desc, max_output_size);
			c_api.TF_AddInput(desc, iou_threshold);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var selected_indices = new TF_Output (op, _idx++);
			return selected_indices;
		}

		/// <summary>
		///   Greedily selects a subset of bounding boxes in descending order of score,
		/// </summary>
		/// <param name="boxes">
		///   A 2-D float tensor of shape <c>[num_boxes, 4]</c>.
		/// </param>
		/// <param name="scores">
		///   A 1-D float tensor of shape <c>[num_boxes]</c> representing a single
		///   score corresponding to each box (each row of boxes).
		/// </param>
		/// <param name="max_output_size">
		///   A scalar integer tensor representing the maximum number of
		///   boxes to be selected by non max suppression.
		/// </param>
		/// <param name="iou_threshold">
		///   A 0-D float tensor representing the threshold for deciding whether
		///   boxes overlap too much with respect to IOU.
		/// </param>
		/// <param name="score_threshold">
		///   A 0-D float tensor representing the threshold for deciding when to remove
		///   boxes based on score.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NonMaxSuppressionV3'.
		/// </param>
		/// <returns>
		///   A 1-D integer tensor of shape <c>[M]</c> representing the selected
		///   indices from the boxes tensor, where <c>M &amp;lt;= max_output_size</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   pruning away boxes that have high intersection-over-union (IOU) overlap
		///   with previously selected boxes.  Bounding boxes with score less than
		///   <c>score_threshold</c> are removed.  Bounding boxes are supplied as
		///   [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any
		///   diagonal pair of box corners and the coordinates can be provided as normalized
		///   (i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm
		///   is agnostic to where the origin is in the coordinate system and more
		///   generally is invariant to orthogonal transformations and translations
		///   of the coordinate system; thus translating or reflections of the coordinate
		///   system result in the same boxes being selected by the algorithm.
		///   The output of this operation is a set of integers indexing into the input
		///   collection of bounding boxes representing the selected boxes.  The bounding
		///   box coordinates corresponding to the selected indices can then be obtained
		///   using the <c>tf.gather operation</c>.  For example:
		///   selected_indices = tf.image.non_max_suppression_v2(
		///   boxes, scores, max_output_size, iou_threshold, score_threshold)
		///   selected_boxes = tf.gather(boxes, selected_indices)
		/// </remarks>
		public TF_Output NonMaxSuppressionV3 (TF_Output boxes, TF_Output scores, TF_Output max_output_size, TF_Output iou_threshold, TF_Output score_threshold, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NonMaxSuppressionV3", MakeName ("NonMaxSuppressionV3", operName));
			c_api.TF_AddInput(desc, boxes);
			c_api.TF_AddInput(desc, scores);
			c_api.TF_AddInput(desc, max_output_size);
			c_api.TF_AddInput(desc, iou_threshold);
			c_api.TF_AddInput(desc, score_threshold);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var selected_indices = new TF_Output (op, _idx++);
			return selected_indices;
		}

		/// <summary>
		///   Greedily selects a subset of bounding boxes in descending order of score,
		/// </summary>
		/// <param name="boxes">
		///   A 2-D float tensor of shape <c>[num_boxes, 4]</c>.
		/// </param>
		/// <param name="scores">
		///   A 1-D float tensor of shape <c>[num_boxes]</c> representing a single
		///   score corresponding to each box (each row of boxes).
		/// </param>
		/// <param name="max_output_size">
		///   A scalar integer tensor representing the maximum number of
		///   boxes to be selected by non max suppression.
		/// </param>
		/// <param name="iou_threshold">
		///   A 0-D float tensor representing the threshold for deciding whether
		///   boxes overlap too much with respect to IOU.
		/// </param>
		/// <param name="score_threshold">
		///   A 0-D float tensor representing the threshold for deciding when to remove
		///   boxes based on score.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NonMaxSuppressionV4'.
		/// </param>
		/// <param name="pad_to_max_output_size">
		///   Optional argument
		///   If true, the output <c>selected_indices</c> is padded to be of length
		///   <c>max_output_size</c>. Defaults to false.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   selected_indices: A 1-D integer tensor of shape <c>[M]</c> representing the selected
		///   indices from the boxes tensor, where <c>M &amp;lt;= max_output_size</c>.
		///   valid_outputs: A 0-D integer tensor representing the number of valid elements in
		///   <c>selected_indices</c>, with the valid elements appearing first.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   pruning away boxes that have high intersection-over-union (IOU) overlap
		///   with previously selected boxes.  Bounding boxes with score less than
		///   <c>score_threshold</c> are removed.  Bounding boxes are supplied as
		///   [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any
		///   diagonal pair of box corners and the coordinates can be provided as normalized
		///   (i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm
		///   is agnostic to where the origin is in the coordinate system and more
		///   generally is invariant to orthogonal transformations and translations
		///   of the coordinate system; thus translating or reflections of the coordinate
		///   system result in the same boxes being selected by the algorithm.
		///   The output of this operation is a set of integers indexing into the input
		///   collection of bounding boxes representing the selected boxes.  The bounding
		///   box coordinates corresponding to the selected indices can then be obtained
		///   using the <c>tf.gather operation</c>.  For example:
		///   selected_indices = tf.image.non_max_suppression_v2(
		///   boxes, scores, max_output_size, iou_threshold, score_threshold)
		///   selected_boxes = tf.gather(boxes, selected_indices)
		/// </remarks>
		public (TF_Output selected_indices, TF_Output valid_outputs) NonMaxSuppressionV4 (TF_Output boxes, TF_Output scores, TF_Output max_output_size, TF_Output iou_threshold, TF_Output score_threshold, bool? pad_to_max_output_size = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NonMaxSuppressionV4", MakeName ("NonMaxSuppressionV4", operName));
			c_api.TF_AddInput(desc, boxes);
			c_api.TF_AddInput(desc, scores);
			c_api.TF_AddInput(desc, max_output_size);
			c_api.TF_AddInput(desc, iou_threshold);
			c_api.TF_AddInput(desc, score_threshold);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (pad_to_max_output_size.HasValue)
				c_api.TF_SetAttrBool (desc, "pad_to_max_output_size", Convert.ToByte(pad_to_max_output_size.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var selected_indices = new TF_Output (op, _idx++);
			var valid_outputs = new TF_Output (op, _idx++);
			return (selected_indices, valid_outputs);
		}

		/// <summary>
		///   Greedily selects a subset of bounding boxes in descending order of score,
		/// </summary>
		/// <param name="boxes">
		///   A 2-D float tensor of shape <c>[num_boxes, 4]</c>.
		/// </param>
		/// <param name="scores">
		///   A 1-D float tensor of shape <c>[num_boxes]</c> representing a single
		///   score corresponding to each box (each row of boxes).
		/// </param>
		/// <param name="max_output_size">
		///   A scalar integer tensor representing the maximum number of
		///   boxes to be selected by non max suppression.
		/// </param>
		/// <param name="iou_threshold">
		///   A 0-D float tensor representing the threshold for deciding whether
		///   boxes overlap too much with respect to IOU.
		/// </param>
		/// <param name="score_threshold">
		///   A 0-D float tensor representing the threshold for deciding when to remove
		///   boxes based on score.
		/// </param>
		/// <param name="soft_nms_sigma">
		///   A 0-D float tensor representing the sigma parameter for Soft NMS; see Bodla et
		///   al (c.f. https://arxiv.org/abs/1704.04503).  When <c>soft_nms_sigma=0.0</c> (which
		///   is default), we fall back to standard (hard) NMS.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NonMaxSuppressionV5'.
		/// </param>
		/// <param name="pad_to_max_output_size">
		///   Optional argument
		///   If true, the output <c>selected_indices</c> is padded to be of length
		///   <c>max_output_size</c>. Defaults to false.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   selected_indices: A 1-D integer tensor of shape <c>[M]</c> representing the selected
		///   indices from the boxes tensor, where <c>M &amp;lt;= max_output_size</c>.
		///   selected_scores: A 1-D float tensor of shape <c>[M]</c> representing the corresponding
		///   scores for each selected box, where <c>M &amp;lt;= max_output_size</c>.  Scores only differ
		///   from corresponding input scores when using Soft NMS (i.e. when
		///   <c>soft_nms_sigma&amp;gt;0</c>)
		///   valid_outputs: A 0-D integer tensor representing the number of valid elements in
		///   <c>selected_indices</c>, with the valid elements appearing first.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   pruning away boxes that have high intersection-over-union (IOU) overlap
		///   with previously selected boxes.  Bounding boxes with score less than
		///   <c>score_threshold</c> are removed.  Bounding boxes are supplied as
		///   [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any
		///   diagonal pair of box corners and the coordinates can be provided as normalized
		///   (i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm
		///   is agnostic to where the origin is in the coordinate system and more
		///   generally is invariant to orthogonal transformations and translations
		///   of the coordinate system; thus translating or reflections of the coordinate
		///   system result in the same boxes being selected by the algorithm.
		///   The output of this operation is a set of integers indexing into the input
		///   collection of bounding boxes representing the selected boxes.  The bounding
		///   box coordinates corresponding to the selected indices can then be obtained
		///   using the <c>tf.gather operation</c>.  For example:
		///   selected_indices = tf.image.non_max_suppression_v2(
		///   boxes, scores, max_output_size, iou_threshold, score_threshold)
		///   selected_boxes = tf.gather(boxes, selected_indices)
		///   This op also supports a Soft-NMS (with Gaussian weighting) mode (c.f.
		///   Bodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score
		///   of other overlapping boxes instead of directly causing them to be pruned.
		///   To enable this Soft-NMS mode, set the <c>soft_nms_sigma</c> parameter to be
		///   larger than 0.
		/// </remarks>
		public (TF_Output selected_indices, TF_Output selected_scores, TF_Output valid_outputs) NonMaxSuppressionV5 (TF_Output boxes, TF_Output scores, TF_Output max_output_size, TF_Output iou_threshold, TF_Output score_threshold, TF_Output soft_nms_sigma, bool? pad_to_max_output_size = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NonMaxSuppressionV5", MakeName ("NonMaxSuppressionV5", operName));
			c_api.TF_AddInput(desc, boxes);
			c_api.TF_AddInput(desc, scores);
			c_api.TF_AddInput(desc, max_output_size);
			c_api.TF_AddInput(desc, iou_threshold);
			c_api.TF_AddInput(desc, score_threshold);
			c_api.TF_AddInput(desc, soft_nms_sigma);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (pad_to_max_output_size.HasValue)
				c_api.TF_SetAttrBool (desc, "pad_to_max_output_size", Convert.ToByte(pad_to_max_output_size.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var selected_indices = new TF_Output (op, _idx++);
			var selected_scores = new TF_Output (op, _idx++);
			var valid_outputs = new TF_Output (op, _idx++);
			return (selected_indices, selected_scores, valid_outputs);
		}

		/// <summary>
		///   Greedily selects a subset of bounding boxes in descending order of score,
		/// </summary>
		/// <param name="overlaps">
		///   A 2-D float tensor of shape <c>[num_boxes, num_boxes]</c> representing
		///   the n-by-n box overlap values.
		/// </param>
		/// <param name="scores">
		///   A 1-D float tensor of shape <c>[num_boxes]</c> representing a single
		///   score corresponding to each box (each row of boxes).
		/// </param>
		/// <param name="max_output_size">
		///   A scalar integer tensor representing the maximum number of
		///   boxes to be selected by non max suppression.
		/// </param>
		/// <param name="overlap_threshold">
		///   A 0-D float tensor representing the threshold for deciding whether
		///   boxes overlap too.
		/// </param>
		/// <param name="score_threshold">
		///   A 0-D float tensor representing the threshold for deciding when to remove
		///   boxes based on score.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NonMaxSuppressionWithOverlaps'.
		/// </param>
		/// <returns>
		///   A 1-D integer tensor of shape <c>[M]</c> representing the selected
		///   indices from the boxes tensor, where <c>M &amp;lt;= max_output_size</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   pruning away boxes that have high overlaps
		///   with previously selected boxes.  Bounding boxes with score less than
		///   <c>score_threshold</c> are removed. N-by-n overlap values are supplied as square matrix,
		///   which allows for defining a custom overlap criterium (eg. intersection over union,
		///   intersection over area, etc.).
		///   
		///   The output of this operation is a set of integers indexing into the input
		///   collection of bounding boxes representing the selected boxes.  The bounding
		///   box coordinates corresponding to the selected indices can then be obtained
		///   using the <c>tf.gather operation</c>.  For example:
		///   
		///   selected_indices = tf.image.non_max_suppression_with_overlaps(
		///   overlaps, scores, max_output_size, overlap_threshold, score_threshold)
		///   selected_boxes = tf.gather(boxes, selected_indices)
		/// </remarks>
		public TF_Output NonMaxSuppressionWithOverlaps (TF_Output overlaps, TF_Output scores, TF_Output max_output_size, TF_Output overlap_threshold, TF_Output score_threshold, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NonMaxSuppressionWithOverlaps", MakeName ("NonMaxSuppressionWithOverlaps", operName));
			c_api.TF_AddInput(desc, overlaps);
			c_api.TF_AddInput(desc, scores);
			c_api.TF_AddInput(desc, max_output_size);
			c_api.TF_AddInput(desc, overlap_threshold);
			c_api.TF_AddInput(desc, score_threshold);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var selected_indices = new TF_Output (op, _idx++);
			return selected_indices;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NonSerializableDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output NonSerializableDataset (TF_Output input_dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NonSerializableDataset", MakeName ("NonSerializableDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Does nothing. Only useful as a placeholder for control edges.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NoOp'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation NoOp (string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NoOp", MakeName ("NoOp", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Returns the truth value of (x != y) element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NotEqual'.
		/// </param>
		/// <param name="incompatible_shape_error">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   *NOTE*: <c>NotEqual</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output NotEqual (TF_Output x, TF_Output y, bool? incompatible_shape_error = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NotEqual", MakeName ("NotEqual", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (incompatible_shape_error.HasValue)
				c_api.TF_SetAttrBool (desc, "incompatible_shape_error", Convert.ToByte(incompatible_shape_error.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Finds values of the <c>n</c>-th order statistic for the last dimension.
		/// </summary>
		/// <param name="input">
		///   1-D or higher with last dimension at least <c>n+1</c>.
		/// </param>
		/// <param name="n">
		///   0-D. Position of sorted vector to select along the last dimension (along
		///   each row for matrices). Valid range of n is <c>[0, input.shape[:-1])</c>
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'NthElement'.
		/// </param>
		/// <param name="reverse">
		///   Optional argument
		///   When set to True, find the nth-largest value in the vector and vice
		///   versa.
		/// </param>
		/// <returns>
		///   The <c>n</c>-th order statistic along each last dimensional slice.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   If the input is a vector (rank-1), finds the entries which is the nth-smallest
		///   value in the vector and outputs their values as scalar tensor.
		///   
		///   For matrices (resp. higher rank input), computes the entries which is the
		///   nth-smallest value in each row (resp. vector along the last dimension). Thus,
		///   
		///   values.shape = input.shape[:-1]
		/// </remarks>
		public TF_Output NthElement (TF_Output input, TF_Output n, bool? reverse = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "NthElement", MakeName ("NthElement", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, n);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (reverse.HasValue)
				c_api.TF_SetAttrBool (desc, "reverse", Convert.ToByte(reverse.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var values = new TF_Output (op, _idx++);
			return values;
		}

		/// <summary>
		///   Returns a one-hot tensor.
		/// </summary>
		/// <param name="indices">
		///   A tensor of indices.
		/// </param>
		/// <param name="depth">
		///   A scalar defining the depth of the one hot dimension.
		/// </param>
		/// <param name="on_value">
		///   A scalar defining the value to fill in output when <c>indices[j] = i</c>.
		/// </param>
		/// <param name="off_value">
		///   A scalar defining the value to fill in output when <c>indices[j] != i</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OneHot'.
		/// </param>
		/// <param name="axis">
		///   Optional argument
		///   The axis to fill (default: -1, a new inner-most axis).
		/// </param>
		/// <returns>
		///   The one-hot tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The locations represented by indices in <c>indices</c> take value <c>on_value</c>,
		///   while all other locations take value <c>off_value</c>.
		///   
		///   If the input <c>indices</c> is rank <c>N</c>, the output will have rank <c>N+1</c>,
		///   The new axis is created at dimension <c>axis</c> (default: the new axis is
		///   appended at the end).
		///   
		///   If <c>indices</c> is a scalar the output shape will be a vector of length <c>depth</c>.
		///   
		///   If <c>indices</c> is a vector of length <c>features</c>, the output shape will be:
		///    <code>
		///   features x depth if axis == -1
		///   depth x features if axis == 0
		///    </code>
		///   
		///   If <c>indices</c> is a matrix (batch) with shape <c>[batch, features]</c>,
		///   the output shape will be:
		///    <code>
		///   batch x features x depth if axis == -1
		///   batch x depth x features if axis == 1
		///   depth x batch x features if axis == 0
		///    </code>
		///   
		///   
		///   Examples
		///   =========
		///   
		///   Suppose that
		///    <code>
		///   indices = [0, 2, -1, 1]
		///   depth = 3
		///   on_value = 5.0
		///   off_value = 0.0
		///   axis = -1
		///    </code>
		///   
		///   Then output is <c>[4 x 3]</c>:
		///    <code>
		///   output =
		///   [5.0 0.0 0.0]  // one_hot(0)
		///   [0.0 0.0 5.0]  // one_hot(2)
		///   [0.0 0.0 0.0]  // one_hot(-1)
		///   [0.0 5.0 0.0]  // one_hot(1)
		///    </code>
		///   
		///   Suppose that
		///    <code>
		///   indices = [0, 2, -1, 1]
		///   depth = 3
		///   on_value = 0.0
		///   off_value = 3.0
		///   axis = 0
		///    </code>
		///   
		///   Then output is <c>[3 x 4]</c>:
		///    <code>
		///   output =
		///   [0.0 3.0 3.0 3.0]
		///   [3.0 3.0 3.0 0.0]
		///   [3.0 3.0 3.0 3.0]
		///   [3.0 0.0 3.0 3.0]
		///   //  ^                one_hot(0)
		///   //      ^            one_hot(2)
		///   //          ^        one_hot(-1)
		///   //              ^    one_hot(1)
		///    </code>
		///   
		///   Suppose that
		///    <code>
		///   indices = [[0, 2], [1, -1]]
		///   depth = 3
		///   on_value = 1.0
		///   off_value = 0.0
		///   axis = -1
		///    </code>
		///   
		///   Then output is <c>[2 x 2 x 3]</c>:
		///    <code>
		///   output =
		///   [
		///   [1.0, 0.0, 0.0]  // one_hot(0)
		///   [0.0, 0.0, 1.0]  // one_hot(2)
		///   ][
		///   [0.0, 1.0, 0.0]  // one_hot(1)
		///   [0.0, 0.0, 0.0]  // one_hot(-1)
		///   ]
		///    </code>
		/// </remarks>
		public TF_Output OneHot (TF_Output indices, TF_Output depth, TF_Output on_value, TF_Output off_value, long? axis = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OneHot", MakeName ("OneHot", operName));
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, depth);
			c_api.TF_AddInput(desc, on_value);
			c_api.TF_AddInput(desc, off_value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (axis.HasValue)
				c_api.TF_SetAttrInt (desc, "axis", axis.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Makes a "one-shot" iterator that can be iterated only once.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OneShotIterator'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dataset_factory">
		///   A function of type <c>() -&amp;gt; DT_VARIANT</c>, where the returned
		///   DT_VARIANT is a dataset.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   A handle to the iterator that can be passed to an "IteratorGetNext"
		///   op.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   A one-shot iterator bundles the logic for defining the dataset and
		///   the state of the iterator in a single op, which allows simple input
		///   pipelines to be defined without an additional initialization
		///   ("MakeIterator") step.
		///   
		///   One-shot iterators have the following limitations:
		///   
		///   * They do not support parameterization: all logic for creating the underlying
		///   dataset must be bundled in the <c>dataset_factory</c> function.
		///   * They are not resettable. Once a one-shot iterator reaches the end of its
		///   underlying dataset, subsequent "IteratorGetNext" operations on that
		///   iterator will always produce an <c>OutOfRange</c> error.
		///   
		///   For greater flexibility, use "Iterator" and "MakeIterator" to define
		///   an iterator using an arbitrary subgraph, which may capture tensors
		///   (including fed values) as parameters, and which may be reset multiple
		///   times by rerunning "MakeIterator".
		/// </remarks>
		public TF_Output OneShotIterator (TF_Function dataset_factory, TF_DataType[] output_types, long[][] output_shapes, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OneShotIterator", MakeName ("OneShotIterator", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "dataset_factory", c_api.TF_FunctionName(dataset_factory));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Returns a tensor of ones with the same shape and type as x.
		/// </summary>
		/// <param name="x">
		///   a tensor of type T.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OnesLike'.
		/// </param>
		/// <returns>
		///   a tensor of the same shape and type as x but filled with ones.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output OnesLike (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OnesLike", MakeName ("OnesLike", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Creates a dataset by applying optimizations to <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		///   A variant tensor representing the input dataset.
		/// </param>
		/// <param name="optimizations">
		///   A <c>tf.string</c> vector <c>tf.Tensor</c> identifying optimizations to use.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OptimizeDataset'.
		/// </param>
		/// <param name="optimization_configs">
		///   Optional argument
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Creates a dataset by applying optimizations to <c>input_dataset</c>.
		/// </remarks>
		public TF_Output OptimizeDataset (TF_Output input_dataset, TF_Output optimizations, TF_DataType[] output_types, long[][] output_shapes, string[] optimization_configs = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OptimizeDataset", MakeName ("OptimizeDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, optimizations);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (optimization_configs != null)
				c_api.TF_SetAttrStringList (desc, "optimization_configs", optimization_configs);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Constructs an Optional variant from a tuple of tensors.
		/// </summary>
		/// <param name="components">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OptionalFromValue'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output OptionalFromValue (TF_Output[] components, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OptionalFromValue", MakeName ("OptionalFromValue", operName));
			c_api.TF_AddInputList(desc, components[0], components.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var optional = new TF_Output (op, _idx++);
			return optional;
		}

		/// <summary>
		///   Returns the value stored in an Optional variant or raises an error if none exists.
		/// </summary>
		/// <param name="optional">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OptionalGetValue'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] OptionalGetValue (TF_Output optional, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OptionalGetValue", MakeName ("OptionalGetValue", operName));
			c_api.TF_AddInput(desc, optional);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "components", status);
			var components = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				components [i] = new TF_Output (op, _idx++);
			
			return components;
		}

		/// <summary>
		///   Returns true if and only if the given Optional variant has a value.
		/// </summary>
		/// <param name="optional">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OptionalHasValue'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output OptionalHasValue (TF_Output optional, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OptionalHasValue", MakeName ("OptionalHasValue", operName));
			c_api.TF_AddInput(desc, optional);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var has_value = new TF_Output (op, _idx++);
			return has_value;
		}

		/// <summary>
		///   Creates an Optional variant with no value.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OptionalNone'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output OptionalNone (string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OptionalNone", MakeName ("OptionalNone", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var optional = new TF_Output (op, _idx++);
			return optional;
		}

		/// <summary>
		///   Op removes all elements in the underlying container.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapClear'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation OrderedMapClear (TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OrderedMapClear", MakeName ("OrderedMapClear", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Op returns the number of incomplete elements in the underlying container.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapIncompleteSize'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output OrderedMapIncompleteSize (TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OrderedMapIncompleteSize", MakeName ("OrderedMapIncompleteSize", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		///   Op peeks at the values at the specified key.  If the
		/// </summary>
		/// <param name="key">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapPeek'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   underlying container does not contain this key
		///   this op will block until it does.   This Op is optimized for
		///   performance.
		/// </remarks>
		public TF_Output[] OrderedMapPeek (TF_Output key, TF_Output indices, TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OrderedMapPeek", MakeName ("OrderedMapPeek", operName));
			c_api.TF_AddInput(desc, key);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "values", status);
			var values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				values [i] = new TF_Output (op, _idx++);
			
			return values;
		}

		/// <summary>
		///   Op returns the number of elements in the underlying container.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapSize'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output OrderedMapSize (TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OrderedMapSize", MakeName ("OrderedMapSize", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		///   Stage (key, values) in the underlying container which behaves like a ordered
		/// </summary>
		/// <param name="key">
		///   int64
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="values">
		///   a list of tensors
		///   dtypes A list of data types that inserted values should adhere to.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapStage'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		///   Maximum number of elements in the Staging Area. If &amp;gt; 0, inserts
		///   on the container will block when the capacity is reached.
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this queue is placed in the given container. Otherwise,
		///   a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   It is necessary to match this name to the matching Unstage Op.
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   associative container.   Elements are ordered by key.
		/// </remarks>
		public TF_Operation OrderedMapStage (TF_Output key, TF_Output indices, TF_Output[] values, TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OrderedMapStage", MakeName ("OrderedMapStage", operName));
			c_api.TF_AddInput(desc, key);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInputList(desc, values[0], values.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Op removes and returns the values associated with the key
		/// </summary>
		/// <param name="key">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapUnstage'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   from the underlying container.   If the underlying container
		///   does not contain this key, the op will block until it does.
		/// </remarks>
		public TF_Output[] OrderedMapUnstage (TF_Output key, TF_Output indices, TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OrderedMapUnstage", MakeName ("OrderedMapUnstage", operName));
			c_api.TF_AddInput(desc, key);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "values", status);
			var values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				values [i] = new TF_Output (op, _idx++);
			
			return values;
		}

		/// <summary>
		///   Op removes and returns the (key, value) element with the smallest
		/// </summary>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapUnstageNoKey'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   key:
		///   values:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   key from the underlying container.   If the underlying container
		///   does not contain elements, the op will block until it does.
		/// </remarks>
		public (TF_Output key, TF_Output[] values) OrderedMapUnstageNoKey (TF_Output indices, TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OrderedMapUnstageNoKey", MakeName ("OrderedMapUnstageNoKey", operName));
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			var key = new TF_Output (op, _idx++);
			_n = c_api.TF_OperationOutputListLength(op, "values", status);
			var values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				values [i] = new TF_Output (op, _idx++);
			
			return (key, values);
		}

		/// <summary>
		///   Retrieves a single tensor from the computation outfeed.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OutfeedDequeue'.
		/// </param>
		/// <param name="device_ordinal">
		///   Optional argument
		///   The TPU device to use. This should be -1 when the Op
		///   is running on a TPU device, and &amp;gt;= 0 when the Op is running on the CPU
		///   device.
		/// </param>
		/// <param name="dtype">
		///   The type of elements in the tensor.
		/// </param>
		/// <param name="shape">
		///   The shape of the tensor.
		/// </param>
		/// <returns>
		///   A tensor that will be read from the device outfeed.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation will block indefinitely until data is available.
		/// </remarks>
		public TF_Output OutfeedDequeue (TF_DataType dtype, long[] shape, long? device_ordinal = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OutfeedDequeue", MakeName ("OutfeedDequeue", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			if (device_ordinal.HasValue)
				c_api.TF_SetAttrInt (desc, "device_ordinal", device_ordinal.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Retrieve multiple values from the computation outfeed.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OutfeedDequeueTuple'.
		/// </param>
		/// <param name="device_ordinal">
		///   Optional argument
		///   The TPU device to use. This should be -1 when the Op
		///   is running on a TPU device, and &amp;gt;= 0 when the Op is running on the CPU
		///   device.
		/// </param>
		/// <param name="dtypes">
		///   The element types of each element in <c>outputs</c>.
		/// </param>
		/// <param name="shapes">
		///   The shapes of each tensor in <c>outputs</c>.
		/// </param>
		/// <returns>
		///   A list of tensors that will be read from the outfeed.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation will block indefinitely until data is available. Output <c>i</c>
		///   corresponds to XLA tuple element <c>i</c>.
		/// </remarks>
		public TF_Output[] OutfeedDequeueTuple (TF_DataType[] dtypes, long[][] shapes, long? device_ordinal = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OutfeedDequeueTuple", MakeName ("OutfeedDequeueTuple", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			if (device_ordinal.HasValue)
				c_api.TF_SetAttrInt (desc, "device_ordinal", device_ordinal.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "outputs", status);
			var outputs = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				outputs [i] = new TF_Output (op, _idx++);
			
			return outputs;
		}

		/// <summary>
		///   Enqueue a Tensor on the computation outfeed.
		/// </summary>
		/// <param name="input">
		///   A tensor that will be inserted into the outfeed queue.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OutfeedEnqueue'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation OutfeedEnqueue (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OutfeedEnqueue", MakeName ("OutfeedEnqueue", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Enqueue multiple Tensor values on the computation outfeed.
		/// </summary>
		/// <param name="inputs">
		///   A list of tensors that will be inserted into the outfeed queue as an
		///   XLA tuple.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'OutfeedEnqueueTuple'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation OutfeedEnqueueTuple (TF_Output[] inputs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "OutfeedEnqueueTuple", MakeName ("OutfeedEnqueueTuple", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Packs a list of <c>N</c> rank-<c>R</c> tensors into one rank-<c>(R+1)</c> tensor.
		/// </summary>
		/// <param name="values">
		///   Must be of same shape and type.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Pack'.
		/// </param>
		/// <param name="axis">
		///   Optional argument
		///   Dimension along which to pack.  Negative values wrap around, so the
		///   valid range is <c>[-(R+1), R+1)</c>.
		/// </param>
		/// <returns>
		///   The packed tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Packs the <c>N</c> tensors in <c>values</c> into a tensor with rank one higher than each
		///   tensor in <c>values</c>, by packing them along the <c>axis</c> dimension.
		///   Given a list of tensors of shape <c>(A, B, C)</c>;
		///   
		///   if <c>axis == 0</c> then the <c>output</c> tensor will have the shape <c>(N, A, B, C)</c>.
		///   if <c>axis == 1</c> then the <c>output</c> tensor will have the shape <c>(A, N, B, C)</c>.
		///   Etc.
		///   
		///   For example:
		///   
		///    <code>
		///   # 'x' is [1, 4]
		///   # 'y' is [2, 5]
		///   # 'z' is [3, 6]
		///   pack([x, y, z]) =&amp;gt; [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.
		///   pack([x, y, z], axis=1) =&amp;gt; [[1, 2, 3], [4, 5, 6]]
		///    </code>
		///   
		///   This is the opposite of <c>unpack</c>.
		/// </remarks>
		public TF_Output Pack (TF_Output[] values, long? axis = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Pack", MakeName ("Pack", operName));
			c_api.TF_AddInputList(desc, values[0], values.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (axis.HasValue)
				c_api.TF_SetAttrInt (desc, "axis", axis.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Pads a tensor with zeros.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="paddings">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Pad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation pads a <c>input</c> with zeros according to the <c>paddings</c> you
		///   specify. <c>paddings</c> is an integer tensor with shape <c>[Dn, 2]</c>, where n is the
		///   rank of <c>input</c>. For each dimension D of <c>input</c>, <c>paddings[D, 0]</c> indicates
		///   how many zeros to add before the contents of <c>input</c> in that dimension, and
		///   <c>paddings[D, 1]</c> indicates how many zeros to add after the contents of <c>input</c>
		///   in that dimension.
		///   
		///   The padded size of each dimension D of the output is:
		///   
		///   <c>paddings(D, 0) + input.dim_size(D) + paddings(D, 1)</c>
		///   
		///   For example:
		///   
		///    <code>
		///   # 't' is [[1, 1], [2, 2]]
		///   # 'paddings' is [[1, 1], [2, 2]]
		///   # rank of 't' is 2
		///   pad(t, paddings) ==&amp;gt; [[0, 0, 0, 0, 0, 0]
		///   [0, 0, 1, 1, 0, 0]
		///   [0, 0, 2, 2, 0, 0]
		///   [0, 0, 0, 0, 0, 0]]
		///    </code>
		///   
		/// </remarks>
		public TF_Output Pad (TF_Output input, TF_Output paddings, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Pad", MakeName ("Pad", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, paddings);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates a dataset that batches and pads <c>batch_size</c> elements from the input.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="batch_size">
		///   A scalar representing the number of elements to accumulate in a
		///   batch.
		/// </param>
		/// <param name="padded_shapes">
		///   A list of int64 tensors representing the desired padded shapes
		///   of the corresponding output components. These shapes may be partially
		///   specified, using <c>-1</c> to indicate that a particular dimension should be
		///   padded to the maximum size of all batch elements.
		/// </param>
		/// <param name="padding_values">
		///   A list of scalars containing the padding value to use for
		///   each of the outputs.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PaddedBatchDataset'.
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output PaddedBatchDataset (TF_Output input_dataset, TF_Output batch_size, TF_Output[] padded_shapes, TF_Output[] padding_values, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PaddedBatchDataset", MakeName ("PaddedBatchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, batch_size);
			c_api.TF_AddInputList(desc, padded_shapes[0], padded_shapes.Length);
			c_api.TF_AddInputList(desc, padding_values[0], padding_values.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that batches and pads <c>batch_size</c> elements from the input.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="batch_size">
		///   A scalar representing the number of elements to accumulate in a
		///   batch.
		/// </param>
		/// <param name="padded_shapes">
		///   A list of int64 tensors representing the desired padded shapes
		///   of the corresponding output components. These shapes may be partially
		///   specified, using <c>-1</c> to indicate that a particular dimension should be
		///   padded to the maximum size of all batch elements.
		/// </param>
		/// <param name="padding_values">
		///   A list of scalars containing the padding value to use for
		///   each of the outputs.
		/// </param>
		/// <param name="drop_remainder">
		///   A scalar representing whether the last batch should be dropped in case its size
		///   is smaller than desired.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PaddedBatchDatasetV2'.
		/// </param>
		/// <param name="parallel_copy">
		///   Optional argument
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output PaddedBatchDatasetV2 (TF_Output input_dataset, TF_Output batch_size, TF_Output[] padded_shapes, TF_Output[] padding_values, TF_Output drop_remainder, long[][] output_shapes, bool? parallel_copy = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PaddedBatchDatasetV2", MakeName ("PaddedBatchDatasetV2", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, batch_size);
			c_api.TF_AddInputList(desc, padded_shapes[0], padded_shapes.Length);
			c_api.TF_AddInputList(desc, padding_values[0], padding_values.Length);
			c_api.TF_AddInput(desc, drop_remainder);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (parallel_copy.HasValue)
				c_api.TF_SetAttrBool (desc, "parallel_copy", Convert.ToByte(parallel_copy.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   A queue that produces elements in first-in first-out order.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PaddingFIFOQueue'.
		/// </param>
		/// <param name="shapes">
		///   Optional argument
		///   The shape of each component in a value. The length of this attr must
		///   be either 0 or the same as the length of component_types.
		///   Shapes of fixed rank but variable size are allowed by setting
		///   any shape dimension to -1.  In this case, the inputs' shape may vary along
		///   the given dimension, and DequeueMany will pad the given dimension with
		///   zeros up to the maximum shape of all elements in the given batch.
		///   If the length of this attr is 0, different queue elements may have
		///   different ranks and shapes, but only one element may be dequeued at a time.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		///   The upper bound on the number of elements in this queue.
		///   Negative numbers mean no limit.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this queue is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this queue will be shared under the given name
		///   across multiple sessions.
		/// </param>
		/// <param name="component_types">
		///   The type of each component in a value.
		/// </param>
		/// <returns>
		///   The handle to the queue.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Variable-size shapes are allowed by setting the corresponding shape dimensions
		///   to 0 in the shape attr.  In this case DequeueMany will pad up to the maximum
		///   size of any given element in the minibatch.  See below for details.
		/// </remarks>
		public TF_Output PaddingFIFOQueue (TF_DataType[] component_types, long[][] shapes = null, long? capacity = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PaddingFIFOQueue", MakeName ("PaddingFIFOQueue", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (shapes != null)
				c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   A queue that produces elements in first-in first-out order.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PaddingFIFOQueueV2'.
		/// </param>
		/// <param name="shapes">
		///   Optional argument
		///   The shape of each component in a value. The length of this attr must
		///   be either 0 or the same as the length of component_types.
		///   Shapes of fixed rank but variable size are allowed by setting
		///   any shape dimension to -1.  In this case, the inputs' shape may vary along
		///   the given dimension, and DequeueMany will pad the given dimension with
		///   zeros up to the maximum shape of all elements in the given batch.
		///   If the length of this attr is 0, different queue elements may have
		///   different ranks and shapes, but only one element may be dequeued at a time.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		///   The upper bound on the number of elements in this queue.
		///   Negative numbers mean no limit.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this queue is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this queue will be shared under the given name
		///   across multiple sessions.
		/// </param>
		/// <param name="component_types">
		///   The type of each component in a value.
		/// </param>
		/// <returns>
		///   The handle to the queue.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Variable-size shapes are allowed by setting the corresponding shape dimensions
		///   to 0 in the shape attr.  In this case DequeueMany will pad up to the maximum
		///   size of any given element in the minibatch.  See below for details.
		/// </remarks>
		public TF_Output PaddingFIFOQueueV2 (TF_DataType[] component_types, long[][] shapes = null, long? capacity = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PaddingFIFOQueueV2", MakeName ("PaddingFIFOQueueV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (shapes != null)
				c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Pads a tensor.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="paddings">
		/// </param>
		/// <param name="constant_values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PadV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation pads <c>input</c> according to the <c>paddings</c> and <c>constant_values</c>
		///   you specify. <c>paddings</c> is an integer tensor with shape <c>[Dn, 2]</c>, where n is
		///   the rank of <c>input</c>. For each dimension D of <c>input</c>, <c>paddings[D, 0]</c> indicates
		///   how many padding values to add before the contents of <c>input</c> in that dimension,
		///   and <c>paddings[D, 1]</c> indicates how many padding values to add after the contents
		///   of <c>input</c> in that dimension. <c>constant_values</c> is a scalar tensor of the same
		///   type as <c>input</c> that indicates the value to use for padding <c>input</c>.
		///   
		///   The padded size of each dimension D of the output is:
		///   
		///   <c>paddings(D, 0) + input.dim_size(D) + paddings(D, 1)</c>
		///   
		///   For example:
		///   
		///    <code>
		///   # 't' is [[1, 1], [2, 2]]
		///   # 'paddings' is [[1, 1], [2, 2]]
		///   # 'constant_values' is 0
		///   # rank of 't' is 2
		///   pad(t, paddings) ==&amp;gt; [[0, 0, 0, 0, 0, 0]
		///   [0, 0, 1, 1, 0, 0]
		///   [0, 0, 2, 2, 0, 0]
		///   [0, 0, 0, 0, 0, 0]]
		///    </code>
		/// </remarks>
		public TF_Output PadV2 (TF_Output input, TF_Output paddings, TF_Output constant_values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PadV2", MakeName ("PadV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, paddings);
			c_api.TF_AddInput(desc, constant_values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Concatenates a list of <c>N</c> tensors along the first dimension.
		/// </summary>
		/// <param name="values">
		///   Tensors to be concatenated. All must have size 1 in the first dimension
		///   and same shape.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ParallelConcat'.
		/// </param>
		/// <param name="shape">
		///   the final shape of the result; should be equal to the shapes of any input
		///   but with the number of input values in the first dimension.
		/// </param>
		/// <returns>
		///   The concatenated tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The input tensors are all required to have size 1 in the first dimension.
		///   
		///   For example:
		///   
		///    <code>
		///   # 'x' is [[1, 4]]
		///   # 'y' is [[2, 5]]
		///   # 'z' is [[3, 6]]
		///   parallel_concat([x, y, z]) =&amp;gt; [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.
		///    </code>
		///   
		///   The difference between concat and parallel_concat is that concat requires all
		///   of the inputs be computed before the operation will begin but doesn't require
		///   that the input shapes be known during graph construction.  Parallel concat
		///   will copy pieces of the input into the output as they become available, in
		///   some situations this can provide a performance benefit.
		/// </remarks>
		public TF_Output ParallelConcat (TF_Output[] values, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ParallelConcat", MakeName ("ParallelConcat", operName));
			c_api.TF_AddInputList(desc, values[0], values.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Interleave the values from the <c>data</c> tensors into a single tensor.
		/// </summary>
		/// <param name="indices">
		/// </param>
		/// <param name="data">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ParallelDynamicStitch'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Builds a merged tensor such that
		///   
		///    <code>
		///   merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]
		///    </code>
		///   
		///   For example, if each <c>indices[m]</c> is scalar or vector, we have
		///   
		///    <code>
		///   # Scalar indices:
		///   merged[indices[m], ...] = data[m][...]
		///   
		///   # Vector indices:
		///   merged[indices[m][i], ...] = data[m][i, ...]
		///    </code>
		///   
		///   Each <c>data[i].shape</c> must start with the corresponding <c>indices[i].shape</c>,
		///   and the rest of <c>data[i].shape</c> must be constant w.r.t. <c>i</c>.  That is, we
		///   must have <c>data[i].shape = indices[i].shape + constant</c>.  In terms of this
		///   <c>constant</c>, the output shape is
		///   
		///   merged.shape = [max(indices)] + constant
		///   
		///   Values may be merged in parallel, so if an index appears in both <c>indices[m][i]</c>
		///   and <c>indices[n][j]</c>, the result may be invalid. This differs from the normal
		///   DynamicStitch operator that defines the behavior in that case.
		///   
		///   For example:
		///   
		///    <code>
		///   indices[0] = 6
		///   indices[1] = [4, 1]
		///   indices[2] = [[5, 2], [0, 3]]
		///   data[0] = [61, 62]
		///   data[1] = [[41, 42], [11, 12]]
		///   data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]
		///   merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],
		///   [51, 52], [61, 62]]
		///    </code>
		///   
		///   This method can be used to merge partitions created by <c>dynamic_partition</c>
		///   as illustrated on the following example:
		///   
		///    <code>
		///   # Apply function (increments x_i) on elements for which a certain condition
		///   # apply (x_i != -1 in this example).
		///   x=tf.constant([0.1, -1., 5.2, 4.3, -1., 7.4])
		///   condition_mask=tf.not_equal(x,tf.constant(-1.))
		///   partitioned_data = tf.dynamic_partition(
		///   x, tf.cast(condition_mask, tf.int32) , 2)
		///   partitioned_data[1] = partitioned_data[1] + 1.0
		///   condition_indices = tf.dynamic_partition(
		///   tf.range(tf.shape(x)[0]), tf.cast(condition_mask, tf.int32) , 2)
		///   x = tf.dynamic_stitch(condition_indices, partitioned_data)
		///   # Here x=[1.1, -1., 6.2, 5.3, -1, 8.4], the -1. values remain
		///   # unchanged.
		///    </code>
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/DynamicStitch.png" alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		/// </remarks>
		public TF_Output ParallelDynamicStitch (TF_Output[] indices, TF_Output[] data, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ParallelDynamicStitch", MakeName ("ParallelDynamicStitch", operName));
			c_api.TF_AddInputList(desc, indices[0], indices.Length);
			c_api.TF_AddInputList(desc, data[0], data.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var merged = new TF_Output (op, _idx++);
			return merged;
		}

		/// <summary>
		///   Creates a dataset that applies <c>f</c> to the outputs of <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="other_arguments">
		/// </param>
		/// <param name="cycle_length">
		/// </param>
		/// <param name="block_length">
		/// </param>
		/// <param name="sloppy">
		/// </param>
		/// <param name="buffer_output_elements">
		/// </param>
		/// <param name="prefetch_input_elements">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ParallelInterleaveDataset'.
		/// </param>
		/// <param name="f">
		///   A function mapping elements of <c>input_dataset</c>, concatenated with
		///   <c>other_arguments</c>, to a Dataset variant that contains elements matching
		///   <c>output_types</c> and <c>output_shapes</c>.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The resulting dataset is similar to the <c>InterleaveDataset</c>, with the exception
		///   that if retrieving the next value from a dataset would cause the requester to
		///   block, it will skip that input dataset. This dataset is especially useful
		///   when loading data from a variable-latency datastores (e.g. HDFS, GCS), as it
		///   allows the training step to proceed so long as some data is available.
		///   
		///   !! WARNING !! This dataset is not deterministic!
		/// </remarks>
		public TF_Output ParallelInterleaveDataset (TF_Output input_dataset, TF_Output[] other_arguments, TF_Output cycle_length, TF_Output block_length, TF_Output sloppy, TF_Output buffer_output_elements, TF_Output prefetch_input_elements, TF_Function f, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ParallelInterleaveDataset", MakeName ("ParallelInterleaveDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInputList(desc, other_arguments[0], other_arguments.Length);
			c_api.TF_AddInput(desc, cycle_length);
			c_api.TF_AddInput(desc, block_length);
			c_api.TF_AddInput(desc, sloppy);
			c_api.TF_AddInput(desc, buffer_output_elements);
			c_api.TF_AddInput(desc, prefetch_input_elements);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "f", c_api.TF_FunctionName(f));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that applies <c>f</c> to the outputs of <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="other_arguments">
		/// </param>
		/// <param name="cycle_length">
		/// </param>
		/// <param name="block_length">
		/// </param>
		/// <param name="num_parallel_calls">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ParallelInterleaveDatasetV2'.
		/// </param>
		/// <param name="sloppy">
		///   Optional argument
		/// </param>
		/// <param name="f">
		///   A function mapping elements of <c>input_dataset</c>, concatenated with
		///   <c>other_arguments</c>, to a Dataset variant that contains elements matching
		///   <c>output_types</c> and <c>output_shapes</c>.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ParallelInterleaveDatasetV2 (TF_Output input_dataset, TF_Output[] other_arguments, TF_Output cycle_length, TF_Output block_length, TF_Output num_parallel_calls, TF_Function f, TF_DataType[] output_types, long[][] output_shapes, bool? sloppy = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ParallelInterleaveDatasetV2", MakeName ("ParallelInterleaveDatasetV2", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInputList(desc, other_arguments[0], other_arguments.Length);
			c_api.TF_AddInput(desc, cycle_length);
			c_api.TF_AddInput(desc, block_length);
			c_api.TF_AddInput(desc, num_parallel_calls);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "f", c_api.TF_FunctionName(f));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (sloppy.HasValue)
				c_api.TF_SetAttrBool (desc, "sloppy", Convert.ToByte(sloppy.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that applies <c>f</c> to the outputs of <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="other_arguments">
		/// </param>
		/// <param name="num_parallel_calls">
		///   The number of concurrent invocations of <c>f</c> that process
		///   elements from <c>input_dataset</c> in parallel.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ParallelMapDataset'.
		/// </param>
		/// <param name="use_inter_op_parallelism">
		///   Optional argument
		/// </param>
		/// <param name="sloppy">
		///   Optional argument
		/// </param>
		/// <param name="preserve_cardinality">
		///   Optional argument
		/// </param>
		/// <param name="f">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Unlike a "MapDataset", which applies <c>f</c> sequentially, this dataset invokes up
		///   to <c>num_parallel_calls</c> copies of <c>f</c> in parallel.
		/// </remarks>
		public TF_Output ParallelMapDataset (TF_Output input_dataset, TF_Output[] other_arguments, TF_Output num_parallel_calls, TF_Function f, TF_DataType[] output_types, long[][] output_shapes, bool? use_inter_op_parallelism = null, bool? sloppy = null, bool? preserve_cardinality = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ParallelMapDataset", MakeName ("ParallelMapDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInputList(desc, other_arguments[0], other_arguments.Length);
			c_api.TF_AddInput(desc, num_parallel_calls);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "f", c_api.TF_FunctionName(f));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (use_inter_op_parallelism.HasValue)
				c_api.TF_SetAttrBool (desc, "use_inter_op_parallelism", Convert.ToByte(use_inter_op_parallelism.Value));
			
			if (sloppy.HasValue)
				c_api.TF_SetAttrBool (desc, "sloppy", Convert.ToByte(sloppy.Value));
			
			if (preserve_cardinality.HasValue)
				c_api.TF_SetAttrBool (desc, "preserve_cardinality", Convert.ToByte(preserve_cardinality.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Outputs random values from a normal distribution. The parameters may each be a
		/// </summary>
		/// <param name="shape">
		///   The shape of the output tensor. Batches are indexed by the 0th dimension.
		/// </param>
		/// <param name="means">
		///   The mean parameter of each batch.
		/// </param>
		/// <param name="stdevs">
		///   The standard deviation parameter of each batch. Must be greater than 0.
		/// </param>
		/// <param name="minvals">
		///   The minimum cutoff. May be -infinity.
		/// </param>
		/// <param name="maxvals">
		///   The maximum cutoff. May be +infinity, and must be more than the minval
		///   for each batch.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ParameterizedTruncatedNormal'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either <c>seed</c> or <c>seed2</c> are set to be non-zero, the random number
		///   generator is seeded by the given seed.  Otherwise, it is seeded by a
		///   random seed.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   A second seed to avoid seed collision.
		/// </param>
		/// <returns>
		///   A matrix of shape num_batches x samples_per_batch, filled with random
		///   truncated normal values using the parameters for each row.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   scalar which applies to the entire output, or a vector of length shape[0] which
		///   stores the parameters for each batch.
		/// </remarks>
		public TF_Output ParameterizedTruncatedNormal (TF_Output shape, TF_Output means, TF_Output stdevs, TF_Output minvals, TF_Output maxvals, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ParameterizedTruncatedNormal", MakeName ("ParameterizedTruncatedNormal", operName));
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, means);
			c_api.TF_AddInput(desc, stdevs);
			c_api.TF_AddInput(desc, minvals);
			c_api.TF_AddInput(desc, maxvals);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Transforms a vector of brain.Example protos (as strings) into typed tensors.
		/// </summary>
		/// <param name="serialized">
		///   A vector containing a batch of binary serialized Example protos.
		/// </param>
		/// <param name="names">
		///   A vector containing the names of the serialized protos.
		///   May contain, for example, table key (descriptive) names for the
		///   corresponding serialized protos.  These are purely useful for debugging
		///   purposes, and the presence of values here has no effect on the output.
		///   May also be an empty vector if no names are available.
		///   If non-empty, this vector must be the same length as "serialized".
		/// </param>
		/// <param name="sparse_keys">
		///   A list of Nsparse string Tensors (scalars).
		///   The keys expected in the Examples' features associated with sparse values.
		/// </param>
		/// <param name="dense_keys">
		///   A list of Ndense string Tensors (scalars).
		///   The keys expected in the Examples' features associated with dense values.
		/// </param>
		/// <param name="dense_defaults">
		///   A list of Ndense Tensors (some may be empty).
		///   dense_defaults[j] provides default values
		///   when the example's feature_map lacks dense_key[j].  If an empty Tensor is
		///   provided for dense_defaults[j], then the Feature dense_keys[j] is required.
		///   The input type is inferred from dense_defaults[j], even when it's empty.
		///   If dense_defaults[j] is not empty, and dense_shapes[j] is fully defined,
		///   then the shape of dense_defaults[j] must match that of dense_shapes[j].
		///   If dense_shapes[j] has an undefined major dimension (variable strides dense
		///   feature), dense_defaults[j] must contain a single element:
		///   the padding element.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ParseExample'.
		/// </param>
		/// <param name="sparse_types">
		///   A list of Nsparse types; the data types of data in each Feature
		///   given in sparse_keys.
		///   Currently the ParseExample supports DT_FLOAT (FloatList),
		///   DT_INT64 (Int64List), and DT_STRING (BytesList).
		/// </param>
		/// <param name="dense_shapes">
		///   A list of Ndense shapes; the shapes of data in each Feature
		///   given in dense_keys.
		///   The number of elements in the Feature corresponding to dense_key[j]
		///   must always equal dense_shapes[j].NumEntries().
		///   If dense_shapes[j] == (D0, D1, ..., DN) then the shape of output
		///   Tensor dense_values[j] will be (|serialized|, D0, D1, ..., DN):
		///   The dense outputs are just the inputs row-stacked by batch.
		///   This works for dense_shapes[j] = (-1, D1, ..., DN).  In this case
		///   the shape of the output Tensor dense_values[j] will be
		///   (|serialized|, M, D1, .., DN), where M is the maximum number of blocks
		///   of elements of length D1 * .... * DN, across all minibatch entries
		///   in the input.  Any minibatch entry with less than M blocks of elements of
		///   length D1 * ... * DN will be padded with the corresponding default_value
		///   scalar element along the second dimension.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sparse_indices:
		///   sparse_values:
		///   sparse_shapes:
		///   dense_values:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output[] sparse_indices, TF_Output[] sparse_values, TF_Output[] sparse_shapes, TF_Output[] dense_values) ParseExample (TF_Output serialized, TF_Output names, TF_Output[] sparse_keys, TF_Output[] dense_keys, TF_Output[] dense_defaults, TF_DataType[] sparse_types, long[][] dense_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ParseExample", MakeName ("ParseExample", operName));
			c_api.TF_AddInput(desc, serialized);
			c_api.TF_AddInput(desc, names);
			c_api.TF_AddInputList(desc, sparse_keys[0], sparse_keys.Length);
			c_api.TF_AddInputList(desc, dense_keys[0], dense_keys.Length);
			c_api.TF_AddInputList(desc, dense_defaults[0], dense_defaults.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "sparse_types", sparse_types);
			c_api.TF_SetAttrShapeList (desc, "dense_shapes", dense_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "sparse_indices", status);
			var sparse_indices = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				sparse_indices [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "sparse_values", status);
			var sparse_values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				sparse_values [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "sparse_shapes", status);
			var sparse_shapes = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				sparse_shapes [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "dense_values", status);
			var dense_values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				dense_values [i] = new TF_Output (op, _idx++);
			
			return (sparse_indices, sparse_values, sparse_shapes, dense_values);
		}

		/// <summary>
		///   Transforms <c>input_dataset</c> containing <c>Example</c> protos as vectors of DT_STRING into a dataset of <c>Tensor</c> or <c>SparseTensor</c> objects representing the parsed features.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="num_parallel_calls">
		/// </param>
		/// <param name="dense_defaults">
		///   A dict mapping string keys to <c>Tensor</c>s.
		///   The keys of the dict must match the dense_keys of the feature.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ParseExampleDataset'.
		/// </param>
		/// <param name="sloppy">
		///   Optional argument
		/// </param>
		/// <param name="sparse_keys">
		///   A list of string keys in the examples features.
		///   The results for these keys will be returned as <c>SparseTensor</c> objects.
		/// </param>
		/// <param name="dense_keys">
		///   A list of Ndense string Tensors (scalars).
		///   The keys expected in the Examples features associated with dense values.
		/// </param>
		/// <param name="sparse_types">
		///   A list of <c>DTypes</c> of the same length as <c>sparse_keys</c>.
		///   Only <c>tf.float32</c> (<c>FloatList</c>), <c>tf.int64</c> (<c>Int64List</c>),
		///   and <c>tf.string</c> (<c>BytesList</c>) are supported.
		/// </param>
		/// <param name="dense_shapes">
		///   List of tuples with the same length as <c>dense_keys</c>.
		///   The shape of the data for each dense feature referenced by <c>dense_keys</c>.
		///   Required for any input tensors identified by <c>dense_keys</c>.  Must be
		///   either fully defined, or may contain an unknown first dimension.
		///   An unknown first dimension means the feature is treated as having
		///   a variable number of blocks, and the output shape along this dimension
		///   is considered unknown at graph build time.  Padding is applied for
		///   minibatch elements smaller than the maximum number of blocks for the
		///   given feature along this dimension.
		/// </param>
		/// <param name="output_types">
		///   The type list for the return values.
		/// </param>
		/// <param name="output_shapes">
		///   The list of shapes being produced.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ParseExampleDataset (TF_Output input_dataset, TF_Output num_parallel_calls, TF_Output[] dense_defaults, string[] sparse_keys, string[] dense_keys, TF_DataType[] sparse_types, long[][] dense_shapes, TF_DataType[] output_types, long[][] output_shapes, bool? sloppy = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ParseExampleDataset", MakeName ("ParseExampleDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, num_parallel_calls);
			c_api.TF_AddInputList(desc, dense_defaults[0], dense_defaults.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrStringList (desc, "sparse_keys", sparse_keys);
			c_api.TF_SetAttrStringList (desc, "dense_keys", dense_keys);
			c_api.TF_SetAttrTypeList (desc, "sparse_types", sparse_types);
			c_api.TF_SetAttrShapeList (desc, "dense_shapes", dense_shapes);
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (sloppy.HasValue)
				c_api.TF_SetAttrBool (desc, "sloppy", Convert.ToByte(sloppy.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Transforms a vector of brain.SequenceExample protos (as strings) into typed tensors.
		/// </summary>
		/// <param name="serialized">
		///   A vector containing binary serialized SequenceExample protos.
		/// </param>
		/// <param name="debug_name">
		///   A vector containing the names of the serialized protos.
		///   May contain, for example, table key (descriptive) name for the
		///   corresponding serialized proto.  This is purely useful for debugging
		///   purposes, and the presence of values here has no effect on the output.
		///   May also be an empty vector if no name is available.
		/// </param>
		/// <param name="context_dense_defaults">
		///   A list of Ncontext_dense Tensors (some may be empty).
		///   context_dense_defaults[j] provides default values
		///   when the SequenceExample's context map lacks context_dense_key[j].
		///   If an empty Tensor is provided for context_dense_defaults[j],
		///   then the Feature context_dense_keys[j] is required.
		///   The input type is inferred from context_dense_defaults[j], even when it's
		///   empty.  If context_dense_defaults[j] is not empty, its shape must match
		///   context_dense_shapes[j].
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ParseSequenceExample'.
		/// </param>
		/// <param name="Ncontext_sparse">
		///   Optional argument
		/// </param>
		/// <param name="Ncontext_dense">
		///   Optional argument
		/// </param>
		/// <param name="Nfeature_list_sparse">
		///   Optional argument
		/// </param>
		/// <param name="Nfeature_list_dense">
		///   Optional argument
		/// </param>
		/// <param name="context_sparse_types">
		///   Optional argument
		///   A list of Ncontext_sparse types; the data types of data in
		///   each context Feature given in context_sparse_keys.
		///   Currently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),
		///   DT_INT64 (Int64List), and DT_STRING (BytesList).
		/// </param>
		/// <param name="feature_list_dense_types">
		///   Optional argument
		/// </param>
		/// <param name="context_dense_shapes">
		///   Optional argument
		///   A list of Ncontext_dense shapes; the shapes of data in
		///   each context Feature given in context_dense_keys.
		///   The number of elements in the Feature corresponding to context_dense_key[j]
		///   must always equal context_dense_shapes[j].NumEntries().
		///   The shape of context_dense_values[j] will match context_dense_shapes[j].
		/// </param>
		/// <param name="feature_list_sparse_types">
		///   Optional argument
		///   A list of Nfeature_list_sparse types; the data types
		///   of data in each FeatureList given in feature_list_sparse_keys.
		///   Currently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),
		///   DT_INT64 (Int64List), and DT_STRING (BytesList).
		/// </param>
		/// <param name="feature_list_dense_shapes">
		///   Optional argument
		///   A list of Nfeature_list_dense shapes; the shapes of
		///   data in each FeatureList given in feature_list_dense_keys.
		///   The shape of each Feature in the FeatureList corresponding to
		///   feature_list_dense_key[j] must always equal
		///   feature_list_dense_shapes[j].NumEntries().
		/// </param>
		/// <param name="feature_list_dense_missing_assumed_empty">
		///   A vector listing the
		///   FeatureList keys which may be missing from the SequenceExamples.  If the
		///   associated FeatureList is missing, it is treated as empty.  By default,
		///   any FeatureList not listed in this vector must exist in the SequenceExamples.
		/// </param>
		/// <param name="context_sparse_keys">
		///   A list of Ncontext_sparse string Tensors (scalars).
		///   The keys expected in the Examples' features associated with context_sparse
		///   values.
		/// </param>
		/// <param name="context_dense_keys">
		///   A list of Ncontext_dense string Tensors (scalars).
		///   The keys expected in the SequenceExamples' context features associated with
		///   dense values.
		/// </param>
		/// <param name="feature_list_sparse_keys">
		///   A list of Nfeature_list_sparse string Tensors
		///   (scalars).  The keys expected in the FeatureLists associated with sparse
		///   values.
		/// </param>
		/// <param name="feature_list_dense_keys">
		///   A list of Nfeature_list_dense string Tensors (scalars).
		///   The keys expected in the SequenceExamples' feature_lists associated
		///   with lists of dense values.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   context_sparse_indices:
		///   context_sparse_values:
		///   context_sparse_shapes:
		///   context_dense_values:
		///   feature_list_sparse_indices:
		///   feature_list_sparse_values:
		///   feature_list_sparse_shapes:
		///   feature_list_dense_values:
		///   feature_list_dense_lengths:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output[] context_sparse_indices, TF_Output[] context_sparse_values, TF_Output[] context_sparse_shapes, TF_Output[] context_dense_values, TF_Output[] feature_list_sparse_indices, TF_Output[] feature_list_sparse_values, TF_Output[] feature_list_sparse_shapes, TF_Output[] feature_list_dense_values, TF_Output[] feature_list_dense_lengths) ParseSequenceExample (TF_Output serialized, TF_Output debug_name, TF_Output[] context_dense_defaults, string[] feature_list_dense_missing_assumed_empty, string[] context_sparse_keys, string[] context_dense_keys, string[] feature_list_sparse_keys, string[] feature_list_dense_keys, long? Ncontext_sparse = null, long? Ncontext_dense = null, long? Nfeature_list_sparse = null, long? Nfeature_list_dense = null, TF_DataType[] context_sparse_types = null, TF_DataType[] feature_list_dense_types = null, long[][] context_dense_shapes = null, TF_DataType[] feature_list_sparse_types = null, long[][] feature_list_dense_shapes = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ParseSequenceExample", MakeName ("ParseSequenceExample", operName));
			c_api.TF_AddInput(desc, serialized);
			c_api.TF_AddInput(desc, debug_name);
			c_api.TF_AddInputList(desc, context_dense_defaults[0], context_dense_defaults.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrStringList (desc, "feature_list_dense_missing_assumed_empty", feature_list_dense_missing_assumed_empty);
			c_api.TF_SetAttrStringList (desc, "context_sparse_keys", context_sparse_keys);
			c_api.TF_SetAttrStringList (desc, "context_dense_keys", context_dense_keys);
			c_api.TF_SetAttrStringList (desc, "feature_list_sparse_keys", feature_list_sparse_keys);
			c_api.TF_SetAttrStringList (desc, "feature_list_dense_keys", feature_list_dense_keys);
			if (Ncontext_sparse.HasValue)
				c_api.TF_SetAttrInt (desc, "Ncontext_sparse", Ncontext_sparse.Value);
			
			if (Ncontext_dense.HasValue)
				c_api.TF_SetAttrInt (desc, "Ncontext_dense", Ncontext_dense.Value);
			
			if (Nfeature_list_sparse.HasValue)
				c_api.TF_SetAttrInt (desc, "Nfeature_list_sparse", Nfeature_list_sparse.Value);
			
			if (Nfeature_list_dense.HasValue)
				c_api.TF_SetAttrInt (desc, "Nfeature_list_dense", Nfeature_list_dense.Value);
			
			if (context_sparse_types != null)
				c_api.TF_SetAttrTypeList (desc, "context_sparse_types", context_sparse_types);
			
			if (feature_list_dense_types != null)
				c_api.TF_SetAttrTypeList (desc, "feature_list_dense_types", feature_list_dense_types);
			
			if (context_dense_shapes != null)
				c_api.TF_SetAttrShapeList (desc, "context_dense_shapes", context_dense_shapes);
			
			if (feature_list_sparse_types != null)
				c_api.TF_SetAttrTypeList (desc, "feature_list_sparse_types", feature_list_sparse_types);
			
			if (feature_list_dense_shapes != null)
				c_api.TF_SetAttrShapeList (desc, "feature_list_dense_shapes", feature_list_dense_shapes);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "context_sparse_indices", status);
			var context_sparse_indices = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				context_sparse_indices [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "context_sparse_values", status);
			var context_sparse_values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				context_sparse_values [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "context_sparse_shapes", status);
			var context_sparse_shapes = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				context_sparse_shapes [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "context_dense_values", status);
			var context_dense_values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				context_dense_values [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "feature_list_sparse_indices", status);
			var feature_list_sparse_indices = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				feature_list_sparse_indices [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "feature_list_sparse_values", status);
			var feature_list_sparse_values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				feature_list_sparse_values [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "feature_list_sparse_shapes", status);
			var feature_list_sparse_shapes = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				feature_list_sparse_shapes [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "feature_list_dense_values", status);
			var feature_list_dense_values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				feature_list_dense_values [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "feature_list_dense_lengths", status);
			var feature_list_dense_lengths = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				feature_list_dense_lengths [i] = new TF_Output (op, _idx++);
			
			return (context_sparse_indices, context_sparse_values, context_sparse_shapes, context_dense_values, feature_list_sparse_indices, feature_list_sparse_values, feature_list_sparse_shapes, feature_list_dense_values, feature_list_dense_lengths);
		}

		/// <summary>
		///   Transforms a tf.Example proto (as a string) into typed tensors.
		/// </summary>
		/// <param name="serialized">
		///   A vector containing a batch of binary serialized Example protos.
		/// </param>
		/// <param name="dense_defaults">
		///   A list of Tensors (some may be empty), whose length matches
		///   the length of <c>dense_keys</c>. dense_defaults[j] provides default values
		///   when the example's feature_map lacks dense_key[j].  If an empty Tensor is
		///   provided for dense_defaults[j], then the Feature dense_keys[j] is required.
		///   The input type is inferred from dense_defaults[j], even when it's empty.
		///   If dense_defaults[j] is not empty, and dense_shapes[j] is fully defined,
		///   then the shape of dense_defaults[j] must match that of dense_shapes[j].
		///   If dense_shapes[j] has an undefined major dimension (variable strides dense
		///   feature), dense_defaults[j] must contain a single element:
		///   the padding element.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ParseSingleExample'.
		/// </param>
		/// <param name="num_sparse">
		///   The number of sparse features to be parsed from the example. This
		///   must match the lengths of <c>sparse_keys</c> and <c>sparse_types</c>.
		/// </param>
		/// <param name="sparse_keys">
		///   A list of <c>num_sparse</c> strings.
		///   The keys expected in the Examples' features associated with sparse values.
		/// </param>
		/// <param name="dense_keys">
		///   The keys expected in the Examples' features associated with dense
		///   values.
		/// </param>
		/// <param name="sparse_types">
		///   A list of <c>num_sparse</c> types; the data types of data in each
		///   Feature given in sparse_keys.
		///   Currently the ParseSingleExample op supports DT_FLOAT (FloatList),
		///   DT_INT64 (Int64List), and DT_STRING (BytesList).
		/// </param>
		/// <param name="dense_shapes">
		///   The shapes of data in each Feature given in dense_keys.
		///   The length of this list must match the length of <c>dense_keys</c>.  The
		///   number of elements in the Feature corresponding to dense_key[j] must
		///   always equal dense_shapes[j].NumEntries().  If dense_shapes[j] ==
		///   (D0, D1, ..., DN) then the shape of output Tensor dense_values[j]
		///   will be (D0, D1, ..., DN): In the case dense_shapes[j] = (-1, D1,
		///   ..., DN), the shape of the output Tensor dense_values[j] will be (M,
		///   D1, .., DN), where M is the number of blocks of elements of length
		///   D1 * .... * DN, in the input.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sparse_indices:
		///   sparse_values:
		///   sparse_shapes:
		///   dense_values:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output[] sparse_indices, TF_Output[] sparse_values, TF_Output[] sparse_shapes, TF_Output[] dense_values) ParseSingleExample (TF_Output serialized, TF_Output[] dense_defaults, long num_sparse, string[] sparse_keys, string[] dense_keys, TF_DataType[] sparse_types, long[][] dense_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ParseSingleExample", MakeName ("ParseSingleExample", operName));
			c_api.TF_AddInput(desc, serialized);
			c_api.TF_AddInputList(desc, dense_defaults[0], dense_defaults.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_sparse", num_sparse);
			c_api.TF_SetAttrStringList (desc, "sparse_keys", sparse_keys);
			c_api.TF_SetAttrStringList (desc, "dense_keys", dense_keys);
			c_api.TF_SetAttrTypeList (desc, "sparse_types", sparse_types);
			c_api.TF_SetAttrShapeList (desc, "dense_shapes", dense_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "sparse_indices", status);
			var sparse_indices = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				sparse_indices [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "sparse_values", status);
			var sparse_values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				sparse_values [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "sparse_shapes", status);
			var sparse_shapes = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				sparse_shapes [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "dense_values", status);
			var dense_values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				dense_values [i] = new TF_Output (op, _idx++);
			
			return (sparse_indices, sparse_values, sparse_shapes, dense_values);
		}

		/// <summary>
		///   Transforms a scalar brain.SequenceExample proto (as strings) into typed tensors.
		/// </summary>
		/// <param name="serialized">
		///   A scalar containing a binary serialized SequenceExample proto.
		/// </param>
		/// <param name="feature_list_dense_missing_assumed_empty">
		///   A vector listing the
		///   FeatureList keys which may be missing from the SequenceExample.  If the
		///   associated FeatureList is missing, it is treated as empty.  By default,
		///   any FeatureList not listed in this vector must exist in the SequenceExample.
		/// </param>
		/// <param name="context_sparse_keys">
		///   A list of Ncontext_sparse string Tensors (scalars).
		///   The keys expected in the Examples' features associated with context_sparse
		///   values.
		/// </param>
		/// <param name="context_dense_keys">
		///   A list of Ncontext_dense string Tensors (scalars).
		///   The keys expected in the SequenceExamples' context features associated with
		///   dense values.
		/// </param>
		/// <param name="feature_list_sparse_keys">
		///   A list of Nfeature_list_sparse string Tensors
		///   (scalars).  The keys expected in the FeatureLists associated with sparse
		///   values.
		/// </param>
		/// <param name="feature_list_dense_keys">
		///   A list of Nfeature_list_dense string Tensors (scalars).
		///   The keys expected in the SequenceExamples' feature_lists associated
		///   with lists of dense values.
		/// </param>
		/// <param name="context_dense_defaults">
		///   A list of Ncontext_dense Tensors (some may be empty).
		///   context_dense_defaults[j] provides default values
		///   when the SequenceExample's context map lacks context_dense_key[j].
		///   If an empty Tensor is provided for context_dense_defaults[j],
		///   then the Feature context_dense_keys[j] is required.
		///   The input type is inferred from context_dense_defaults[j], even when it's
		///   empty.  If context_dense_defaults[j] is not empty, its shape must match
		///   context_dense_shapes[j].
		/// </param>
		/// <param name="debug_name">
		///   A scalar containing the name of the serialized proto.
		///   May contain, for example, table key (descriptive) name for the
		///   corresponding serialized proto.  This is purely useful for debugging
		///   purposes, and the presence of values here has no effect on the output.
		///   May also be an empty scalar if no name is available.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ParseSingleSequenceExample'.
		/// </param>
		/// <param name="context_sparse_types">
		///   Optional argument
		///   A list of Ncontext_sparse types; the data types of data in
		///   each context Feature given in context_sparse_keys.
		///   Currently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),
		///   DT_INT64 (Int64List), and DT_STRING (BytesList).
		/// </param>
		/// <param name="feature_list_dense_types">
		///   Optional argument
		/// </param>
		/// <param name="context_dense_shapes">
		///   Optional argument
		///   A list of Ncontext_dense shapes; the shapes of data in
		///   each context Feature given in context_dense_keys.
		///   The number of elements in the Feature corresponding to context_dense_key[j]
		///   must always equal context_dense_shapes[j].NumEntries().
		///   The shape of context_dense_values[j] will match context_dense_shapes[j].
		/// </param>
		/// <param name="feature_list_sparse_types">
		///   Optional argument
		///   A list of Nfeature_list_sparse types; the data types
		///   of data in each FeatureList given in feature_list_sparse_keys.
		///   Currently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),
		///   DT_INT64 (Int64List), and DT_STRING (BytesList).
		/// </param>
		/// <param name="feature_list_dense_shapes">
		///   Optional argument
		///   A list of Nfeature_list_dense shapes; the shapes of
		///   data in each FeatureList given in feature_list_dense_keys.
		///   The shape of each Feature in the FeatureList corresponding to
		///   feature_list_dense_key[j] must always equal
		///   feature_list_dense_shapes[j].NumEntries().
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   context_sparse_indices:
		///   context_sparse_values:
		///   context_sparse_shapes:
		///   context_dense_values:
		///   feature_list_sparse_indices:
		///   feature_list_sparse_values:
		///   feature_list_sparse_shapes:
		///   feature_list_dense_values:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output[] context_sparse_indices, TF_Output[] context_sparse_values, TF_Output[] context_sparse_shapes, TF_Output[] context_dense_values, TF_Output[] feature_list_sparse_indices, TF_Output[] feature_list_sparse_values, TF_Output[] feature_list_sparse_shapes, TF_Output[] feature_list_dense_values) ParseSingleSequenceExample (TF_Output serialized, TF_Output feature_list_dense_missing_assumed_empty, TF_Output[] context_sparse_keys, TF_Output[] context_dense_keys, TF_Output[] feature_list_sparse_keys, TF_Output[] feature_list_dense_keys, TF_Output[] context_dense_defaults, TF_Output debug_name, TF_DataType[] context_sparse_types = null, TF_DataType[] feature_list_dense_types = null, long[][] context_dense_shapes = null, TF_DataType[] feature_list_sparse_types = null, long[][] feature_list_dense_shapes = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ParseSingleSequenceExample", MakeName ("ParseSingleSequenceExample", operName));
			c_api.TF_AddInput(desc, serialized);
			c_api.TF_AddInput(desc, feature_list_dense_missing_assumed_empty);
			c_api.TF_AddInputList(desc, context_sparse_keys[0], context_sparse_keys.Length);
			c_api.TF_AddInputList(desc, context_dense_keys[0], context_dense_keys.Length);
			c_api.TF_AddInputList(desc, feature_list_sparse_keys[0], feature_list_sparse_keys.Length);
			c_api.TF_AddInputList(desc, feature_list_dense_keys[0], feature_list_dense_keys.Length);
			c_api.TF_AddInputList(desc, context_dense_defaults[0], context_dense_defaults.Length);
			c_api.TF_AddInput(desc, debug_name);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (context_sparse_types != null)
				c_api.TF_SetAttrTypeList (desc, "context_sparse_types", context_sparse_types);
			
			if (feature_list_dense_types != null)
				c_api.TF_SetAttrTypeList (desc, "feature_list_dense_types", feature_list_dense_types);
			
			if (context_dense_shapes != null)
				c_api.TF_SetAttrShapeList (desc, "context_dense_shapes", context_dense_shapes);
			
			if (feature_list_sparse_types != null)
				c_api.TF_SetAttrTypeList (desc, "feature_list_sparse_types", feature_list_sparse_types);
			
			if (feature_list_dense_shapes != null)
				c_api.TF_SetAttrShapeList (desc, "feature_list_dense_shapes", feature_list_dense_shapes);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "context_sparse_indices", status);
			var context_sparse_indices = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				context_sparse_indices [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "context_sparse_values", status);
			var context_sparse_values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				context_sparse_values [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "context_sparse_shapes", status);
			var context_sparse_shapes = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				context_sparse_shapes [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "context_dense_values", status);
			var context_dense_values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				context_dense_values [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "feature_list_sparse_indices", status);
			var feature_list_sparse_indices = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				feature_list_sparse_indices [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "feature_list_sparse_values", status);
			var feature_list_sparse_values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				feature_list_sparse_values [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "feature_list_sparse_shapes", status);
			var feature_list_sparse_shapes = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				feature_list_sparse_shapes [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "feature_list_dense_values", status);
			var feature_list_dense_values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				feature_list_dense_values [i] = new TF_Output (op, _idx++);
			
			return (context_sparse_indices, context_sparse_values, context_sparse_shapes, context_dense_values, feature_list_sparse_indices, feature_list_sparse_values, feature_list_sparse_shapes, feature_list_dense_values);
		}

		/// <summary>
		///   Transforms a serialized tensorflow.TensorProto proto into a Tensor.
		/// </summary>
		/// <param name="serialized">
		///   A scalar string containing a serialized TensorProto proto.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ParseTensor'.
		/// </param>
		/// <param name="out_type">
		///   The type of the serialized tensor.  The provided type must match the
		///   type of the serialized tensor and no implicit conversion will take place.
		/// </param>
		/// <returns>
		///   A Tensor of type <c>out_type</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ParseTensor (TF_Output serialized, TF_DataType out_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ParseTensor", MakeName ("ParseTensor", operName));
			c_api.TF_AddInput(desc, serialized);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "out_type", out_type);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   returns <c>f(inputs)</c>, where <c>f</c>'s body is placed and partitioned.
		/// </summary>
		/// <param name="args">
		///   A list of input tensors.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PartitionedCall'.
		/// </param>
		/// <param name="config">
		///   Optional argument
		/// </param>
		/// <param name="config_proto">
		///   Optional argument
		/// </param>
		/// <param name="executor_type">
		///   Optional argument
		/// </param>
		/// <param name="Tout">
		///   A list of output types.
		/// </param>
		/// <param name="f">
		///   A function that takes 'args', a list of tensors, and returns 'output',
		///   another list of tensors. Input and output types are specified by 'Tin'
		///   and 'Tout'. The function body of f will be placed and partitioned across
		///   devices, setting this op apart from the regular Call op.
		/// </param>
		/// <returns>
		///   A list of return values.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] PartitionedCall (TF_Output[] args, TF_DataType[] Tout, TF_Function f, string config = null, string config_proto = null, string executor_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PartitionedCall", MakeName ("PartitionedCall", operName));
			c_api.TF_AddInputList(desc, args[0], args.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "Tout", Tout);
			c_api.TF_SetAttrFuncName (desc, "f", c_api.TF_FunctionName(f));
			if (config != null)
				c_api.TF_SetAttrString (desc, "config", config);
			
			if (config_proto != null)
				c_api.TF_SetAttrString (desc, "config_proto", config_proto);
			
			if (executor_type != null)
				c_api.TF_SetAttrString (desc, "executor_type", executor_type);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		///   A placeholder op for a value that will be fed into the computation.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Placeholder'.
		/// </param>
		/// <param name="shape">
		///   Optional argument
		///   (Optional) The shape of the tensor. If the shape has 0 dimensions, the
		///   shape is unconstrained.
		/// </param>
		/// <param name="dtype">
		///   The type of elements in the tensor.
		/// </param>
		/// <returns>
		///   A placeholder tensor that must be replaced using the feed mechanism.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   N.B. This operation will fail with an error if it is executed. It is
		///   intended as a way to represent a value that will always be fed, and to
		///   provide attrs that enable the fed value to be checked at runtime.
		/// </remarks>
		public TF_Output Placeholder (TF_DataType dtype, long[] shape = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Placeholder", MakeName ("Placeholder", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (shape != null)
				c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   A placeholder op for a value that will be fed into the computation.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PlaceholderV2'.
		/// </param>
		/// <param name="dtype">
		///   The type of elements in the tensor.
		/// </param>
		/// <param name="shape">
		///   The shape of the tensor. The shape can be any partially-specified
		///   shape.  To be unconstrained, pass in a shape with unknown rank.
		/// </param>
		/// <returns>
		///   A placeholder tensor that must be replaced using the feed mechanism.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   N.B. This operation will fail with an error if it is executed. It is
		///   intended as a way to represent a value that will always be fed, and to
		///   provide attrs that enable the fed value to be checked at runtime.
		/// </remarks>
		public TF_Output PlaceholderV2 (TF_DataType dtype, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PlaceholderV2", MakeName ("PlaceholderV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   A placeholder op that passes through <c>input</c> when its output is not fed.
		/// </summary>
		/// <param name="input">
		///   The default value to produce when <c>output</c> is not fed.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PlaceholderWithDefault'.
		/// </param>
		/// <param name="shape">
		///   The (possibly partial) shape of the tensor.
		/// </param>
		/// <returns>
		///   A placeholder tensor that defaults to <c>input</c> if it is not fed.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output PlaceholderWithDefault (TF_Output input, long[] shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PlaceholderWithDefault", MakeName ("PlaceholderWithDefault", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Compute the polygamma function \\(\psi^{(n)}(x)\\).
		/// </summary>
		/// <param name="a">
		/// </param>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Polygamma'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The polygamma function is defined as:
		///   
		///   
		///   \\(\psi^{(a)}(x) = \frac{d^a}{dx^a} \psi(x)\\)
		///   
		///   where \\(\psi(x)\\) is the digamma function.
		///   The polygamma function is defined only for non-negative integer orders \\a\\.
		/// </remarks>
		public TF_Output Polygamma (TF_Output a, TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Polygamma", MakeName ("Polygamma", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Computes element-wise population count (a.k.a. popcount, bitsum, bitcount).
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PopulationCount'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   For each entry in <c>x</c>, calculates the number of <c>1</c> (on) bits in the binary
		///   representation of that entry.
		///   
		///   **NOTE**: It is more efficient to first <c>tf.bitcast</c> your tensors into
		///   <c>int32</c> or <c>int64</c> and perform the bitcount on the result, than to feed in
		///   8- or 16-bit inputs and then aggregate the resulting counts.
		/// </remarks>
		public TF_Output PopulationCount (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PopulationCount", MakeName ("PopulationCount", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes the power of one value to another.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Pow'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given a tensor <c>x</c> and a tensor <c>y</c>, this operation computes \\(x^y\\) for
		///   corresponding elements in <c>x</c> and <c>y</c>. For example:
		///   
		///    <code>
		///   # tensor 'x' is [[2, 2]], [3, 3]]
		///   # tensor 'y' is [[8, 16], [2, 3]]
		///   tf.pow(x, y) ==&amp;gt; [[256, 65536], [9, 27]]
		///    </code>
		/// </remarks>
		public TF_Output Pow (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Pow", MakeName ("Pow", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Creates a dataset that asynchronously prefetches elements from <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="buffer_size">
		///   The maximum number of elements to buffer in an iterator over
		///   this dataset.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PrefetchDataset'.
		/// </param>
		/// <param name="slack_period">
		///   Optional argument
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output PrefetchDataset (TF_Output input_dataset, TF_Output buffer_size, TF_DataType[] output_types, long[][] output_shapes, long? slack_period = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PrefetchDataset", MakeName ("PrefetchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, buffer_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (slack_period.HasValue)
				c_api.TF_SetAttrInt (desc, "slack_period", slack_period.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   An op which linearizes one Tensor value to an opaque variant tensor.
		/// </summary>
		/// <param name="input">
		///   A tensor that will be linearized.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Prelinearize'.
		/// </param>
		/// <param name="shape">
		///   Optional argument
		///   The shape of the tensor.
		/// </param>
		/// <param name="layout">
		///   Optional argument
		///   A vector holding the requested layout in minor-to-major sequence. If a layout
		///   attribute is passed but its values are all -1 the layout will be computed by
		///   the infeed operation.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Prelinearize (TF_Output input, long[] shape = null, long[] layout = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Prelinearize", MakeName ("Prelinearize", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (shape != null)
				c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			
			if (layout != null)
				c_api.TF_SetAttrIntList (desc, "layout", ref layout[0], layout.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   An op which linearizes multiple Tensor values to an opaque variant tensor.
		/// </summary>
		/// <param name="inputs">
		///   A list of tensors that will be provided using the infeed mechanism.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PrelinearizeTuple'.
		/// </param>
		/// <param name="layouts">
		///   Optional argument
		///   A vector holding the requested layout in minor-to-major sequence for all the
		///   tuple shapes in the order the shapes appear in the "shapes" input. The layout
		///   elements for a sub-shape can be set to -1 in which case the corresponding layout
		///   will be computed by the infeed operation.
		/// </param>
		/// <param name="shapes">
		///   The shapes of each tensor in <c>inputs</c>.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output PrelinearizeTuple (TF_Output[] inputs, long[][] shapes, long[] layouts = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PrelinearizeTuple", MakeName ("PrelinearizeTuple", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			if (layouts != null)
				c_api.TF_SetAttrIntList (desc, "layouts", ref layouts[0], layouts.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   An identity op that triggers an error if a gradient is requested.
		/// </summary>
		/// <param name="input">
		///   any tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PreventGradient'.
		/// </param>
		/// <param name="message">
		///   Optional argument
		///   Will be printed in the error when anyone tries to differentiate
		///   this operation.
		/// </param>
		/// <returns>
		///   the same input tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   When executed in a graph, this op outputs its input tensor as-is.
		///   
		///   When building ops to compute gradients, the TensorFlow gradient system
		///   will return an error when trying to lookup the gradient of this op,
		///   because no gradient must ever be registered for this function.  This
		///   op exists to prevent subtle bugs from silently returning unimplemented
		///   gradients in some corner cases.
		/// </remarks>
		public TF_Output PreventGradient (TF_Output input, string message = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PreventGradient", MakeName ("PreventGradient", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (message != null)
				c_api.TF_SetAttrString (desc, "message", message);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Prints a list of tensors.
		/// </summary>
		/// <param name="input">
		///   The tensor passed to <c>output</c>
		/// </param>
		/// <param name="data">
		///   A list of tensors to print out when op is evaluated.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Print'.
		/// </param>
		/// <param name="message">
		///   Optional argument
		///   A string, prefix of the error message.
		/// </param>
		/// <param name="first_n">
		///   Optional argument
		///   Only log <c>first_n</c> number of times. -1 disables logging.
		/// </param>
		/// <param name="summarize">
		///   Optional argument
		///   Only print this many entries of each tensor.
		/// </param>
		/// <returns>
		///   = The unmodified <c>input</c> tensor
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Passes <c>input</c> through to <c>output</c> and prints <c>data</c> when evaluating.
		/// </remarks>
		public TF_Output Print (TF_Output input, TF_Output[] data, string message = null, long? first_n = null, long? summarize = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Print", MakeName ("Print", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInputList(desc, data[0], data.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (message != null)
				c_api.TF_SetAttrString (desc, "message", message);
			
			if (first_n.HasValue)
				c_api.TF_SetAttrInt (desc, "first_n", first_n.Value);
			
			if (summarize.HasValue)
				c_api.TF_SetAttrInt (desc, "summarize", summarize.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Prints a string scalar.
		/// </summary>
		/// <param name="input">
		///   The string scalar to print.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PrintV2'.
		/// </param>
		/// <param name="output_stream">
		///   Optional argument
		///   A string specifying the output stream or logging level to print to.
		/// </param>
		/// <param name="end">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   Prints a string scalar to the desired output_stream.
		/// </remarks>
		public TF_Operation PrintV2 (TF_Output input, string output_stream = null, string end = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PrintV2", MakeName ("PrintV2", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (output_stream != null)
				c_api.TF_SetAttrString (desc, "output_stream", output_stream);
			
			if (end != null)
				c_api.TF_SetAttrString (desc, "end", end);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   A queue that produces elements sorted by the first component value.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PriorityQueue'.
		/// </param>
		/// <param name="component_types">
		///   Optional argument
		///   The type of each component in a value.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		///   The upper bound on the number of elements in this queue.
		///   Negative numbers mean no limit.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this queue is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this queue will be shared under the given name
		///   across multiple sessions.
		/// </param>
		/// <param name="shapes">
		///   The shape of each component in a value. The length of this attr must
		///   be either 0 or the same as the length of component_types. If the length of
		///   this attr is 0, the shapes of queue elements are not constrained, and
		///   only one element may be dequeued at a time.
		/// </param>
		/// <returns>
		///   The handle to the queue.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Note that the PriorityQueue requires the first component of any element
		///   to be a scalar int64, in addition to the other elements declared by
		///   component_types.  Therefore calls to Enqueue and EnqueueMany (resp. Dequeue
		///   and DequeueMany) on a PriorityQueue will all require (resp. output) one extra
		///   entry in their input (resp. output) lists.
		/// </remarks>
		public TF_Output PriorityQueue (long[][] shapes, TF_DataType[] component_types = null, long? capacity = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PriorityQueue", MakeName ("PriorityQueue", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			if (component_types != null)
				c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   A queue that produces elements sorted by the first component value.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PriorityQueueV2'.
		/// </param>
		/// <param name="component_types">
		///   Optional argument
		///   The type of each component in a value.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		///   The upper bound on the number of elements in this queue.
		///   Negative numbers mean no limit.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this queue is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this queue will be shared under the given name
		///   across multiple sessions.
		/// </param>
		/// <param name="shapes">
		///   The shape of each component in a value. The length of this attr must
		///   be either 0 or the same as the length of component_types. If the length of
		///   this attr is 0, the shapes of queue elements are not constrained, and
		///   only one element may be dequeued at a time.
		/// </param>
		/// <returns>
		///   The handle to the queue.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Note that the PriorityQueue requires the first component of any element
		///   to be a scalar int64, in addition to the other elements declared by
		///   component_types.  Therefore calls to Enqueue and EnqueueMany (resp. Dequeue
		///   and DequeueMany) on a PriorityQueue will all require (resp. output) one extra
		///   entry in their input (resp. output) lists.
		/// </remarks>
		public TF_Output PriorityQueueV2 (long[][] shapes, TF_DataType[] component_types = null, long? capacity = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PriorityQueueV2", MakeName ("PriorityQueueV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			if (component_types != null)
				c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that uses a custom thread pool to compute <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="num_threads">
		///   Identifies the number of threads to use for the private threadpool.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PrivateThreadPoolDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output PrivateThreadPoolDataset (TF_Output input_dataset, TF_Output num_threads, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PrivateThreadPoolDataset", MakeName ("PrivateThreadPoolDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, num_threads);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Computes the product of elements across dimensions of a tensor.
		/// </summary>
		/// <param name="input">
		///   The tensor to reduce.
		/// </param>
		/// <param name="reduction_indices">
		///   The dimensions to reduce. Must be in the range
		///   <c>[-rank(input), rank(input))</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Prod'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		///   If true, retain reduced dimensions with length 1.
		/// </param>
		/// <returns>
		///   The reduced tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Reduces <c>input</c> along the dimensions given in <c>axis</c>. Unless
		///   <c>keep_dims</c> is true, the rank of the tensor is reduced by 1 for each entry in
		///   <c>axis</c>. If <c>keep_dims</c> is true, the reduced dimensions are
		///   retained with length 1.
		/// </remarks>
		public TF_Output Prod (TF_Output input, TF_Output reduction_indices, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Prod", MakeName ("Prod", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, reduction_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Invokes a python function to compute func(input)-&amp;gt;output.
		/// </summary>
		/// <param name="input">
		///   List of Tensors that will provide input to the Op.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PyFunc'.
		/// </param>
		/// <param name="token">
		///   A token representing a registered python function in this address space.
		/// </param>
		/// <param name="Tout">
		///   Data types of the outputs from the op.
		///   The length of the list specifies the number of outputs.
		/// </param>
		/// <returns>
		///   The outputs from the Op.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation is considered stateful. For a stateless version, see
		///   PyFuncStateless.
		/// </remarks>
		public TF_Output[] PyFunc (TF_Output[] input, string token, TF_DataType[] Tout, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PyFunc", MakeName ("PyFunc", operName));
			c_api.TF_AddInputList(desc, input[0], input.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "token", token);
			c_api.TF_SetAttrTypeList (desc, "Tout", Tout);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		///   A stateless version of PyFunc.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'PyFuncStateless'.
		/// </param>
		/// <param name="token">
		/// </param>
		/// <param name="Tout">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] PyFuncStateless (TF_Output[] input, string token, TF_DataType[] Tout, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "PyFuncStateless", MakeName ("PyFuncStateless", operName));
			c_api.TF_AddInputList(desc, input[0], input.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "token", token);
			c_api.TF_SetAttrTypeList (desc, "Tout", Tout);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		///   Computes the QR decompositions of one or more matrices.
		/// </summary>
		/// <param name="input">
		///   A tensor of shape <c>[..., M, N]</c> whose inner-most 2 dimensions
		///   form matrices of size <c>[M, N]</c>. Let <c>P</c> be the minimum of <c>M</c> and <c>N</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Qr'.
		/// </param>
		/// <param name="full_matrices">
		///   Optional argument
		///   If true, compute full-sized <c>q</c> and <c>r</c>. If false
		///   (the default), compute only the leading <c>P</c> columns of <c>q</c>.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   q: Orthonormal basis for range of <c>a</c>. If <c>full_matrices</c> is <c>False</c> then
		///   shape is <c>[..., M, P]</c>; if <c>full_matrices</c> is <c>True</c> then shape is
		///   <c>[..., M, M]</c>.
		///   r: Triangular factor. If <c>full_matrices</c> is <c>False</c> then shape is
		///   <c>[..., P, N]</c>. If <c>full_matrices</c> is <c>True</c> then shape is <c>[..., M, N]</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Computes the QR decomposition of each inner matrix in <c>tensor</c> such that
		///   <c>tensor[..., :, :] = q[..., :, :] * r[..., :,:])</c>
		///   
		///    <code>
		///   # a is a tensor.
		///   # q is a tensor of orthonormal matrices.
		///   # r is a tensor of upper triangular matrices.
		///   q, r = qr(a)
		///   q_full, r_full = qr(a, full_matrices=True)
		///    </code>
		/// </remarks>
		public (TF_Output q, TF_Output r) Qr (TF_Output input, bool? full_matrices = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Qr", MakeName ("Qr", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (full_matrices.HasValue)
				c_api.TF_SetAttrBool (desc, "full_matrices", Convert.ToByte(full_matrices.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var q = new TF_Output (op, _idx++);
			var r = new TF_Output (op, _idx++);
			return (q, r);
		}

		/// <summary>
		///   Use QuantizeAndDequantizeV2 instead.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizeAndDequantize'.
		/// </param>
		/// <param name="signed_input">
		///   Optional argument
		/// </param>
		/// <param name="num_bits">
		///   Optional argument
		/// </param>
		/// <param name="range_given">
		///   Optional argument
		/// </param>
		/// <param name="input_min">
		///   Optional argument
		/// </param>
		/// <param name="input_max">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output QuantizeAndDequantize (TF_Output input, bool? signed_input = null, long? num_bits = null, bool? range_given = null, float? input_min = null, float? input_max = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizeAndDequantize", MakeName ("QuantizeAndDequantize", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (signed_input.HasValue)
				c_api.TF_SetAttrBool (desc, "signed_input", Convert.ToByte(signed_input.Value));
			
			if (num_bits.HasValue)
				c_api.TF_SetAttrInt (desc, "num_bits", num_bits.Value);
			
			if (range_given.HasValue)
				c_api.TF_SetAttrBool (desc, "range_given", Convert.ToByte(range_given.Value));
			
			if (input_min.HasValue)
				c_api.TF_SetAttrFloat (desc, "input_min", input_min.Value);
			
			if (input_max.HasValue)
				c_api.TF_SetAttrFloat (desc, "input_max", input_max.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Quantizes then dequantizes a tensor.
		/// </summary>
		/// <param name="input">
		///   Tensor to quantize and then dequantize.
		/// </param>
		/// <param name="input_min">
		///   If <c>range_given == True</c>, this specifies the minimum input value that needs to
		///   be represented, otherwise it is determined from the min value of the <c>input</c>
		///   tensor.
		/// </param>
		/// <param name="input_max">
		///   If <c>range_given == True</c>, this specifies the maximum input value that needs to
		///   be represented, otherwise it is determined from the max value of the <c>input</c>
		///   tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizeAndDequantizeV2'.
		/// </param>
		/// <param name="signed_input">
		///   Optional argument
		///   Whether the quantization is signed or unsigned. (actually this parameter should
		///   have been called &amp;lt;b&amp;gt;<c>signed_output</c>&amp;lt;/b&amp;gt;)
		/// </param>
		/// <param name="num_bits">
		///   Optional argument
		///   The bitwidth of the quantization.
		/// </param>
		/// <param name="range_given">
		///   Optional argument
		///   Whether the range is given or should be determined from the <c>input</c> tensor.
		/// </param>
		/// <param name="round_mode">
		///   Optional argument
		///   The 'round_mode' attribute controls which rounding tie-breaking algorithm is
		///   used when rounding float values to their quantized equivalents. The following
		///   rounding modes are currently supported:
		///   
		///   *   HALF_TO_EVEN: this is the default round_mode.
		///   *   HALF_UP: round towards positive. In this mode 7.5 rounds up to 8 and -7.5
		///   rounds up to -7.
		///   
		/// </param>
		/// <param name="narrow_range">
		///   Optional argument
		///   If True, then the absolute value of the quantized minimum value is the same as
		///   the quantized maximum value, instead of 1 greater.
		///   i.e. for 8 bit quantization, the minimum value is -127 instead of -128.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op simulates the precision loss from the quantized forward pass by:
		///   
		///   1. Quantizing the tensor to fixed point numbers, which should match the target
		///   quantization method when it is used in inference.
		///   2. Dequantizing it back to floating point numbers for the following ops, most
		///   likely matmul.
		///   
		///   There are different ways to quantize. This version uses only scaling, so 0.0
		///   maps to 0.
		///   
		///   From the specified 'num_bits' in the quantized output type, it determines
		///   minimum and maximum representable quantized values.
		///   
		///   e.g.
		///   
		///   *   [-128, 127] for signed, num_bits = 8, or
		///   *   [0, 255] for unsigned, num_bits = 8.
		///   
		///   If range_given == False, the initial input_min, input_max will be determined
		///   automatically as the minimum and maximum values in the input tensor, otherwise
		///   the specified values of input_min, input_max are used.
		///   
		///   Note: If the input_min, input_max are specified, they do not need to equal the
		///   actual minimum and maximum values in the tensor. e.g. in some cases it may be
		///   beneficial to specify these values such that the low probability extremes of the
		///   input distribution are clipped.
		///   
		///   This op determines the maximum scale_factor that would map the initial
		///   [input_min, input_max] range to a range that lies within the representable
		///   quantized range.
		///   
		///   It determines the scale from one of input_min and input_max, then updates the
		///   other one to maximize the respresentable range.
		///   
		///   e.g.
		///   
		///   *   if the output is signed, num_bits = 8, [input_min, input_max] = [-10.0,
		///   5.0]: it would use a scale_factor of -128 / -10.0 = 12.8 In this case, it
		///   would update input_max to be 127 / 12.8 = 9.921875
		///   *   if the output is signed, num_bits = 8, [input_min, input_max] = [-10.0,
		///   10.0]: it would use a scale_factor of 127 / 10.0 = 12.7 In this case, it
		///   would update input_min to be 128.0 / 12.7 = -10.07874
		///   *   if the output is unsigned, input_min is forced to be 0, and only the
		///   specified input_max is used.
		///   
		///   After determining the scale_factor and updating the input range, it applies the
		///   following to each value in the 'input' tensor.
		///   
		///   output = round(clamp(value, input_min, input_max) * scale_factor) / scale_factor.
		///   
		///   The above round function rounds the value based on the given round_mode.
		///   
		/// </remarks>
		public TF_Output QuantizeAndDequantizeV2 (TF_Output input, TF_Output input_min, TF_Output input_max, bool? signed_input = null, long? num_bits = null, bool? range_given = null, string round_mode = null, bool? narrow_range = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizeAndDequantizeV2", MakeName ("QuantizeAndDequantizeV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_min);
			c_api.TF_AddInput(desc, input_max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (signed_input.HasValue)
				c_api.TF_SetAttrBool (desc, "signed_input", Convert.ToByte(signed_input.Value));
			
			if (num_bits.HasValue)
				c_api.TF_SetAttrInt (desc, "num_bits", num_bits.Value);
			
			if (range_given.HasValue)
				c_api.TF_SetAttrBool (desc, "range_given", Convert.ToByte(range_given.Value));
			
			if (round_mode != null)
				c_api.TF_SetAttrString (desc, "round_mode", round_mode);
			
			if (narrow_range.HasValue)
				c_api.TF_SetAttrBool (desc, "narrow_range", Convert.ToByte(narrow_range.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Quantizes then dequantizes a tensor.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_min">
		/// </param>
		/// <param name="input_max">
		/// </param>
		/// <param name="num_bits">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizeAndDequantizeV3'.
		/// </param>
		/// <param name="signed_input">
		///   Optional argument
		/// </param>
		/// <param name="range_given">
		///   Optional argument
		/// </param>
		/// <param name="narrow_range">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This is almost identical to QuantizeAndDequantizeV2, except that num_bits is a
		///   tensor, so its value can change during training.
		/// </remarks>
		public TF_Output QuantizeAndDequantizeV3 (TF_Output input, TF_Output input_min, TF_Output input_max, TF_Output num_bits, bool? signed_input = null, bool? range_given = null, bool? narrow_range = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizeAndDequantizeV3", MakeName ("QuantizeAndDequantizeV3", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_min);
			c_api.TF_AddInput(desc, input_max);
			c_api.TF_AddInput(desc, num_bits);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (signed_input.HasValue)
				c_api.TF_SetAttrBool (desc, "signed_input", Convert.ToByte(signed_input.Value));
			
			if (range_given.HasValue)
				c_api.TF_SetAttrBool (desc, "range_given", Convert.ToByte(range_given.Value));
			
			if (narrow_range.HasValue)
				c_api.TF_SetAttrBool (desc, "narrow_range", Convert.ToByte(narrow_range.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns x + y element-wise, working on quantized buffers.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="min_x">
		///   The float value that the lowest quantized <c>x</c> value represents.
		/// </param>
		/// <param name="max_x">
		///   The float value that the highest quantized <c>x</c> value represents.
		/// </param>
		/// <param name="min_y">
		///   The float value that the lowest quantized <c>y</c> value represents.
		/// </param>
		/// <param name="max_y">
		///   The float value that the highest quantized <c>y</c> value represents.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedAdd'.
		/// </param>
		/// <param name="Toutput">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   z:
		///   min_z: The float value that the lowest quantized output value represents.
		///   max_z: The float value that the highest quantized output value represents.
		///   
		///   *NOTE*: <c>QuantizedAdd</c> supports limited forms of broadcasting. More about
		///   broadcasting [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output z, TF_Output min_z, TF_Output max_z) QuantizedAdd (TF_Output x, TF_Output y, TF_Output min_x, TF_Output max_x, TF_Output min_y, TF_Output max_y, TF_DataType? Toutput = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedAdd", MakeName ("QuantizedAdd", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			c_api.TF_AddInput(desc, min_x);
			c_api.TF_AddInput(desc, max_x);
			c_api.TF_AddInput(desc, min_y);
			c_api.TF_AddInput(desc, max_y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Toutput.HasValue)
				c_api.TF_SetAttrType (desc, "Toutput", Toutput.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			var min_z = new TF_Output (op, _idx++);
			var max_z = new TF_Output (op, _idx++);
			return (z, min_z, max_z);
		}

		/// <summary>
		///   Produces the average pool of the input tensor for quantized types.
		/// </summary>
		/// <param name="input">
		///   4-D with shape <c>[batch, height, width, channels]</c>.
		/// </param>
		/// <param name="min_input">
		///   The float value that the lowest quantized input value represents.
		/// </param>
		/// <param name="max_input">
		///   The float value that the highest quantized input value represents.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedAvgPool'.
		/// </param>
		/// <param name="ksize">
		///   The size of the window for each dimension of the input tensor.
		///   The length must be 4 to match the number of dimensions of the input.
		/// </param>
		/// <param name="strides">
		///   The stride of the sliding window for each dimension of the input
		///   tensor.  The length must be 4 to match the number of dimensions of the input.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output: The float value that the lowest quantized output value represents.
		///   max_output: The float value that the highest quantized output value represents.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedAvgPool (TF_Output input, TF_Output min_input, TF_Output max_input, long[] ksize, long[] strides, string padding, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedAvgPool", MakeName ("QuantizedAvgPool", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		///   Quantized Batch normalization.
		/// </summary>
		/// <param name="t">
		///   A 4D input Tensor.
		/// </param>
		/// <param name="t_min">
		///   The value represented by the lowest quantized input.
		/// </param>
		/// <param name="t_max">
		///   The value represented by the highest quantized input.
		/// </param>
		/// <param name="m">
		///   A 1D mean Tensor with size matching the last dimension of t.
		///   This is the first output from tf.nn.moments,
		///   or a saved moving average thereof.
		/// </param>
		/// <param name="m_min">
		///   The value represented by the lowest quantized mean.
		/// </param>
		/// <param name="m_max">
		///   The value represented by the highest quantized mean.
		/// </param>
		/// <param name="v">
		///   A 1D variance Tensor with size matching the last dimension of t.
		///   This is the second output from tf.nn.moments,
		///   or a saved moving average thereof.
		/// </param>
		/// <param name="v_min">
		///   The value represented by the lowest quantized variance.
		/// </param>
		/// <param name="v_max">
		///   The value represented by the highest quantized variance.
		/// </param>
		/// <param name="beta">
		///   A 1D beta Tensor with size matching the last dimension of t.
		///   An offset to be added to the normalized tensor.
		/// </param>
		/// <param name="beta_min">
		///   The value represented by the lowest quantized offset.
		/// </param>
		/// <param name="beta_max">
		///   The value represented by the highest quantized offset.
		/// </param>
		/// <param name="gamma">
		///   A 1D gamma Tensor with size matching the last dimension of t.
		///   If "scale_after_normalization" is true, this tensor will be multiplied
		///   with the normalized tensor.
		/// </param>
		/// <param name="gamma_min">
		///   The value represented by the lowest quantized gamma.
		/// </param>
		/// <param name="gamma_max">
		///   The value represented by the highest quantized gamma.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedBatchNormWithGlobalNormalization'.
		/// </param>
		/// <param name="out_type">
		/// </param>
		/// <param name="variance_epsilon">
		///   A small float number to avoid dividing by 0.
		/// </param>
		/// <param name="scale_after_normalization">
		///   A bool indicating whether the resulted tensor
		///   needs to be multiplied with gamma.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   result:
		///   result_min:
		///   result_max:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   This op is deprecated and will be removed in the future. Prefer
		///   <c>tf.nn.batch_normalization</c>.
		/// </remarks>
		public (TF_Output result, TF_Output result_min, TF_Output result_max) QuantizedBatchNormWithGlobalNormalization (TF_Output t, TF_Output t_min, TF_Output t_max, TF_Output m, TF_Output m_min, TF_Output m_max, TF_Output v, TF_Output v_min, TF_Output v_max, TF_Output beta, TF_Output beta_min, TF_Output beta_max, TF_Output gamma, TF_Output gamma_min, TF_Output gamma_max, TF_DataType out_type, float variance_epsilon, bool scale_after_normalization, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedBatchNormWithGlobalNormalization", MakeName ("QuantizedBatchNormWithGlobalNormalization", operName));
			c_api.TF_AddInput(desc, t);
			c_api.TF_AddInput(desc, t_min);
			c_api.TF_AddInput(desc, t_max);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, m_min);
			c_api.TF_AddInput(desc, m_max);
			c_api.TF_AddInput(desc, v);
			c_api.TF_AddInput(desc, v_min);
			c_api.TF_AddInput(desc, v_max);
			c_api.TF_AddInput(desc, beta);
			c_api.TF_AddInput(desc, beta_min);
			c_api.TF_AddInput(desc, beta_max);
			c_api.TF_AddInput(desc, gamma);
			c_api.TF_AddInput(desc, gamma_min);
			c_api.TF_AddInput(desc, gamma_max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "out_type", out_type);
			c_api.TF_SetAttrFloat (desc, "variance_epsilon", variance_epsilon);
			c_api.TF_SetAttrBool (desc, "scale_after_normalization", Convert.ToByte(scale_after_normalization));
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var result = new TF_Output (op, _idx++);
			var result_min = new TF_Output (op, _idx++);
			var result_max = new TF_Output (op, _idx++);
			return (result, result_min, result_max);
		}

		/// <summary>
		///   Adds Tensor 'bias' to Tensor 'input' for Quantized types.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="bias">
		///   A 1D bias Tensor with size matching the last dimension of 'input'.
		/// </param>
		/// <param name="min_input">
		///   The float value that the lowest quantized input value represents.
		/// </param>
		/// <param name="max_input">
		///   The float value that the highest quantized input value represents.
		/// </param>
		/// <param name="min_bias">
		///   The float value that the lowest quantized bias value represents.
		/// </param>
		/// <param name="max_bias">
		///   The float value that the highest quantized bias value represents.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedBiasAdd'.
		/// </param>
		/// <param name="out_type">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_out: The float value that the lowest quantized output value represents.
		///   max_out: The float value that the highest quantized output value represents.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Broadcasts the values of bias on dimensions 0..N-2 of 'input'.
		/// </remarks>
		public (TF_Output output, TF_Output min_out, TF_Output max_out) QuantizedBiasAdd (TF_Output input, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_bias, TF_Output max_bias, TF_DataType out_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedBiasAdd", MakeName ("QuantizedBiasAdd", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_bias);
			c_api.TF_AddInput(desc, max_bias);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "out_type", out_type);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_out = new TF_Output (op, _idx++);
			var max_out = new TF_Output (op, _idx++);
			return (output, min_out, max_out);
		}

		/// <summary>
		///   Concatenates quantized tensors along one dimension.
		/// </summary>
		/// <param name="concat_dim">
		///   0-D.  The dimension along which to concatenate.  Must be in the
		///   range [0, rank(values)).
		/// </param>
		/// <param name="values">
		///   The <c>N</c> Tensors to concatenate. Their ranks and types must match,
		///   and their sizes must match in all dimensions except <c>concat_dim</c>.
		/// </param>
		/// <param name="input_mins">
		///   The minimum scalar values for each of the input tensors.
		/// </param>
		/// <param name="input_maxes">
		///   The maximum scalar values for each of the input tensors.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConcat'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output: A <c>Tensor</c> with the concatenation of values stacked along the
		///   <c>concat_dim</c> dimension.  This tensor's shape matches that of <c>values</c> except
		///   in <c>concat_dim</c> where it has the sum of the sizes.
		///   output_min: The float value that the minimum quantized output value represents.
		///   output_max: The float value that the maximum quantized output value represents.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output output_min, TF_Output output_max) QuantizedConcat (TF_Output concat_dim, TF_Output[] values, TF_Output[] input_mins, TF_Output[] input_maxes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConcat", MakeName ("QuantizedConcat", operName));
			c_api.TF_AddInput(desc, concat_dim);
			c_api.TF_AddInputList(desc, values[0], values.Length);
			c_api.TF_AddInputList(desc, input_mins[0], input_mins.Length);
			c_api.TF_AddInputList(desc, input_maxes[0], input_maxes.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var output_min = new TF_Output (op, _idx++);
			var output_max = new TF_Output (op, _idx++);
			return (output, output_min, output_max);
		}

		/// <summary>
		///   Computes a 2D convolution given quantized 4D input and filter tensors.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		///   filter's input_depth dimension must match input's depth dimensions.
		/// </param>
		/// <param name="min_input">
		///   The float value that the lowest quantized input value represents.
		/// </param>
		/// <param name="max_input">
		///   The float value that the highest quantized input value represents.
		/// </param>
		/// <param name="min_filter">
		///   The float value that the lowest quantized filter value represents.
		/// </param>
		/// <param name="max_filter">
		///   The float value that the highest quantized filter value represents.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2D'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		///   1-D tensor of length 4.  The dilation factor for each dimension of
		///   <c>input</c>. If set to k &amp;gt; 1, there will be k-1 skipped cells between each
		///   filter element on that dimension. The dimension order is determined by the
		///   value of <c>data_format</c>, see above for details. Dilations in the batch and
		///   depth dimensions must be 1.
		/// </param>
		/// <param name="strides">
		///   The stride of the sliding window for each dimension of the input
		///   tensor.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output: The float value that the lowest quantized output value represents.
		///   max_output: The float value that the highest quantized output value represents.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The inputs are quantized tensors where the lowest value represents the real
		///   number of the associated minimum, and the highest represents the maximum.
		///   This means that you can only interpret the quantized output in the same way, by
		///   taking the returned minimum and maximum values into account.
		/// </remarks>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2D (TF_Output input, TF_Output filter, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2D", MakeName ("QuantizedConv2D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DAndRelu'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="padding_list">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DAndRelu (TF_Output input, TF_Output filter, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, long[] padding_list = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DAndRelu", MakeName ("QuantizedConv2DAndRelu", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			if (padding_list != null)
				c_api.TF_SetAttrIntList (desc, "padding_list", ref padding_list[0], padding_list.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="min_freezed_output">
		/// </param>
		/// <param name="max_freezed_output">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DAndReluAndRequantize'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="padding_list">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DAndReluAndRequantize (TF_Output input, TF_Output filter, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, TF_Output min_freezed_output, TF_Output max_freezed_output, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, long[] padding_list = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DAndReluAndRequantize", MakeName ("QuantizedConv2DAndReluAndRequantize", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			c_api.TF_AddInput(desc, min_freezed_output);
			c_api.TF_AddInput(desc, max_freezed_output);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			if (padding_list != null)
				c_api.TF_SetAttrIntList (desc, "padding_list", ref padding_list[0], padding_list.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="min_freezed_output">
		/// </param>
		/// <param name="max_freezed_output">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DAndRequantize'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="padding_list">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DAndRequantize (TF_Output input, TF_Output filter, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, TF_Output min_freezed_output, TF_Output max_freezed_output, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, long[] padding_list = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DAndRequantize", MakeName ("QuantizedConv2DAndRequantize", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			c_api.TF_AddInput(desc, min_freezed_output);
			c_api.TF_AddInput(desc, max_freezed_output);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			if (padding_list != null)
				c_api.TF_SetAttrIntList (desc, "padding_list", ref padding_list[0], padding_list.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		///   Computes QuantizedConv2D per channel.
		/// </summary>
		/// <param name="input">
		///   The original input tensor.
		/// </param>
		/// <param name="filter">
		///   The original filter tensor.
		/// </param>
		/// <param name="min_input">
		///   The minimum value of the input tensor
		/// </param>
		/// <param name="max_input">
		///   The maximum value of the input tensor.
		/// </param>
		/// <param name="min_filter">
		///   The minimum value of the filter tensor.
		/// </param>
		/// <param name="max_filter">
		///   The maximum value of the filter tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DPerChannel'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		///   The quantized type of output tensor that needs to be converted.
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		///   list of dilation values.
		/// </param>
		/// <param name="strides">
		///   list of stride values.
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output: The output tensor.
		///   min_output: The minimum value of the final output tensor.
		///   max_output: The maximum value of the final output tensor.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DPerChannel (TF_Output input, TF_Output filter, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DPerChannel", MakeName ("QuantizedConv2DPerChannel", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DWithBias'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="padding_list">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DWithBias (TF_Output input, TF_Output filter, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, long[] padding_list = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DWithBias", MakeName ("QuantizedConv2DWithBias", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			if (padding_list != null)
				c_api.TF_SetAttrIntList (desc, "padding_list", ref padding_list[0], padding_list.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DWithBiasAndRelu'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="padding_list">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DWithBiasAndRelu (TF_Output input, TF_Output filter, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, long[] padding_list = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DWithBiasAndRelu", MakeName ("QuantizedConv2DWithBiasAndRelu", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			if (padding_list != null)
				c_api.TF_SetAttrIntList (desc, "padding_list", ref padding_list[0], padding_list.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="min_freezed_output">
		/// </param>
		/// <param name="max_freezed_output">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DWithBiasAndReluAndRequantize'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="padding_list">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DWithBiasAndReluAndRequantize (TF_Output input, TF_Output filter, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, TF_Output min_freezed_output, TF_Output max_freezed_output, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, long[] padding_list = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DWithBiasAndReluAndRequantize", MakeName ("QuantizedConv2DWithBiasAndReluAndRequantize", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			c_api.TF_AddInput(desc, min_freezed_output);
			c_api.TF_AddInput(desc, max_freezed_output);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			if (padding_list != null)
				c_api.TF_SetAttrIntList (desc, "padding_list", ref padding_list[0], padding_list.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="min_freezed_output">
		/// </param>
		/// <param name="max_freezed_output">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DWithBiasAndRequantize'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="padding_list">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DWithBiasAndRequantize (TF_Output input, TF_Output filter, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, TF_Output min_freezed_output, TF_Output max_freezed_output, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, long[] padding_list = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DWithBiasAndRequantize", MakeName ("QuantizedConv2DWithBiasAndRequantize", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			c_api.TF_AddInput(desc, min_freezed_output);
			c_api.TF_AddInput(desc, max_freezed_output);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			if (padding_list != null)
				c_api.TF_SetAttrIntList (desc, "padding_list", ref padding_list[0], padding_list.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="min_freezed_output">
		/// </param>
		/// <param name="max_freezed_output">
		/// </param>
		/// <param name="summand">
		/// </param>
		/// <param name="min_summand">
		/// </param>
		/// <param name="max_summand">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DWithBiasSignedSumAndReluAndRequantize'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="padding_list">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DWithBiasSignedSumAndReluAndRequantize (TF_Output input, TF_Output filter, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, TF_Output min_freezed_output, TF_Output max_freezed_output, TF_Output summand, TF_Output min_summand, TF_Output max_summand, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, long[] padding_list = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DWithBiasSignedSumAndReluAndRequantize", MakeName ("QuantizedConv2DWithBiasSignedSumAndReluAndRequantize", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			c_api.TF_AddInput(desc, min_freezed_output);
			c_api.TF_AddInput(desc, max_freezed_output);
			c_api.TF_AddInput(desc, summand);
			c_api.TF_AddInput(desc, min_summand);
			c_api.TF_AddInput(desc, max_summand);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			if (padding_list != null)
				c_api.TF_SetAttrIntList (desc, "padding_list", ref padding_list[0], padding_list.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="summand">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DWithBiasSumAndRelu'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="padding_list">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DWithBiasSumAndRelu (TF_Output input, TF_Output filter, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, TF_Output summand, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, long[] padding_list = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DWithBiasSumAndRelu", MakeName ("QuantizedConv2DWithBiasSumAndRelu", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			c_api.TF_AddInput(desc, summand);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			if (padding_list != null)
				c_api.TF_SetAttrIntList (desc, "padding_list", ref padding_list[0], padding_list.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="filter">
		/// </param>
		/// <param name="bias">
		/// </param>
		/// <param name="min_input">
		/// </param>
		/// <param name="max_input">
		/// </param>
		/// <param name="min_filter">
		/// </param>
		/// <param name="max_filter">
		/// </param>
		/// <param name="min_freezed_output">
		/// </param>
		/// <param name="max_freezed_output">
		/// </param>
		/// <param name="summand">
		/// </param>
		/// <param name="min_summand">
		/// </param>
		/// <param name="max_summand">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2DWithBiasSumAndReluAndRequantize'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		/// </param>
		/// <param name="padding_list">
		///   Optional argument
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output:
		///   max_output:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedConv2DWithBiasSumAndReluAndRequantize (TF_Output input, TF_Output filter, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, TF_Output min_freezed_output, TF_Output max_freezed_output, TF_Output summand, TF_Output min_summand, TF_Output max_summand, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, long[] padding_list = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedConv2DWithBiasSumAndReluAndRequantize", MakeName ("QuantizedConv2DWithBiasSumAndReluAndRequantize", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			c_api.TF_AddInput(desc, min_freezed_output);
			c_api.TF_AddInput(desc, max_freezed_output);
			c_api.TF_AddInput(desc, summand);
			c_api.TF_AddInput(desc, min_summand);
			c_api.TF_AddInput(desc, max_summand);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			if (padding_list != null)
				c_api.TF_SetAttrIntList (desc, "padding_list", ref padding_list[0], padding_list.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		///   Computes quantized depthwise Conv2D.
		/// </summary>
		/// <param name="input">
		///   The original input tensor.
		/// </param>
		/// <param name="filter">
		///   The original filter tensor.
		/// </param>
		/// <param name="min_input">
		///   The float value that the minimum quantized input value represents.
		/// </param>
		/// <param name="max_input">
		///   The float value that the maximum quantized input value represents.
		/// </param>
		/// <param name="min_filter">
		///   The float value that the minimum quantized filter value represents.
		/// </param>
		/// <param name="max_filter">
		///   The float value that the maximum quantized filter value represents.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedDepthwiseConv2D'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		///   The type of the output.
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		///   List of dilation values.
		/// </param>
		/// <param name="strides">
		///   List of stride values.
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output: The output tensor.
		///   min_output: The float value that the minimum quantized output value represents.
		///   max_output: The float value that the maximum quantized output value represents.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedDepthwiseConv2D (TF_Output input, TF_Output filter, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedDepthwiseConv2D", MakeName ("QuantizedDepthwiseConv2D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		///   Computes quantized depthwise Conv2D with Bias.
		/// </summary>
		/// <param name="input">
		///   The original input tensor.
		/// </param>
		/// <param name="filter">
		///   The original filter tensor.
		/// </param>
		/// <param name="bias">
		///   The original bias tensor.
		/// </param>
		/// <param name="min_input">
		///   The float value that the minimum quantized input value represents.
		/// </param>
		/// <param name="max_input">
		///   The float value that the maximum quantized input value represents.
		/// </param>
		/// <param name="min_filter">
		///   The float value that the minimum quantized filter value represents.
		/// </param>
		/// <param name="max_filter">
		///   The float value that the maximum quantized filter value represents.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedDepthwiseConv2DWithBias'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		///   The type of the output.
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		///   List of dilation values.
		/// </param>
		/// <param name="strides">
		///   List of stride values.
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output: The output tensor.
		///   min_output: The float value that the minimum quantized output value represents.
		///   max_output: The float value that the maximum quantized output value represents.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedDepthwiseConv2DWithBias (TF_Output input, TF_Output filter, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedDepthwiseConv2DWithBias", MakeName ("QuantizedDepthwiseConv2DWithBias", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		///   Computes quantized depthwise Conv2D with Bias and Relu.
		/// </summary>
		/// <param name="input">
		///   The original input tensor.
		/// </param>
		/// <param name="filter">
		///   The original filter tensor.
		/// </param>
		/// <param name="bias">
		///   The original bias tensor.
		/// </param>
		/// <param name="min_input">
		///   The float value that the minimum quantized input value represents.
		/// </param>
		/// <param name="max_input">
		///   The float value that the maximum quantized input value represents.
		/// </param>
		/// <param name="min_filter">
		///   The float value that the minimum quantized filter value represents.
		/// </param>
		/// <param name="max_filter">
		///   The float value that the maximum quantized filter value represents.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedDepthwiseConv2DWithBiasAndRelu'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		///   The type of the output.
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		///   List of dilation values.
		/// </param>
		/// <param name="strides">
		///   List of stride values.
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output: The output tensor.
		///   min_output: The float value that the minimum quantized output value represents.
		///   max_output: The float value that the maximum quantized output value represents.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedDepthwiseConv2DWithBiasAndRelu (TF_Output input, TF_Output filter, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedDepthwiseConv2DWithBiasAndRelu", MakeName ("QuantizedDepthwiseConv2DWithBiasAndRelu", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		///   Computes quantized depthwise Conv2D with Bias, Relu and Requantize.
		/// </summary>
		/// <param name="input">
		///   The original input tensor.
		/// </param>
		/// <param name="filter">
		///   The original filter tensor.
		/// </param>
		/// <param name="bias">
		///   The original bias tensor.
		/// </param>
		/// <param name="min_input">
		///   The float value that the minimum quantized input value represents.
		/// </param>
		/// <param name="max_input">
		///   The float value that the maximum quantized input value represents.
		/// </param>
		/// <param name="min_filter">
		///   The float value that the minimum quantized filter value represents.
		/// </param>
		/// <param name="max_filter">
		///   The float value that the maximum quantized filter value represents.
		/// </param>
		/// <param name="min_freezed_output">
		///   The minimum float value of the output tensor.
		/// </param>
		/// <param name="max_freezed_output">
		///   The maximum float value of the output tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		///   The type of the output.
		/// </param>
		/// <param name="dilations">
		///   Optional argument
		///   List of dilation values.
		/// </param>
		/// <param name="strides">
		///   List of stride values.
		/// </param>
		/// <param name="padding">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output: The output tensor.
		///   min_output: The float value that the minimum quantized output value represents.
		///   max_output: The float value that the maximum quantized output value represents.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize (TF_Output input, TF_Output filter, TF_Output bias, TF_Output min_input, TF_Output max_input, TF_Output min_filter, TF_Output max_filter, TF_Output min_freezed_output, TF_Output max_freezed_output, long[] strides, string padding, TF_DataType? out_type = null, long[] dilations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize", MakeName ("QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, filter);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			c_api.TF_AddInput(desc, min_filter);
			c_api.TF_AddInput(desc, max_filter);
			c_api.TF_AddInput(desc, min_freezed_output);
			c_api.TF_AddInput(desc, max_freezed_output);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			if (dilations != null)
				c_api.TF_SetAttrIntList (desc, "dilations", ref dilations[0], dilations.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		///   Quantized Instance normalization.
		/// </summary>
		/// <param name="x">
		///   A 4D input Tensor.
		/// </param>
		/// <param name="x_min">
		///   The value represented by the lowest quantized input.
		/// </param>
		/// <param name="x_max">
		///   The value represented by the highest quantized input.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedInstanceNorm'.
		/// </param>
		/// <param name="output_range_given">
		///   Optional argument
		///   If True, <c>given_y_min</c> and <c>given_y_min</c>
		///   and <c>given_y_max</c> are used as the output range. Otherwise,
		///   the implementation computes the output range.
		/// </param>
		/// <param name="given_y_min">
		///   Optional argument
		///   Output in <c>y_min</c> if <c>output_range_given</c> is True.
		/// </param>
		/// <param name="given_y_max">
		///   Optional argument
		///   Output in <c>y_max</c> if <c>output_range_given</c> is True.
		/// </param>
		/// <param name="variance_epsilon">
		///   Optional argument
		///   A small float number to avoid dividing by 0.
		/// </param>
		/// <param name="min_separation">
		///   Optional argument
		///   Minimum value of <c>y_max - y_min</c>
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   y: A 4D Tensor.
		///   y_min: The value represented by the lowest quantized output.
		///   y_max: The value represented by the highest quantized output.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output y, TF_Output y_min, TF_Output y_max) QuantizedInstanceNorm (TF_Output x, TF_Output x_min, TF_Output x_max, bool? output_range_given = null, float? given_y_min = null, float? given_y_max = null, float? variance_epsilon = null, float? min_separation = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedInstanceNorm", MakeName ("QuantizedInstanceNorm", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, x_min);
			c_api.TF_AddInput(desc, x_max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (output_range_given.HasValue)
				c_api.TF_SetAttrBool (desc, "output_range_given", Convert.ToByte(output_range_given.Value));
			
			if (given_y_min.HasValue)
				c_api.TF_SetAttrFloat (desc, "given_y_min", given_y_min.Value);
			
			if (given_y_max.HasValue)
				c_api.TF_SetAttrFloat (desc, "given_y_max", given_y_max.Value);
			
			if (variance_epsilon.HasValue)
				c_api.TF_SetAttrFloat (desc, "variance_epsilon", variance_epsilon.Value);
			
			if (min_separation.HasValue)
				c_api.TF_SetAttrFloat (desc, "min_separation", min_separation.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			var y_min = new TF_Output (op, _idx++);
			var y_max = new TF_Output (op, _idx++);
			return (y, y_min, y_max);
		}

		/// <summary>
		///   Perform a quantized matrix multiplication of  <c>a</c> by the matrix <c>b</c>.
		/// </summary>
		/// <param name="a">
		///   Must be a two-dimensional tensor.
		/// </param>
		/// <param name="b">
		///   Must be a two-dimensional tensor.
		/// </param>
		/// <param name="min_a">
		///   The float value that the lowest quantized <c>a</c> value represents.
		/// </param>
		/// <param name="max_a">
		///   The float value that the highest quantized <c>a</c> value represents.
		/// </param>
		/// <param name="min_b">
		///   The float value that the lowest quantized <c>b</c> value represents.
		/// </param>
		/// <param name="max_b">
		///   The float value that the highest quantized <c>b</c> value represents.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedMatMul'.
		/// </param>
		/// <param name="Toutput">
		///   Optional argument
		/// </param>
		/// <param name="transpose_a">
		///   Optional argument
		///   If true, <c>a</c> is transposed before multiplication.
		/// </param>
		/// <param name="transpose_b">
		///   Optional argument
		///   If true, <c>b</c> is transposed before multiplication.
		/// </param>
		/// <param name="Tactivation">
		///   Optional argument
		///   The type of output produced by activation function
		///   following this operation.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_out: The float value that the lowest quantized output value represents.
		///   max_out: The float value that the highest quantized output value represents.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The inputs must be two-dimensional matrices and the inner dimension of
		///   <c>a</c> (after being transposed if <c>transpose_a</c> is non-zero) must match the
		///   outer dimension of <c>b</c> (after being transposed if <c>transposed_b</c> is
		///   non-zero).
		/// </remarks>
		public (TF_Output output, TF_Output min_out, TF_Output max_out) QuantizedMatMul (TF_Output a, TF_Output b, TF_Output min_a, TF_Output max_a, TF_Output min_b, TF_Output max_b, TF_DataType? Toutput = null, bool? transpose_a = null, bool? transpose_b = null, TF_DataType? Tactivation = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedMatMul", MakeName ("QuantizedMatMul", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, b);
			c_api.TF_AddInput(desc, min_a);
			c_api.TF_AddInput(desc, max_a);
			c_api.TF_AddInput(desc, min_b);
			c_api.TF_AddInput(desc, max_b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Toutput.HasValue)
				c_api.TF_SetAttrType (desc, "Toutput", Toutput.Value);
			
			if (transpose_a.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_a", Convert.ToByte(transpose_a.Value));
			
			if (transpose_b.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_b", Convert.ToByte(transpose_b.Value));
			
			if (Tactivation.HasValue)
				c_api.TF_SetAttrType (desc, "Tactivation", Tactivation.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_out = new TF_Output (op, _idx++);
			var max_out = new TF_Output (op, _idx++);
			return (output, min_out, max_out);
		}

		/// <summary>
		///   Performs a quantized matrix multiplication of <c>a</c> by the matrix <c>b</c> with bias
		///   add.
		/// </summary>
		/// <param name="a">
		///   A matrix to be multiplied. Must be a two-dimensional tensor of type <c>quint8</c>.
		/// </param>
		/// <param name="b">
		///   A matrix to be multiplied and must be a two-dimensional tensor of type <c>qint8</c>.
		/// </param>
		/// <param name="bias">
		///   A 1D bias tensor with size matching inner dimension of <c>b</c> (after being
		///   transposed if <c>transposed_b</c> is non-zero).
		/// </param>
		/// <param name="min_a">
		///   The float value that the lowest quantized <c>a</c> value represents.
		/// </param>
		/// <param name="max_a">
		///   The float value that the highest quantized <c>a</c> value represents.
		/// </param>
		/// <param name="min_b">
		///   The float value that the lowest quantized <c>b</c> value represents.
		/// </param>
		/// <param name="max_b">
		///   The float value that the highest quantized <c>b</c> value represents.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedMatMulWithBias'.
		/// </param>
		/// <param name="Toutput">
		///   Optional argument
		/// </param>
		/// <param name="transpose_a">
		///   Optional argument
		///   If true, <c>a</c> is transposed before multiplication.
		/// </param>
		/// <param name="transpose_b">
		///   Optional argument
		///   If true, <c>b</c> is transposed before multiplication.
		/// </param>
		/// <param name="input_quant_mode">
		///   Optional argument
		///   Input data quantization mode. Either MIN_FIRST(default) or SCALED.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_out: The float value that the lowest quantized output value represents.
		///   max_out: The float value that the highest quantized output value represents.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The inputs must be two-dimensional matrices and 1D bias vector. And the inner
		///   dimension of <c>a</c> (after being transposed if <c>transpose_a</c> is non-zero) must
		///   match the outer dimension of <c>b</c> (after being transposed if <c>transposed_b</c> is
		///   non-zero). Then do broadcast add operation with bias values on the matrix
		///   mulplication result. The bias size must match inner dimension of <c>b</c>.
		/// </remarks>
		public (TF_Output output, TF_Output min_out, TF_Output max_out) QuantizedMatMulWithBias (TF_Output a, TF_Output b, TF_Output bias, TF_Output min_a, TF_Output max_a, TF_Output min_b, TF_Output max_b, TF_DataType? Toutput = null, bool? transpose_a = null, bool? transpose_b = null, string input_quant_mode = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedMatMulWithBias", MakeName ("QuantizedMatMulWithBias", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, b);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_a);
			c_api.TF_AddInput(desc, max_a);
			c_api.TF_AddInput(desc, min_b);
			c_api.TF_AddInput(desc, max_b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Toutput.HasValue)
				c_api.TF_SetAttrType (desc, "Toutput", Toutput.Value);
			
			if (transpose_a.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_a", Convert.ToByte(transpose_a.Value));
			
			if (transpose_b.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_b", Convert.ToByte(transpose_b.Value));
			
			if (input_quant_mode != null)
				c_api.TF_SetAttrString (desc, "input_quant_mode", input_quant_mode);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_out = new TF_Output (op, _idx++);
			var max_out = new TF_Output (op, _idx++);
			return (output, min_out, max_out);
		}

		/// <summary>
		///   Perform a quantized matrix multiplication of  <c>a</c> by the matrix <c>b</c> with bias
		///   add and relu fusion.
		/// </summary>
		/// <param name="a">
		///   A matrix to be multiplied. Must be a two-dimensional tensor of type <c>quint8</c>.
		/// </param>
		/// <param name="b">
		///   A matrix to be multiplied and must be a two-dimensional tensor of type <c>qint8</c>.
		/// </param>
		/// <param name="bias">
		///   A 1D bias tensor with size matching with inner dimension of <c>b</c> (after being
		///   transposed if <c>transposed_b</c> is non-zero).
		/// </param>
		/// <param name="min_a">
		///   The float value that the lowest quantized <c>a</c> value represents.
		/// </param>
		/// <param name="max_a">
		///   The float value that the highest quantized <c>a</c> value represents.
		/// </param>
		/// <param name="min_b">
		///   The float value that the lowest quantized <c>b</c> value represents.
		/// </param>
		/// <param name="max_b">
		///   The float value that the highest quantized <c>b</c> value represents.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedMatMulWithBiasAndRelu'.
		/// </param>
		/// <param name="Toutput">
		///   Optional argument
		/// </param>
		/// <param name="transpose_a">
		///   Optional argument
		///   If true, <c>a</c> is transposed before multiplication.
		/// </param>
		/// <param name="transpose_b">
		///   Optional argument
		///   If true, <c>b</c> is transposed before multiplication.
		/// </param>
		/// <param name="input_quant_mode">
		///   Optional argument
		///   Input data quantization mode. Either MIN_FIRST(default) or SCALED.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_out: The float value that the lowest quantized output value represents.
		///   max_out: The float value that the highest quantized output value represents.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The inputs must be two-dimensional matrices and 1D bias vector. And the inner
		///   dimension of <c>a</c> (after being transposed if <c>transpose_a</c> is non-zero) must
		///   match the outer dimension of <c>b</c> (after being transposed if <c>transposed_b</c> is
		///   non-zero). Then do broadcast add operation with bias values on the matrix
		///   mulplication result. The bias size must match inner dimension of <c>b</c>. Then do
		///   relu activation to get non-negative result.
		/// </remarks>
		public (TF_Output output, TF_Output min_out, TF_Output max_out) QuantizedMatMulWithBiasAndRelu (TF_Output a, TF_Output b, TF_Output bias, TF_Output min_a, TF_Output max_a, TF_Output min_b, TF_Output max_b, TF_DataType? Toutput = null, bool? transpose_a = null, bool? transpose_b = null, string input_quant_mode = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedMatMulWithBiasAndRelu", MakeName ("QuantizedMatMulWithBiasAndRelu", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, b);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_a);
			c_api.TF_AddInput(desc, max_a);
			c_api.TF_AddInput(desc, min_b);
			c_api.TF_AddInput(desc, max_b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Toutput.HasValue)
				c_api.TF_SetAttrType (desc, "Toutput", Toutput.Value);
			
			if (transpose_a.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_a", Convert.ToByte(transpose_a.Value));
			
			if (transpose_b.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_b", Convert.ToByte(transpose_b.Value));
			
			if (input_quant_mode != null)
				c_api.TF_SetAttrString (desc, "input_quant_mode", input_quant_mode);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_out = new TF_Output (op, _idx++);
			var max_out = new TF_Output (op, _idx++);
			return (output, min_out, max_out);
		}

		/// <summary>
		///   Perform a quantized matrix multiplication of  <c>a</c> by the matrix <c>b</c> with bias
		///   add and relu and requantize fusion.
		/// </summary>
		/// <param name="a">
		///   A matrix to be multiplied. Must be a two-dimensional tensor of type <c>quint8</c>.
		/// </param>
		/// <param name="b">
		///   A matrix to be multiplied and must be a two-dimensional tensor of type <c>qint8</c>.
		/// </param>
		/// <param name="bias">
		///   A 1D bias tensor with size matching with inner dimension of <c>b</c> (after being
		///   transposed if <c>transposed_b</c> is non-zero).
		/// </param>
		/// <param name="min_a">
		///   The float value that the lowest quantized <c>a</c> value represents.
		/// </param>
		/// <param name="max_a">
		///   The float value that the highest quantized <c>a</c> value represents.
		/// </param>
		/// <param name="min_b">
		///   The float value that the lowest quantized <c>b</c> value represents.
		/// </param>
		/// <param name="max_b">
		///   The float value that the highest quantized <c>b</c> value represents.
		/// </param>
		/// <param name="min_freezed_output">
		///   The float value that the highest quantized output value after requantize.
		/// </param>
		/// <param name="max_freezed_output">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedMatMulWithBiasAndReluAndRequantize'.
		/// </param>
		/// <param name="Toutput">
		///   Optional argument
		/// </param>
		/// <param name="transpose_a">
		///   Optional argument
		///   If true, <c>a</c> is transposed before multiplication.
		/// </param>
		/// <param name="transpose_b">
		///   Optional argument
		///   If true, <c>b</c> is transposed before multiplication.
		/// </param>
		/// <param name="input_quant_mode">
		///   Optional argument
		///   Input data quantization mode. Either MIN_FIRST(default) or SCALED.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_out: The float value that the lowest quantized output value represents.
		///   max_out: The float value that the highest quantized output value represents.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The inputs must be two-dimensional matrices and 1D bias vector. And the inner
		///   dimension of <c>a</c> (after being transposed if <c>transpose_a</c> is non-zero) must
		///   match the outer dimension of <c>b</c> (after being transposed if <c>transposed_b</c> is
		///   non-zero). Then do broadcast add operation with bias values on the matrix
		///   mulplication result. The bias size must match inner dimension of <c>b</c>.  Then do
		///   relu activation to get non-negative result. Then do requantize operation to get
		///   final uint8 result.
		/// </remarks>
		public (TF_Output output, TF_Output min_out, TF_Output max_out) QuantizedMatMulWithBiasAndReluAndRequantize (TF_Output a, TF_Output b, TF_Output bias, TF_Output min_a, TF_Output max_a, TF_Output min_b, TF_Output max_b, TF_Output min_freezed_output, TF_Output max_freezed_output, TF_DataType? Toutput = null, bool? transpose_a = null, bool? transpose_b = null, string input_quant_mode = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedMatMulWithBiasAndReluAndRequantize", MakeName ("QuantizedMatMulWithBiasAndReluAndRequantize", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, b);
			c_api.TF_AddInput(desc, bias);
			c_api.TF_AddInput(desc, min_a);
			c_api.TF_AddInput(desc, max_a);
			c_api.TF_AddInput(desc, min_b);
			c_api.TF_AddInput(desc, max_b);
			c_api.TF_AddInput(desc, min_freezed_output);
			c_api.TF_AddInput(desc, max_freezed_output);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Toutput.HasValue)
				c_api.TF_SetAttrType (desc, "Toutput", Toutput.Value);
			
			if (transpose_a.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_a", Convert.ToByte(transpose_a.Value));
			
			if (transpose_b.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_b", Convert.ToByte(transpose_b.Value));
			
			if (input_quant_mode != null)
				c_api.TF_SetAttrString (desc, "input_quant_mode", input_quant_mode);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_out = new TF_Output (op, _idx++);
			var max_out = new TF_Output (op, _idx++);
			return (output, min_out, max_out);
		}

		/// <summary>
		///   Produces the max pool of the input tensor for quantized types.
		/// </summary>
		/// <param name="input">
		///   The 4D (batch x rows x cols x depth) Tensor to MaxReduce over.
		/// </param>
		/// <param name="min_input">
		///   The float value that the lowest quantized input value represents.
		/// </param>
		/// <param name="max_input">
		///   The float value that the highest quantized input value represents.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedMaxPool'.
		/// </param>
		/// <param name="ksize">
		///   The size of the window for each dimension of the input tensor.
		///   The length must be 4 to match the number of dimensions of the input.
		/// </param>
		/// <param name="strides">
		///   The stride of the sliding window for each dimension of the input
		///   tensor. The length must be 4 to match the number of dimensions of the input.
		/// </param>
		/// <param name="padding">
		///   The type of padding algorithm to use.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   min_output: The float value that the lowest quantized output value represents.
		///   max_output: The float value that the highest quantized output value represents.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output min_output, TF_Output max_output) QuantizedMaxPool (TF_Output input, TF_Output min_input, TF_Output max_input, long[] ksize, long[] strides, string padding, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedMaxPool", MakeName ("QuantizedMaxPool", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, min_input);
			c_api.TF_AddInput(desc, max_input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrIntList (desc, "ksize", ref ksize[0], ksize.Length);
			c_api.TF_SetAttrIntList (desc, "strides", ref strides[0], strides.Length);
			c_api.TF_SetAttrString (desc, "padding", padding);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var min_output = new TF_Output (op, _idx++);
			var max_output = new TF_Output (op, _idx++);
			return (output, min_output, max_output);
		}

		/// <summary>
		///   Returns x * y element-wise, working on quantized buffers.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="min_x">
		///   The float value that the lowest quantized <c>x</c> value represents.
		/// </param>
		/// <param name="max_x">
		///   The float value that the highest quantized <c>x</c> value represents.
		/// </param>
		/// <param name="min_y">
		///   The float value that the lowest quantized <c>y</c> value represents.
		/// </param>
		/// <param name="max_y">
		///   The float value that the highest quantized <c>y</c> value represents.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedMul'.
		/// </param>
		/// <param name="Toutput">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   z:
		///   min_z: The float value that the lowest quantized output value represents.
		///   max_z: The float value that the highest quantized output value represents.
		///   
		///   *NOTE*: <c>QuantizedMul</c> supports limited forms of broadcasting. More about
		///   broadcasting [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output z, TF_Output min_z, TF_Output max_z) QuantizedMul (TF_Output x, TF_Output y, TF_Output min_x, TF_Output max_x, TF_Output min_y, TF_Output max_y, TF_DataType? Toutput = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedMul", MakeName ("QuantizedMul", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			c_api.TF_AddInput(desc, min_x);
			c_api.TF_AddInput(desc, max_x);
			c_api.TF_AddInput(desc, min_y);
			c_api.TF_AddInput(desc, max_y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Toutput.HasValue)
				c_api.TF_SetAttrType (desc, "Toutput", Toutput.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			var min_z = new TF_Output (op, _idx++);
			var max_z = new TF_Output (op, _idx++);
			return (z, min_z, max_z);
		}

		/// <summary>
		///   Convert the quantized 'input' tensor into a lower-precision 'output', using the
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_min">
		///   The float value that the minimum quantized input value represents.
		/// </param>
		/// <param name="input_max">
		///   The float value that the maximum quantized input value represents.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizeDownAndShrinkRange'.
		/// </param>
		/// <param name="out_type">
		///   The type of the output. Should be a lower bit depth than Tinput.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   output_min: The float value that the minimum quantized output value represents.
		///   output_max: The float value that the maximum quantized output value represents.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   actual distribution of the values to maximize the usage of the lower bit depth
		///   and adjusting the output min and max ranges accordingly.
		///   
		///   [input_min, input_max] are scalar floats that specify the range for the float
		///   interpretation of the 'input' data. For example, if input_min is -1.0f and
		///   input_max is 1.0f, and we are dealing with quint16 quantized data, then a 0
		///   value in the 16-bit data should be interpreted as -1.0f, and a 65535 means 1.0f.
		///   
		///   This operator tries to squeeze as much precision as possible into an output with
		///   a lower bit depth by calculating the actual min and max values found in the
		///   data. For example, maybe that quint16 input has no values lower than 16,384 and
		///   none higher than 49,152. That means only half the range is actually needed, all
		///   the float interpretations are between -0.5f and 0.5f, so if we want to compress
		///   the data into a quint8 output, we can use that range rather than the theoretical
		///   -1.0f to 1.0f that is suggested by the input min and max.
		///   
		///   In practice, this is most useful for taking output from operations like
		///   QuantizedMatMul that can produce higher bit-depth outputs than their inputs and
		///   may have large potential output ranges, but in practice have a distribution of
		///   input values that only uses a small fraction of the possible range. By feeding
		///   that output into this operator, we can reduce it from 32 bits down to 8 with
		///   minimal loss of accuracy.
		/// </remarks>
		public (TF_Output output, TF_Output output_min, TF_Output output_max) QuantizeDownAndShrinkRange (TF_Output input, TF_Output input_min, TF_Output input_max, TF_DataType out_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizeDownAndShrinkRange", MakeName ("QuantizeDownAndShrinkRange", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_min);
			c_api.TF_AddInput(desc, input_max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "out_type", out_type);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var output_min = new TF_Output (op, _idx++);
			var output_max = new TF_Output (op, _idx++);
			return (output, output_min, output_max);
		}

		/// <summary>
		///   Computes Quantized Rectified Linear: <c>max(features, 0)</c>
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="min_features">
		///   The float value that the lowest quantized value represents.
		/// </param>
		/// <param name="max_features">
		///   The float value that the highest quantized value represents.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedRelu'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   activations: Has the same output shape as "features".
		///   min_activations: The float value that the lowest quantized value represents.
		///   max_activations: The float value that the highest quantized value represents.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output activations, TF_Output min_activations, TF_Output max_activations) QuantizedRelu (TF_Output features, TF_Output min_features, TF_Output max_features, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedRelu", MakeName ("QuantizedRelu", operName));
			c_api.TF_AddInput(desc, features);
			c_api.TF_AddInput(desc, min_features);
			c_api.TF_AddInput(desc, max_features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var activations = new TF_Output (op, _idx++);
			var min_activations = new TF_Output (op, _idx++);
			var max_activations = new TF_Output (op, _idx++);
			return (activations, min_activations, max_activations);
		}

		/// <summary>
		///   Computes Quantized Rectified Linear 6: <c>min(max(features, 0), 6)</c>
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="min_features">
		///   The float value that the lowest quantized value represents.
		/// </param>
		/// <param name="max_features">
		///   The float value that the highest quantized value represents.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedRelu6'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   activations: Has the same output shape as "features".
		///   min_activations: The float value that the lowest quantized value represents.
		///   max_activations: The float value that the highest quantized value represents.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output activations, TF_Output min_activations, TF_Output max_activations) QuantizedRelu6 (TF_Output features, TF_Output min_features, TF_Output max_features, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedRelu6", MakeName ("QuantizedRelu6", operName));
			c_api.TF_AddInput(desc, features);
			c_api.TF_AddInput(desc, min_features);
			c_api.TF_AddInput(desc, max_features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var activations = new TF_Output (op, _idx++);
			var min_activations = new TF_Output (op, _idx++);
			var max_activations = new TF_Output (op, _idx++);
			return (activations, min_activations, max_activations);
		}

		/// <summary>
		///   Computes Quantized Rectified Linear X: <c>min(max(features, 0), max_value)</c>
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="max_value">
		/// </param>
		/// <param name="min_features">
		///   The float value that the lowest quantized value represents.
		/// </param>
		/// <param name="max_features">
		///   The float value that the highest quantized value represents.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedReluX'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   activations: Has the same output shape as "features".
		///   min_activations: The float value that the lowest quantized value represents.
		///   max_activations: The float value that the highest quantized value represents.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output activations, TF_Output min_activations, TF_Output max_activations) QuantizedReluX (TF_Output features, TF_Output max_value, TF_Output min_features, TF_Output max_features, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedReluX", MakeName ("QuantizedReluX", operName));
			c_api.TF_AddInput(desc, features);
			c_api.TF_AddInput(desc, max_value);
			c_api.TF_AddInput(desc, min_features);
			c_api.TF_AddInput(desc, max_features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var activations = new TF_Output (op, _idx++);
			var min_activations = new TF_Output (op, _idx++);
			var max_activations = new TF_Output (op, _idx++);
			return (activations, min_activations, max_activations);
		}

		/// <summary>
		///   Reshapes a quantized tensor as per the Reshape op.
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="shape">
		///   Defines the shape of the output tensor.
		/// </param>
		/// <param name="input_min">
		///   The minimum value of the input.
		/// </param>
		/// <param name="input_max">
		///   The maximum value of the input.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedReshape'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   output_min: This value is copied from input_min.
		///   output_max: This value is copied from input_max.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///    <code>
		/// </remarks>
		public (TF_Output output, TF_Output output_min, TF_Output output_max) QuantizedReshape (TF_Output tensor, TF_Output shape, TF_Output input_min, TF_Output input_max, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedReshape", MakeName ("QuantizedReshape", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, input_min);
			c_api.TF_AddInput(desc, input_max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var output_min = new TF_Output (op, _idx++);
			var output_max = new TF_Output (op, _idx++);
			return (output, output_min, output_max);
		}

		/// <summary>
		///   Resize quantized <c>images</c> to <c>size</c> using quantized bilinear interpolation.
		/// </summary>
		/// <param name="images">
		///   4-D with shape <c>[batch, height, width, channels]</c>.
		/// </param>
		/// <param name="size">
		///   = A 1-D int32 Tensor of 2 elements: <c>new_height, new_width</c>.  The
		///   new size for the images.
		/// </param>
		/// <param name="min">
		/// </param>
		/// <param name="max">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedResizeBilinear'.
		/// </param>
		/// <param name="align_corners">
		///   Optional argument
		///   If true, the centers of the 4 corner pixels of the input and output tensors are
		///   aligned, preserving the values at the corner pixels. Defaults to false.
		/// </param>
		/// <param name="half_pixel_centers">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   resized_images: 4-D with shape
		///   <c>[batch, new_height, new_width, channels]</c>.
		///   out_min:
		///   out_max:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Input images and output images must be quantized types.
		/// </remarks>
		public (TF_Output resized_images, TF_Output out_min, TF_Output out_max) QuantizedResizeBilinear (TF_Output images, TF_Output size, TF_Output min, TF_Output max, bool? align_corners = null, bool? half_pixel_centers = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizedResizeBilinear", MakeName ("QuantizedResizeBilinear", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, size);
			c_api.TF_AddInput(desc, min);
			c_api.TF_AddInput(desc, max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (align_corners.HasValue)
				c_api.TF_SetAttrBool (desc, "align_corners", Convert.ToByte(align_corners.Value));
			
			if (half_pixel_centers.HasValue)
				c_api.TF_SetAttrBool (desc, "half_pixel_centers", Convert.ToByte(half_pixel_centers.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var resized_images = new TF_Output (op, _idx++);
			var out_min = new TF_Output (op, _idx++);
			var out_max = new TF_Output (op, _idx++);
			return (resized_images, out_min, out_max);
		}

		/// <summary>
		///   Quantize the 'input' tensor of type float to 'output' tensor of type 'T'.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="min_range">
		///   The minimum scalar value possibly produced for the input.
		/// </param>
		/// <param name="max_range">
		///   The maximum scalar value possibly produced for the input.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizeV2'.
		/// </param>
		/// <param name="mode">
		///   Optional argument
		/// </param>
		/// <param name="round_mode">
		///   Optional argument
		/// </param>
		/// <param name="T">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output: The quantized data produced from the float input.
		///   output_min: The actual minimum scalar value used for the output.
		///   output_max: The actual maximum scalar value used for the output.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   [min_range, max_range] are scalar floats that specify the range for
		///   the 'input' data. The 'mode' attribute controls exactly which calculations are
		///   used to convert the float values to their quantized equivalents.  The
		///   'round_mode' attribute controls which rounding tie-breaking algorithm is used
		///   when rounding float values to their quantized equivalents.
		///   
		///   In 'MIN_COMBINED' mode, each value of the tensor will undergo the following:
		///   
		///    <code>
		///   out[i] = (in[i] - min_range) * range(T) / (max_range - min_range)
		///   if T == qint8: out[i] -= (range(T) + 1) / 2.0
		///    </code>
		///   
		///   here <c>range(T) = numeric_limits&amp;lt;T&amp;gt;::max() - numeric_limits&amp;lt;T&amp;gt;::min()</c>
		///   
		///   *MIN_COMBINED Mode Example*
		///   
		///   Assume the input is type float and has a possible range of [0.0, 6.0] and the
		///   output type is quint8 ([0, 255]). The min_range and max_range values should be
		///   specified as 0.0 and 6.0. Quantizing from float to quint8 will multiply each
		///   value of the input by 255/6 and cast to quint8.
		///   
		///   If the output type was qint8 ([-128, 127]), the operation will additionally
		///   subtract each value by 128 prior to casting, so that the range of values aligns
		///   with the range of qint8.
		///   
		///   If the mode is 'MIN_FIRST', then this approach is used:
		///   
		///    <code>
		///   num_discrete_values = 1 &amp;lt;&amp;lt; (# of bits in T)
		///   range_adjust = num_discrete_values / (num_discrete_values - 1)
		///   range = (range_max - range_min) * range_adjust
		///   range_scale = num_discrete_values / range
		///   quantized = round(input * range_scale) - round(range_min * range_scale) +
		///   numeric_limits&amp;lt;T&amp;gt;::min()
		///   quantized = max(quantized, numeric_limits&amp;lt;T&amp;gt;::min())
		///   quantized = min(quantized, numeric_limits&amp;lt;T&amp;gt;::max())
		///    </code>
		///   
		///   The biggest difference between this and MIN_COMBINED is that the minimum range
		///   is rounded first, before it's subtracted from the rounded value. With
		///   MIN_COMBINED, a small bias is introduced where repeated iterations of quantizing
		///   and dequantizing will introduce a larger and larger error.
		///   
		///   *SCALED mode Example*
		///   
		///   <c>SCALED</c> mode matches the quantization approach used in
		///   <c>QuantizeAndDequantize{V2|V3}</c>.
		///   
		///   If the mode is <c>SCALED</c>, we do not use the full range of the output type,
		///   choosing to elide the lowest possible value for symmetry (e.g., output range is
		///   -127 to 127, not -128 to 127 for signed 8 bit quantization), so that 0.0 maps to
		///   0.
		///   
		///   We first find the range of values in our tensor. The
		///   range we use is always centered on 0, so we find m such that
		///   
		///    <code>
		///   m = max(abs(input_min), abs(input_max))
		///    </code>
		///   
		///   Our input tensor range is then <c>[-m, m]</c>.
		///   
		///   Next, we choose our fixed-point quantization buckets, <c>[min_fixed, max_fixed]</c>.
		///   If T is signed, this is
		///   
		///    <code>
		///   num_bits = sizeof(T) * 8
		///   [min_fixed, max_fixed] =
		///   [-(1 &amp;lt;&amp;lt; (num_bits - 1) - 1), (1 &amp;lt;&amp;lt; (num_bits - 1)) - 1]
		///    </code>
		///   
		///   Otherwise, if T is unsigned, the fixed-point range is
		///   
		///    <code>
		///   [min_fixed, max_fixed] = [0, (1 &amp;lt;&amp;lt; num_bits) - 1]
		///    </code>
		///   
		///   From this we compute our scaling factor, s:
		///   
		///    <code>
		///   s = (max_fixed - min_fixed) / (2 * m)
		///    </code>
		///   
		///   Now we can quantize the elements of our tensor:
		///   
		///    <code>
		///   result = round(input * s)
		///    </code>
		///   
		///   One thing to watch out for is that the operator may choose to adjust the
		///   requested minimum and maximum values slightly during the quantization process,
		///   so you should always use the output ports as the range for further calculations.
		///   For example, if the requested minimum and maximum values are close to equal,
		///   they will be separated by a small epsilon value to prevent ill-formed quantized
		///   buffers from being created. Otherwise, you can end up with buffers where all the
		///   quantized values map to the same float value, which causes problems for
		///   operations that have to perform further calculations on them.
		/// </remarks>
		public (TF_Output output, TF_Output output_min, TF_Output output_max) QuantizeV2 (TF_Output input, TF_Output min_range, TF_Output max_range, TF_DataType T, string mode = null, string round_mode = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QuantizeV2", MakeName ("QuantizeV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, min_range);
			c_api.TF_AddInput(desc, max_range);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "T", T);
			if (mode != null)
				c_api.TF_SetAttrString (desc, "mode", mode);
			
			if (round_mode != null)
				c_api.TF_SetAttrString (desc, "round_mode", round_mode);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var output_min = new TF_Output (op, _idx++);
			var output_max = new TF_Output (op, _idx++);
			return (output, output_min, output_max);
		}

		/// <summary>
		///   Closes the given queue.
		/// </summary>
		/// <param name="handle">
		///   The handle to a queue.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueClose'.
		/// </param>
		/// <param name="cancel_pending_enqueues">
		///   Optional argument
		///   If true, all pending enqueue requests that are
		///   blocked on the given queue will be canceled.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   This operation signals that no more elements will be enqueued in the
		///   given queue. Subsequent Enqueue(Many) operations will fail.
		///   Subsequent Dequeue(Many) operations will continue to succeed if
		///   sufficient elements remain in the queue. Subsequent Dequeue(Many)
		///   operations that would block will fail immediately.
		/// </remarks>
		public TF_Operation QueueClose (TF_Output handle, bool? cancel_pending_enqueues = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueClose", MakeName ("QueueClose", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (cancel_pending_enqueues.HasValue)
				c_api.TF_SetAttrBool (desc, "cancel_pending_enqueues", Convert.ToByte(cancel_pending_enqueues.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Closes the given queue.
		/// </summary>
		/// <param name="handle">
		///   The handle to a queue.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueCloseV2'.
		/// </param>
		/// <param name="cancel_pending_enqueues">
		///   Optional argument
		///   If true, all pending enqueue requests that are
		///   blocked on the given queue will be canceled.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   This operation signals that no more elements will be enqueued in the
		///   given queue. Subsequent Enqueue(Many) operations will fail.
		///   Subsequent Dequeue(Many) operations will continue to succeed if
		///   sufficient elements remain in the queue. Subsequent Dequeue(Many)
		///   operations that would block will fail immediately.
		/// </remarks>
		public TF_Operation QueueCloseV2 (TF_Output handle, bool? cancel_pending_enqueues = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueCloseV2", MakeName ("QueueCloseV2", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (cancel_pending_enqueues.HasValue)
				c_api.TF_SetAttrBool (desc, "cancel_pending_enqueues", Convert.ToByte(cancel_pending_enqueues.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Dequeues a tuple of one or more tensors from the given queue.
		/// </summary>
		/// <param name="handle">
		///   The handle to a queue.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeue'.
		/// </param>
		/// <param name="timeout_ms">
		///   Optional argument
		///   If the queue is empty, this operation will block for up to
		///   timeout_ms milliseconds.
		///   Note: This option is not supported yet.
		/// </param>
		/// <param name="component_types">
		///   The type of each component in a tuple.
		/// </param>
		/// <returns>
		///   One or more tensors that were dequeued as a tuple.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation has k outputs, where k is the number of components
		///   in the tuples stored in the given queue, and output i is the ith
		///   component of the dequeued tuple.
		///   
		///   N.B. If the queue is empty, this operation will block until an element
		///   has been dequeued (or 'timeout_ms' elapses, if specified).
		/// </remarks>
		public TF_Output[] QueueDequeue (TF_Output handle, TF_DataType[] component_types, long? timeout_ms = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueDequeue", MakeName ("QueueDequeue", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (timeout_ms.HasValue)
				c_api.TF_SetAttrInt (desc, "timeout_ms", timeout_ms.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "components", status);
			var components = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				components [i] = new TF_Output (op, _idx++);
			
			return components;
		}

		/// <summary>
		///   Dequeues <c>n</c> tuples of one or more tensors from the given queue.
		/// </summary>
		/// <param name="handle">
		///   The handle to a queue.
		/// </param>
		/// <param name="n">
		///   The number of tuples to dequeue.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeueMany'.
		/// </param>
		/// <param name="timeout_ms">
		///   Optional argument
		///   If the queue has fewer than n elements, this operation
		///   will block for up to timeout_ms milliseconds.
		///   Note: This option is not supported yet.
		/// </param>
		/// <param name="component_types">
		///   The type of each component in a tuple.
		/// </param>
		/// <returns>
		///   One or more tensors that were dequeued as a tuple.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   If the queue is closed and there are fewer than <c>n</c> elements, then an
		///   OutOfRange error is returned.
		///   
		///   This operation concatenates queue-element component tensors along the
		///   0th dimension to make a single component tensor.  All of the components
		///   in the dequeued tuple will have size <c>n</c> in the 0th dimension.
		///   
		///   This operation has <c>k</c> outputs, where <c>k</c> is the number of components in
		///   the tuples stored in the given queue, and output <c>i</c> is the ith
		///   component of the dequeued tuple.
		///   
		///   N.B. If the queue is empty, this operation will block until <c>n</c> elements
		///   have been dequeued (or 'timeout_ms' elapses, if specified).
		/// </remarks>
		public TF_Output[] QueueDequeueMany (TF_Output handle, TF_Output n, TF_DataType[] component_types, long? timeout_ms = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueDequeueMany", MakeName ("QueueDequeueMany", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, n);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (timeout_ms.HasValue)
				c_api.TF_SetAttrInt (desc, "timeout_ms", timeout_ms.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "components", status);
			var components = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				components [i] = new TF_Output (op, _idx++);
			
			return components;
		}

		/// <summary>
		///   Dequeues <c>n</c> tuples of one or more tensors from the given queue.
		/// </summary>
		/// <param name="handle">
		///   The handle to a queue.
		/// </param>
		/// <param name="n">
		///   The number of tuples to dequeue.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeueManyV2'.
		/// </param>
		/// <param name="timeout_ms">
		///   Optional argument
		///   If the queue has fewer than n elements, this operation
		///   will block for up to timeout_ms milliseconds.
		///   Note: This option is not supported yet.
		/// </param>
		/// <param name="component_types">
		///   The type of each component in a tuple.
		/// </param>
		/// <returns>
		///   One or more tensors that were dequeued as a tuple.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   If the queue is closed and there are fewer than <c>n</c> elements, then an
		///   OutOfRange error is returned.
		///   
		///   This operation concatenates queue-element component tensors along the
		///   0th dimension to make a single component tensor.  All of the components
		///   in the dequeued tuple will have size <c>n</c> in the 0th dimension.
		///   
		///   This operation has <c>k</c> outputs, where <c>k</c> is the number of components in
		///   the tuples stored in the given queue, and output <c>i</c> is the ith
		///   component of the dequeued tuple.
		///   
		///   N.B. If the queue is empty, this operation will block until <c>n</c> elements
		///   have been dequeued (or 'timeout_ms' elapses, if specified).
		/// </remarks>
		public TF_Output[] QueueDequeueManyV2 (TF_Output handle, TF_Output n, TF_DataType[] component_types, long? timeout_ms = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueDequeueManyV2", MakeName ("QueueDequeueManyV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, n);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (timeout_ms.HasValue)
				c_api.TF_SetAttrInt (desc, "timeout_ms", timeout_ms.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "components", status);
			var components = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				components [i] = new TF_Output (op, _idx++);
			
			return components;
		}

		/// <summary>
		///   Dequeues <c>n</c> tuples of one or more tensors from the given queue.
		/// </summary>
		/// <param name="handle">
		///   The handle to a queue.
		/// </param>
		/// <param name="n">
		///   The number of tuples to dequeue.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeueUpTo'.
		/// </param>
		/// <param name="timeout_ms">
		///   Optional argument
		///   If the queue has fewer than n elements, this operation
		///   will block for up to timeout_ms milliseconds.
		///   Note: This option is not supported yet.
		/// </param>
		/// <param name="component_types">
		///   The type of each component in a tuple.
		/// </param>
		/// <returns>
		///   One or more tensors that were dequeued as a tuple.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation is not supported by all queues.  If a queue does not support
		///   DequeueUpTo, then an Unimplemented error is returned.
		///   
		///   If the queue is closed and there are more than 0 but less than <c>n</c>
		///   elements remaining, then instead of returning an OutOfRange error like
		///   QueueDequeueMany, less than <c>n</c> elements are returned immediately.  If
		///   the queue is closed and there are 0 elements left in the queue, then
		///   an OutOfRange error is returned just like in QueueDequeueMany.
		///   Otherwise the behavior is identical to QueueDequeueMany:
		///   
		///   This operation concatenates queue-element component tensors along the
		///   0th dimension to make a single component tensor.  All of the components
		///   in the dequeued tuple will have size <c>n</c> in the 0th dimension.
		///   
		///   This operation has k outputs, where <c>k</c> is the number of components in
		///   the tuples stored in the given queue, and output <c>i</c> is the ith
		///   component of the dequeued tuple.
		/// </remarks>
		public TF_Output[] QueueDequeueUpTo (TF_Output handle, TF_Output n, TF_DataType[] component_types, long? timeout_ms = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueDequeueUpTo", MakeName ("QueueDequeueUpTo", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, n);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (timeout_ms.HasValue)
				c_api.TF_SetAttrInt (desc, "timeout_ms", timeout_ms.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "components", status);
			var components = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				components [i] = new TF_Output (op, _idx++);
			
			return components;
		}

		/// <summary>
		///   Dequeues <c>n</c> tuples of one or more tensors from the given queue.
		/// </summary>
		/// <param name="handle">
		///   The handle to a queue.
		/// </param>
		/// <param name="n">
		///   The number of tuples to dequeue.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeueUpToV2'.
		/// </param>
		/// <param name="timeout_ms">
		///   Optional argument
		///   If the queue has fewer than n elements, this operation
		///   will block for up to timeout_ms milliseconds.
		///   Note: This option is not supported yet.
		/// </param>
		/// <param name="component_types">
		///   The type of each component in a tuple.
		/// </param>
		/// <returns>
		///   One or more tensors that were dequeued as a tuple.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation is not supported by all queues.  If a queue does not support
		///   DequeueUpTo, then an Unimplemented error is returned.
		///   
		///   If the queue is closed and there are more than 0 but less than <c>n</c>
		///   elements remaining, then instead of returning an OutOfRange error like
		///   QueueDequeueMany, less than <c>n</c> elements are returned immediately.  If
		///   the queue is closed and there are 0 elements left in the queue, then
		///   an OutOfRange error is returned just like in QueueDequeueMany.
		///   Otherwise the behavior is identical to QueueDequeueMany:
		///   
		///   This operation concatenates queue-element component tensors along the
		///   0th dimension to make a single component tensor.  All of the components
		///   in the dequeued tuple will have size n in the 0th dimension.
		///   
		///   This operation has <c>k</c> outputs, where <c>k</c> is the number of components in
		///   the tuples stored in the given queue, and output <c>i</c> is the ith
		///   component of the dequeued tuple.
		/// </remarks>
		public TF_Output[] QueueDequeueUpToV2 (TF_Output handle, TF_Output n, TF_DataType[] component_types, long? timeout_ms = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueDequeueUpToV2", MakeName ("QueueDequeueUpToV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, n);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (timeout_ms.HasValue)
				c_api.TF_SetAttrInt (desc, "timeout_ms", timeout_ms.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "components", status);
			var components = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				components [i] = new TF_Output (op, _idx++);
			
			return components;
		}

		/// <summary>
		///   Dequeues a tuple of one or more tensors from the given queue.
		/// </summary>
		/// <param name="handle">
		///   The handle to a queue.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeueV2'.
		/// </param>
		/// <param name="timeout_ms">
		///   Optional argument
		///   If the queue is empty, this operation will block for up to
		///   timeout_ms milliseconds.
		///   Note: This option is not supported yet.
		/// </param>
		/// <param name="component_types">
		///   The type of each component in a tuple.
		/// </param>
		/// <returns>
		///   One or more tensors that were dequeued as a tuple.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation has k outputs, where k is the number of components
		///   in the tuples stored in the given queue, and output i is the ith
		///   component of the dequeued tuple.
		///   
		///   N.B. If the queue is empty, this operation will block until an element
		///   has been dequeued (or 'timeout_ms' elapses, if specified).
		/// </remarks>
		public TF_Output[] QueueDequeueV2 (TF_Output handle, TF_DataType[] component_types, long? timeout_ms = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueDequeueV2", MakeName ("QueueDequeueV2", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (timeout_ms.HasValue)
				c_api.TF_SetAttrInt (desc, "timeout_ms", timeout_ms.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "components", status);
			var components = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				components [i] = new TF_Output (op, _idx++);
			
			return components;
		}

		/// <summary>
		///   Enqueues a tuple of one or more tensors in the given queue.
		/// </summary>
		/// <param name="handle">
		///   The handle to a queue.
		/// </param>
		/// <param name="components">
		///   One or more tensors from which the enqueued tensors should be taken.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueEnqueue'.
		/// </param>
		/// <param name="timeout_ms">
		///   Optional argument
		///   If the queue is full, this operation will block for up to
		///   timeout_ms milliseconds.
		///   Note: This option is not supported yet.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   The components input has k elements, which correspond to the components of
		///   tuples stored in the given queue.
		///   
		///   N.B. If the queue is full, this operation will block until the given
		///   element has been enqueued (or 'timeout_ms' elapses, if specified).
		/// </remarks>
		public TF_Operation QueueEnqueue (TF_Output handle, TF_Output[] components, long? timeout_ms = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueEnqueue", MakeName ("QueueEnqueue", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInputList(desc, components[0], components.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (timeout_ms.HasValue)
				c_api.TF_SetAttrInt (desc, "timeout_ms", timeout_ms.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Enqueues zero or more tuples of one or more tensors in the given queue.
		/// </summary>
		/// <param name="handle">
		///   The handle to a queue.
		/// </param>
		/// <param name="components">
		///   One or more tensors from which the enqueued tensors should
		///   be taken.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueEnqueueMany'.
		/// </param>
		/// <param name="timeout_ms">
		///   Optional argument
		///   If the queue is too full, this operation will block for up
		///   to timeout_ms milliseconds.
		///   Note: This option is not supported yet.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   This operation slices each component tensor along the 0th dimension to
		///   make multiple queue elements. All of the tuple components must have the
		///   same size in the 0th dimension.
		///   
		///   The components input has k elements, which correspond to the components of
		///   tuples stored in the given queue.
		///   
		///   N.B. If the queue is full, this operation will block until the given
		///   elements have been enqueued (or 'timeout_ms' elapses, if specified).
		/// </remarks>
		public TF_Operation QueueEnqueueMany (TF_Output handle, TF_Output[] components, long? timeout_ms = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueEnqueueMany", MakeName ("QueueEnqueueMany", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInputList(desc, components[0], components.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (timeout_ms.HasValue)
				c_api.TF_SetAttrInt (desc, "timeout_ms", timeout_ms.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Enqueues zero or more tuples of one or more tensors in the given queue.
		/// </summary>
		/// <param name="handle">
		///   The handle to a queue.
		/// </param>
		/// <param name="components">
		///   One or more tensors from which the enqueued tensors should
		///   be taken.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueEnqueueManyV2'.
		/// </param>
		/// <param name="timeout_ms">
		///   Optional argument
		///   If the queue is too full, this operation will block for up
		///   to timeout_ms milliseconds.
		///   Note: This option is not supported yet.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   This operation slices each component tensor along the 0th dimension to
		///   make multiple queue elements. All of the tuple components must have the
		///   same size in the 0th dimension.
		///   
		///   The components input has k elements, which correspond to the components of
		///   tuples stored in the given queue.
		///   
		///   N.B. If the queue is full, this operation will block until the given
		///   elements have been enqueued (or 'timeout_ms' elapses, if specified).
		/// </remarks>
		public TF_Operation QueueEnqueueManyV2 (TF_Output handle, TF_Output[] components, long? timeout_ms = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueEnqueueManyV2", MakeName ("QueueEnqueueManyV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInputList(desc, components[0], components.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (timeout_ms.HasValue)
				c_api.TF_SetAttrInt (desc, "timeout_ms", timeout_ms.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Enqueues a tuple of one or more tensors in the given queue.
		/// </summary>
		/// <param name="handle">
		///   The handle to a queue.
		/// </param>
		/// <param name="components">
		///   One or more tensors from which the enqueued tensors should be taken.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueEnqueueV2'.
		/// </param>
		/// <param name="timeout_ms">
		///   Optional argument
		///   If the queue is full, this operation will block for up to
		///   timeout_ms milliseconds.
		///   Note: This option is not supported yet.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   The components input has k elements, which correspond to the components of
		///   tuples stored in the given queue.
		///   
		///   N.B. If the queue is full, this operation will block until the given
		///   element has been enqueued (or 'timeout_ms' elapses, if specified).
		/// </remarks>
		public TF_Operation QueueEnqueueV2 (TF_Output handle, TF_Output[] components, long? timeout_ms = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueEnqueueV2", MakeName ("QueueEnqueueV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInputList(desc, components[0], components.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (timeout_ms.HasValue)
				c_api.TF_SetAttrInt (desc, "timeout_ms", timeout_ms.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Returns true if queue is closed.
		/// </summary>
		/// <param name="handle">
		///   The handle to a queue.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueIsClosed'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation returns true if the queue is closed and false if the queue
		///   is open.
		/// </remarks>
		public TF_Output QueueIsClosed (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueIsClosed", MakeName ("QueueIsClosed", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var is_closed = new TF_Output (op, _idx++);
			return is_closed;
		}

		/// <summary>
		///   Returns true if queue is closed.
		/// </summary>
		/// <param name="handle">
		///   The handle to a queue.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueIsClosedV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation returns true if the queue is closed and false if the queue
		///   is open.
		/// </remarks>
		public TF_Output QueueIsClosedV2 (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueIsClosedV2", MakeName ("QueueIsClosedV2", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var is_closed = new TF_Output (op, _idx++);
			return is_closed;
		}

		/// <summary>
		///   Computes the number of elements in the given queue.
		/// </summary>
		/// <param name="handle">
		///   The handle to a queue.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueSize'.
		/// </param>
		/// <returns>
		///   The number of elements in the given queue.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output QueueSize (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueSize", MakeName ("QueueSize", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		///   Computes the number of elements in the given queue.
		/// </summary>
		/// <param name="handle">
		///   The handle to a queue.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueSizeV2'.
		/// </param>
		/// <returns>
		///   The number of elements in the given queue.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output QueueSizeV2 (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "QueueSizeV2", MakeName ("QueueSizeV2", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		///   Gather ragged slices from <c>params</c> axis <c>0</c> according to <c>indices</c>.
		/// </summary>
		/// <param name="params_nested_splits">
		///   The <c>nested_row_splits</c> tensors that define the row-partitioning for the
		///   <c>params</c> RaggedTensor input.
		/// </param>
		/// <param name="params_dense_values">
		///   The <c>flat_values</c> for the <c>params</c> RaggedTensor. There was a terminology change
		///   at the python level from dense_values to flat_values, so dense_values is the
		///   deprecated name.
		/// </param>
		/// <param name="indices">
		///   Indices in the outermost dimension of <c>params</c> of the values that should be
		///   gathered.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RaggedGather'.
		/// </param>
		/// <param name="OUTPUT_RAGGED_RANK">
		///   The ragged rank of the output RaggedTensor. <c>output_nested_splits</c> will contain
		///   this number of <c>row_splits</c> tensors. This value should equal
		///   <c>indices.shape.ndims + params.ragged_rank - 1</c>.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_nested_splits: The <c>nested_row_splits</c> tensors that define the row-partitioning for the
		///   returned RaggedTensor.
		///   output_dense_values: The <c>flat_values</c> for the returned RaggedTensor.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Outputs a <c>RaggedTensor</c> output composed from <c>output_dense_values</c> and
		///   <c>output_nested_splits</c>, such that:
		///   
		///    <code>
		///   output.shape = indices.shape + params.shape[1:]
		///   output.ragged_rank = indices.shape.ndims + params.ragged_rank
		///   output[i...j, d0...dn] = params[indices[i...j], d0...dn]
		///    </code>
		///   
		///   where
		///   
		///   * <c>params =
		///   ragged.from_nested_row_splits(params_dense_values, params_nested_splits)</c>
		///   provides the values that should be gathered.
		///   * <c>indices</c> ia a dense tensor with dtype <c>int32</c> or <c>int64</c>, indicating which
		///   values should be gathered.
		///   * <c>output =
		///   ragged.from_nested_row_splits(output_dense_values, output_nested_splits)</c>
		///   is the output tensor.
		///   
		///   (Note: This c++ op is used to implement the higher-level python
		///   <c>tf.ragged.gather</c> op, which also supports ragged indices.)
		///   
		/// </remarks>
		public (TF_Output[] output_nested_splits, TF_Output output_dense_values) RaggedGather (TF_Output[] params_nested_splits, TF_Output params_dense_values, TF_Output indices, long OUTPUT_RAGGED_RANK, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RaggedGather", MakeName ("RaggedGather", operName));
			c_api.TF_AddInputList(desc, params_nested_splits[0], params_nested_splits.Length);
			c_api.TF_AddInput(desc, params_dense_values);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "OUTPUT_RAGGED_RANK", OUTPUT_RAGGED_RANK);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output_nested_splits", status);
			var output_nested_splits = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output_nested_splits [i] = new TF_Output (op, _idx++);
			
			var output_dense_values = new TF_Output (op, _idx++);
			return (output_nested_splits, output_dense_values);
		}

		/// <summary>
		///   Returns a <c>RaggedTensor</c> containing the specified sequences of numbers.
		/// </summary>
		/// <param name="starts">
		///   The starts of each range.
		/// </param>
		/// <param name="limits">
		///   The limits of each range.
		/// </param>
		/// <param name="deltas">
		///   The deltas of each range.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RaggedRange'.
		/// </param>
		/// <param name="Tsplits">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   rt_nested_splits: The <c>row_splits</c> for the returned <c>RaggedTensor</c>.
		///   rt_dense_values: The <c>flat_values</c> for the returned <c>RaggedTensor</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   
		///   Returns a <c>RaggedTensor</c> <c>result</c> composed from <c>rt_dense_values</c> and
		///   <c>rt_nested_splits</c>, such that
		///   <c>result[i] = range(starts[i], limits[i], deltas[i])</c>.
		///   
		///    <code>
		///   &amp;gt;&amp;gt;&amp;gt; (rt_nested_splits, rt_dense_values) = gen_ragged_ops.ragged_range(
		///   ...     starts=[2, 5, 8], limits=[3, 5, 12], deltas=1)
		///   &amp;gt;&amp;gt;&amp;gt; result = ragged.from_nested_row_splits(rt_dense_values, rt_nested_splits)
		///   &amp;gt;&amp;gt;&amp;gt; print result.eval().tolist()
		///   [[2],               # result[0] = range(2, 3)
		///   [],                # result[1] = range(5, 5)
		///   [8, 9, 10, 11]]    # result[2] = range(8, 12)
		///    </code>
		///   
		///   The input tensors <c>starts</c>, <c>limits</c>, and <c>deltas</c> may be scalars or vectors.
		///   The vector inputs must all have the same size.  Scalar inputs are broadcast
		///   to match the size of the vector inputs.
		/// </remarks>
		public (TF_Output rt_nested_splits, TF_Output rt_dense_values) RaggedRange (TF_Output starts, TF_Output limits, TF_Output deltas, TF_DataType? Tsplits = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RaggedRange", MakeName ("RaggedRange", operName));
			c_api.TF_AddInput(desc, starts);
			c_api.TF_AddInput(desc, limits);
			c_api.TF_AddInput(desc, deltas);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Tsplits.HasValue)
				c_api.TF_SetAttrType (desc, "Tsplits", Tsplits.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var rt_nested_splits = new TF_Output (op, _idx++);
			var rt_dense_values = new TF_Output (op, _idx++);
			return (rt_nested_splits, rt_dense_values);
		}

		/// <summary>
		///   Decodes a <c>variant</c> Tensor into a <c>RaggedTensor</c>.
		/// </summary>
		/// <param name="encoded_ragged">
		///   A <c>variant</c> Tensor containing encoded <c>RaggedTensor</c>s.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RaggedTensorFromVariant'.
		/// </param>
		/// <param name="input_ragged_rank">
		///   The ragged rank of each encoded <c>RaggedTensor</c> component in the input. If set to
		///   -1, this is inferred as <c>output_ragged_rank</c> - <c>rank(encoded_ragged)</c>
		/// </param>
		/// <param name="output_ragged_rank">
		///   The expected ragged rank of the output <c>RaggedTensor</c>. The following must hold:
		///   <c>output_ragged_rank = rank(encoded_ragged) + input_ragged_rank</c>.
		/// </param>
		/// <param name="Tvalues">
		/// </param>
		/// <param name="Tsplits">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_nested_splits: A list of one or more Tensors representing the splits of the output
		///   <c>RaggedTensor</c>.
		///   output_dense_values: A Tensor representing the values of the output <c>RaggedTensor</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Decodes the given <c>variant</c> Tensor and returns a <c>RaggedTensor</c>. The input
		///   could be a scalar, meaning it encodes a single <c>RaggedTensor</c> with ragged_rank
		///   <c>output_ragged_rank</c>. It could also have an arbitrary rank, in which case each
		///   element is decoded into a <c>RaggedTensor</c> with ragged_rank <c>input_ragged_rank</c>
		///   and these are then stacked according to the input shape to output a single
		///   <c>RaggedTensor</c> with ragged_rank <c>output_ragged_rank</c>. Each <c>variant</c> element in
		///   the input Tensor is decoded by retrieving from the element a 1-D <c>variant</c>
		///   Tensor with <c>input_ragged_rank + 1</c> Tensors, corresponding to the splits and
		///   values of the decoded <c>RaggedTensor</c>. If <c>input_ragged_rank</c> is -1, then it is
		///   inferred as <c>output_ragged_rank</c> - <c>rank(encoded_ragged)</c>. See
		///   <c>RaggedTensorToVariant</c> for the corresponding encoding logic.
		///   
		/// </remarks>
		public (TF_Output[] output_nested_splits, TF_Output output_dense_values) RaggedTensorFromVariant (TF_Output encoded_ragged, long input_ragged_rank, long output_ragged_rank, TF_DataType Tvalues, TF_DataType Tsplits, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RaggedTensorFromVariant", MakeName ("RaggedTensorFromVariant", operName));
			c_api.TF_AddInput(desc, encoded_ragged);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "input_ragged_rank", input_ragged_rank);
			c_api.TF_SetAttrInt (desc, "output_ragged_rank", output_ragged_rank);
			c_api.TF_SetAttrType (desc, "Tvalues", Tvalues);
			c_api.TF_SetAttrType (desc, "Tsplits", Tsplits);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output_nested_splits", status);
			var output_nested_splits = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output_nested_splits [i] = new TF_Output (op, _idx++);
			
			var output_dense_values = new TF_Output (op, _idx++);
			return (output_nested_splits, output_dense_values);
		}

		/// <summary>
		///   Converts a <c>RaggedTensor</c> into a <c>SparseTensor</c> with the same values.
		/// </summary>
		/// <param name="rt_nested_splits">
		///   The <c>row_splits</c> for the <c>RaggedTensor</c>.
		/// </param>
		/// <param name="rt_dense_values">
		///   The <c>flat_values</c> for the <c>RaggedTensor</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RaggedTensorToSparse'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sparse_indices: The indices for the <c>SparseTensor</c>.
		///   sparse_values: The values of the <c>SparseTensor</c>.
		///   sparse_dense_shape: <c>sparse_dense_shape</c> is a tight bounding box of the input <c>RaggedTensor</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   input=ragged.from_nested_row_splits(rt_dense_values, rt_nested_splits)
		///   output=SparseTensor(indices=sparse_indices, values=sparse_values,
		///   dense_shape=sparse_dense_shape)
		/// </remarks>
		public (TF_Output sparse_indices, TF_Output sparse_values, TF_Output sparse_dense_shape) RaggedTensorToSparse (TF_Output[] rt_nested_splits, TF_Output rt_dense_values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RaggedTensorToSparse", MakeName ("RaggedTensorToSparse", operName));
			c_api.TF_AddInputList(desc, rt_nested_splits[0], rt_nested_splits.Length);
			c_api.TF_AddInput(desc, rt_dense_values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var sparse_indices = new TF_Output (op, _idx++);
			var sparse_values = new TF_Output (op, _idx++);
			var sparse_dense_shape = new TF_Output (op, _idx++);
			return (sparse_indices, sparse_values, sparse_dense_shape);
		}

		/// <summary>
		///   Encodes a <c>RaggedTensor</c> into a <c>variant</c> Tensor.
		/// </summary>
		/// <param name="rt_nested_splits">
		///   A list of one or more Tensors representing the splits of the input
		///   <c>RaggedTensor</c>.
		/// </param>
		/// <param name="rt_dense_values">
		///   A Tensor representing the values of the input <c>RaggedTensor</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RaggedTensorToVariant'.
		/// </param>
		/// <param name="batched_input">
		///   A <c>bool</c> denoting whether the input is a batched <c>RaggedTensor</c>.
		/// </param>
		/// <returns>
		///   A <c>variant</c> Tensor that containing encoded <c>RaggedTensor</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   
		///   Encodes the given <c>RaggedTensor</c> and returns a <c>variant</c> Tensor. If
		///   <c>batched_input</c> is True, then input <c>RaggedTensor</c> is unbatched along the
		///   zero-th dimension, each component <c>RaggedTensor</c> is encoded into a scalar
		///   <c>variant</c> Tensor, and these are stacked to return a 1-D <c>variant</c> Tensor.
		///   If <c>batched_input</c> is False, then the input <c>RaggedTensor</c> is encoded as is and
		///   a scalar <c>variant</c> Tensor is returned. A <c>RaggedTensor</c> is encoded by first
		///   creating a 1-D <c>variant</c> Tensor with <c>ragged_rank + 1</c> elements, containing the
		///   splits and values Tensors of the <c>RaggedTensor</c>. Then the 1-D <c>variant</c> Tensor
		///   is wrapped in a scalar <c>variant</c> Tensor. See <c>RaggedTensorFromVariant</c> for the
		///   corresponding decoding logic.
		///   
		/// </remarks>
		public TF_Output RaggedTensorToVariant (TF_Output[] rt_nested_splits, TF_Output rt_dense_values, bool batched_input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RaggedTensorToVariant", MakeName ("RaggedTensorToVariant", operName));
			c_api.TF_AddInputList(desc, rt_nested_splits[0], rt_nested_splits.Length);
			c_api.TF_AddInput(desc, rt_dense_values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrBool (desc, "batched_input", Convert.ToByte(batched_input));
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var encoded_ragged = new TF_Output (op, _idx++);
			return encoded_ragged;
		}

		/// <summary>
		///   Randomly crop <c>image</c>.
		/// </summary>
		/// <param name="image">
		///   3-D of shape <c>[height, width, channels]</c>.
		/// </param>
		/// <param name="size">
		///   1-D of length 2 containing: <c>crop_height</c>, <c>crop_width</c>..
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomCrop'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either seed or seed2 are set to be non-zero, the random number
		///   generator is seeded by the given seed.  Otherwise, it is seeded by a
		///   random seed.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   An second seed to avoid seed collision.
		/// </param>
		/// <returns>
		///   3-D of shape <c>[crop_height, crop_width, channels].</c>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   <c>size</c> is a 1-D int64 tensor with 2 elements representing the crop height and
		///   width.  The values must be non negative.
		///   
		///   This Op picks a random location in <c>image</c> and crops a <c>height</c> by <c>width</c>
		///   rectangle from that location.  The random location is picked so the cropped
		///   area will fit inside the original image.
		/// </remarks>
		public TF_Output RandomCrop (TF_Output image, TF_Output size, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomCrop", MakeName ("RandomCrop", operName));
			c_api.TF_AddInput(desc, image);
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates a Dataset that returns pseudorandom numbers.
		/// </summary>
		/// <param name="seed">
		///   A scalar seed for the random number generator. If either seed or
		///   seed2 is set to be non-zero, the random number generator is seeded
		///   by the given seed.  Otherwise, a random seed is used.
		/// </param>
		/// <param name="seed2">
		///   A second scalar seed to avoid seed collision.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RandomDataset (TF_Output seed, TF_Output seed2, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomDataset", MakeName ("RandomDataset", operName));
			c_api.TF_AddInput(desc, seed);
			c_api.TF_AddInput(desc, seed2);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Outputs random values from the Gamma distribution(s) described by alpha.
		/// </summary>
		/// <param name="shape">
		///   1-D integer tensor. Shape of independent samples to draw from each
		///   distribution described by the shape parameters given in alpha.
		/// </param>
		/// <param name="alpha">
		///   A tensor in which each scalar is a "shape" parameter describing the
		///   associated gamma distribution.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomGamma'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either <c>seed</c> or <c>seed2</c> are set to be non-zero, the random number
		///   generator is seeded by the given seed.  Otherwise, it is seeded by a
		///   random seed.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   A second seed to avoid seed collision.
		/// </param>
		/// <returns>
		///   A tensor with shape <c>shape + shape(alpha)</c>. Each slice
		///   <c>[:, ..., :, i0, i1, ...iN]</c> contains the samples drawn for
		///   <c>alpha[i0, i1, ...iN]</c>. The dtype of the output matches the dtype of alpha.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op uses the algorithm by Marsaglia et al. to acquire samples via
		///   transformation-rejection from pairs of uniform and normal random variables.
		///   See http://dl.acm.org/citation.cfm?id=358414
		/// </remarks>
		public TF_Output RandomGamma (TF_Output shape, TF_Output alpha, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomGamma", MakeName ("RandomGamma", operName));
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, alpha);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the derivative of a Gamma random sample w.r.t. <c>alpha</c>.
		/// </summary>
		/// <param name="alpha">
		/// </param>
		/// <param name="sample">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomGammaGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RandomGammaGrad (TF_Output alpha, TF_Output sample, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomGammaGrad", MakeName ("RandomGammaGrad", operName));
			c_api.TF_AddInput(desc, alpha);
			c_api.TF_AddInput(desc, sample);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Use RandomPoissonV2 instead.
		/// </summary>
		/// <param name="shape">
		/// </param>
		/// <param name="rate">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomPoisson'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RandomPoisson (TF_Output shape, TF_Output rate, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomPoisson", MakeName ("RandomPoisson", operName));
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, rate);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Outputs random values from the Poisson distribution(s) described by rate.
		/// </summary>
		/// <param name="shape">
		///   1-D integer tensor. Shape of independent samples to draw from each
		///   distribution described by the shape parameters given in rate.
		/// </param>
		/// <param name="rate">
		///   A tensor in which each scalar is a "rate" parameter describing the
		///   associated poisson distribution.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomPoissonV2'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either <c>seed</c> or <c>seed2</c> are set to be non-zero, the random number
		///   generator is seeded by the given seed.  Otherwise, it is seeded by a
		///   random seed.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   A second seed to avoid seed collision.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   A tensor with shape <c>shape + shape(rate)</c>. Each slice
		///   <c>[:, ..., :, i0, i1, ...iN]</c> contains the samples drawn for
		///   <c>rate[i0, i1, ...iN]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op uses two algorithms, depending on rate. If rate &amp;gt;= 10, then
		///   the algorithm by Hormann is used to acquire samples via
		///   transformation-rejection.
		///   See http://www.sciencedirect.com/science/article/pii/0167668793909974.
		///   
		///   Otherwise, Knuth's algorithm is used to acquire samples via multiplying uniform
		///   random variables.
		///   See Donald E. Knuth (1969). Seminumerical Algorithms. The Art of Computer
		///   Programming, Volume 2. Addison Wesley
		/// </remarks>
		public TF_Output RandomPoissonV2 (TF_Output shape, TF_Output rate, long? seed = null, long? seed2 = null, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomPoissonV2", MakeName ("RandomPoissonV2", operName));
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, rate);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Randomly shuffles a tensor along its first dimension.
		/// </summary>
		/// <param name="value">
		///   The tensor to be shuffled.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomShuffle'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either <c>seed</c> or <c>seed2</c> are set to be non-zero, the random number
		///   generator is seeded by the given seed.  Otherwise, it is seeded by a
		///   random seed.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   A second seed to avoid seed collision.
		/// </param>
		/// <returns>
		///   A tensor of same shape and type as <c>value</c>, shuffled along its first
		///   dimension.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The tensor is shuffled along dimension 0, such that each <c>value[j]</c> is mapped
		///   to one and only one <c>output[i]</c>. For example, a mapping that might occur for a
		///   3x2 tensor is:
		///   
		///    <code>
		///   [[1, 2],       [[5, 6],
		///   [3, 4],  ==&amp;gt;   [1, 2],
		///   [5, 6]]        [3, 4]]
		///    </code>
		/// </remarks>
		public TF_Output RandomShuffle (TF_Output value, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomShuffle", MakeName ("RandomShuffle", operName));
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   A queue that randomizes the order of elements.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomShuffleQueue'.
		/// </param>
		/// <param name="shapes">
		///   Optional argument
		///   The shape of each component in a value. The length of this attr must
		///   be either 0 or the same as the length of component_types. If the length of
		///   this attr is 0, the shapes of queue elements are not constrained, and
		///   only one element may be dequeued at a time.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		///   The upper bound on the number of elements in this queue.
		///   Negative numbers mean no limit.
		/// </param>
		/// <param name="min_after_dequeue">
		///   Optional argument
		///   Dequeue will block unless there would be this
		///   many elements after the dequeue or the queue is closed. This
		///   ensures a minimum level of mixing of elements.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either seed or seed2 is set to be non-zero, the random number
		///   generator is seeded by the given seed.  Otherwise, a random seed is used.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   A second seed to avoid seed collision.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this queue is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this queue will be shared under the given name
		///   across multiple sessions.
		/// </param>
		/// <param name="component_types">
		///   The type of each component in a value.
		/// </param>
		/// <returns>
		///   The handle to the queue.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RandomShuffleQueue (TF_DataType[] component_types, long[][] shapes = null, long? capacity = null, long? min_after_dequeue = null, long? seed = null, long? seed2 = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomShuffleQueue", MakeName ("RandomShuffleQueue", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (shapes != null)
				c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (min_after_dequeue.HasValue)
				c_api.TF_SetAttrInt (desc, "min_after_dequeue", min_after_dequeue.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   A queue that randomizes the order of elements.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomShuffleQueueV2'.
		/// </param>
		/// <param name="shapes">
		///   Optional argument
		///   The shape of each component in a value. The length of this attr must
		///   be either 0 or the same as the length of component_types. If the length of
		///   this attr is 0, the shapes of queue elements are not constrained, and
		///   only one element may be dequeued at a time.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		///   The upper bound on the number of elements in this queue.
		///   Negative numbers mean no limit.
		/// </param>
		/// <param name="min_after_dequeue">
		///   Optional argument
		///   Dequeue will block unless there would be this
		///   many elements after the dequeue or the queue is closed. This
		///   ensures a minimum level of mixing of elements.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either seed or seed2 is set to be non-zero, the random number
		///   generator is seeded by the given seed.  Otherwise, a random seed is used.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   A second seed to avoid seed collision.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this queue is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this queue will be shared under the given name
		///   across multiple sessions.
		/// </param>
		/// <param name="component_types">
		///   The type of each component in a value.
		/// </param>
		/// <returns>
		///   The handle to the queue.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RandomShuffleQueueV2 (TF_DataType[] component_types, long[][] shapes = null, long? capacity = null, long? min_after_dequeue = null, long? seed = null, long? seed2 = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomShuffleQueueV2", MakeName ("RandomShuffleQueueV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "component_types", component_types);
			if (shapes != null)
				c_api.TF_SetAttrShapeList (desc, "shapes", shapes);
			
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (min_after_dequeue.HasValue)
				c_api.TF_SetAttrInt (desc, "min_after_dequeue", min_after_dequeue.Value);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Outputs random values from a normal distribution.
		/// </summary>
		/// <param name="shape">
		///   The shape of the output tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomStandardNormal'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either <c>seed</c> or <c>seed2</c> are set to be non-zero, the random number
		///   generator is seeded by the given seed.  Otherwise, it is seeded by a
		///   random seed.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   A second seed to avoid seed collision.
		/// </param>
		/// <param name="dtype">
		///   The type of the output.
		/// </param>
		/// <returns>
		///   A tensor of the specified shape filled with random normal values.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The generated values will have mean 0 and standard deviation 1.
		/// </remarks>
		public TF_Output RandomStandardNormal (TF_Output shape, TF_DataType dtype, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomStandardNormal", MakeName ("RandomStandardNormal", operName));
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Outputs random values from a uniform distribution.
		/// </summary>
		/// <param name="shape">
		///   The shape of the output tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomUniform'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either <c>seed</c> or <c>seed2</c> are set to be non-zero, the random number
		///   generator is seeded by the given seed.  Otherwise, it is seeded by a
		///   random seed.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   A second seed to avoid seed collision.
		/// </param>
		/// <param name="dtype">
		///   The type of the output.
		/// </param>
		/// <returns>
		///   A tensor of the specified shape filled with uniform random values.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The generated values follow a uniform distribution in the range <c>[0, 1)</c>. The
		///   lower bound 0 is included in the range, while the upper bound 1 is excluded.
		/// </remarks>
		public TF_Output RandomUniform (TF_Output shape, TF_DataType dtype, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomUniform", MakeName ("RandomUniform", operName));
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Outputs random integers from a uniform distribution.
		/// </summary>
		/// <param name="shape">
		///   The shape of the output tensor.
		/// </param>
		/// <param name="minval">
		///   0-D.  Inclusive lower bound on the generated integers.
		/// </param>
		/// <param name="maxval">
		///   0-D.  Exclusive upper bound on the generated integers.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomUniformInt'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either <c>seed</c> or <c>seed2</c> are set to be non-zero, the random number
		///   generator is seeded by the given seed.  Otherwise, it is seeded by a
		///   random seed.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   A second seed to avoid seed collision.
		/// </param>
		/// <returns>
		///   A tensor of the specified shape filled with uniform random integers.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The generated values are uniform integers in the range <c>[minval, maxval)</c>.
		///   The lower bound <c>minval</c> is included in the range, while the upper bound
		///   <c>maxval</c> is excluded.
		///   
		///   The random integers are slightly biased unless <c>maxval - minval</c> is an exact
		///   power of two.  The bias is small for values of <c>maxval - minval</c> significantly
		///   smaller than the range of the output (either <c>2^32</c> or <c>2^64</c>).
		/// </remarks>
		public TF_Output RandomUniformInt (TF_Output shape, TF_Output minval, TF_Output maxval, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RandomUniformInt", MakeName ("RandomUniformInt", operName));
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, minval);
			c_api.TF_AddInput(desc, maxval);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates a sequence of numbers.
		/// </summary>
		/// <param name="start">
		///   0-D (scalar). First entry in the sequence.
		/// </param>
		/// <param name="limit">
		///   0-D (scalar). Upper limit of sequence, exclusive.
		/// </param>
		/// <param name="delta">
		///   0-D (scalar). Optional. Default is 1. Number that increments <c>start</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Range'.
		/// </param>
		/// <returns>
		///   1-D.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation creates a sequence of numbers that begins at <c>start</c> and
		///   extends by increments of <c>delta</c> up to but not including <c>limit</c>.
		///   
		///   For example:
		///   
		///    <code>
		///   # 'start' is 3
		///   # 'limit' is 18
		///   # 'delta' is 3
		///   tf.range(start, limit, delta) ==&amp;gt; [3, 6, 9, 12, 15]
		///    </code>
		/// </remarks>
		public TF_Output Range (TF_Output start, TF_Output limit, TF_Output delta, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Range", MakeName ("Range", operName));
			c_api.TF_AddInput(desc, start);
			c_api.TF_AddInput(desc, limit);
			c_api.TF_AddInput(desc, delta);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates a dataset with a range of values. Corresponds to python's xrange.
		/// </summary>
		/// <param name="start">
		///   corresponds to start in python's xrange().
		/// </param>
		/// <param name="stop">
		///   corresponds to stop in python's xrange().
		/// </param>
		/// <param name="step">
		///   corresponds to step in python's xrange().
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RangeDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RangeDataset (TF_Output start, TF_Output stop, TF_Output step, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RangeDataset", MakeName ("RangeDataset", operName));
			c_api.TF_AddInput(desc, start);
			c_api.TF_AddInput(desc, stop);
			c_api.TF_AddInput(desc, step);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Returns the rank of a tensor.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Rank'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation returns an integer representing the rank of <c>input</c>.
		///   
		///   For example:
		///   
		///    <code>
		///   # 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]
		///   # shape of tensor 't' is [2, 2, 3]
		///   rank(t) ==&amp;gt; 3
		///    </code>
		///   
		///   **Note**: The rank of a tensor is not the same as the rank of a matrix. The rank
		///   of a tensor is the number of indices required to uniquely select each element
		///   of the tensor. Rank is also known as "order", "degree", or "ndims."
		/// </remarks>
		public TF_Output Rank (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Rank", MakeName ("Rank", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns the number of records this Reader has produced.
		/// </summary>
		/// <param name="reader_handle">
		///   Handle to a Reader.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderNumRecordsProduced'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This is the same as the number of ReaderRead executions that have
		///   succeeded.
		/// </remarks>
		public TF_Output ReaderNumRecordsProduced (TF_Output reader_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderNumRecordsProduced", MakeName ("ReaderNumRecordsProduced", operName));
			c_api.TF_AddInput(desc, reader_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var records_produced = new TF_Output (op, _idx++);
			return records_produced;
		}

		/// <summary>
		///   Returns the number of records this Reader has produced.
		/// </summary>
		/// <param name="reader_handle">
		///   Handle to a Reader.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderNumRecordsProducedV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This is the same as the number of ReaderRead executions that have
		///   succeeded.
		/// </remarks>
		public TF_Output ReaderNumRecordsProducedV2 (TF_Output reader_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderNumRecordsProducedV2", MakeName ("ReaderNumRecordsProducedV2", operName));
			c_api.TF_AddInput(desc, reader_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var records_produced = new TF_Output (op, _idx++);
			return records_produced;
		}

		/// <summary>
		///   Returns the number of work units this Reader has finished processing.
		/// </summary>
		/// <param name="reader_handle">
		///   Handle to a Reader.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderNumWorkUnitsCompleted'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ReaderNumWorkUnitsCompleted (TF_Output reader_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderNumWorkUnitsCompleted", MakeName ("ReaderNumWorkUnitsCompleted", operName));
			c_api.TF_AddInput(desc, reader_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var units_completed = new TF_Output (op, _idx++);
			return units_completed;
		}

		/// <summary>
		///   Returns the number of work units this Reader has finished processing.
		/// </summary>
		/// <param name="reader_handle">
		///   Handle to a Reader.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderNumWorkUnitsCompletedV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ReaderNumWorkUnitsCompletedV2 (TF_Output reader_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderNumWorkUnitsCompletedV2", MakeName ("ReaderNumWorkUnitsCompletedV2", operName));
			c_api.TF_AddInput(desc, reader_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var units_completed = new TF_Output (op, _idx++);
			return units_completed;
		}

		/// <summary>
		///   Returns the next record (key, value pair) produced by a Reader.
		/// </summary>
		/// <param name="reader_handle">
		///   Handle to a Reader.
		/// </param>
		/// <param name="queue_handle">
		///   Handle to a Queue, with string work items.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderRead'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   key: A scalar.
		///   value: A scalar.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Will dequeue from the input queue if necessary (e.g. when the
		///   Reader needs to start reading from a new file since it has finished
		///   with the previous file).
		/// </remarks>
		public (TF_Output key, TF_Output value) ReaderRead (TF_Output reader_handle, TF_Output queue_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderRead", MakeName ("ReaderRead", operName));
			c_api.TF_AddInput(desc, reader_handle);
			c_api.TF_AddInput(desc, queue_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var key = new TF_Output (op, _idx++);
			var value = new TF_Output (op, _idx++);
			return (key, value);
		}

		/// <summary>
		///   Returns up to <c>num_records</c> (key, value) pairs produced by a Reader.
		/// </summary>
		/// <param name="reader_handle">
		///   Handle to a <c>Reader</c>.
		/// </param>
		/// <param name="queue_handle">
		///   Handle to a <c>Queue</c>, with string work items.
		/// </param>
		/// <param name="num_records">
		///   number of records to read from <c>Reader</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderReadUpTo'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   keys: A 1-D tensor.
		///   values: A 1-D tensor.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Will dequeue from the input queue if necessary (e.g. when the
		///   Reader needs to start reading from a new file since it has finished
		///   with the previous file).
		///   It may return less than <c>num_records</c> even before the last batch.
		/// </remarks>
		public (TF_Output keys, TF_Output values) ReaderReadUpTo (TF_Output reader_handle, TF_Output queue_handle, TF_Output num_records, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderReadUpTo", MakeName ("ReaderReadUpTo", operName));
			c_api.TF_AddInput(desc, reader_handle);
			c_api.TF_AddInput(desc, queue_handle);
			c_api.TF_AddInput(desc, num_records);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var keys = new TF_Output (op, _idx++);
			var values = new TF_Output (op, _idx++);
			return (keys, values);
		}

		/// <summary>
		///   Returns up to <c>num_records</c> (key, value) pairs produced by a Reader.
		/// </summary>
		/// <param name="reader_handle">
		///   Handle to a <c>Reader</c>.
		/// </param>
		/// <param name="queue_handle">
		///   Handle to a <c>Queue</c>, with string work items.
		/// </param>
		/// <param name="num_records">
		///   number of records to read from <c>Reader</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderReadUpToV2'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   keys: A 1-D tensor.
		///   values: A 1-D tensor.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Will dequeue from the input queue if necessary (e.g. when the
		///   Reader needs to start reading from a new file since it has finished
		///   with the previous file).
		///   It may return less than <c>num_records</c> even before the last batch.
		/// </remarks>
		public (TF_Output keys, TF_Output values) ReaderReadUpToV2 (TF_Output reader_handle, TF_Output queue_handle, TF_Output num_records, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderReadUpToV2", MakeName ("ReaderReadUpToV2", operName));
			c_api.TF_AddInput(desc, reader_handle);
			c_api.TF_AddInput(desc, queue_handle);
			c_api.TF_AddInput(desc, num_records);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var keys = new TF_Output (op, _idx++);
			var values = new TF_Output (op, _idx++);
			return (keys, values);
		}

		/// <summary>
		///   Returns the next record (key, value pair) produced by a Reader.
		/// </summary>
		/// <param name="reader_handle">
		///   Handle to a Reader.
		/// </param>
		/// <param name="queue_handle">
		///   Handle to a Queue, with string work items.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderReadV2'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   key: A scalar.
		///   value: A scalar.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Will dequeue from the input queue if necessary (e.g. when the
		///   Reader needs to start reading from a new file since it has finished
		///   with the previous file).
		/// </remarks>
		public (TF_Output key, TF_Output value) ReaderReadV2 (TF_Output reader_handle, TF_Output queue_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderReadV2", MakeName ("ReaderReadV2", operName));
			c_api.TF_AddInput(desc, reader_handle);
			c_api.TF_AddInput(desc, queue_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var key = new TF_Output (op, _idx++);
			var value = new TF_Output (op, _idx++);
			return (key, value);
		}

		/// <summary>
		///   Restore a Reader to its initial clean state.
		/// </summary>
		/// <param name="reader_handle">
		///   Handle to a Reader.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderReset'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ReaderReset (TF_Output reader_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderReset", MakeName ("ReaderReset", operName));
			c_api.TF_AddInput(desc, reader_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Restore a Reader to its initial clean state.
		/// </summary>
		/// <param name="reader_handle">
		///   Handle to a Reader.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderResetV2'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ReaderResetV2 (TF_Output reader_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderResetV2", MakeName ("ReaderResetV2", operName));
			c_api.TF_AddInput(desc, reader_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Restore a reader to a previously saved state.
		/// </summary>
		/// <param name="reader_handle">
		///   Handle to a Reader.
		/// </param>
		/// <param name="state">
		///   Result of a ReaderSerializeState of a Reader with type
		///   matching reader_handle.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderRestoreState'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   Not all Readers support being restored, so this can produce an
		///   Unimplemented error.
		/// </remarks>
		public TF_Operation ReaderRestoreState (TF_Output reader_handle, TF_Output state, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderRestoreState", MakeName ("ReaderRestoreState", operName));
			c_api.TF_AddInput(desc, reader_handle);
			c_api.TF_AddInput(desc, state);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Restore a reader to a previously saved state.
		/// </summary>
		/// <param name="reader_handle">
		///   Handle to a Reader.
		/// </param>
		/// <param name="state">
		///   Result of a ReaderSerializeState of a Reader with type
		///   matching reader_handle.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderRestoreStateV2'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   Not all Readers support being restored, so this can produce an
		///   Unimplemented error.
		/// </remarks>
		public TF_Operation ReaderRestoreStateV2 (TF_Output reader_handle, TF_Output state, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderRestoreStateV2", MakeName ("ReaderRestoreStateV2", operName));
			c_api.TF_AddInput(desc, reader_handle);
			c_api.TF_AddInput(desc, state);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Produce a string tensor that encodes the state of a Reader.
		/// </summary>
		/// <param name="reader_handle">
		///   Handle to a Reader.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderSerializeState'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Not all Readers support being serialized, so this can produce an
		///   Unimplemented error.
		/// </remarks>
		public TF_Output ReaderSerializeState (TF_Output reader_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderSerializeState", MakeName ("ReaderSerializeState", operName));
			c_api.TF_AddInput(desc, reader_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var state = new TF_Output (op, _idx++);
			return state;
		}

		/// <summary>
		///   Produce a string tensor that encodes the state of a Reader.
		/// </summary>
		/// <param name="reader_handle">
		///   Handle to a Reader.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderSerializeStateV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Not all Readers support being serialized, so this can produce an
		///   Unimplemented error.
		/// </remarks>
		public TF_Output ReaderSerializeStateV2 (TF_Output reader_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReaderSerializeStateV2", MakeName ("ReaderSerializeStateV2", operName));
			c_api.TF_AddInput(desc, reader_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var state = new TF_Output (op, _idx++);
			return state;
		}

		/// <summary>
		///   Reads and outputs the entire contents of the input filename.
		/// </summary>
		/// <param name="filename">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReadFile'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ReadFile (TF_Output filename, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReadFile", MakeName ("ReadFile", operName));
			c_api.TF_AddInput(desc, filename);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var contents = new TF_Output (op, _idx++);
			return contents;
		}

		/// <summary>
		///   Reads the value of a variable.
		/// </summary>
		/// <param name="resource">
		///   handle to the resource in which to store the variable.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReadVariableOp'.
		/// </param>
		/// <param name="dtype">
		///   the dtype of the value.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The tensor returned by this operation is immutable.
		///   
		///   The value returned by this operation is guaranteed to be influenced by all the
		///   writes on which this operation depends directly or indirectly, and to not be
		///   influenced by any of the writes which depend directly or indirectly on this
		///   operation.
		/// </remarks>
		public TF_Output ReadVariableOp (TF_Output resource, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReadVariableOp", MakeName ("ReadVariableOp", operName));
			c_api.TF_AddInput(desc, resource);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			return value;
		}

		/// <summary>
		///   Returns the real part of a complex number.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Real'.
		/// </param>
		/// <param name="Tout">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given a tensor <c>input</c> of complex numbers, this operation returns a tensor of
		///   type <c>float</c> that is the real part of each element in <c>input</c>. All elements in
		///   <c>input</c> must be complex numbers of the form \\(a + bj\\), where *a* is the real
		///   part returned by this operation and *b* is the imaginary part.
		///   
		///   For example:
		///   
		///    <code>
		///   # tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]
		///   tf.real(input) ==&amp;gt; [-2.25, 3.25]
		///    </code>
		/// </remarks>
		public TF_Output Real (TF_Output input, TF_DataType? Tout = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Real", MakeName ("Real", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (Tout.HasValue)
				c_api.TF_SetAttrType (desc, "Tout", Tout.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns x / y element-wise for real types.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RealDiv'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   If <c>x</c> and <c>y</c> are reals, this will return the floating-point division.
		///   
		///   *NOTE*: <c>Div</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output RealDiv (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RealDiv", MakeName ("RealDiv", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Creates a dataset that changes the batch size.
		/// </summary>
		/// <param name="input_dataset">
		///   A variant tensor representing the input dataset.
		/// </param>
		/// <param name="num_replicas">
		///   A scalar representing the number of replicas to distribute this batch across. As
		///   a result of this transformation the current batch size would end up being
		///   divided  by this parameter.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RebatchDataset'.
		/// </param>
		/// <param name="use_fallback">
		///   Optional argument
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Creates a dataset that changes the batch size of the dataset to current batch
		///   size // num_workers.
		/// </remarks>
		public TF_Output RebatchDataset (TF_Output input_dataset, TF_Output num_replicas, TF_DataType[] output_types, long[][] output_shapes, bool? use_fallback = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RebatchDataset", MakeName ("RebatchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, num_replicas);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (use_fallback.HasValue)
				c_api.TF_SetAttrBool (desc, "use_fallback", Convert.ToByte(use_fallback.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Computes the reciprocal of x element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Reciprocal'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   I.e., \\(y = 1 / x\\).
		/// </remarks>
		public TF_Output Reciprocal (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Reciprocal", MakeName ("Reciprocal", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes the gradient for the inverse of <c>x</c> wrt its input.
		/// </summary>
		/// <param name="y">
		/// </param>
		/// <param name="dy">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReciprocalGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Specifically, <c>grad = -dy * y*y</c>, where <c>y = 1/x</c>, and <c>dy</c>
		///   is the corresponding input gradient.
		/// </remarks>
		public TF_Output ReciprocalGrad (TF_Output y, TF_Output dy, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReciprocalGrad", MakeName ("ReciprocalGrad", operName));
			c_api.TF_AddInput(desc, y);
			c_api.TF_AddInput(desc, dy);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Emits randomized records.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RecordInput'.
		/// </param>
		/// <param name="file_random_seed">
		///   Optional argument
		///   Random seeds used to produce randomized records.
		/// </param>
		/// <param name="file_shuffle_shift_ratio">
		///   Optional argument
		///   Shifts the list of files after the list is randomly
		///   shuffled.
		/// </param>
		/// <param name="file_buffer_size">
		///   Optional argument
		///   The randomization shuffling buffer.
		/// </param>
		/// <param name="file_parallelism">
		///   Optional argument
		///   How many sstables are opened and concurrently iterated over.
		/// </param>
		/// <param name="batch_size">
		///   Optional argument
		///   The batch size.
		/// </param>
		/// <param name="compression_type">
		///   Optional argument
		///   The type of compression for the file. Currently ZLIB and
		///   GZIP are supported. Defaults to none.
		/// </param>
		/// <param name="file_pattern">
		///   Glob pattern for the data files.
		/// </param>
		/// <returns>
		///   A tensor of shape [batch_size].
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RecordInput (string file_pattern, long? file_random_seed = null, float? file_shuffle_shift_ratio = null, long? file_buffer_size = null, long? file_parallelism = null, long? batch_size = null, string compression_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RecordInput", MakeName ("RecordInput", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "file_pattern", file_pattern);
			if (file_random_seed.HasValue)
				c_api.TF_SetAttrInt (desc, "file_random_seed", file_random_seed.Value);
			
			if (file_shuffle_shift_ratio.HasValue)
				c_api.TF_SetAttrFloat (desc, "file_shuffle_shift_ratio", file_shuffle_shift_ratio.Value);
			
			if (file_buffer_size.HasValue)
				c_api.TF_SetAttrInt (desc, "file_buffer_size", file_buffer_size.Value);
			
			if (file_parallelism.HasValue)
				c_api.TF_SetAttrInt (desc, "file_parallelism", file_parallelism.Value);
			
			if (batch_size.HasValue)
				c_api.TF_SetAttrInt (desc, "batch_size", batch_size.Value);
			
			if (compression_type != null)
				c_api.TF_SetAttrString (desc, "compression_type", compression_type);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var records = new TF_Output (op, _idx++);
			return records;
		}

		/// <summary>
		///   An op that receives embedding activations on the TPU.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RecvTPUEmbeddingActivations'.
		/// </param>
		/// <param name="num_outputs">
		///   The number of output activation tensors, equal to the number of
		///   embedding tables in the model.
		/// </param>
		/// <param name="config">
		///   Serialized TPUEmbeddingConfiguration proto.
		/// </param>
		/// <returns>
		///   A TensorList of embedding activations containing one Tensor per
		///   embedding table in the model.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The TPU system performs the embedding lookups and aggregations specified by
		///   the arguments to TPUEmbeddingEnqueue(Integer/Sparse/SparseTensor)Batch. The
		///   results of these aggregations are visible to the Tensorflow Graph as the
		///   outputs of a RecvTPUEmbeddingActivations op. This op returns a list containing
		///   one Tensor of activations per table specified in the model. There can be at
		///   most one RecvTPUEmbeddingActivations op in the TPU graph.
		/// </remarks>
		public TF_Output[] RecvTPUEmbeddingActivations (long num_outputs, string config, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RecvTPUEmbeddingActivations", MakeName ("RecvTPUEmbeddingActivations", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_outputs", num_outputs);
			c_api.TF_SetAttrString (desc, "config", config);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "outputs", status);
			var outputs = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				outputs [i] = new TF_Output (op, _idx++);
			
			return outputs;
		}

		/// <summary>
		///   Reduces the input dataset to a singleton using a reduce function.
		/// </summary>
		/// <param name="input_dataset">
		///   A variant tensor representing the input dataset.
		/// </param>
		/// <param name="initial_state">
		///   A nested structure of tensors, representing the initial state of the
		///   transformation.
		/// </param>
		/// <param name="other_arguments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReduceDataset'.
		/// </param>
		/// <param name="use_inter_op_parallelism">
		///   Optional argument
		/// </param>
		/// <param name="f">
		///   A function that maps <c>(old_state, input_element)</c> to <c>new_state</c>. It must take
		///   two arguments and return a nested structures of tensors. The structure of
		///   <c>new_state</c> must match the structure of <c>initial_state</c>.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] ReduceDataset (TF_Output input_dataset, TF_Output[] initial_state, TF_Output[] other_arguments, TF_Function f, TF_DataType[] output_types, long[][] output_shapes, bool? use_inter_op_parallelism = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReduceDataset", MakeName ("ReduceDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInputList(desc, initial_state[0], initial_state.Length);
			c_api.TF_AddInputList(desc, other_arguments[0], other_arguments.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "f", c_api.TF_FunctionName(f));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (use_inter_op_parallelism.HasValue)
				c_api.TF_SetAttrBool (desc, "use_inter_op_parallelism", Convert.ToByte(use_inter_op_parallelism.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "components", status);
			var components = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				components [i] = new TF_Output (op, _idx++);
			
			return components;
		}

		/// <summary>
		///   Joins a string Tensor across the given dimensions.
		/// </summary>
		/// <param name="inputs">
		///   The input to be joined.  All reduced indices must have non-zero size.
		/// </param>
		/// <param name="reduction_indices">
		///   The dimensions to reduce over.  Dimensions are reduced in the
		///   order specified.  Omitting <c>reduction_indices</c> is equivalent to passing
		///   <c>[n-1, n-2, ..., 0]</c>.  Negative indices from <c>-n</c> to <c>-1</c> are supported.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReduceJoin'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		///   If <c>True</c>, retain reduced dimensions with length <c>1</c>.
		/// </param>
		/// <param name="separator">
		///   Optional argument
		///   The separator to use when joining.
		/// </param>
		/// <returns>
		///   Has shape equal to that of the input with reduced dimensions removed or
		///   set to <c>1</c> depending on <c>keep_dims</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Computes the string join across dimensions in the given string Tensor of shape
		///   <c>[\\(d_0, d_1, ..., d_{n-1}\\)]</c>.  Returns a new Tensor created by joining the input
		///   strings with the given separator (default: empty string).  Negative indices are
		///   counted backwards from the end, with <c>-1</c> being equivalent to <c>n - 1</c>.  If
		///   indices are not specified, joins across all dimensions beginning from <c>n - 1</c>
		///   through <c>0</c>.
		///   
		///   For example:
		///   
		///    <code>
		///   # tensor <c>a</c> is [["a", "b"], ["c", "d"]]
		///   tf.reduce_join(a, 0) ==&amp;gt; ["ac", "bd"]
		///   tf.reduce_join(a, 1) ==&amp;gt; ["ab", "cd"]
		///   tf.reduce_join(a, -2) = tf.reduce_join(a, 0) ==&amp;gt; ["ac", "bd"]
		///   tf.reduce_join(a, -1) = tf.reduce_join(a, 1) ==&amp;gt; ["ab", "cd"]
		///   tf.reduce_join(a, 0, keep_dims=True) ==&amp;gt; [["ac", "bd"]]
		///   tf.reduce_join(a, 1, keep_dims=True) ==&amp;gt; [["ab"], ["cd"]]
		///   tf.reduce_join(a, 0, separator=".") ==&amp;gt; ["a.c", "b.d"]
		///   tf.reduce_join(a, [0, 1]) ==&amp;gt; "acbd"
		///   tf.reduce_join(a, [1, 0]) ==&amp;gt; "abcd"
		///   tf.reduce_join(a, []) ==&amp;gt; [["a", "b"], ["c", "d"]]
		///   tf.reduce_join(a) = tf.reduce_join(a, [1, 0]) ==&amp;gt; "abcd"
		///    </code>
		/// </remarks>
		public TF_Output ReduceJoin (TF_Output inputs, TF_Output reduction_indices, bool? keep_dims = null, string separator = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReduceJoin", MakeName ("ReduceJoin", operName));
			c_api.TF_AddInput(desc, inputs);
			c_api.TF_AddInput(desc, reduction_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			if (separator != null)
				c_api.TF_SetAttrString (desc, "separator", separator);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates or finds a child frame, and makes <c>data</c> available to the child frame.
		/// </summary>
		/// <param name="data">
		///   The tensor to be made available to the child frame.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RefEnter'.
		/// </param>
		/// <param name="is_constant">
		///   Optional argument
		///   If true, the output is constant within the child frame.
		/// </param>
		/// <param name="parallel_iterations">
		///   Optional argument
		///   The number of iterations allowed to run in parallel.
		/// </param>
		/// <param name="frame_name">
		///   The name of the child frame.
		/// </param>
		/// <returns>
		///   The same tensor as <c>data</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The unique <c>frame_name</c> is used by the <c>Executor</c> to identify frames. If
		///   <c>is_constant</c> is true, <c>output</c> is a constant in the child frame; otherwise
		///   it may be changed in the child frame. At most <c>parallel_iterations</c> iterations
		///   are run in parallel in the child frame.
		/// </remarks>
		public TF_Output RefEnter (TF_Output data, string frame_name, bool? is_constant = null, long? parallel_iterations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RefEnter", MakeName ("RefEnter", operName));
			c_api.TF_AddInput(desc, data);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "frame_name", frame_name);
			if (is_constant.HasValue)
				c_api.TF_SetAttrBool (desc, "is_constant", Convert.ToByte(is_constant.Value));
			
			if (parallel_iterations.HasValue)
				c_api.TF_SetAttrInt (desc, "parallel_iterations", parallel_iterations.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Exits the current frame to its parent frame.
		/// </summary>
		/// <param name="data">
		///   The tensor to be made available to the parent frame.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RefExit'.
		/// </param>
		/// <returns>
		///   The same tensor as <c>data</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Exit makes its input <c>data</c> available to the parent frame.
		/// </remarks>
		public TF_Output RefExit (TF_Output data, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RefExit", MakeName ("RefExit", operName));
			c_api.TF_AddInput(desc, data);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Return the same ref tensor as the input ref tensor.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RefIdentity'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RefIdentity (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RefIdentity", MakeName ("RefIdentity", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Forwards the value of an available tensor from <c>inputs</c> to <c>output</c>.
		/// </summary>
		/// <param name="inputs">
		///   The input tensors, exactly one of which will become available.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RefMerge'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output: Will be set to the available input tensor.
		///   value_index: The index of the chosen input tensor in <c>inputs</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   <c>Merge</c> waits for at least one of the tensors in <c>inputs</c> to become available.
		///   It is usually combined with <c>Switch</c> to implement branching.
		///   
		///   <c>Merge</c> forwards the first tensor for become available to <c>output</c>, and sets
		///   <c>value_index</c> to its index in <c>inputs</c>.
		/// </remarks>
		public (TF_Output output, TF_Output value_index) RefMerge (TF_Output[] inputs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RefMerge", MakeName ("RefMerge", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var value_index = new TF_Output (op, _idx++);
			return (output, value_index);
		}

		/// <summary>
		///   Makes its input available to the next iteration.
		/// </summary>
		/// <param name="data">
		///   The tensor to be made available to the next iteration.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RefNextIteration'.
		/// </param>
		/// <returns>
		///   The same tensor as <c>data</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RefNextIteration (TF_Output data, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RefNextIteration", MakeName ("RefNextIteration", operName));
			c_api.TF_AddInput(desc, data);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Forwards the <c>index</c>th element of <c>inputs</c> to <c>output</c>.
		/// </summary>
		/// <param name="index">
		///   A scalar that determines the input that gets selected.
		/// </param>
		/// <param name="inputs">
		///   A list of ref tensors, one of which will be forwarded to <c>output</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RefSelect'.
		/// </param>
		/// <returns>
		///   The forwarded tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RefSelect (TF_Output index, TF_Output[] inputs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RefSelect", MakeName ("RefSelect", operName));
			c_api.TF_AddInput(desc, index);
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Forwards the ref tensor <c>data</c> to the output port determined by <c>pred</c>.
		/// </summary>
		/// <param name="data">
		///   The ref tensor to be forwarded to the appropriate output.
		/// </param>
		/// <param name="pred">
		///   A scalar that specifies which output port will receive data.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RefSwitch'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_false: If <c>pred</c> is false, data will be forwarded to this output.
		///   output_true: If <c>pred</c> is true, data will be forwarded to this output.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   If <c>pred</c> is true, the <c>data</c> input is forwarded to <c>output_true</c>. Otherwise,
		///   the data goes to <c>output_false</c>.
		///   
		///   See also <c>Switch</c> and <c>Merge</c>.
		/// </remarks>
		public (TF_Output output_false, TF_Output output_true) RefSwitch (TF_Output data, TF_Output pred, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RefSwitch", MakeName ("RefSwitch", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, pred);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_false = new TF_Output (op, _idx++);
			var output_true = new TF_Output (op, _idx++);
			return (output_false, output_true);
		}

		/// <summary>
		///   Check if the input matches the regex pattern.
		/// </summary>
		/// <param name="input">
		///   A string tensor of the text to be processed.
		/// </param>
		/// <param name="pattern">
		///   A scalar string tensor containing the regular expression to match the input.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RegexFullMatch'.
		/// </param>
		/// <returns>
		///   A bool tensor with the same shape as <c>input</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The input is a string tensor of any shape. The pattern is a scalar
		///   string tensor which is applied to every element of the input tensor.
		///   The boolean values (True or False) of the output tensor indicate
		///   if the input matches the regex pattern provided.
		///   
		///   The pattern follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)
		/// </remarks>
		public TF_Output RegexFullMatch (TF_Output input, TF_Output pattern, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RegexFullMatch", MakeName ("RegexFullMatch", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, pattern);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Replaces matches of the <c>pattern</c> regular expression in <c>input</c> with the
		///   replacement string provided in <c>rewrite</c>.
		/// </summary>
		/// <param name="input">
		///   The text to be processed.
		/// </param>
		/// <param name="pattern">
		///   The regular expression to be matched in the <c>input</c> strings.
		/// </param>
		/// <param name="rewrite">
		///   The rewrite string to be substituted for the <c>pattern</c> expression where it is
		///   matched in the <c>input</c> strings.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RegexReplace'.
		/// </param>
		/// <param name="replace_global">
		///   Optional argument
		///   If True, the replacement is global (that is, all matches of the <c>pattern</c> regular
		///   expression in each input string are rewritten), otherwise the <c>rewrite</c>
		///   substitution is only made for the first <c>pattern</c> match.
		/// </param>
		/// <returns>
		///   The text after applying pattern match and rewrite substitution.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   It follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)
		/// </remarks>
		public TF_Output RegexReplace (TF_Output input, TF_Output pattern, TF_Output rewrite, bool? replace_global = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RegexReplace", MakeName ("RegexReplace", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, pattern);
			c_api.TF_AddInput(desc, rewrite);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (replace_global.HasValue)
				c_api.TF_SetAttrBool (desc, "replace_global", Convert.ToByte(replace_global.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes rectified linear: <c>max(features, 0)</c>.
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Relu'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Relu (TF_Output features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Relu", MakeName ("Relu", operName));
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var activations = new TF_Output (op, _idx++);
			return activations;
		}

		/// <summary>
		///   Computes rectified linear 6: <c>min(max(features, 0), 6)</c>.
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Relu6'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Relu6 (TF_Output features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Relu6", MakeName ("Relu6", operName));
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var activations = new TF_Output (op, _idx++);
			return activations;
		}

		/// <summary>
		///   Computes rectified linear 6 gradients for a Relu6 operation.
		/// </summary>
		/// <param name="gradients">
		///   The backpropagated gradients to the corresponding Relu6 operation.
		/// </param>
		/// <param name="features">
		///   The features passed as input to the corresponding Relu6 operation, or
		///   its output; using either one produces the same result.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Relu6Grad'.
		/// </param>
		/// <returns>
		///   The gradients:
		///   <c>gradients * (features &amp;gt; 0) * (features &amp;lt; 6)</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Relu6Grad (TF_Output gradients, TF_Output features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Relu6Grad", MakeName ("Relu6Grad", operName));
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var backprops = new TF_Output (op, _idx++);
			return backprops;
		}

		/// <summary>
		///   Computes rectified linear gradients for a Relu operation.
		/// </summary>
		/// <param name="gradients">
		///   The backpropagated gradients to the corresponding Relu operation.
		/// </param>
		/// <param name="features">
		///   The features passed as input to the corresponding Relu operation, OR
		///   the outputs of that operation (both work equivalently).
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReluGrad'.
		/// </param>
		/// <returns>
		///   <c>gradients * (features &amp;gt; 0)</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ReluGrad (TF_Output gradients, TF_Output features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReluGrad", MakeName ("ReluGrad", operName));
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var backprops = new TF_Output (op, _idx++);
			return backprops;
		}

		/// <summary>
		///   Runs function <c>f</c> on a remote device indicated by <c>target</c>.
		/// </summary>
		/// <param name="target">
		///   A fully specified device name where we want to run the function.
		/// </param>
		/// <param name="args">
		///   A list of arguments for the function.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RemoteCall'.
		/// </param>
		/// <param name="Tout">
		///   The type list for the return values.
		/// </param>
		/// <param name="f">
		///   The function to run remotely.
		/// </param>
		/// <returns>
		///   A list of return values.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] RemoteCall (TF_Output target, TF_Output[] args, TF_DataType[] Tout, TF_Function f, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RemoteCall", MakeName ("RemoteCall", operName));
			c_api.TF_AddInput(desc, target);
			c_api.TF_AddInputList(desc, args[0], args.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "Tout", Tout);
			c_api.TF_SetAttrFuncName (desc, "f", c_api.TF_FunctionName(f));
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		///   Execute a sub graph on a remote processor.
		/// </summary>
		/// <param name="inputs">
		///   Arbitrary number of tensors with arbitrary data types
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RemoteFusedGraphExecute'.
		/// </param>
		/// <param name="Toutputs">
		/// </param>
		/// <param name="serialized_remote_fused_graph_execute_info">
		///   Serialized protocol buffer
		///   of RemoteFusedGraphExecuteInfo which contains graph specifications.
		/// </param>
		/// <returns>
		///   Arbitrary number of tensors with arbitrary data types
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The graph specifications(such as graph itself, input tensors and output names)
		///   are stored as a serialized protocol buffer of RemoteFusedGraphExecuteInfo
		///   as serialized_remote_fused_graph_execute_info.
		///   The specifications will be passed to a dedicated registered
		///   remote fused graph executor.  The executor will send the graph specifications
		///   to a remote processor and execute that graph.  The execution results
		///   will be passed to consumer nodes as outputs of this node.
		/// </remarks>
		public TF_Output[] RemoteFusedGraphExecute (TF_Output[] inputs, TF_DataType[] Toutputs, string serialized_remote_fused_graph_execute_info, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RemoteFusedGraphExecute", MakeName ("RemoteFusedGraphExecute", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "Toutputs", Toutputs);
			c_api.TF_SetAttrString (desc, "serialized_remote_fused_graph_execute_info", serialized_remote_fused_graph_execute_info);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "outputs", status);
			var outputs = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				outputs [i] = new TF_Output (op, _idx++);
			
			return outputs;
		}

		/// <summary>
		///   Creates a dataset that emits the outputs of <c>input_dataset</c> <c>count</c> times.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="count">
		///   A scalar representing the number of times that <c>input_dataset</c> should
		///   be repeated. A value of <c>-1</c> indicates that it should be repeated infinitely.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RepeatDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output RepeatDataset (TF_Output input_dataset, TF_Output count, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RepeatDataset", MakeName ("RepeatDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, count);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Computes a range that covers the actual values present in a quantized tensor.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_min">
		///   The float value that the minimum quantized input value represents.
		/// </param>
		/// <param name="input_max">
		///   The float value that the maximum quantized input value represents.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RequantizationRange'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_min: The computed min output.
		///   output_max: the computed max output.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Given a quantized tensor described by <c>(input, input_min, input_max)</c>, outputs a
		///   range that covers the actual values present in that tensor. This op is typically
		///   used to produce the <c>requested_output_min</c> and <c>requested_output_max</c> for
		///   <c>Requantize</c>.
		/// </remarks>
		public (TF_Output output_min, TF_Output output_max) RequantizationRange (TF_Output input, TF_Output input_min, TF_Output input_max, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RequantizationRange", MakeName ("RequantizationRange", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_min);
			c_api.TF_AddInput(desc, input_max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_min = new TF_Output (op, _idx++);
			var output_max = new TF_Output (op, _idx++);
			return (output_min, output_max);
		}

		/// <summary>
		///   Computes requantization range per channel.
		/// </summary>
		/// <param name="input">
		///   The original input tensor.
		/// </param>
		/// <param name="input_min">
		///   The minimum value of the input tensor
		/// </param>
		/// <param name="input_max">
		///   The maximum value of the input tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RequantizationRangePerChannel'.
		/// </param>
		/// <param name="clip_value_max">
		///   The maximum value of the output that needs to be clipped.
		///   Example: set this to 6 for Relu6.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_min: The minimum value of the final output tensor
		///   output_max: The maximum value of the final output tensor.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output_min, TF_Output output_max) RequantizationRangePerChannel (TF_Output input, TF_Output input_min, TF_Output input_max, float clip_value_max, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RequantizationRangePerChannel", MakeName ("RequantizationRangePerChannel", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_min);
			c_api.TF_AddInput(desc, input_max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFloat (desc, "clip_value_max", clip_value_max);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_min = new TF_Output (op, _idx++);
			var output_max = new TF_Output (op, _idx++);
			return (output_min, output_max);
		}

		/// <summary>
		///   Converts the quantized <c>input</c> tensor into a lower-precision <c>output</c>.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="input_min">
		///   The float value that the minimum quantized input value represents.
		/// </param>
		/// <param name="input_max">
		///   The float value that the maximum quantized input value represents.
		/// </param>
		/// <param name="requested_output_min">
		///   The float value that the minimum quantized output value represents.
		/// </param>
		/// <param name="requested_output_max">
		///   The float value that the maximum quantized output value represents.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Requantize'.
		/// </param>
		/// <param name="out_type">
		///   The type of the output. Should be a lower bit depth than Tinput.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output:
		///   output_min: The requested_output_min value is copied into this output.
		///   output_max: The requested_output_max value is copied into this output.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Converts the quantized <c>input</c> tensor into a lower-precision <c>output</c>, using the
		///   output range specified with <c>requested_output_min</c> and <c>requested_output_max</c>.
		///   
		///   <c>[input_min, input_max]</c> are scalar floats that specify the range for the float
		///   interpretation of the <c>input</c> data. For example, if <c>input_min</c> is -1.0f and
		///   <c>input_max</c> is 1.0f, and we are dealing with <c>quint16</c> quantized data, then a 0
		///   value in the 16-bit data should be interpreted as -1.0f, and a 65535 means 1.0f.
		/// </remarks>
		public (TF_Output output, TF_Output output_min, TF_Output output_max) Requantize (TF_Output input, TF_Output input_min, TF_Output input_max, TF_Output requested_output_min, TF_Output requested_output_max, TF_DataType out_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Requantize", MakeName ("Requantize", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_min);
			c_api.TF_AddInput(desc, input_max);
			c_api.TF_AddInput(desc, requested_output_min);
			c_api.TF_AddInput(desc, requested_output_max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "out_type", out_type);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var output_min = new TF_Output (op, _idx++);
			var output_max = new TF_Output (op, _idx++);
			return (output, output_min, output_max);
		}

		/// <summary>
		///   Requantizes input with min and max values known per channel.
		/// </summary>
		/// <param name="input">
		///   The original input tensor.
		/// </param>
		/// <param name="input_min">
		///   The minimum value of the input tensor
		/// </param>
		/// <param name="input_max">
		///   The maximum value of the input tensor.
		/// </param>
		/// <param name="requested_output_min">
		///   The minimum value of the output tensor requested.
		/// </param>
		/// <param name="requested_output_max">
		///   The maximum value of the output tensor requested.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RequantizePerChannel'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		///   The quantized type of output tensor that needs to be converted.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output: Output tensor.
		///   output_min: The minimum value of the final output tensor
		///   output_max: The maximum value of the final output tensor.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output output, TF_Output output_min, TF_Output output_max) RequantizePerChannel (TF_Output input, TF_Output input_min, TF_Output input_max, TF_Output requested_output_min, TF_Output requested_output_max, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RequantizePerChannel", MakeName ("RequantizePerChannel", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, input_min);
			c_api.TF_AddInput(desc, input_max);
			c_api.TF_AddInput(desc, requested_output_min);
			c_api.TF_AddInput(desc, requested_output_max);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			var output_min = new TF_Output (op, _idx++);
			var output_max = new TF_Output (op, _idx++);
			return (output, output_min, output_max);
		}

		/// <summary>
		///   Reshapes a tensor.
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="shape">
		///   Defines the shape of the output tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Reshape'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given <c>tensor</c>, this operation returns a tensor that has the same values
		///   as <c>tensor</c> with shape <c>shape</c>.
		///   
		///   If one component of <c>shape</c> is the special value -1, the size of that dimension
		///   is computed so that the total size remains constant.  In particular, a <c>shape</c>
		///   of <c>[-1]</c> flattens into 1-D.  At most one component of <c>shape</c> can be -1.
		///   
		///   If <c>shape</c> is 1-D or higher, then the operation returns a tensor with shape
		///   <c>shape</c> filled with the values of <c>tensor</c>. In this case, the number of elements
		///   implied by <c>shape</c> must be the same as the number of elements in <c>tensor</c>.
		///   
		///   For example:
		///   
		///    <code>
		///   # tensor 't' is [1, 2, 3, 4, 5, 6, 7, 8, 9]
		///   # tensor 't' has shape [9]
		///   reshape(t, [3, 3]) ==&amp;gt; [[1, 2, 3],
		///   [4, 5, 6],
		///   [7, 8, 9]]
		///   
		///   # tensor 't' is [[[1, 1], [2, 2]],
		///   #                [[3, 3], [4, 4]]]
		///   # tensor 't' has shape [2, 2, 2]
		///   reshape(t, [2, 4]) ==&amp;gt; [[1, 1, 2, 2],
		///   [3, 3, 4, 4]]
		///   
		///   # tensor 't' is [[[1, 1, 1],
		///   #                 [2, 2, 2]],
		///   #                [[3, 3, 3],
		///   #                 [4, 4, 4]],
		///   #                [[5, 5, 5],
		///   #                 [6, 6, 6]]]
		///   # tensor 't' has shape [3, 2, 3]
		///   # pass '[-1]' to flatten 't'
		///   reshape(t, [-1]) ==&amp;gt; [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]
		///   
		///   # -1 can also be used to infer the shape
		///   
		///   # -1 is inferred to be 9:
		///   reshape(t, [2, -1]) ==&amp;gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3],
		///   [4, 4, 4, 5, 5, 5, 6, 6, 6]]
		///   # -1 is inferred to be 2:
		///   reshape(t, [-1, 9]) ==&amp;gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3],
		///   [4, 4, 4, 5, 5, 5, 6, 6, 6]]
		///   # -1 is inferred to be 3:
		///   reshape(t, [ 2, -1, 3]) ==&amp;gt; [[[1, 1, 1],
		///   [2, 2, 2],
		///   [3, 3, 3]],
		///   [[4, 4, 4],
		///   [5, 5, 5],
		///   [6, 6, 6]]]
		///   
		///   # tensor 't' is [7]
		///   # shape <c>[]</c> reshapes to a scalar
		///   reshape(t, []) ==&amp;gt; 7
		///    </code>
		/// </remarks>
		public TF_Output Reshape (TF_Output tensor, TF_Output shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Reshape", MakeName ("Reshape", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Resize <c>images</c> to <c>size</c> using area interpolation.
		/// </summary>
		/// <param name="images">
		///   4-D with shape <c>[batch, height, width, channels]</c>.
		/// </param>
		/// <param name="size">
		///   = A 1-D int32 Tensor of 2 elements: <c>new_height, new_width</c>.  The
		///   new size for the images.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeArea'.
		/// </param>
		/// <param name="align_corners">
		///   Optional argument
		///   If true, the centers of the 4 corner pixels of the input and output tensors are
		///   aligned, preserving the values at the corner pixels. Defaults to false.
		/// </param>
		/// <returns>
		///   4-D with shape
		///   <c>[batch, new_height, new_width, channels]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Input images can be of different types but output images are always float.
		///   
		///   The range of pixel values for the output image might be slightly different
		///   from the range for the input image because of limited numerical precision.
		///   To guarantee an output range, for example <c>[0.0, 1.0]</c>, apply
		///   <c>tf.clip_by_value</c> to the output.
		///   
		///   Each output pixel is computed by first transforming the pixel's footprint into
		///   the input tensor and then averaging the pixels that intersect the footprint. An
		///   input pixel's contribution to the average is weighted by the fraction of its
		///   area that intersects the footprint.  This is the same as OpenCV's INTER_AREA.
		/// </remarks>
		public TF_Output ResizeArea (TF_Output images, TF_Output size, bool? align_corners = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResizeArea", MakeName ("ResizeArea", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (align_corners.HasValue)
				c_api.TF_SetAttrBool (desc, "align_corners", Convert.ToByte(align_corners.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var resized_images = new TF_Output (op, _idx++);
			return resized_images;
		}

		/// <summary>
		///   Resize <c>images</c> to <c>size</c> using bicubic interpolation.
		/// </summary>
		/// <param name="images">
		///   4-D with shape <c>[batch, height, width, channels]</c>.
		/// </param>
		/// <param name="size">
		///   = A 1-D int32 Tensor of 2 elements: <c>new_height, new_width</c>.  The
		///   new size for the images.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeBicubic'.
		/// </param>
		/// <param name="align_corners">
		///   Optional argument
		///   If true, the centers of the 4 corner pixels of the input and output tensors are
		///   aligned, preserving the values at the corner pixels. Defaults to false.
		/// </param>
		/// <param name="half_pixel_centers">
		///   Optional argument
		/// </param>
		/// <returns>
		///   4-D with shape
		///   <c>[batch, new_height, new_width, channels]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Input images can be of different types but output images are always float.
		/// </remarks>
		public TF_Output ResizeBicubic (TF_Output images, TF_Output size, bool? align_corners = null, bool? half_pixel_centers = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResizeBicubic", MakeName ("ResizeBicubic", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (align_corners.HasValue)
				c_api.TF_SetAttrBool (desc, "align_corners", Convert.ToByte(align_corners.Value));
			
			if (half_pixel_centers.HasValue)
				c_api.TF_SetAttrBool (desc, "half_pixel_centers", Convert.ToByte(half_pixel_centers.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var resized_images = new TF_Output (op, _idx++);
			return resized_images;
		}

		/// <summary>
		///   Computes the gradient of bicubic interpolation.
		/// </summary>
		/// <param name="grads">
		///   4-D with shape <c>[batch, height, width, channels]</c>.
		/// </param>
		/// <param name="original_image">
		///   4-D with shape <c>[batch, orig_height, orig_width, channels]</c>,
		///   The image tensor that was resized.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeBicubicGrad'.
		/// </param>
		/// <param name="align_corners">
		///   Optional argument
		///   If true, the centers of the 4 corner pixels of the input and grad tensors are
		///   aligned. Defaults to false.
		/// </param>
		/// <param name="half_pixel_centers">
		///   Optional argument
		/// </param>
		/// <returns>
		///   4-D with shape <c>[batch, orig_height, orig_width, channels]</c>.
		///   Gradients with respect to the input image. Input image must have been
		///   float or double.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ResizeBicubicGrad (TF_Output grads, TF_Output original_image, bool? align_corners = null, bool? half_pixel_centers = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResizeBicubicGrad", MakeName ("ResizeBicubicGrad", operName));
			c_api.TF_AddInput(desc, grads);
			c_api.TF_AddInput(desc, original_image);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (align_corners.HasValue)
				c_api.TF_SetAttrBool (desc, "align_corners", Convert.ToByte(align_corners.Value));
			
			if (half_pixel_centers.HasValue)
				c_api.TF_SetAttrBool (desc, "half_pixel_centers", Convert.ToByte(half_pixel_centers.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Resize <c>images</c> to <c>size</c> using bilinear interpolation.
		/// </summary>
		/// <param name="images">
		///   4-D with shape <c>[batch, height, width, channels]</c>.
		/// </param>
		/// <param name="size">
		///   = A 1-D int32 Tensor of 2 elements: <c>new_height, new_width</c>.  The
		///   new size for the images.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeBilinear'.
		/// </param>
		/// <param name="align_corners">
		///   Optional argument
		///   If true, the centers of the 4 corner pixels of the input and output tensors are
		///   aligned, preserving the values at the corner pixels. Defaults to false.
		/// </param>
		/// <param name="half_pixel_centers">
		///   Optional argument
		/// </param>
		/// <returns>
		///   4-D with shape
		///   <c>[batch, new_height, new_width, channels]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Input images can be of different types but output images are always float.
		/// </remarks>
		public TF_Output ResizeBilinear (TF_Output images, TF_Output size, bool? align_corners = null, bool? half_pixel_centers = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResizeBilinear", MakeName ("ResizeBilinear", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (align_corners.HasValue)
				c_api.TF_SetAttrBool (desc, "align_corners", Convert.ToByte(align_corners.Value));
			
			if (half_pixel_centers.HasValue)
				c_api.TF_SetAttrBool (desc, "half_pixel_centers", Convert.ToByte(half_pixel_centers.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var resized_images = new TF_Output (op, _idx++);
			return resized_images;
		}

		/// <summary>
		///   Computes the gradient of bilinear interpolation.
		/// </summary>
		/// <param name="grads">
		///   4-D with shape <c>[batch, height, width, channels]</c>.
		/// </param>
		/// <param name="original_image">
		///   4-D with shape <c>[batch, orig_height, orig_width, channels]</c>,
		///   The image tensor that was resized.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeBilinearGrad'.
		/// </param>
		/// <param name="align_corners">
		///   Optional argument
		///   If true, the centers of the 4 corner pixels of the input and grad tensors are
		///   aligned. Defaults to false.
		/// </param>
		/// <param name="half_pixel_centers">
		///   Optional argument
		/// </param>
		/// <returns>
		///   4-D with shape <c>[batch, orig_height, orig_width, channels]</c>.
		///   Gradients with respect to the input image. Input image must have been
		///   float or double.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ResizeBilinearGrad (TF_Output grads, TF_Output original_image, bool? align_corners = null, bool? half_pixel_centers = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResizeBilinearGrad", MakeName ("ResizeBilinearGrad", operName));
			c_api.TF_AddInput(desc, grads);
			c_api.TF_AddInput(desc, original_image);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (align_corners.HasValue)
				c_api.TF_SetAttrBool (desc, "align_corners", Convert.ToByte(align_corners.Value));
			
			if (half_pixel_centers.HasValue)
				c_api.TF_SetAttrBool (desc, "half_pixel_centers", Convert.ToByte(half_pixel_centers.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Resize <c>images</c> to <c>size</c> using nearest neighbor interpolation.
		/// </summary>
		/// <param name="images">
		///   4-D with shape <c>[batch, height, width, channels]</c>.
		/// </param>
		/// <param name="size">
		///   = A 1-D int32 Tensor of 2 elements: <c>new_height, new_width</c>.  The
		///   new size for the images.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeNearestNeighbor'.
		/// </param>
		/// <param name="align_corners">
		///   Optional argument
		///   If true, the centers of the 4 corner pixels of the input and output tensors are
		///   aligned, preserving the values at the corner pixels. Defaults to false.
		/// </param>
		/// <param name="half_pixel_centers">
		///   Optional argument
		/// </param>
		/// <returns>
		///   4-D with shape
		///   <c>[batch, new_height, new_width, channels]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ResizeNearestNeighbor (TF_Output images, TF_Output size, bool? align_corners = null, bool? half_pixel_centers = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResizeNearestNeighbor", MakeName ("ResizeNearestNeighbor", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (align_corners.HasValue)
				c_api.TF_SetAttrBool (desc, "align_corners", Convert.ToByte(align_corners.Value));
			
			if (half_pixel_centers.HasValue)
				c_api.TF_SetAttrBool (desc, "half_pixel_centers", Convert.ToByte(half_pixel_centers.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var resized_images = new TF_Output (op, _idx++);
			return resized_images;
		}

		/// <summary>
		///   Computes the gradient of nearest neighbor interpolation.
		/// </summary>
		/// <param name="grads">
		///   4-D with shape <c>[batch, height, width, channels]</c>.
		/// </param>
		/// <param name="size">
		///   = A 1-D int32 Tensor of 2 elements: <c>orig_height, orig_width</c>. The
		///   original input size.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeNearestNeighborGrad'.
		/// </param>
		/// <param name="align_corners">
		///   Optional argument
		///   If true, the centers of the 4 corner pixels of the input and grad tensors are
		///   aligned. Defaults to false.
		/// </param>
		/// <param name="half_pixel_centers">
		///   Optional argument
		/// </param>
		/// <returns>
		///   4-D with shape <c>[batch, orig_height, orig_width, channels]</c>. Gradients
		///   with respect to the input image.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ResizeNearestNeighborGrad (TF_Output grads, TF_Output size, bool? align_corners = null, bool? half_pixel_centers = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResizeNearestNeighborGrad", MakeName ("ResizeNearestNeighborGrad", operName));
			c_api.TF_AddInput(desc, grads);
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (align_corners.HasValue)
				c_api.TF_SetAttrBool (desc, "align_corners", Convert.ToByte(align_corners.Value));
			
			if (half_pixel_centers.HasValue)
				c_api.TF_SetAttrBool (desc, "half_pixel_centers", Convert.ToByte(half_pixel_centers.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Applies a gradient to a given accumulator.
		/// </summary>
		/// <param name="handle">
		///   The handle to a accumulator.
		/// </param>
		/// <param name="local_step">
		///   The local_step value at which the gradient was computed.
		/// </param>
		/// <param name="gradient">
		///   A tensor of the gradient to be accumulated.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceAccumulatorApplyGradient'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   Does not add if local_step is lesser than the accumulator's global_step.
		/// </remarks>
		public TF_Operation ResourceAccumulatorApplyGradient (TF_Output handle, TF_Output local_step, TF_Output gradient, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceAccumulatorApplyGradient", MakeName ("ResourceAccumulatorApplyGradient", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, local_step);
			c_api.TF_AddInput(desc, gradient);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Returns the number of gradients aggregated in the given accumulators.
		/// </summary>
		/// <param name="handle">
		///   The handle to an accumulator.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceAccumulatorNumAccumulated'.
		/// </param>
		/// <returns>
		///   The number of gradients aggregated in the given accumulator.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ResourceAccumulatorNumAccumulated (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceAccumulatorNumAccumulated", MakeName ("ResourceAccumulatorNumAccumulated", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var num_accumulated = new TF_Output (op, _idx++);
			return num_accumulated;
		}

		/// <summary>
		///   Updates the accumulator with a new value for global_step.
		/// </summary>
		/// <param name="handle">
		///   The handle to an accumulator.
		/// </param>
		/// <param name="new_global_step">
		///   The new global_step value to set.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceAccumulatorSetGlobalStep'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   Logs warning if the accumulator's value is already higher than
		///   new_global_step.
		/// </remarks>
		public TF_Operation ResourceAccumulatorSetGlobalStep (TF_Output handle, TF_Output new_global_step, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceAccumulatorSetGlobalStep", MakeName ("ResourceAccumulatorSetGlobalStep", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, new_global_step);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Extracts the average gradient in the given ConditionalAccumulator.
		/// </summary>
		/// <param name="handle">
		///   The handle to an accumulator.
		/// </param>
		/// <param name="num_required">
		///   Number of gradients required before we return an aggregate.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceAccumulatorTakeGradient'.
		/// </param>
		/// <param name="dtype">
		///   The data type of accumulated gradients. Needs to correspond to the type
		///   of the accumulator.
		/// </param>
		/// <returns>
		///   The average of the accumulated gradients.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The op blocks until sufficient (i.e., more than num_required)
		///   gradients have been accumulated.  If the accumulator has already
		///   aggregated more than num_required gradients, it returns the average of
		///   the accumulated gradients.  Also automatically increments the recorded
		///   global_step in the accumulator by 1, and resets the aggregate to 0.
		/// </remarks>
		public TF_Output ResourceAccumulatorTakeGradient (TF_Output handle, TF_Output num_required, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceAccumulatorTakeGradient", MakeName ("ResourceAccumulatorTakeGradient", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, num_required);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var average = new TF_Output (op, _idx++);
			return average;
		}

		/// <summary>
		///   Update '*var' according to the adadelta scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum_update">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="rho">
		///   Decay factor. Must be a scalar.
		/// </param>
		/// <param name="epsilon">
		///   Constant factor. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdadelta'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, updating of the var, accum and update_accum tensors will be protected by
		///   a lock; otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   accum = rho() * accum + (1 - rho()) * grad.square();
		///   update = (update_accum + epsilon).sqrt() * (accum + epsilon()).rsqrt() * grad;
		///   update_accum = rho() * update_accum + (1 - rho()) * update.square();
		///   var -= update;
		/// </remarks>
		public TF_Operation ResourceApplyAdadelta (TF_Output var, TF_Output accum, TF_Output accum_update, TF_Output lr, TF_Output rho, TF_Output epsilon, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyAdadelta", MakeName ("ResourceApplyAdadelta", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, accum_update);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update '*var' according to the adagrad scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdagrad'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <param name="update_slots">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   accum += grad * grad
		///   var -= lr * grad * (1 / sqrt(accum))
		/// </remarks>
		public TF_Operation ResourceApplyAdagrad (TF_Output var, TF_Output accum, TF_Output lr, TF_Output grad, bool? use_locking = null, bool? update_slots = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyAdagrad", MakeName ("ResourceApplyAdagrad", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (update_slots.HasValue)
				c_api.TF_SetAttrBool (desc, "update_slots", Convert.ToByte(update_slots.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update '*var' according to the proximal adagrad scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="gradient_accumulator">
		///   Should be from a Variable().
		/// </param>
		/// <param name="gradient_squared_accumulator">
		///   Should be from a Variable().
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="l1">
		///   L1 regularization. Must be a scalar.
		/// </param>
		/// <param name="l2">
		///   L2 regularization. Must be a scalar.
		/// </param>
		/// <param name="global_step">
		///   Training step number. Must be a scalar.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdagradDA'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, updating of the var and accum tensors will be protected by
		///   a lock; otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceApplyAdagradDA (TF_Output var, TF_Output gradient_accumulator, TF_Output gradient_squared_accumulator, TF_Output grad, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output global_step, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyAdagradDA", MakeName ("ResourceApplyAdagradDA", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, gradient_accumulator);
			c_api.TF_AddInput(desc, gradient_squared_accumulator);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, global_step);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update '*var' according to the adagrad scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="epsilon">
		///   Constant factor. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdagradV2'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <param name="update_slots">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   accum += grad * grad
		///   var -= lr * grad * (1 / sqrt(accum))
		/// </remarks>
		public TF_Operation ResourceApplyAdagradV2 (TF_Output var, TF_Output accum, TF_Output lr, TF_Output epsilon, TF_Output grad, bool? use_locking = null, bool? update_slots = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyAdagradV2", MakeName ("ResourceApplyAdagradV2", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (update_slots.HasValue)
				c_api.TF_SetAttrBool (desc, "update_slots", Convert.ToByte(update_slots.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update '*var' according to the Adam algorithm.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="m">
		///   Should be from a Variable().
		/// </param>
		/// <param name="v">
		///   Should be from a Variable().
		/// </param>
		/// <param name="beta1_power">
		///   Must be a scalar.
		/// </param>
		/// <param name="beta2_power">
		///   Must be a scalar.
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="beta1">
		///   Momentum factor. Must be a scalar.
		/// </param>
		/// <param name="beta2">
		///   Momentum factor. Must be a scalar.
		/// </param>
		/// <param name="epsilon">
		///   Ridge term. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdam'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var, m, and v tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <param name="use_nesterov">
		///   Optional argument
		///   If <c>True</c>, uses the nesterov update.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   $$lr_t := \text{learning\_rate} * \sqrt{1 - beta_2^t} / (1 - beta_1^t)$$
		///   $$m_t := beta_1 * m_{t-1} + (1 - beta_1) * g$$
		///   $$v_t := beta_2 * v_{t-1} + (1 - beta_2) * g * g$$
		///   $$variable := variable - lr_t * m_t / (\sqrt{v_t} + \epsilon)$$
		/// </remarks>
		public TF_Operation ResourceApplyAdam (TF_Output var, TF_Output m, TF_Output v, TF_Output beta1_power, TF_Output beta2_power, TF_Output lr, TF_Output beta1, TF_Output beta2, TF_Output epsilon, TF_Output grad, bool? use_locking = null, bool? use_nesterov = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyAdam", MakeName ("ResourceApplyAdam", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, v);
			c_api.TF_AddInput(desc, beta1_power);
			c_api.TF_AddInput(desc, beta2_power);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, beta1);
			c_api.TF_AddInput(desc, beta2);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (use_nesterov.HasValue)
				c_api.TF_SetAttrBool (desc, "use_nesterov", Convert.ToByte(use_nesterov.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update '*var' according to the AdaMax algorithm.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="m">
		///   Should be from a Variable().
		/// </param>
		/// <param name="v">
		///   Should be from a Variable().
		/// </param>
		/// <param name="beta1_power">
		///   Must be a scalar.
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="beta1">
		///   Momentum factor. Must be a scalar.
		/// </param>
		/// <param name="beta2">
		///   Momentum factor. Must be a scalar.
		/// </param>
		/// <param name="epsilon">
		///   Ridge term. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdaMax'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var, m, and v tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   m_t &amp;lt;- beta1 * m_{t-1} + (1 - beta1) * g
		///   v_t &amp;lt;- max(beta2 * v_{t-1}, abs(g))
		///   variable &amp;lt;- variable - learning_rate / (1 - beta1^t) * m_t / (v_t + epsilon)
		/// </remarks>
		public TF_Operation ResourceApplyAdaMax (TF_Output var, TF_Output m, TF_Output v, TF_Output beta1_power, TF_Output lr, TF_Output beta1, TF_Output beta2, TF_Output epsilon, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyAdaMax", MakeName ("ResourceApplyAdaMax", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, v);
			c_api.TF_AddInput(desc, beta1_power);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, beta1);
			c_api.TF_AddInput(desc, beta2);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update '*var' according to the Adam algorithm.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="m">
		///   Should be from a Variable().
		/// </param>
		/// <param name="v">
		///   Should be from a Variable().
		/// </param>
		/// <param name="vhat">
		///   Should be from a Variable().
		/// </param>
		/// <param name="beta1_power">
		///   Must be a scalar.
		/// </param>
		/// <param name="beta2_power">
		///   Must be a scalar.
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="beta1">
		///   Momentum factor. Must be a scalar.
		/// </param>
		/// <param name="beta2">
		///   Momentum factor. Must be a scalar.
		/// </param>
		/// <param name="epsilon">
		///   Ridge term. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdamWithAmsgrad'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var, m, and v tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   $$lr_t := \text{learning\_rate} * \sqrt{1 - beta_2^t} / (1 - beta_1^t)$$
		///   $$m_t := beta_1 * m_{t-1} + (1 - beta_1) * g$$
		///   $$v_t := beta_2 * v_{t-1} + (1 - beta_2) * g * g$$
		///   $$vhat_t := max{vhat_{t-1}, v_t}$$
		///   $$variable := variable - lr_t * m_t / (\sqrt{vhat_t} + \epsilon)$$
		/// </remarks>
		public TF_Operation ResourceApplyAdamWithAmsgrad (TF_Output var, TF_Output m, TF_Output v, TF_Output vhat, TF_Output beta1_power, TF_Output beta2_power, TF_Output lr, TF_Output beta1, TF_Output beta2, TF_Output epsilon, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyAdamWithAmsgrad", MakeName ("ResourceApplyAdamWithAmsgrad", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, v);
			c_api.TF_AddInput(desc, vhat);
			c_api.TF_AddInput(desc, beta1_power);
			c_api.TF_AddInput(desc, beta2_power);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, beta1);
			c_api.TF_AddInput(desc, beta2);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update '*var' according to the AddSign update.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="m">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="alpha">
		///   Must be a scalar.
		/// </param>
		/// <param name="sign_decay">
		///   Must be a scalar.
		/// </param>
		/// <param name="beta">
		///   Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAddSign'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and m tensors is
		///   protected by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   m_t &amp;lt;- beta1 * m_{t-1} + (1 - beta1) * g
		///   update &amp;lt;- (alpha + sign_decay * sign(g) *sign(m)) * g
		///   variable &amp;lt;- variable - lr_t * update
		/// </remarks>
		public TF_Operation ResourceApplyAddSign (TF_Output var, TF_Output m, TF_Output lr, TF_Output alpha, TF_Output sign_decay, TF_Output beta, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyAddSign", MakeName ("ResourceApplyAddSign", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, alpha);
			c_api.TF_AddInput(desc, sign_decay);
			c_api.TF_AddInput(desc, beta);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update '*var' according to the centered RMSProp algorithm.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="mg">
		///   Should be from a Variable().
		/// </param>
		/// <param name="ms">
		///   Should be from a Variable().
		/// </param>
		/// <param name="mom">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="rho">
		///   Decay rate. Must be a scalar.
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="epsilon">
		///   Ridge term. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyCenteredRMSProp'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var, mg, ms, and mom tensors is
		///   protected by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   The centered RMSProp algorithm uses an estimate of the centered second moment
		///   (i.e., the variance) for normalization, as opposed to regular RMSProp, which
		///   uses the (uncentered) second moment. This often helps with training, but is
		///   slightly more expensive in terms of computation and memory.
		///   
		///   Note that in dense implementation of this algorithm, mg, ms, and mom will
		///   update even if the grad is zero, but in this sparse implementation, mg, ms,
		///   and mom will not update in iterations during which the grad is zero.
		///   
		///   mean_square = decay * mean_square + (1-decay) * gradient ** 2
		///   mean_grad = decay * mean_grad + (1-decay) * gradient
		///   
		///   Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)
		///   
		///   mg &amp;lt;- rho * mg_{t-1} + (1-rho) * grad
		///   ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad
		///   mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms - mg * mg + epsilon)
		///   var &amp;lt;- var - mom
		/// </remarks>
		public TF_Operation ResourceApplyCenteredRMSProp (TF_Output var, TF_Output mg, TF_Output ms, TF_Output mom, TF_Output lr, TF_Output rho, TF_Output momentum, TF_Output epsilon, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyCenteredRMSProp", MakeName ("ResourceApplyCenteredRMSProp", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, mg);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, momentum);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update '*var' according to the Ftrl-proximal scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="linear">
		///   Should be from a Variable().
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="l1">
		///   L1 regulariation. Must be a scalar.
		/// </param>
		/// <param name="l2">
		///   L2 regulariation. Must be a scalar.
		/// </param>
		/// <param name="lr_power">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyFtrl'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   accum_new = accum + grad * grad
		///   linear += grad - (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
		///   quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
		///   var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0
		///   accum = accum_new
		/// </remarks>
		public TF_Operation ResourceApplyFtrl (TF_Output var, TF_Output accum, TF_Output linear, TF_Output grad, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output lr_power, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyFtrl", MakeName ("ResourceApplyFtrl", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, linear);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, lr_power);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update '*var' according to the Ftrl-proximal scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="linear">
		///   Should be from a Variable().
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="l1">
		///   L1 regulariation. Must be a scalar.
		/// </param>
		/// <param name="l2">
		///   L2 shrinkage regulariation. Must be a scalar.
		/// </param>
		/// <param name="l2_shrinkage">
		/// </param>
		/// <param name="lr_power">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyFtrlV2'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   grad_with_shrinkage = grad + 2 * l2_shrinkage * var
		///   accum_new = accum + grad_with_shrinkage * grad_with_shrinkage
		///   linear += grad_with_shrinkage +
		///   (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
		///   quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
		///   var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0
		///   accum = accum_new
		/// </remarks>
		public TF_Operation ResourceApplyFtrlV2 (TF_Output var, TF_Output accum, TF_Output linear, TF_Output grad, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output l2_shrinkage, TF_Output lr_power, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyFtrlV2", MakeName ("ResourceApplyFtrlV2", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, linear);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, l2_shrinkage);
			c_api.TF_AddInput(desc, lr_power);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update '*var' by subtracting 'alpha' * 'delta' from it.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="alpha">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="delta">
		///   The change.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyGradientDescent'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, the subtraction will be protected by a lock;
		///   otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceApplyGradientDescent (TF_Output var, TF_Output alpha, TF_Output delta, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyGradientDescent", MakeName ("ResourceApplyGradientDescent", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, alpha);
			c_api.TF_AddInput(desc, delta);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update '*var' according to the momentum scheme. Set use_nesterov = True if you
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="momentum">
		///   Momentum. Must be a scalar.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyKerasMomentum'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <param name="use_nesterov">
		///   Optional argument
		///   If <c>True</c>, the tensor passed to compute grad will be
		///   var + momentum * accum, so in the end, the var you get is actually
		///   var + momentum * accum.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   want to use Nesterov momentum.
		///   
		///   accum = accum * momentum - lr * grad
		///   var += accum
		/// </remarks>
		public TF_Operation ResourceApplyKerasMomentum (TF_Output var, TF_Output accum, TF_Output lr, TF_Output grad, TF_Output momentum, bool? use_locking = null, bool? use_nesterov = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyKerasMomentum", MakeName ("ResourceApplyKerasMomentum", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, momentum);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (use_nesterov.HasValue)
				c_api.TF_SetAttrBool (desc, "use_nesterov", Convert.ToByte(use_nesterov.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update '*var' according to the momentum scheme. Set use_nesterov = True if you
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="momentum">
		///   Momentum. Must be a scalar.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyMomentum'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <param name="use_nesterov">
		///   Optional argument
		///   If <c>True</c>, the tensor passed to compute grad will be
		///   var - lr * momentum * accum, so in the end, the var you get is actually
		///   var - lr * momentum * accum.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   want to use Nesterov momentum.
		///   
		///   accum = accum * momentum + grad
		///   var -= lr * accum
		/// </remarks>
		public TF_Operation ResourceApplyMomentum (TF_Output var, TF_Output accum, TF_Output lr, TF_Output grad, TF_Output momentum, bool? use_locking = null, bool? use_nesterov = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyMomentum", MakeName ("ResourceApplyMomentum", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, momentum);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (use_nesterov.HasValue)
				c_api.TF_SetAttrBool (desc, "use_nesterov", Convert.ToByte(use_nesterov.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update '*var' according to the AddSign update.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="m">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="logbase">
		///   Must be a scalar.
		/// </param>
		/// <param name="sign_decay">
		///   Must be a scalar.
		/// </param>
		/// <param name="beta">
		///   Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyPowerSign'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and m tensors is
		///   protected by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   m_t &amp;lt;- beta1 * m_{t-1} + (1 - beta1) * g
		///   update &amp;lt;- exp(logbase * sign_decay * sign(g) * sign(m_t)) * g
		///   variable &amp;lt;- variable - lr_t * update
		/// </remarks>
		public TF_Operation ResourceApplyPowerSign (TF_Output var, TF_Output m, TF_Output lr, TF_Output logbase, TF_Output sign_decay, TF_Output beta, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyPowerSign", MakeName ("ResourceApplyPowerSign", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, m);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, logbase);
			c_api.TF_AddInput(desc, sign_decay);
			c_api.TF_AddInput(desc, beta);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update '*var' and '*accum' according to FOBOS with Adagrad learning rate.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="l1">
		///   L1 regularization. Must be a scalar.
		/// </param>
		/// <param name="l2">
		///   L2 regularization. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyProximalAdagrad'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, updating of the var and accum tensors will be protected by
		///   a lock; otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   accum += grad * grad
		///   prox_v = var - lr * grad * (1 / sqrt(accum))
		///   var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}
		/// </remarks>
		public TF_Operation ResourceApplyProximalAdagrad (TF_Output var, TF_Output accum, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyProximalAdagrad", MakeName ("ResourceApplyProximalAdagrad", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update '*var' as FOBOS algorithm with fixed learning rate.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="alpha">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="l1">
		///   L1 regularization. Must be a scalar.
		/// </param>
		/// <param name="l2">
		///   L2 regularization. Must be a scalar.
		/// </param>
		/// <param name="delta">
		///   The change.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyProximalGradientDescent'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, the subtraction will be protected by a lock;
		///   otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   prox_v = var - alpha * delta
		///   var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}
		/// </remarks>
		public TF_Operation ResourceApplyProximalGradientDescent (TF_Output var, TF_Output alpha, TF_Output l1, TF_Output l2, TF_Output delta, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyProximalGradientDescent", MakeName ("ResourceApplyProximalGradientDescent", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, alpha);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, delta);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update '*var' according to the RMSProp algorithm.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="ms">
		///   Should be from a Variable().
		/// </param>
		/// <param name="mom">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="rho">
		///   Decay rate. Must be a scalar.
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="epsilon">
		///   Ridge term. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyRMSProp'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var, ms, and mom tensors is protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   Note that in dense implementation of this algorithm, ms and mom will
		///   update even if the grad is zero, but in this sparse implementation, ms
		///   and mom will not update in iterations during which the grad is zero.
		///   
		///   mean_square = decay * mean_square + (1-decay) * gradient ** 2
		///   Delta = learning_rate * gradient / sqrt(mean_square + epsilon)
		///   
		///   ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad
		///   mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
		///   var &amp;lt;- var - mom
		/// </remarks>
		public TF_Operation ResourceApplyRMSProp (TF_Output var, TF_Output ms, TF_Output mom, TF_Output lr, TF_Output rho, TF_Output momentum, TF_Output epsilon, TF_Output grad, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceApplyRMSProp", MakeName ("ResourceApplyRMSProp", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, momentum);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   A conditional accumulator for aggregating gradients.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceConditionalAccumulator'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this accumulator is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this accumulator will be shared under the
		///   given name across multiple sessions.
		/// </param>
		/// <param name="reduction_type">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		///   The type of the value being accumulated.
		/// </param>
		/// <param name="shape">
		///   The shape of the values, can be [], in which case shape is unknown.
		/// </param>
		/// <returns>
		///   The handle to the accumulator.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The accumulator accepts gradients marked with local_step greater or
		///   equal to the most recent global_step known to the accumulator. The
		///   average can be extracted from the accumulator, provided sufficient
		///   gradients have been accumulated. Extracting the average automatically
		///   resets the aggregate to 0, and increments the global_step recorded by
		///   the accumulator.
		///   This is a resource version of ConditionalAccumulator that will work in TF2.0
		///   with tf.cond version 2.
		/// </remarks>
		public TF_Output ResourceConditionalAccumulator (TF_DataType dtype, long[] shape, string container = null, string shared_name = null, string reduction_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceConditionalAccumulator", MakeName ("ResourceConditionalAccumulator", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (reduction_type != null)
				c_api.TF_SetAttrString (desc, "reduction_type", reduction_type);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Increments variable pointed to by 'resource' until it reaches 'limit'.
		/// </summary>
		/// <param name="resource">
		///   Should be from a scalar <c>Variable</c> node.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceCountUpTo'.
		/// </param>
		/// <param name="limit">
		///   If incrementing ref would bring it above limit, instead generates an
		///   'OutOfRange' error.
		/// </param>
		/// <param name="T">
		/// </param>
		/// <returns>
		///   A copy of the input before increment. If nothing else modifies the
		///   input, the values produced will all be distinct.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ResourceCountUpTo (TF_Output resource, long limit, TF_DataType T, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceCountUpTo", MakeName ("ResourceCountUpTo", operName));
			c_api.TF_AddInput(desc, resource);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "limit", limit);
			c_api.TF_SetAttrType (desc, "T", T);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Gather slices from the variable pointed to by <c>resource</c> according to <c>indices</c>.
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceGather'.
		/// </param>
		/// <param name="batch_dims">
		///   Optional argument
		/// </param>
		/// <param name="validate_indices">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   <c>indices</c> must be an integer tensor of any dimension (usually 0-D or 1-D).
		///   Produces an output tensor with shape <c>indices.shape + params.shape[1:]</c> where:
		///   
		///    <code>
		///   # Scalar indices
		///   output[:, ..., :] = params[indices, :, ... :]
		///   
		///   # Vector indices
		///   output[i, :, ..., :] = params[indices[i], :, ... :]
		///   
		///   # Higher rank indices
		///   output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]
		///    </code>
		/// </remarks>
		public TF_Output ResourceGather (TF_Output resource, TF_Output indices, TF_DataType dtype, long? batch_dims = null, bool? validate_indices = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceGather", MakeName ("ResourceGather", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (batch_dims.HasValue)
				c_api.TF_SetAttrInt (desc, "batch_dims", batch_dims.Value);
			
			if (validate_indices.HasValue)
				c_api.TF_SetAttrBool (desc, "validate_indices", Convert.ToByte(validate_indices.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceGatherNd'.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ResourceGatherNd (TF_Output resource, TF_Output indices, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceGatherNd", MakeName ("ResourceGatherNd", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Adds sparse updates to the variable referenced by <c>resource</c>.
		/// </summary>
		/// <param name="resource">
		///   Should be from a <c>Variable</c> node.
		/// </param>
		/// <param name="indices">
		///   A tensor of indices into the first dimension of <c>ref</c>.
		/// </param>
		/// <param name="updates">
		///   A tensor of updated values to add to <c>ref</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterAdd'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   This operation computes
		///   
		///   # Scalar indices
		///   ref[indices, ...] += updates[...]
		///   
		///   # Vector indices (for each i)
		///   ref[indices[i], ...] += updates[i, ...]
		///   
		///   # High rank indices (for each i, ..., j)
		///   ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]
		///   
		///   Duplicate entries are handled correctly: if multiple <c>indices</c> reference
		///   the same location, their contributions add.
		///   
		///   Requires <c>updates.shape = indices.shape + ref.shape[1:]</c> or <c>updates.shape = []</c>.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src='https://www.tensorflow.org/images/ScatterAdd.png' alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		/// </remarks>
		public TF_Operation ResourceScatterAdd (TF_Output resource, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceScatterAdd", MakeName ("ResourceScatterAdd", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Divides sparse updates into the variable referenced by <c>resource</c>.
		/// </summary>
		/// <param name="resource">
		///   Should be from a <c>Variable</c> node.
		/// </param>
		/// <param name="indices">
		///   A tensor of indices into the first dimension of <c>ref</c>.
		/// </param>
		/// <param name="updates">
		///   A tensor of updated values to add to <c>ref</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterDiv'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   This operation computes
		///   
		///   # Scalar indices
		///   ref[indices, ...] /= updates[...]
		///   
		///   # Vector indices (for each i)
		///   ref[indices[i], ...] /= updates[i, ...]
		///   
		///   # High rank indices (for each i, ..., j)
		///   ref[indices[i, ..., j], ...] /= updates[i, ..., j, ...]
		///   
		///   Duplicate entries are handled correctly: if multiple <c>indices</c> reference
		///   the same location, their contributions multiply.
		///   
		///   Requires <c>updates.shape = indices.shape + ref.shape[1:]</c> or <c>updates.shape = []</c>.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src='https://www.tensorflow.org/images/ScatterAdd.png' alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		/// </remarks>
		public TF_Operation ResourceScatterDiv (TF_Output resource, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceScatterDiv", MakeName ("ResourceScatterDiv", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Reduces sparse updates into the variable referenced by <c>resource</c> using the <c>max</c> operation.
		/// </summary>
		/// <param name="resource">
		///   Should be from a <c>Variable</c> node.
		/// </param>
		/// <param name="indices">
		///   A tensor of indices into the first dimension of <c>ref</c>.
		/// </param>
		/// <param name="updates">
		///   A tensor of updated values to add to <c>ref</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterMax'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   This operation computes
		///   
		///   # Scalar indices
		///   ref[indices, ...] = max(ref[indices, ...], updates[...])
		///   
		///   # Vector indices (for each i)
		///   ref[indices[i], ...] = max(ref[indices[i], ...], updates[i, ...])
		///   
		///   # High rank indices (for each i, ..., j)
		///   ref[indices[i, ..., j], ...] = max(ref[indices[i, ..., j], ...], updates[i, ..., j, ...])
		///   
		///   Duplicate entries are handled correctly: if multiple <c>indices</c> reference
		///   the same location, their contributions are combined.
		///   
		///   Requires <c>updates.shape = indices.shape + ref.shape[1:]</c> or <c>updates.shape = []</c>.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src='https://www.tensorflow.org/images/ScatterAdd.png' alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		/// </remarks>
		public TF_Operation ResourceScatterMax (TF_Output resource, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceScatterMax", MakeName ("ResourceScatterMax", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Reduces sparse updates into the variable referenced by <c>resource</c> using the <c>min</c> operation.
		/// </summary>
		/// <param name="resource">
		///   Should be from a <c>Variable</c> node.
		/// </param>
		/// <param name="indices">
		///   A tensor of indices into the first dimension of <c>ref</c>.
		/// </param>
		/// <param name="updates">
		///   A tensor of updated values to add to <c>ref</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterMin'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   This operation computes
		///   
		///   # Scalar indices
		///   ref[indices, ...] = min(ref[indices, ...], updates[...])
		///   
		///   # Vector indices (for each i)
		///   ref[indices[i], ...] = min(ref[indices[i], ...], updates[i, ...])
		///   
		///   # High rank indices (for each i, ..., j)
		///   ref[indices[i, ..., j], ...] = min(ref[indices[i, ..., j], ...], updates[i, ..., j, ...])
		///   
		///   Duplicate entries are handled correctly: if multiple <c>indices</c> reference
		///   the same location, their contributions are combined.
		///   
		///   Requires <c>updates.shape = indices.shape + ref.shape[1:]</c> or <c>updates.shape = []</c>.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src='https://www.tensorflow.org/images/ScatterAdd.png' alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		/// </remarks>
		public TF_Operation ResourceScatterMin (TF_Output resource, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceScatterMin", MakeName ("ResourceScatterMin", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Multiplies sparse updates into the variable referenced by <c>resource</c>.
		/// </summary>
		/// <param name="resource">
		///   Should be from a <c>Variable</c> node.
		/// </param>
		/// <param name="indices">
		///   A tensor of indices into the first dimension of <c>ref</c>.
		/// </param>
		/// <param name="updates">
		///   A tensor of updated values to add to <c>ref</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterMul'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   This operation computes
		///   
		///   # Scalar indices
		///   ref[indices, ...] *= updates[...]
		///   
		///   # Vector indices (for each i)
		///   ref[indices[i], ...] *= updates[i, ...]
		///   
		///   # High rank indices (for each i, ..., j)
		///   ref[indices[i, ..., j], ...] *= updates[i, ..., j, ...]
		///   
		///   Duplicate entries are handled correctly: if multiple <c>indices</c> reference
		///   the same location, their contributions multiply.
		///   
		///   Requires <c>updates.shape = indices.shape + ref.shape[1:]</c> or <c>updates.shape = []</c>.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src='https://www.tensorflow.org/images/ScatterAdd.png' alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		/// </remarks>
		public TF_Operation ResourceScatterMul (TF_Output resource, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceScatterMul", MakeName ("ResourceScatterMul", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Applies sparse addition to individual values or slices in a Variable.
		/// </summary>
		/// <param name="reference">
		///   A resource handle. Must be from a VarHandleOp.
		/// </param>
		/// <param name="indices">
		///   A Tensor. Must be one of the following types: int32, int64.
		///   A tensor of indices into ref.
		/// </param>
		/// <param name="updates">
		///   A Tensor. Must have the same type as ref. A tensor of
		///   values to add to ref.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterNdAdd'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   An optional bool. Defaults to True. If True, the assignment will
		///   be protected by a lock; otherwise the behavior is undefined,
		///   but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   <c>ref</c> is a <c>Tensor</c> with rank <c>P</c> and <c>indices</c> is a <c>Tensor</c> of rank <c>Q</c>.
		///   
		///   <c>indices</c> must be integer tensor, containing indices into <c>ref</c>.
		///   It must be shape <c>[d_0, ..., d_{Q-2}, K]</c> where <c>0 &amp;lt; K &amp;lt;= P</c>.
		///   
		///   The innermost dimension of <c>indices</c> (with length <c>K</c>) corresponds to
		///   indices into elements (if <c>K = P</c>) or slices (if <c>K &amp;lt; P</c>) along the <c>K</c>th
		///   dimension of <c>ref</c>.
		///   
		///   <c>updates</c> is <c>Tensor</c> of rank <c>Q-1+P-K</c> with shape:
		///   
		///    <code>
		///   [d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]]
		///    </code>
		///   
		///   For example, say we want to add 4 scattered elements to a rank-1 tensor to
		///   8 elements. In Python, that addition would look like this:
		///   
		///    <code>
		///   ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8], use_resource=True)
		///   indices = tf.constant([[4], [3], [1], [7]])
		///   updates = tf.constant([9, 10, 11, 12])
		///   add = tf.scatter_nd_add(ref, indices, updates)
		///   with tf.Session() as sess:
		///   print sess.run(add)
		///    </code>
		///   
		///   The resulting update to ref would look like this:
		///   
		///   [1, 13, 3, 14, 14, 6, 7, 20]
		///   
		///   See <c>tf.scatter_nd</c> for more details about how to make updates to
		///   slices.
		/// </remarks>
		public TF_Operation ResourceScatterNdAdd (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceScatterNdAdd", MakeName ("ResourceScatterNdAdd", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Applies sparse subtraction to individual values or slices in a Variable.
		/// </summary>
		/// <param name="reference">
		///   A resource handle. Must be from a VarHandleOp.
		/// </param>
		/// <param name="indices">
		///   A Tensor. Must be one of the following types: int32, int64.
		///   A tensor of indices into ref.
		/// </param>
		/// <param name="updates">
		///   A Tensor. Must have the same type as ref. A tensor of
		///   values to add to ref.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterNdSub'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   An optional bool. Defaults to True. If True, the assignment will
		///   be protected by a lock; otherwise the behavior is undefined,
		///   but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   <c>ref</c> is a <c>Tensor</c> with rank <c>P</c> and <c>indices</c> is a <c>Tensor</c> of rank <c>Q</c>.
		///   
		///   <c>indices</c> must be integer tensor, containing indices into <c>ref</c>.
		///   It must be shape <c>[d_0, ..., d_{Q-2}, K]</c> where <c>0 &amp;lt; K &amp;lt;= P</c>.
		///   
		///   The innermost dimension of <c>indices</c> (with length <c>K</c>) corresponds to
		///   indices into elements (if <c>K = P</c>) or slices (if <c>K &amp;lt; P</c>) along the <c>K</c>th
		///   dimension of <c>ref</c>.
		///   
		///   <c>updates</c> is <c>Tensor</c> of rank <c>Q-1+P-K</c> with shape:
		///   
		///    <code>
		///   [d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]]
		///    </code>
		///   
		///   For example, say we want to subtract 4 scattered elements from a rank-1 tensor
		///   with 8 elements. In Python, that subtraction would look like this:
		///   
		///    <code>
		///   ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8], use_resource=True)
		///   indices = tf.constant([[4], [3], [1], [7]])
		///   updates = tf.constant([9, 10, 11, 12])
		///   sub = tf.scatter_nd_sub(ref, indices, updates)
		///   with tf.Session() as sess:
		///   print sess.run(sub)
		///    </code>
		///   
		///   The resulting update to ref would look like this:
		///   
		///   [1, -9, 3, -6, -4, 6, 7, -4]
		///   
		///   See <c>tf.scatter_nd</c> for more details about how to make updates to
		///   slices.
		/// </remarks>
		public TF_Operation ResourceScatterNdSub (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceScatterNdSub", MakeName ("ResourceScatterNdSub", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Applies sparse <c>updates</c> to individual values or slices within a given
		/// </summary>
		/// <param name="reference">
		///   A resource handle. Must be from a VarHandleOp.
		/// </param>
		/// <param name="indices">
		///   A Tensor. Must be one of the following types: int32, int64.
		///   A tensor of indices into ref.
		/// </param>
		/// <param name="updates">
		///   A Tensor. Must have the same type as ref. A tensor of updated
		///   values to add to ref.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterNdUpdate'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   An optional bool. Defaults to True. If True, the assignment will
		///   be protected by a lock; otherwise the behavior is undefined,
		///   but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   variable according to <c>indices</c>.
		///   
		///   <c>ref</c> is a <c>Tensor</c> with rank <c>P</c> and <c>indices</c> is a <c>Tensor</c> of rank <c>Q</c>.
		///   
		///   <c>indices</c> must be integer tensor, containing indices into <c>ref</c>.
		///   It must be shape <c>[d_0, ..., d_{Q-2}, K]</c> where <c>0 &amp;lt; K &amp;lt;= P</c>.
		///   
		///   The innermost dimension of <c>indices</c> (with length <c>K</c>) corresponds to
		///   indices into elements (if <c>K = P</c>) or slices (if <c>K &amp;lt; P</c>) along the <c>K</c>th
		///   dimension of <c>ref</c>.
		///   
		///   <c>updates</c> is <c>Tensor</c> of rank <c>Q-1+P-K</c> with shape:
		///   
		///    <code>
		///   [d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].
		///    </code>
		///   
		///   For example, say we want to update 4 scattered elements to a rank-1 tensor to
		///   8 elements. In Python, that update would look like this:
		///   
		///    <code>
		///   ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
		///   indices = tf.constant([[4], [3], [1] ,[7]])
		///   updates = tf.constant([9, 10, 11, 12])
		///   update = tf.scatter_nd_update(ref, indices, updates)
		///   with tf.Session() as sess:
		///   print sess.run(update)
		///    </code>
		///   
		///   The resulting update to ref would look like this:
		///   
		///   [1, 11, 3, 10, 9, 6, 7, 12]
		///   
		///   See <c>tf.scatter_nd</c> for more details about how to make updates to
		///   slices.
		/// </remarks>
		public TF_Operation ResourceScatterNdUpdate (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceScatterNdUpdate", MakeName ("ResourceScatterNdUpdate", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Subtracts sparse updates from the variable referenced by <c>resource</c>.
		/// </summary>
		/// <param name="resource">
		///   Should be from a <c>Variable</c> node.
		/// </param>
		/// <param name="indices">
		///   A tensor of indices into the first dimension of <c>ref</c>.
		/// </param>
		/// <param name="updates">
		///   A tensor of updated values to add to <c>ref</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterSub'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   This operation computes
		///   
		///   # Scalar indices
		///   ref[indices, ...] -= updates[...]
		///   
		///   # Vector indices (for each i)
		///   ref[indices[i], ...] -= updates[i, ...]
		///   
		///   # High rank indices (for each i, ..., j)
		///   ref[indices[i, ..., j], ...] -= updates[i, ..., j, ...]
		///   
		///   Duplicate entries are handled correctly: if multiple <c>indices</c> reference
		///   the same location, their contributions add.
		///   
		///   Requires <c>updates.shape = indices.shape + ref.shape[1:]</c> or <c>updates.shape = []</c>.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src='https://www.tensorflow.org/images/ScatterAdd.png' alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		/// </remarks>
		public TF_Operation ResourceScatterSub (TF_Output resource, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceScatterSub", MakeName ("ResourceScatterSub", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Assigns sparse updates to the variable referenced by <c>resource</c>.
		/// </summary>
		/// <param name="resource">
		///   Should be from a <c>Variable</c> node.
		/// </param>
		/// <param name="indices">
		///   A tensor of indices into the first dimension of <c>ref</c>.
		/// </param>
		/// <param name="updates">
		///   A tensor of updated values to add to <c>ref</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterUpdate'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   This operation computes
		///   
		///   # Scalar indices
		///   ref[indices, ...] = updates[...]
		///   
		///   # Vector indices (for each i)
		///   ref[indices[i], ...] = updates[i, ...]
		///   
		///   # High rank indices (for each i, ..., j)
		///   ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]
		/// </remarks>
		public TF_Operation ResourceScatterUpdate (TF_Output resource, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceScatterUpdate", MakeName ("ResourceScatterUpdate", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   var: Should be from a Variable().
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum_update">
		///   : Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Learning rate. Must be a scalar.
		/// </param>
		/// <param name="rho">
		///   Decay factor. Must be a scalar.
		/// </param>
		/// <param name="epsilon">
		///   Constant factor. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var and accum.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyAdadelta'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, updating of the var and accum tensors will be protected by
		///   a lock; otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceSparseApplyAdadelta (TF_Output var, TF_Output accum, TF_Output accum_update, TF_Output lr, TF_Output rho, TF_Output epsilon, TF_Output grad, TF_Output indices, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyAdadelta", MakeName ("ResourceSparseApplyAdadelta", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, accum_update);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update relevant entries in '*var' and '*accum' according to the adagrad scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Learning rate. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var and accum.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyAdagrad'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <param name="update_slots">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   That is for rows we have grad for, we update var and accum as follows:
		///   accum += grad * grad
		///   var -= lr * grad * (1 / sqrt(accum))
		/// </remarks>
		public TF_Operation ResourceSparseApplyAdagrad (TF_Output var, TF_Output accum, TF_Output lr, TF_Output grad, TF_Output indices, bool? use_locking = null, bool? update_slots = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyAdagrad", MakeName ("ResourceSparseApplyAdagrad", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (update_slots.HasValue)
				c_api.TF_SetAttrBool (desc, "update_slots", Convert.ToByte(update_slots.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update entries in '*var' and '*accum' according to the proximal adagrad scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="gradient_accumulator">
		///   Should be from a Variable().
		/// </param>
		/// <param name="gradient_squared_accumulator">
		///   Should be from a Variable().
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var and accum.
		/// </param>
		/// <param name="lr">
		///   Learning rate. Must be a scalar.
		/// </param>
		/// <param name="l1">
		///   L1 regularization. Must be a scalar.
		/// </param>
		/// <param name="l2">
		///   L2 regularization. Must be a scalar.
		/// </param>
		/// <param name="global_step">
		///   Training step number. Must be a scalar.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyAdagradDA'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, updating of the var and accum tensors will be protected by
		///   a lock; otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation ResourceSparseApplyAdagradDA (TF_Output var, TF_Output gradient_accumulator, TF_Output gradient_squared_accumulator, TF_Output grad, TF_Output indices, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output global_step, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyAdagradDA", MakeName ("ResourceSparseApplyAdagradDA", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, gradient_accumulator);
			c_api.TF_AddInput(desc, gradient_squared_accumulator);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, global_step);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update relevant entries in '*var' and '*accum' according to the adagrad scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Learning rate. Must be a scalar.
		/// </param>
		/// <param name="epsilon">
		///   Constant factor. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var and accum.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyAdagradV2'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <param name="update_slots">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   That is for rows we have grad for, we update var and accum as follows:
		///   accum += grad * grad
		///   var -= lr * grad * (1 / sqrt(accum))
		/// </remarks>
		public TF_Operation ResourceSparseApplyAdagradV2 (TF_Output var, TF_Output accum, TF_Output lr, TF_Output epsilon, TF_Output grad, TF_Output indices, bool? use_locking = null, bool? update_slots = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyAdagradV2", MakeName ("ResourceSparseApplyAdagradV2", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (update_slots.HasValue)
				c_api.TF_SetAttrBool (desc, "update_slots", Convert.ToByte(update_slots.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update '*var' according to the centered RMSProp algorithm.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="mg">
		///   Should be from a Variable().
		/// </param>
		/// <param name="ms">
		///   Should be from a Variable().
		/// </param>
		/// <param name="mom">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="rho">
		///   Decay rate. Must be a scalar.
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="epsilon">
		///   Ridge term. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var, ms and mom.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyCenteredRMSProp'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var, mg, ms, and mom tensors is
		///   protected by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   The centered RMSProp algorithm uses an estimate of the centered second moment
		///   (i.e., the variance) for normalization, as opposed to regular RMSProp, which
		///   uses the (uncentered) second moment. This often helps with training, but is
		///   slightly more expensive in terms of computation and memory.
		///   
		///   Note that in dense implementation of this algorithm, mg, ms, and mom will
		///   update even if the grad is zero, but in this sparse implementation, mg, ms,
		///   and mom will not update in iterations during which the grad is zero.
		///   
		///   mean_square = decay * mean_square + (1-decay) * gradient ** 2
		///   mean_grad = decay * mean_grad + (1-decay) * gradient
		///   Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)
		///   
		///   ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad
		///   mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
		///   var &amp;lt;- var - mom
		/// </remarks>
		public TF_Operation ResourceSparseApplyCenteredRMSProp (TF_Output var, TF_Output mg, TF_Output ms, TF_Output mom, TF_Output lr, TF_Output rho, TF_Output momentum, TF_Output epsilon, TF_Output grad, TF_Output indices, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyCenteredRMSProp", MakeName ("ResourceSparseApplyCenteredRMSProp", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, mg);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, momentum);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update relevant entries in '*var' according to the Ftrl-proximal scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="linear">
		///   Should be from a Variable().
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var and accum.
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="l1">
		///   L1 regularization. Must be a scalar.
		/// </param>
		/// <param name="l2">
		///   L2 regularization. Must be a scalar.
		/// </param>
		/// <param name="lr_power">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyFtrl'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   That is for rows we have grad for, we update var, accum and linear as follows:
		///   accum_new = accum + grad * grad
		///   linear += grad - (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
		///   quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
		///   var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0
		///   accum = accum_new
		/// </remarks>
		public TF_Operation ResourceSparseApplyFtrl (TF_Output var, TF_Output accum, TF_Output linear, TF_Output grad, TF_Output indices, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output lr_power, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyFtrl", MakeName ("ResourceSparseApplyFtrl", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, linear);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, lr_power);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update relevant entries in '*var' according to the Ftrl-proximal scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="linear">
		///   Should be from a Variable().
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var and accum.
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="l1">
		///   L1 regularization. Must be a scalar.
		/// </param>
		/// <param name="l2">
		///   L2 shrinkage regulariation. Must be a scalar.
		/// </param>
		/// <param name="l2_shrinkage">
		/// </param>
		/// <param name="lr_power">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyFtrlV2'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   That is for rows we have grad for, we update var, accum and linear as follows:
		///   grad_with_shrinkage = grad + 2 * l2_shrinkage * var
		///   accum_new = accum + grad_with_shrinkage * grad_with_shrinkage
		///   linear += grad_with_shrinkage +
		///   (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
		///   quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
		///   var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0
		///   accum = accum_new
		/// </remarks>
		public TF_Operation ResourceSparseApplyFtrlV2 (TF_Output var, TF_Output accum, TF_Output linear, TF_Output grad, TF_Output indices, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output l2_shrinkage, TF_Output lr_power, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyFtrlV2", MakeName ("ResourceSparseApplyFtrlV2", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, linear);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, l2_shrinkage);
			c_api.TF_AddInput(desc, lr_power);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update relevant entries in '*var' and '*accum' according to the momentum scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Learning rate. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var and accum.
		/// </param>
		/// <param name="momentum">
		///   Momentum. Must be a scalar.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyKerasMomentum'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <param name="use_nesterov">
		///   Optional argument
		///   If <c>True</c>, the tensor passed to compute grad will be
		///   var + momentum * accum, so in the end, the var you get is actually
		///   var + momentum * accum.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   Set use_nesterov = True if you want to use Nesterov momentum.
		///   
		///   That is for rows we have grad for, we update var and accum as follows:
		///   
		///   accum = accum * momentum - lr * grad
		///   var += accum
		/// </remarks>
		public TF_Operation ResourceSparseApplyKerasMomentum (TF_Output var, TF_Output accum, TF_Output lr, TF_Output grad, TF_Output indices, TF_Output momentum, bool? use_locking = null, bool? use_nesterov = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyKerasMomentum", MakeName ("ResourceSparseApplyKerasMomentum", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, momentum);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (use_nesterov.HasValue)
				c_api.TF_SetAttrBool (desc, "use_nesterov", Convert.ToByte(use_nesterov.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update relevant entries in '*var' and '*accum' according to the momentum scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Learning rate. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var and accum.
		/// </param>
		/// <param name="momentum">
		///   Momentum. Must be a scalar.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyMomentum'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <param name="use_nesterov">
		///   Optional argument
		///   If <c>True</c>, the tensor passed to compute grad will be
		///   var - lr * momentum * accum, so in the end, the var you get is actually
		///   var - lr * momentum * accum.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   Set use_nesterov = True if you want to use Nesterov momentum.
		///   
		///   That is for rows we have grad for, we update var and accum as follows:
		///   
		///   accum = accum * momentum + grad
		///   var -= lr * accum
		/// </remarks>
		public TF_Operation ResourceSparseApplyMomentum (TF_Output var, TF_Output accum, TF_Output lr, TF_Output grad, TF_Output indices, TF_Output momentum, bool? use_locking = null, bool? use_nesterov = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyMomentum", MakeName ("ResourceSparseApplyMomentum", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, momentum);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (use_nesterov.HasValue)
				c_api.TF_SetAttrBool (desc, "use_nesterov", Convert.ToByte(use_nesterov.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Sparse update entries in '*var' and '*accum' according to FOBOS algorithm.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Learning rate. Must be a scalar.
		/// </param>
		/// <param name="l1">
		///   L1 regularization. Must be a scalar.
		/// </param>
		/// <param name="l2">
		///   L2 regularization. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var and accum.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyProximalAdagrad'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, updating of the var and accum tensors will be protected by
		///   a lock; otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   That is for rows we have grad for, we update var and accum as follows:
		///   accum += grad * grad
		///   prox_v = var
		///   prox_v -= lr * grad * (1 / sqrt(accum))
		///   var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}
		/// </remarks>
		public TF_Operation ResourceSparseApplyProximalAdagrad (TF_Output var, TF_Output accum, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output grad, TF_Output indices, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyProximalAdagrad", MakeName ("ResourceSparseApplyProximalAdagrad", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Sparse update '*var' as FOBOS algorithm with fixed learning rate.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="alpha">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="l1">
		///   L1 regularization. Must be a scalar.
		/// </param>
		/// <param name="l2">
		///   L2 regularization. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var and accum.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyProximalGradientDescent'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, the subtraction will be protected by a lock;
		///   otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   That is for rows we have grad for, we update var as follows:
		///   prox_v = var - alpha * grad
		///   var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}
		/// </remarks>
		public TF_Operation ResourceSparseApplyProximalGradientDescent (TF_Output var, TF_Output alpha, TF_Output l1, TF_Output l2, TF_Output grad, TF_Output indices, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyProximalGradientDescent", MakeName ("ResourceSparseApplyProximalGradientDescent", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, alpha);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Update '*var' according to the RMSProp algorithm.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="ms">
		///   Should be from a Variable().
		/// </param>
		/// <param name="mom">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="rho">
		///   Decay rate. Must be a scalar.
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="epsilon">
		///   Ridge term. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var, ms and mom.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyRMSProp'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var, ms, and mom tensors is protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   Note that in dense implementation of this algorithm, ms and mom will
		///   update even if the grad is zero, but in this sparse implementation, ms
		///   and mom will not update in iterations during which the grad is zero.
		///   
		///   mean_square = decay * mean_square + (1-decay) * gradient ** 2
		///   Delta = learning_rate * gradient / sqrt(mean_square + epsilon)
		///   
		///   ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad
		///   mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
		///   var &amp;lt;- var - mom
		/// </remarks>
		public TF_Operation ResourceSparseApplyRMSProp (TF_Output var, TF_Output ms, TF_Output mom, TF_Output lr, TF_Output rho, TF_Output momentum, TF_Output epsilon, TF_Output grad, TF_Output indices, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceSparseApplyRMSProp", MakeName ("ResourceSparseApplyRMSProp", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, momentum);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Assign <c>value</c> to the sliced l-value reference of <c>ref</c>.
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="begin">
		/// </param>
		/// <param name="end">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceStridedSliceAssign'.
		/// </param>
		/// <param name="begin_mask">
		///   Optional argument
		/// </param>
		/// <param name="end_mask">
		///   Optional argument
		/// </param>
		/// <param name="ellipsis_mask">
		///   Optional argument
		/// </param>
		/// <param name="new_axis_mask">
		///   Optional argument
		/// </param>
		/// <param name="shrink_axis_mask">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   The values of <c>value</c> are assigned to the positions in the variable
		///   <c>ref</c> that are selected by the slice parameters. The slice parameters
		///   <c>begin, </c>end<c>, </c>strides<c>, etc. work exactly as in </c>StridedSlice<c>.
		///   
		///   NOTE this op currently does not support broadcasting and so </c>value<c>'s
		///   shape must be exactly the shape produced by the slice of </c>ref<c>.
		/// </remarks>
		public TF_Operation ResourceStridedSliceAssign (TF_Output reference, TF_Output begin, TF_Output end, TF_Output strides, TF_Output value, long? begin_mask = null, long? end_mask = null, long? ellipsis_mask = null, long? new_axis_mask = null, long? shrink_axis_mask = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ResourceStridedSliceAssign", MakeName ("ResourceStridedSliceAssign", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, begin);
			c_api.TF_AddInput(desc, end);
			c_api.TF_AddInput(desc, strides);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (begin_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "begin_mask", begin_mask.Value);
			
			if (end_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "end_mask", end_mask.Value);
			
			if (ellipsis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "ellipsis_mask", ellipsis_mask.Value);
			
			if (new_axis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "new_axis_mask", new_axis_mask.Value);
			
			if (shrink_axis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "shrink_axis_mask", shrink_axis_mask.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Restores a tensor from checkpoint files.
		/// </summary>
		/// <param name="file_pattern">
		///   Must have a single element. The pattern of the files from
		///   which we read the tensor.
		/// </param>
		/// <param name="tensor_name">
		///   Must have a single element. The name of the tensor to be
		///   restored.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Restore'.
		/// </param>
		/// <param name="preferred_shard">
		///   Optional argument
		///   Index of file to open first if multiple files match
		///   <c>file_pattern</c>.
		/// </param>
		/// <param name="dt">
		///   The type of the tensor to be restored.
		/// </param>
		/// <returns>
		///   The restored tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Reads a tensor stored in one or several files. If there are several files (for
		///   instance because a tensor was saved as slices), <c>file_pattern</c> may contain
		///   wildcard symbols (<c>*</c> and <c>?</c>) in the filename portion only, not in the
		///   directory portion.
		///   
		///   If a <c>file_pattern</c> matches several files, <c>preferred_shard</c> can be used to hint
		///   in which file the requested tensor is likely to be found. This op will first
		///   open the file at index <c>preferred_shard</c> in the list of matching files and try
		///   to restore tensors from that file.  Only if some tensors or tensor slices are
		///   not found in that first file, then the Op opens all the files. Setting
		///   <c>preferred_shard</c> to match the value passed as the <c>shard</c> input
		///   of a matching <c>Save</c> Op may speed up Restore.  This attribute only affects
		///   performance, not correctness.  The default value -1 means files are processed in
		///   order.
		///   
		///   See also <c>RestoreSlice</c>.
		/// </remarks>
		public TF_Output Restore (TF_Output file_pattern, TF_Output tensor_name, TF_DataType dt, long? preferred_shard = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Restore", MakeName ("Restore", operName));
			c_api.TF_AddInput(desc, file_pattern);
			c_api.TF_AddInput(desc, tensor_name);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dt", dt);
			if (preferred_shard.HasValue)
				c_api.TF_SetAttrInt (desc, "preferred_shard", preferred_shard.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var tensor = new TF_Output (op, _idx++);
			return tensor;
		}

		/// <summary>
		///   Restores a tensor from checkpoint files.
		/// </summary>
		/// <param name="file_pattern">
		///   Must have a single element. The pattern of the files from
		///   which we read the tensor.
		/// </param>
		/// <param name="tensor_name">
		///   Must have a single element. The name of the tensor to be
		///   restored.
		/// </param>
		/// <param name="shape_and_slice">
		///   Scalar. The shapes and slice specifications to use when
		///   restoring a tensors.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RestoreSlice'.
		/// </param>
		/// <param name="preferred_shard">
		///   Optional argument
		///   Index of file to open first if multiple files match
		///   <c>file_pattern</c>. See the documentation for <c>Restore</c>.
		/// </param>
		/// <param name="dt">
		///   The type of the tensor to be restored.
		/// </param>
		/// <returns>
		///   The restored tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This is like <c>Restore</c> except that restored tensor can be listed as filling
		///   only a slice of a larger tensor.  <c>shape_and_slice</c> specifies the shape of the
		///   larger tensor and the slice that the restored tensor covers.
		///   
		///   The <c>shape_and_slice</c> input has the same format as the
		///   elements of the <c>shapes_and_slices</c> input of the <c>SaveSlices</c> op.
		/// </remarks>
		public TF_Output RestoreSlice (TF_Output file_pattern, TF_Output tensor_name, TF_Output shape_and_slice, TF_DataType dt, long? preferred_shard = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RestoreSlice", MakeName ("RestoreSlice", operName));
			c_api.TF_AddInput(desc, file_pattern);
			c_api.TF_AddInput(desc, tensor_name);
			c_api.TF_AddInput(desc, shape_and_slice);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dt", dt);
			if (preferred_shard.HasValue)
				c_api.TF_SetAttrInt (desc, "preferred_shard", preferred_shard.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var tensor = new TF_Output (op, _idx++);
			return tensor;
		}

		/// <summary>
		///   Restores tensors from a V2 checkpoint.
		/// </summary>
		/// <param name="prefix">
		///   Must have a single element.  The prefix of a V2 checkpoint.
		/// </param>
		/// <param name="tensor_names">
		///   shape {N}.  The names of the tensors to be restored.
		/// </param>
		/// <param name="shape_and_slices">
		///   shape {N}.  The slice specs of the tensors to be restored.
		///   Empty strings indicate that they are non-partitioned tensors.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RestoreV2'.
		/// </param>
		/// <param name="dtypes">
		///   shape {N}.  The list of expected dtype for the tensors.  Must match
		///   those stored in the checkpoint.
		/// </param>
		/// <returns>
		///   shape {N}.  The restored tensors, whose shapes are read from the
		///   checkpoint directly.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   For backward compatibility with the V1 format, this Op currently allows
		///   restoring from a V1 checkpoint as well:
		///   - This Op first attempts to find the V2 index file pointed to by "prefix", and
		///   if found proceed to read it as a V2 checkpoint;
		///   - Otherwise the V1 read path is invoked.
		///   Relying on this behavior is not recommended, as the ability to fall back to read
		///   V1 might be deprecated and eventually removed.
		///   
		///   By default, restores the named tensors in full.  If the caller wishes to restore
		///   specific slices of stored tensors, "shape_and_slices" should be non-empty
		///   strings and correspondingly well-formed.
		///   
		///   Callers must ensure all the named tensors are indeed stored in the checkpoint.
		/// </remarks>
		public TF_Output[] RestoreV2 (TF_Output prefix, TF_Output tensor_names, TF_Output shape_and_slices, TF_DataType[] dtypes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RestoreV2", MakeName ("RestoreV2", operName));
			c_api.TF_AddInput(desc, prefix);
			c_api.TF_AddInput(desc, tensor_names);
			c_api.TF_AddInput(desc, shape_and_slices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "tensors", status);
			var tensors = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				tensors [i] = new TF_Output (op, _idx++);
			
			return tensors;
		}

		/// <summary>
		///   Retrieve Adadelta embedding parameters.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingAdadeltaParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters: Parameter parameters updated by the Adadelta optimization algorithm.
		///   accumulators: Parameter accumulators updated by the Adadelta optimization algorithm.
		///   updates: Parameter updates updated by the Adadelta optimization algorithm.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   An op that retrieves optimization parameters from embedding to host
		///   memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
		///   the correct embedding table configuration. For example, this op is
		///   used to retrieve updated parameters before saving a checkpoint.
		/// </remarks>
		public (TF_Output parameters, TF_Output accumulators, TF_Output updates) RetrieveTPUEmbeddingAdadeltaParameters (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingAdadeltaParameters", MakeName ("RetrieveTPUEmbeddingAdadeltaParameters", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var accumulators = new TF_Output (op, _idx++);
			var updates = new TF_Output (op, _idx++);
			return (parameters, accumulators, updates);
		}

		/// <summary>
		///   Retrieve Adadelta embedding parameters with debug support.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters: Parameter parameters updated by the Adadelta optimization algorithm.
		///   accumulators: Parameter accumulators updated by the Adadelta optimization algorithm.
		///   updates: Parameter updates updated by the Adadelta optimization algorithm.
		///   gradient_accumulators: Parameter gradient_accumulators updated by the Adadelta optimization algorithm.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   An op that retrieves optimization parameters from embedding to host
		///   memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
		///   the correct embedding table configuration. For example, this op is
		///   used to retrieve updated parameters before saving a checkpoint.
		/// </remarks>
		public (TF_Output parameters, TF_Output accumulators, TF_Output updates, TF_Output gradient_accumulators) RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug", MakeName ("RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var accumulators = new TF_Output (op, _idx++);
			var updates = new TF_Output (op, _idx++);
			var gradient_accumulators = new TF_Output (op, _idx++);
			return (parameters, accumulators, updates, gradient_accumulators);
		}

		/// <summary>
		///   Retrieve Adagrad embedding parameters.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingAdagradParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters: Parameter parameters updated by the Adagrad optimization algorithm.
		///   accumulators: Parameter accumulators updated by the Adagrad optimization algorithm.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   An op that retrieves optimization parameters from embedding to host
		///   memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
		///   the correct embedding table configuration. For example, this op is
		///   used to retrieve updated parameters before saving a checkpoint.
		/// </remarks>
		public (TF_Output parameters, TF_Output accumulators) RetrieveTPUEmbeddingAdagradParameters (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingAdagradParameters", MakeName ("RetrieveTPUEmbeddingAdagradParameters", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var accumulators = new TF_Output (op, _idx++);
			return (parameters, accumulators);
		}

		/// <summary>
		///   Retrieve Adagrad embedding parameters with debug support.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingAdagradParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters: Parameter parameters updated by the Adagrad optimization algorithm.
		///   accumulators: Parameter accumulators updated by the Adagrad optimization algorithm.
		///   gradient_accumulators: Parameter gradient_accumulators updated by the Adagrad optimization algorithm.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   An op that retrieves optimization parameters from embedding to host
		///   memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
		///   the correct embedding table configuration. For example, this op is
		///   used to retrieve updated parameters before saving a checkpoint.
		/// </remarks>
		public (TF_Output parameters, TF_Output accumulators, TF_Output gradient_accumulators) RetrieveTPUEmbeddingAdagradParametersGradAccumDebug (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingAdagradParametersGradAccumDebug", MakeName ("RetrieveTPUEmbeddingAdagradParametersGradAccumDebug", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var accumulators = new TF_Output (op, _idx++);
			var gradient_accumulators = new TF_Output (op, _idx++);
			return (parameters, accumulators, gradient_accumulators);
		}

		/// <summary>
		///   Retrieve ADAM embedding parameters.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingADAMParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters: Parameter parameters updated by the ADAM optimization algorithm.
		///   momenta: Parameter momenta updated by the ADAM optimization algorithm.
		///   velocities: Parameter velocities updated by the ADAM optimization algorithm.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   An op that retrieves optimization parameters from embedding to host
		///   memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
		///   the correct embedding table configuration. For example, this op is
		///   used to retrieve updated parameters before saving a checkpoint.
		/// </remarks>
		public (TF_Output parameters, TF_Output momenta, TF_Output velocities) RetrieveTPUEmbeddingADAMParameters (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingADAMParameters", MakeName ("RetrieveTPUEmbeddingADAMParameters", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var momenta = new TF_Output (op, _idx++);
			var velocities = new TF_Output (op, _idx++);
			return (parameters, momenta, velocities);
		}

		/// <summary>
		///   Retrieve ADAM embedding parameters with debug support.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingADAMParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters: Parameter parameters updated by the ADAM optimization algorithm.
		///   momenta: Parameter momenta updated by the ADAM optimization algorithm.
		///   velocities: Parameter velocities updated by the ADAM optimization algorithm.
		///   gradient_accumulators: Parameter gradient_accumulators updated by the ADAM optimization algorithm.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   An op that retrieves optimization parameters from embedding to host
		///   memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
		///   the correct embedding table configuration. For example, this op is
		///   used to retrieve updated parameters before saving a checkpoint.
		/// </remarks>
		public (TF_Output parameters, TF_Output momenta, TF_Output velocities, TF_Output gradient_accumulators) RetrieveTPUEmbeddingADAMParametersGradAccumDebug (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingADAMParametersGradAccumDebug", MakeName ("RetrieveTPUEmbeddingADAMParametersGradAccumDebug", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var momenta = new TF_Output (op, _idx++);
			var velocities = new TF_Output (op, _idx++);
			var gradient_accumulators = new TF_Output (op, _idx++);
			return (parameters, momenta, velocities, gradient_accumulators);
		}

		/// <summary>
		///   Retrieve centered RMSProp embedding parameters.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingCenteredRMSPropParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters: Parameter parameters updated by the centered RMSProp optimization algorithm.
		///   ms: Parameter ms updated by the centered RMSProp optimization algorithm.
		///   mom: Parameter mom updated by the centered RMSProp optimization algorithm.
		///   mg: Parameter mg updated by the centered RMSProp optimization algorithm.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   An op that retrieves optimization parameters from embedding to host
		///   memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
		///   the correct embedding table configuration. For example, this op is
		///   used to retrieve updated parameters before saving a checkpoint.
		/// </remarks>
		public (TF_Output parameters, TF_Output ms, TF_Output mom, TF_Output mg) RetrieveTPUEmbeddingCenteredRMSPropParameters (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingCenteredRMSPropParameters", MakeName ("RetrieveTPUEmbeddingCenteredRMSPropParameters", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var ms = new TF_Output (op, _idx++);
			var mom = new TF_Output (op, _idx++);
			var mg = new TF_Output (op, _idx++);
			return (parameters, ms, mom, mg);
		}

		/// <summary>
		///   Retrieve FTRL embedding parameters.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingFTRLParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters: Parameter parameters updated by the FTRL optimization algorithm.
		///   accumulators: Parameter accumulators updated by the FTRL optimization algorithm.
		///   linears: Parameter linears updated by the FTRL optimization algorithm.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   An op that retrieves optimization parameters from embedding to host
		///   memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
		///   the correct embedding table configuration. For example, this op is
		///   used to retrieve updated parameters before saving a checkpoint.
		/// </remarks>
		public (TF_Output parameters, TF_Output accumulators, TF_Output linears) RetrieveTPUEmbeddingFTRLParameters (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingFTRLParameters", MakeName ("RetrieveTPUEmbeddingFTRLParameters", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var accumulators = new TF_Output (op, _idx++);
			var linears = new TF_Output (op, _idx++);
			return (parameters, accumulators, linears);
		}

		/// <summary>
		///   Retrieve FTRL embedding parameters with debug support.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingFTRLParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters: Parameter parameters updated by the FTRL optimization algorithm.
		///   accumulators: Parameter accumulators updated by the FTRL optimization algorithm.
		///   linears: Parameter linears updated by the FTRL optimization algorithm.
		///   gradient_accumulators: Parameter gradient_accumulators updated by the FTRL optimization algorithm.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   An op that retrieves optimization parameters from embedding to host
		///   memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
		///   the correct embedding table configuration. For example, this op is
		///   used to retrieve updated parameters before saving a checkpoint.
		/// </remarks>
		public (TF_Output parameters, TF_Output accumulators, TF_Output linears, TF_Output gradient_accumulators) RetrieveTPUEmbeddingFTRLParametersGradAccumDebug (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingFTRLParametersGradAccumDebug", MakeName ("RetrieveTPUEmbeddingFTRLParametersGradAccumDebug", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var accumulators = new TF_Output (op, _idx++);
			var linears = new TF_Output (op, _idx++);
			var gradient_accumulators = new TF_Output (op, _idx++);
			return (parameters, accumulators, linears, gradient_accumulators);
		}

		/// <summary>
		///   Retrieve MDL Adagrad Light embedding parameters.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingMDLAdagradLightParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters: Parameter parameters updated by the MDL Adagrad Light optimization algorithm.
		///   accumulators: Parameter accumulators updated by the MDL Adagrad Light optimization algorithm.
		///   weights: Parameter weights updated by the MDL Adagrad Light optimization algorithm.
		///   benefits: Parameter benefits updated by the MDL Adagrad Light optimization algorithm.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   An op that retrieves optimization parameters from embedding to host
		///   memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
		///   the correct embedding table configuration. For example, this op is
		///   used to retrieve updated parameters before saving a checkpoint.
		/// </remarks>
		public (TF_Output parameters, TF_Output accumulators, TF_Output weights, TF_Output benefits) RetrieveTPUEmbeddingMDLAdagradLightParameters (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingMDLAdagradLightParameters", MakeName ("RetrieveTPUEmbeddingMDLAdagradLightParameters", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var accumulators = new TF_Output (op, _idx++);
			var weights = new TF_Output (op, _idx++);
			var benefits = new TF_Output (op, _idx++);
			return (parameters, accumulators, weights, benefits);
		}

		/// <summary>
		///   Retrieve Momentum embedding parameters.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingMomentumParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters: Parameter parameters updated by the Momentum optimization algorithm.
		///   momenta: Parameter momenta updated by the Momentum optimization algorithm.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   An op that retrieves optimization parameters from embedding to host
		///   memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
		///   the correct embedding table configuration. For example, this op is
		///   used to retrieve updated parameters before saving a checkpoint.
		/// </remarks>
		public (TF_Output parameters, TF_Output momenta) RetrieveTPUEmbeddingMomentumParameters (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingMomentumParameters", MakeName ("RetrieveTPUEmbeddingMomentumParameters", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var momenta = new TF_Output (op, _idx++);
			return (parameters, momenta);
		}

		/// <summary>
		///   Retrieve Momentum embedding parameters with debug support.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingMomentumParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters: Parameter parameters updated by the Momentum optimization algorithm.
		///   momenta: Parameter momenta updated by the Momentum optimization algorithm.
		///   gradient_accumulators: Parameter gradient_accumulators updated by the Momentum optimization algorithm.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   An op that retrieves optimization parameters from embedding to host
		///   memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
		///   the correct embedding table configuration. For example, this op is
		///   used to retrieve updated parameters before saving a checkpoint.
		/// </remarks>
		public (TF_Output parameters, TF_Output momenta, TF_Output gradient_accumulators) RetrieveTPUEmbeddingMomentumParametersGradAccumDebug (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingMomentumParametersGradAccumDebug", MakeName ("RetrieveTPUEmbeddingMomentumParametersGradAccumDebug", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var momenta = new TF_Output (op, _idx++);
			var gradient_accumulators = new TF_Output (op, _idx++);
			return (parameters, momenta, gradient_accumulators);
		}

		/// <summary>
		///   Retrieve proximal Adagrad embedding parameters.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingProximalAdagradParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters: Parameter parameters updated by the proximal Adagrad optimization algorithm.
		///   accumulators: Parameter accumulators updated by the proximal Adagrad optimization algorithm.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   An op that retrieves optimization parameters from embedding to host
		///   memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
		///   the correct embedding table configuration. For example, this op is
		///   used to retrieve updated parameters before saving a checkpoint.
		/// </remarks>
		public (TF_Output parameters, TF_Output accumulators) RetrieveTPUEmbeddingProximalAdagradParameters (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingProximalAdagradParameters", MakeName ("RetrieveTPUEmbeddingProximalAdagradParameters", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var accumulators = new TF_Output (op, _idx++);
			return (parameters, accumulators);
		}

		/// <summary>
		///   Retrieve proximal Adagrad embedding parameters with debug support.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters: Parameter parameters updated by the proximal Adagrad optimization algorithm.
		///   accumulators: Parameter accumulators updated by the proximal Adagrad optimization algorithm.
		///   gradient_accumulators: Parameter gradient_accumulators updated by the proximal Adagrad optimization algorithm.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   An op that retrieves optimization parameters from embedding to host
		///   memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
		///   the correct embedding table configuration. For example, this op is
		///   used to retrieve updated parameters before saving a checkpoint.
		/// </remarks>
		public (TF_Output parameters, TF_Output accumulators, TF_Output gradient_accumulators) RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug", MakeName ("RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var accumulators = new TF_Output (op, _idx++);
			var gradient_accumulators = new TF_Output (op, _idx++);
			return (parameters, accumulators, gradient_accumulators);
		}

		/// <summary>
		///   Retrieve RMSProp embedding parameters.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingRMSPropParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters: Parameter parameters updated by the RMSProp optimization algorithm.
		///   ms: Parameter ms updated by the RMSProp optimization algorithm.
		///   mom: Parameter mom updated by the RMSProp optimization algorithm.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   An op that retrieves optimization parameters from embedding to host
		///   memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
		///   the correct embedding table configuration. For example, this op is
		///   used to retrieve updated parameters before saving a checkpoint.
		/// </remarks>
		public (TF_Output parameters, TF_Output ms, TF_Output mom) RetrieveTPUEmbeddingRMSPropParameters (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingRMSPropParameters", MakeName ("RetrieveTPUEmbeddingRMSPropParameters", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var ms = new TF_Output (op, _idx++);
			var mom = new TF_Output (op, _idx++);
			return (parameters, ms, mom);
		}

		/// <summary>
		///   Retrieve RMSProp embedding parameters with debug support.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   parameters: Parameter parameters updated by the RMSProp optimization algorithm.
		///   ms: Parameter ms updated by the RMSProp optimization algorithm.
		///   mom: Parameter mom updated by the RMSProp optimization algorithm.
		///   gradient_accumulators: Parameter gradient_accumulators updated by the RMSProp optimization algorithm.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   An op that retrieves optimization parameters from embedding to host
		///   memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
		///   the correct embedding table configuration. For example, this op is
		///   used to retrieve updated parameters before saving a checkpoint.
		/// </remarks>
		public (TF_Output parameters, TF_Output ms, TF_Output mom, TF_Output gradient_accumulators) RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug", MakeName ("RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			var ms = new TF_Output (op, _idx++);
			var mom = new TF_Output (op, _idx++);
			var gradient_accumulators = new TF_Output (op, _idx++);
			return (parameters, ms, mom, gradient_accumulators);
		}

		/// <summary>
		///   Retrieve SGD embedding parameters.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingStochasticGradientDescentParameters'.
		/// </param>
		/// <param name="table_id">
		///   Optional argument
		/// </param>
		/// <param name="table_name">
		///   Optional argument
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="shard_id">
		/// </param>
		/// <returns>
		///   Parameter parameters updated by the stochastic gradient descent optimization algorithm.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   An op that retrieves optimization parameters from embedding to host
		///   memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
		///   the correct embedding table configuration. For example, this op is
		///   used to retrieve updated parameters before saving a checkpoint.
		/// </remarks>
		public TF_Output RetrieveTPUEmbeddingStochasticGradientDescentParameters (long num_shards, long shard_id, long? table_id = null, string table_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RetrieveTPUEmbeddingStochasticGradientDescentParameters", MakeName ("RetrieveTPUEmbeddingStochasticGradientDescentParameters", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_shards", num_shards);
			c_api.TF_SetAttrInt (desc, "shard_id", shard_id);
			if (table_id.HasValue)
				c_api.TF_SetAttrInt (desc, "table_id", table_id.Value);
			
			if (table_name != null)
				c_api.TF_SetAttrString (desc, "table_name", table_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var parameters = new TF_Output (op, _idx++);
			return parameters;
		}

		/// <summary>
		///   Reverses specific dimensions of a tensor.
		/// </summary>
		/// <param name="tensor">
		///   Up to 8-D.
		/// </param>
		/// <param name="dims">
		///   1-D. The dimensions to reverse.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Reverse'.
		/// </param>
		/// <returns>
		///   The same shape as <c>tensor</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given a <c>tensor</c>, and a <c>bool</c> tensor <c>dims</c> representing the dimensions
		///   of <c>tensor</c>, this operation reverses each dimension i of <c>tensor</c> where
		///   <c>dims[i]</c> is <c>True</c>.
		///   
		///   <c>tensor</c> can have up to 8 dimensions. The number of dimensions
		///   of <c>tensor</c> must equal the number of elements in <c>dims</c>. In other words:
		///   
		///   <c>rank(tensor) = size(dims)</c>
		///   
		///   For example:
		///   
		///    <code>
		///   # tensor 't' is [[[[ 0,  1,  2,  3],
		///   #                  [ 4,  5,  6,  7],
		///   #                  [ 8,  9, 10, 11]],
		///   #                 [[12, 13, 14, 15],
		///   #                  [16, 17, 18, 19],
		///   #                  [20, 21, 22, 23]]]]
		///   # tensor 't' shape is [1, 2, 3, 4]
		///   
		///   # 'dims' is [False, False, False, True]
		///   reverse(t, dims) ==&amp;gt; [[[[ 3,  2,  1,  0],
		///   [ 7,  6,  5,  4],
		///   [ 11, 10, 9, 8]],
		///   [[15, 14, 13, 12],
		///   [19, 18, 17, 16],
		///   [23, 22, 21, 20]]]]
		///   
		///   # 'dims' is [False, True, False, False]
		///   reverse(t, dims) ==&amp;gt; [[[[12, 13, 14, 15],
		///   [16, 17, 18, 19],
		///   [20, 21, 22, 23]
		///   [[ 0,  1,  2,  3],
		///   [ 4,  5,  6,  7],
		///   [ 8,  9, 10, 11]]]]
		///   
		///   # 'dims' is [False, False, True, False]
		///   reverse(t, dims) ==&amp;gt; [[[[8, 9, 10, 11],
		///   [4, 5, 6, 7],
		///   [0, 1, 2, 3]]
		///   [[20, 21, 22, 23],
		///   [16, 17, 18, 19],
		///   [12, 13, 14, 15]]]]
		///    </code>
		/// </remarks>
		public TF_Output Reverse (TF_Output tensor, TF_Output dims, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Reverse", MakeName ("Reverse", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, dims);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Reverses variable length slices.
		/// </summary>
		/// <param name="input">
		///   The input to reverse.
		/// </param>
		/// <param name="seq_lengths">
		///   1-D with length <c>input.dims(batch_dim)</c> and
		///   <c>max(seq_lengths) &amp;lt;= input.dims(seq_dim)</c>
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReverseSequence'.
		/// </param>
		/// <param name="batch_dim">
		///   Optional argument
		///   The dimension along which reversal is performed.
		/// </param>
		/// <param name="seq_dim">
		///   The dimension which is partially reversed.
		/// </param>
		/// <returns>
		///   The partially reversed input. It has the same shape as <c>input</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op first slices <c>input</c> along the dimension <c>batch_dim</c>, and for each
		///   slice <c>i</c>, reverses the first <c>seq_lengths[i]</c> elements along
		///   the dimension <c>seq_dim</c>.
		///   
		///   The elements of <c>seq_lengths</c> must obey <c>seq_lengths[i] &amp;lt;= input.dims[seq_dim]</c>,
		///   and <c>seq_lengths</c> must be a vector of length <c>input.dims[batch_dim]</c>.
		///   
		///   The output slice <c>i</c> along dimension <c>batch_dim</c> is then given by input
		///   slice <c>i</c>, with the first <c>seq_lengths[i]</c> slices along dimension
		///   <c>seq_dim</c> reversed.
		///   
		///   For example:
		///   
		///    <code>
		///   # Given this:
		///   batch_dim = 0
		///   seq_dim = 1
		///   input.dims = (4, 8, ...)
		///   seq_lengths = [7, 2, 3, 5]
		///   
		///   # then slices of input are reversed on seq_dim, but only up to seq_lengths:
		///   output[0, 0:7, :, ...] = input[0, 7:0:-1, :, ...]
		///   output[1, 0:2, :, ...] = input[1, 2:0:-1, :, ...]
		///   output[2, 0:3, :, ...] = input[2, 3:0:-1, :, ...]
		///   output[3, 0:5, :, ...] = input[3, 5:0:-1, :, ...]
		///   
		///   # while entries past seq_lens are copied through:
		///   output[0, 7:, :, ...] = input[0, 7:, :, ...]
		///   output[1, 2:, :, ...] = input[1, 2:, :, ...]
		///   output[2, 3:, :, ...] = input[2, 3:, :, ...]
		///   output[3, 2:, :, ...] = input[3, 2:, :, ...]
		///    </code>
		///   
		///   In contrast, if:
		///   
		///    <code>
		///   # Given this:
		///   batch_dim = 2
		///   seq_dim = 0
		///   input.dims = (8, ?, 4, ...)
		///   seq_lengths = [7, 2, 3, 5]
		///   
		///   # then slices of input are reversed on seq_dim, but only up to seq_lengths:
		///   output[0:7, :, 0, :, ...] = input[7:0:-1, :, 0, :, ...]
		///   output[0:2, :, 1, :, ...] = input[2:0:-1, :, 1, :, ...]
		///   output[0:3, :, 2, :, ...] = input[3:0:-1, :, 2, :, ...]
		///   output[0:5, :, 3, :, ...] = input[5:0:-1, :, 3, :, ...]
		///   
		///   # while entries past seq_lens are copied through:
		///   output[7:, :, 0, :, ...] = input[7:, :, 0, :, ...]
		///   output[2:, :, 1, :, ...] = input[2:, :, 1, :, ...]
		///   output[3:, :, 2, :, ...] = input[3:, :, 2, :, ...]
		///   output[2:, :, 3, :, ...] = input[2:, :, 3, :, ...]
		///    </code>
		/// </remarks>
		public TF_Output ReverseSequence (TF_Output input, TF_Output seq_lengths, long seq_dim, long? batch_dim = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReverseSequence", MakeName ("ReverseSequence", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, seq_lengths);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "seq_dim", seq_dim);
			if (batch_dim.HasValue)
				c_api.TF_SetAttrInt (desc, "batch_dim", batch_dim.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Reverses specific dimensions of a tensor.
		/// </summary>
		/// <param name="tensor">
		///   Up to 8-D.
		/// </param>
		/// <param name="axis">
		///   1-D. The indices of the dimensions to reverse. Must be in the range
		///   <c>[-rank(tensor), rank(tensor))</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ReverseV2'.
		/// </param>
		/// <returns>
		///   The same shape as <c>tensor</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   NOTE <c>tf.reverse</c> has now changed behavior in preparation for 1.0.
		///   <c>tf.reverse_v2</c> is currently an alias that will be deprecated before TF 1.0.
		///   
		///   Given a <c>tensor</c>, and a <c>int32</c> tensor <c>axis</c> representing the set of
		///   dimensions of <c>tensor</c> to reverse. This operation reverses each dimension
		///   <c>i</c> for which there exists <c>j</c> s.t. <c>axis[j] == i</c>.
		///   
		///   <c>tensor</c> can have up to 8 dimensions. The number of dimensions specified
		///   in <c>axis</c> may be 0 or more entries. If an index is specified more than
		///   once, a InvalidArgument error is raised.
		///   
		///   For example:
		///   
		///    <code>
		///   # tensor 't' is [[[[ 0,  1,  2,  3],
		///   #                  [ 4,  5,  6,  7],
		///   #                  [ 8,  9, 10, 11]],
		///   #                 [[12, 13, 14, 15],
		///   #                  [16, 17, 18, 19],
		///   #                  [20, 21, 22, 23]]]]
		///   # tensor 't' shape is [1, 2, 3, 4]
		///   
		///   # 'dims' is [3] or 'dims' is [-1]
		///   reverse(t, dims) ==&amp;gt; [[[[ 3,  2,  1,  0],
		///   [ 7,  6,  5,  4],
		///   [ 11, 10, 9, 8]],
		///   [[15, 14, 13, 12],
		///   [19, 18, 17, 16],
		///   [23, 22, 21, 20]]]]
		///   
		///   # 'dims' is '[1]' (or 'dims' is '[-3]')
		///   reverse(t, dims) ==&amp;gt; [[[[12, 13, 14, 15],
		///   [16, 17, 18, 19],
		///   [20, 21, 22, 23]
		///   [[ 0,  1,  2,  3],
		///   [ 4,  5,  6,  7],
		///   [ 8,  9, 10, 11]]]]
		///   
		///   # 'dims' is '[2]' (or 'dims' is '[-2]')
		///   reverse(t, dims) ==&amp;gt; [[[[8, 9, 10, 11],
		///   [4, 5, 6, 7],
		///   [0, 1, 2, 3]]
		///   [[20, 21, 22, 23],
		///   [16, 17, 18, 19],
		///   [12, 13, 14, 15]]]]
		///    </code>
		/// </remarks>
		public TF_Output ReverseV2 (TF_Output tensor, TF_Output axis, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ReverseV2", MakeName ("ReverseV2", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, axis);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Real-valued fast Fourier transform.
		/// </summary>
		/// <param name="input">
		///   A float32 tensor.
		/// </param>
		/// <param name="fft_length">
		///   An int32 tensor of shape [1]. The FFT length.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RFFT'.
		/// </param>
		/// <returns>
		///   A complex64 tensor of the same rank as <c>input</c>. The inner-most
		///   dimension of <c>input</c> is replaced with the <c>fft_length / 2 + 1</c> unique
		///   frequency components of its 1D Fourier transform.
		///   
		///   @compatibility(numpy)
		///   Equivalent to np.fft.rfft
		///   @end_compatibility
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Computes the 1-dimensional discrete Fourier transform of a real-valued signal
		///   over the inner-most dimension of <c>input</c>.
		///   
		///   Since the DFT of a real signal is Hermitian-symmetric, <c>RFFT</c> only returns the
		///   <c>fft_length / 2 + 1</c> unique components of the FFT: the zero-frequency term,
		///   followed by the <c>fft_length / 2</c> positive-frequency terms.
		///   
		///   Along the axis <c>RFFT</c> is computed on, if <c>fft_length</c> is smaller than the
		///   corresponding dimension of <c>input</c>, the dimension is cropped. If it is larger,
		///   the dimension is padded with zeros.
		/// </remarks>
		public TF_Output RFFT (TF_Output input, TF_Output fft_length, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RFFT", MakeName ("RFFT", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, fft_length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   2D real-valued fast Fourier transform.
		/// </summary>
		/// <param name="input">
		///   A float32 tensor.
		/// </param>
		/// <param name="fft_length">
		///   An int32 tensor of shape [2]. The FFT length for each dimension.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RFFT2D'.
		/// </param>
		/// <returns>
		///   A complex64 tensor of the same rank as <c>input</c>. The inner-most 2
		///   dimensions of <c>input</c> are replaced with their 2D Fourier transform. The
		///   inner-most dimension contains <c>fft_length / 2 + 1</c> unique frequency
		///   components.
		///   
		///   @compatibility(numpy)
		///   Equivalent to np.fft.rfft2
		///   @end_compatibility
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Computes the 2-dimensional discrete Fourier transform of a real-valued signal
		///   over the inner-most 2 dimensions of <c>input</c>.
		///   
		///   Since the DFT of a real signal is Hermitian-symmetric, <c>RFFT2D</c> only returns the
		///   <c>fft_length / 2 + 1</c> unique components of the FFT for the inner-most dimension
		///   of <c>output</c>: the zero-frequency term, followed by the <c>fft_length / 2</c>
		///   positive-frequency terms.
		///   
		///   Along each axis <c>RFFT2D</c> is computed on, if <c>fft_length</c> is smaller than the
		///   corresponding dimension of <c>input</c>, the dimension is cropped. If it is larger,
		///   the dimension is padded with zeros.
		/// </remarks>
		public TF_Output RFFT2D (TF_Output input, TF_Output fft_length, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RFFT2D", MakeName ("RFFT2D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, fft_length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   3D real-valued fast Fourier transform.
		/// </summary>
		/// <param name="input">
		///   A float32 tensor.
		/// </param>
		/// <param name="fft_length">
		///   An int32 tensor of shape [3]. The FFT length for each dimension.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RFFT3D'.
		/// </param>
		/// <returns>
		///   A complex64 tensor of the same rank as <c>input</c>. The inner-most 3
		///   dimensions of <c>input</c> are replaced with the their 3D Fourier transform. The
		///   inner-most dimension contains <c>fft_length / 2 + 1</c> unique frequency
		///   components.
		///   
		///   @compatibility(numpy)
		///   Equivalent to np.fft.rfftn with 3 dimensions.
		///   @end_compatibility
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Computes the 3-dimensional discrete Fourier transform of a real-valued signal
		///   over the inner-most 3 dimensions of <c>input</c>.
		///   
		///   Since the DFT of a real signal is Hermitian-symmetric, <c>RFFT3D</c> only returns the
		///   <c>fft_length / 2 + 1</c> unique components of the FFT for the inner-most dimension
		///   of <c>output</c>: the zero-frequency term, followed by the <c>fft_length / 2</c>
		///   positive-frequency terms.
		///   
		///   Along each axis <c>RFFT3D</c> is computed on, if <c>fft_length</c> is smaller than the
		///   corresponding dimension of <c>input</c>, the dimension is cropped. If it is larger,
		///   the dimension is padded with zeros.
		/// </remarks>
		public TF_Output RFFT3D (TF_Output input, TF_Output fft_length, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RFFT3D", MakeName ("RFFT3D", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, fft_length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Converts one or more images from RGB to HSV.
		/// </summary>
		/// <param name="images">
		///   1-D or higher rank. RGB data to convert. Last dimension must be size 3.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RGBToHSV'.
		/// </param>
		/// <returns>
		///   <c>images</c> converted to HSV.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Outputs a tensor of the same shape as the <c>images</c> tensor, containing the HSV
		///   value of the pixels. The output is only well defined if the value in <c>images</c>
		///   are in <c>[0,1]</c>.
		///   
		///   <c>output[..., 0]</c> contains hue, <c>output[..., 1]</c> contains saturation, and
		///   <c>output[..., 2]</c> contains value. All HSV values are in <c>[0,1]</c>. A hue of 0
		///   corresponds to pure red, hue 1/3 is pure green, and 2/3 is pure blue.
		/// </remarks>
		public TF_Output RGBToHSV (TF_Output images, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RGBToHSV", MakeName ("RGBToHSV", operName));
			c_api.TF_AddInput(desc, images);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Elementwise computes the bitwise right-shift of <c>x</c> and <c>y</c>.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RightShift'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Performs a logical shift for unsigned integer types, and an arithmetic shift
		///   for signed integer types.
		///   
		///   If <c>y</c> is negative, or greater than or equal to than the width of <c>x</c> in bits
		///   the result is implementation defined.
		///   
		///   Example:
		///   
		///    <code>
		///   import tensorflow as tf
		///   from tensorflow.python.ops import bitwise_ops
		///   import numpy as np
		///   dtype_list = [tf.int8, tf.int16, tf.int32, tf.int64]
		///   
		///   for dtype in dtype_list:
		///   lhs = tf.constant([-1, -5, -3, -14], dtype=dtype)
		///   rhs = tf.constant([5, 0, 7, 11], dtype=dtype)
		///   
		///   right_shift_result = bitwise_ops.right_shift(lhs, rhs)
		///   
		///   print(right_shift_result)
		///   
		///   # This will print:
		///   # tf.Tensor([-1 -5 -1 -1], shape=(4,), dtype=int8)
		///   # tf.Tensor([-1 -5 -1 -1], shape=(4,), dtype=int16)
		///   # tf.Tensor([-1 -5 -1 -1], shape=(4,), dtype=int32)
		///   # tf.Tensor([-1 -5 -1 -1], shape=(4,), dtype=int64)
		///   
		///   lhs = np.array([-2, 64, 101, 32], dtype=np.int8)
		///   rhs = np.array([-1, -5, -3, -14], dtype=np.int8)
		///   bitwise_ops.right_shift(lhs, rhs)
		///   # &amp;lt;tf.Tensor: id=151, shape=(4,), dtype=int8, numpy=array([ -2,  64, 101,  32], dtype=int8)&amp;gt;
		///    </code>
		///   
		/// </remarks>
		public TF_Output RightShift (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RightShift", MakeName ("RightShift", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Returns element-wise integer closest to x.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Rint'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   If the result is midway between two representable values,
		///   the even representable is chosen.
		///   For example:
		///   
		///    <code>
		///   rint(-1.5) ==&amp;gt; -2.0
		///   rint(0.5000001) ==&amp;gt; 1.0
		///   rint([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) ==&amp;gt; [-2., -2., -0., 0., 2., 2., 2.]
		///    </code>
		/// </remarks>
		public TF_Output Rint (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Rint", MakeName ("Rint", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Advance the counter of a counter-based RNG.
		/// </summary>
		/// <param name="resource">
		///   The handle of the resource variable that stores the state of the RNG.
		/// </param>
		/// <param name="algorithm">
		///   The RNG algorithm.
		/// </param>
		/// <param name="delta">
		///   The amount of advancement.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RngSkip'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   The state of the RNG after
		///   <c>rng_skip(n)</c> will be the same as that after <c>stateful_uniform([n])</c>
		///   (or any other distribution). The actual increment added to the
		///   counter is an unspecified implementation detail.
		/// </remarks>
		public TF_Operation RngSkip (TF_Output resource, TF_Output algorithm, TF_Output delta, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RngSkip", MakeName ("RngSkip", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, algorithm);
			c_api.TF_AddInput(desc, delta);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Rolls the elements of a tensor along an axis.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="shift">
		///   Dimension must be 0-D or 1-D. <c>shift[i]</c> specifies the number of places by which
		///   elements are shifted positively (towards larger indices) along the dimension
		///   specified by <c>axis[i]</c>. Negative shifts will roll the elements in the opposite
		///   direction.
		/// </param>
		/// <param name="axis">
		///   Dimension must be 0-D or 1-D. <c>axis[i]</c> specifies the dimension that the shift
		///   <c>shift[i]</c> should occur. If the same axis is referenced more than once, the
		///   total shift for that axis will be the sum of all the shifts that belong to that
		///   axis.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Roll'.
		/// </param>
		/// <returns>
		///   Has the same shape and size as the input. The elements are shifted
		///   positively (towards larger indices) by the offsets of <c>shift</c> along the
		///   dimensions of <c>axis</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The elements are shifted positively (towards larger indices) by the offset of
		///   <c>shift</c> along the dimension of <c>axis</c>. Negative <c>shift</c> values will shift
		///   elements in the opposite direction. Elements that roll passed the last position
		///   will wrap around to the first and vice versa. Multiple shifts along multiple
		///   axes may be specified.
		///   
		///   For example:
		///   
		///    <code>
		///   # 't' is [0, 1, 2, 3, 4]
		///   roll(t, shift=2, axis=0) ==&amp;gt; [3, 4, 0, 1, 2]
		///   
		///   # shifting along multiple dimensions
		///   # 't' is [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]
		///   roll(t, shift=[1, -2], axis=[0, 1]) ==&amp;gt; [[7, 8, 9, 5, 6], [2, 3, 4, 0, 1]]
		///   
		///   # shifting along the same axis multiple times
		///   # 't' is [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]
		///   roll(t, shift=[2, -3], axis=[1, 1]) ==&amp;gt; [[1, 2, 3, 4, 0], [6, 7, 8, 9, 5]]
		///    </code>
		/// </remarks>
		public TF_Output Roll (TF_Output input, TF_Output shift, TF_Output axis, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Roll", MakeName ("Roll", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, shift);
			c_api.TF_AddInput(desc, axis);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Rounds the values of a tensor to the nearest integer, element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Round'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Rounds half to even.  Also known as bankers rounding. If you want to round
		///   according to the current system rounding mode use std::cint.
		/// </remarks>
		public TF_Output Round (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Round", MakeName ("Round", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Perform batches of RPC requests.
		/// </summary>
		/// <param name="address">
		///   <c>0-D</c> or <c>1-D</c>.  The address (i.e. host_name:port) of the RPC server.
		///   If this tensor has more than 1 element, then multiple parallel rpc requests
		///   are sent.  This argument broadcasts with <c>method</c> and <c>request</c>.
		/// </param>
		/// <param name="method">
		///   <c>0-D</c> or <c>1-D</c>.  The method address on the RPC server.
		///   If this tensor has more than 1 element, then multiple parallel rpc requests
		///   are sent.  This argument broadcasts with <c>address</c> and <c>request</c>.
		/// </param>
		/// <param name="request">
		///   <c>0-D</c> or <c>1-D</c>.  Serialized proto strings: the rpc request argument.
		///   If this tensor has more than 1 element, then multiple parallel rpc requests
		///   are sent.  This argument broadcasts with <c>address</c> and <c>method</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Rpc'.
		/// </param>
		/// <param name="protocol">
		///   Optional argument
		///   RPC protocol to use.  Empty string means use the default protocol.
		///   Options include 'grpc'.
		/// </param>
		/// <param name="fail_fast">
		///   Optional argument
		///   <c>boolean</c>. If <c>true</c> (default), then failures to connect
		///   (i.e., the server does not immediately respond) cause an RPC failure.
		/// </param>
		/// <param name="timeout_in_ms">
		///   Optional argument
		///   <c>int</c>. If <c>0</c> (default), then the kernel will run the RPC
		///   request and only time out if the RPC deadline passes or the session times out.
		///   If this value is greater than <c>0</c>, then the op will raise an exception if
		///   the RPC takes longer than <c>timeout_in_ms</c>.
		/// </param>
		/// <returns>
		///   Same shape as <c>request</c>. Serialized proto strings: the rpc responses.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op asynchronously performs either a single RPC request, or a batch
		///   of requests.  RPC requests are defined by three main parameters:
		///   
		///   - <c>address</c> (the host+port or BNS address of the request)
		///   - <c>method</c> (the RPC method name for the request)
		///   - <c>request</c> (the serialized proto string, or vector of strings,
		///   of the RPC request argument).
		///   
		///   For example, if you have an RPC service running on port localhost:2345,
		///   and its interface is configured with the following proto declaration:
		///   
		///    <code>
		///   service MyService {
		///   rpc MyMethod(MyRequestProto) returns (MyResponseProto) {
		///   }
		///   };
		///    </code>
		///   
		///   then call this op with arguments:
		///   
		///    <code>
		///   address = "localhost:2345"
		///   method = "MyService/MyMethod"
		///    </code>
		///   
		///   The <c>request</c> tensor is a string tensor representing serialized <c>MyRequestProto</c>
		///   strings; and the output string tensor <c>response</c> will have the same shape
		///   and contain (upon successful completion) corresponding serialized
		///   <c>MyResponseProto</c> strings.
		///   
		///   For example, to send a single, empty, <c>MyRequestProto</c>, call
		///   this op with <c>request = ""</c>.  To send 5 **parallel** empty requests,
		///   call this op with <c>request = ["", "", "", "", ""]</c>.
		///   
		///   More generally, one can create a batch of <c>MyRequestProto</c> serialized protos
		///   from regular batched tensors using the <c>encode_proto</c> op, and convert
		///   the response <c>MyResponseProto</c> serialized protos to batched tensors
		///   using the <c>decode_proto</c> op.
		///   
		///   **NOTE** Working with serialized proto strings is faster than instantiating
		///   actual proto objects in memory, so no performance degradation is expected
		///   compared to writing custom kernels for this workflow.
		///   
		///   If the connection fails or the remote worker returns an error
		///   status, the op reraises this exception locally.
		///   
		///   See the <c>TryRpc</c> op if you prefer to handle RPC failures manually in the graph.
		/// </remarks>
		public TF_Output Rpc (TF_Output address, TF_Output method, TF_Output request, string protocol = null, bool? fail_fast = null, long? timeout_in_ms = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Rpc", MakeName ("Rpc", operName));
			c_api.TF_AddInput(desc, address);
			c_api.TF_AddInput(desc, method);
			c_api.TF_AddInput(desc, request);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (protocol != null)
				c_api.TF_SetAttrString (desc, "protocol", protocol);
			
			if (fail_fast.HasValue)
				c_api.TF_SetAttrBool (desc, "fail_fast", Convert.ToByte(fail_fast.Value));
			
			if (timeout_in_ms.HasValue)
				c_api.TF_SetAttrInt (desc, "timeout_in_ms", timeout_in_ms.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var response = new TF_Output (op, _idx++);
			return response;
		}

		/// <summary>
		///   Computes reciprocal of square root of x element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Rsqrt'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   I.e., \\(y = 1 / \sqrt{x}\\).
		/// </remarks>
		public TF_Output Rsqrt (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Rsqrt", MakeName ("Rsqrt", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes the gradient for the rsqrt of <c>x</c> wrt its input.
		/// </summary>
		/// <param name="y">
		/// </param>
		/// <param name="dy">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'RsqrtGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Specifically, <c>grad = dy * -0.5 * y^3</c>, where <c>y = rsqrt(x)</c>, and <c>dy</c>
		///   is the corresponding input gradient.
		/// </remarks>
		public TF_Output RsqrtGrad (TF_Output y, TF_Output dy, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "RsqrtGrad", MakeName ("RsqrtGrad", operName));
			c_api.TF_AddInput(desc, y);
			c_api.TF_AddInput(desc, dy);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Generate a single randomly distorted bounding box for an image.
		/// </summary>
		/// <param name="image_size">
		///   1-D, containing <c>[height, width, channels]</c>.
		/// </param>
		/// <param name="bounding_boxes">
		///   3-D with shape <c>[batch, N, 4]</c> describing the N bounding boxes
		///   associated with the image.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SampleDistortedBoundingBox'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either <c>seed</c> or <c>seed2</c> are set to non-zero, the random number
		///   generator is seeded by the given <c>seed</c>.  Otherwise, it is seeded by a random
		///   seed.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   A second seed to avoid seed collision.
		/// </param>
		/// <param name="min_object_covered">
		///   Optional argument
		///   The cropped area of the image must contain at least this
		///   fraction of any bounding box supplied. The value of this parameter should be
		///   non-negative. In the case of 0, the cropped area does not need to overlap
		///   any of the bounding boxes supplied.
		/// </param>
		/// <param name="aspect_ratio_range">
		///   Optional argument
		///   The cropped area of the image must have an aspect ratio =
		///   width / height within this range.
		/// </param>
		/// <param name="area_range">
		///   Optional argument
		///   The cropped area of the image must contain a fraction of the
		///   supplied image within this range.
		/// </param>
		/// <param name="max_attempts">
		///   Optional argument
		///   Number of attempts at generating a cropped region of the image
		///   of the specified constraints. After <c>max_attempts</c> failures, return the entire
		///   image.
		/// </param>
		/// <param name="use_image_if_no_bounding_boxes">
		///   Optional argument
		///   Controls behavior if no bounding boxes supplied.
		///   If true, assume an implicit bounding box covering the whole input. If false,
		///   raise an error.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   begin: 1-D, containing <c>[offset_height, offset_width, 0]</c>. Provide as input to
		///   <c>tf.slice</c>.
		///   size: 1-D, containing <c>[target_height, target_width, -1]</c>. Provide as input to
		///   <c>tf.slice</c>.
		///   bboxes: 3-D with shape <c>[1, 1, 4]</c> containing the distorted bounding box.
		///   Provide as input to <c>tf.image.draw_bounding_boxes</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Bounding box annotations are often supplied in addition to ground-truth labels
		///   in image recognition or object localization tasks. A common technique for
		///   training such a system is to randomly distort an image while preserving
		///   its content, i.e. *data augmentation*. This Op outputs a randomly distorted
		///   localization of an object, i.e. bounding box, given an <c>image_size</c>,
		///   <c>bounding_boxes</c> and a series of constraints.
		///   
		///   The output of this Op is a single bounding box that may be used to crop the
		///   original image. The output is returned as 3 tensors: <c>begin</c>, <c>size</c> and
		///   <c>bboxes</c>. The first 2 tensors can be fed directly into <c>tf.slice</c> to crop the
		///   image. The latter may be supplied to <c>tf.image.draw_bounding_boxes</c> to visualize
		///   what the bounding box looks like.
		///   
		///   Bounding boxes are supplied and returned as <c>[y_min, x_min, y_max, x_max]</c>. The
		///   bounding box coordinates are floats in <c>[0.0, 1.0]</c> relative to the width and
		///   height of the underlying image.
		///   
		///   For example,
		///   
		///    <code>
		///   # Generate a single distorted bounding box.
		///   begin, size, bbox_for_draw = tf.image.sample_distorted_bounding_box(
		///   tf.shape(image),
		///   bounding_boxes=bounding_boxes)
		///   
		///   # Draw the bounding box in an image summary.
		///   image_with_box = tf.image.draw_bounding_boxes(tf.expand_dims(image, 0),
		///   bbox_for_draw)
		///   tf.summary.image('images_with_box', image_with_box)
		///   
		///   # Employ the bounding box to distort the image.
		///   distorted_image = tf.slice(image, begin, size)
		///    </code>
		///   
		///   Note that if no bounding box information is available, setting
		///   <c>use_image_if_no_bounding_boxes = true</c> will assume there is a single implicit
		///   bounding box covering the whole image. If <c>use_image_if_no_bounding_boxes</c> is
		///   false and no bounding boxes are supplied, an error is raised.
		/// </remarks>
		public (TF_Output begin, TF_Output size, TF_Output bboxes) SampleDistortedBoundingBox (TF_Output image_size, TF_Output bounding_boxes, long? seed = null, long? seed2 = null, float? min_object_covered = null, float[] aspect_ratio_range = null, float[] area_range = null, long? max_attempts = null, bool? use_image_if_no_bounding_boxes = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SampleDistortedBoundingBox", MakeName ("SampleDistortedBoundingBox", operName));
			c_api.TF_AddInput(desc, image_size);
			c_api.TF_AddInput(desc, bounding_boxes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (min_object_covered.HasValue)
				c_api.TF_SetAttrFloat (desc, "min_object_covered", min_object_covered.Value);
			
			if (aspect_ratio_range != null)
				c_api.TF_SetAttrFloatList (desc, "aspect_ratio_range", ref aspect_ratio_range[0], aspect_ratio_range.Length);
			
			if (area_range != null)
				c_api.TF_SetAttrFloatList (desc, "area_range", ref area_range[0], area_range.Length);
			
			if (max_attempts.HasValue)
				c_api.TF_SetAttrInt (desc, "max_attempts", max_attempts.Value);
			
			if (use_image_if_no_bounding_boxes.HasValue)
				c_api.TF_SetAttrBool (desc, "use_image_if_no_bounding_boxes", Convert.ToByte(use_image_if_no_bounding_boxes.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var begin = new TF_Output (op, _idx++);
			var size = new TF_Output (op, _idx++);
			var bboxes = new TF_Output (op, _idx++);
			return (begin, size, bboxes);
		}

		/// <summary>
		///   Generate a single randomly distorted bounding box for an image.
		/// </summary>
		/// <param name="image_size">
		///   1-D, containing <c>[height, width, channels]</c>.
		/// </param>
		/// <param name="bounding_boxes">
		///   3-D with shape <c>[batch, N, 4]</c> describing the N bounding boxes
		///   associated with the image.
		/// </param>
		/// <param name="min_object_covered">
		///   The cropped area of the image must contain at least this
		///   fraction of any bounding box supplied. The value of this parameter should be
		///   non-negative. In the case of 0, the cropped area does not need to overlap
		///   any of the bounding boxes supplied.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SampleDistortedBoundingBoxV2'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either <c>seed</c> or <c>seed2</c> are set to non-zero, the random number
		///   generator is seeded by the given <c>seed</c>.  Otherwise, it is seeded by a random
		///   seed.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   A second seed to avoid seed collision.
		/// </param>
		/// <param name="aspect_ratio_range">
		///   Optional argument
		///   The cropped area of the image must have an aspect ratio =
		///   width / height within this range.
		/// </param>
		/// <param name="area_range">
		///   Optional argument
		///   The cropped area of the image must contain a fraction of the
		///   supplied image within this range.
		/// </param>
		/// <param name="max_attempts">
		///   Optional argument
		///   Number of attempts at generating a cropped region of the image
		///   of the specified constraints. After <c>max_attempts</c> failures, return the entire
		///   image.
		/// </param>
		/// <param name="use_image_if_no_bounding_boxes">
		///   Optional argument
		///   Controls behavior if no bounding boxes supplied.
		///   If true, assume an implicit bounding box covering the whole input. If false,
		///   raise an error.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   begin: 1-D, containing <c>[offset_height, offset_width, 0]</c>. Provide as input to
		///   <c>tf.slice</c>.
		///   size: 1-D, containing <c>[target_height, target_width, -1]</c>. Provide as input to
		///   <c>tf.slice</c>.
		///   bboxes: 3-D with shape <c>[1, 1, 4]</c> containing the distorted bounding box.
		///   Provide as input to <c>tf.image.draw_bounding_boxes</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Bounding box annotations are often supplied in addition to ground-truth labels
		///   in image recognition or object localization tasks. A common technique for
		///   training such a system is to randomly distort an image while preserving
		///   its content, i.e. *data augmentation*. This Op outputs a randomly distorted
		///   localization of an object, i.e. bounding box, given an <c>image_size</c>,
		///   <c>bounding_boxes</c> and a series of constraints.
		///   
		///   The output of this Op is a single bounding box that may be used to crop the
		///   original image. The output is returned as 3 tensors: <c>begin</c>, <c>size</c> and
		///   <c>bboxes</c>. The first 2 tensors can be fed directly into <c>tf.slice</c> to crop the
		///   image. The latter may be supplied to <c>tf.image.draw_bounding_boxes</c> to visualize
		///   what the bounding box looks like.
		///   
		///   Bounding boxes are supplied and returned as <c>[y_min, x_min, y_max, x_max]</c>. The
		///   bounding box coordinates are floats in <c>[0.0, 1.0]</c> relative to the width and
		///   height of the underlying image.
		///   
		///   For example,
		///   
		///    <code>
		///   # Generate a single distorted bounding box.
		///   begin, size, bbox_for_draw = tf.image.sample_distorted_bounding_box(
		///   tf.shape(image),
		///   bounding_boxes=bounding_boxes)
		///   
		///   # Draw the bounding box in an image summary.
		///   image_with_box = tf.image.draw_bounding_boxes(tf.expand_dims(image, 0),
		///   bbox_for_draw)
		///   tf.summary.image('images_with_box', image_with_box)
		///   
		///   # Employ the bounding box to distort the image.
		///   distorted_image = tf.slice(image, begin, size)
		///    </code>
		///   
		///   Note that if no bounding box information is available, setting
		///   <c>use_image_if_no_bounding_boxes = true</c> will assume there is a single implicit
		///   bounding box covering the whole image. If <c>use_image_if_no_bounding_boxes</c> is
		///   false and no bounding boxes are supplied, an error is raised.
		/// </remarks>
		public (TF_Output begin, TF_Output size, TF_Output bboxes) SampleDistortedBoundingBoxV2 (TF_Output image_size, TF_Output bounding_boxes, TF_Output min_object_covered, long? seed = null, long? seed2 = null, float[] aspect_ratio_range = null, float[] area_range = null, long? max_attempts = null, bool? use_image_if_no_bounding_boxes = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SampleDistortedBoundingBoxV2", MakeName ("SampleDistortedBoundingBoxV2", operName));
			c_api.TF_AddInput(desc, image_size);
			c_api.TF_AddInput(desc, bounding_boxes);
			c_api.TF_AddInput(desc, min_object_covered);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			if (aspect_ratio_range != null)
				c_api.TF_SetAttrFloatList (desc, "aspect_ratio_range", ref aspect_ratio_range[0], aspect_ratio_range.Length);
			
			if (area_range != null)
				c_api.TF_SetAttrFloatList (desc, "area_range", ref area_range[0], area_range.Length);
			
			if (max_attempts.HasValue)
				c_api.TF_SetAttrInt (desc, "max_attempts", max_attempts.Value);
			
			if (use_image_if_no_bounding_boxes.HasValue)
				c_api.TF_SetAttrBool (desc, "use_image_if_no_bounding_boxes", Convert.ToByte(use_image_if_no_bounding_boxes.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var begin = new TF_Output (op, _idx++);
			var size = new TF_Output (op, _idx++);
			var bboxes = new TF_Output (op, _idx++);
			return (begin, size, bboxes);
		}

		/// <summary>
		///   Creates a dataset that contains <c>rate</c> elements from the <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="rate">
		///   A scalar representing the sample rate of elements from the <c>input_dataset</c>
		///   that should be taken.
		/// </param>
		/// <param name="seed">
		///   A scalar representing seed of random number generator.
		/// </param>
		/// <param name="seed2">
		///   A scalar representing seed2 of random number generator.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SamplingDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SamplingDataset (TF_Output input_dataset, TF_Output rate, TF_Output seed, TF_Output seed2, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SamplingDataset", MakeName ("SamplingDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, rate);
			c_api.TF_AddInput(desc, seed);
			c_api.TF_AddInput(desc, seed2);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Saves the input tensors to disk.
		/// </summary>
		/// <param name="filename">
		///   Must have a single element. The name of the file to which we write
		///   the tensor.
		/// </param>
		/// <param name="tensor_names">
		///   Shape <c>[N]</c>. The names of the tensors to be saved.
		/// </param>
		/// <param name="data">
		///   <c>N</c> tensors to save.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Save'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   The size of <c>tensor_names</c> must match the number of tensors in <c>data</c>. <c>data[i]</c>
		///   is written to <c>filename</c> with name <c>tensor_names[i]</c>.
		///   
		///   See also <c>SaveSlices</c>.
		/// </remarks>
		public TF_Operation Save (TF_Output filename, TF_Output tensor_names, TF_Output[] data, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Save", MakeName ("Save", operName));
			c_api.TF_AddInput(desc, filename);
			c_api.TF_AddInput(desc, tensor_names);
			c_api.TF_AddInputList(desc, data[0], data.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Saves input tensors slices to disk.
		/// </summary>
		/// <param name="filename">
		///   Must have a single element. The name of the file to which we write the
		///   tensor.
		/// </param>
		/// <param name="tensor_names">
		///   Shape <c>[N]</c>. The names of the tensors to be saved.
		/// </param>
		/// <param name="shapes_and_slices">
		///   Shape <c>[N]</c>.  The shapes and slice specifications to use when
		///   saving the tensors.
		/// </param>
		/// <param name="data">
		///   <c>N</c> tensors to save.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SaveSlices'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   This is like <c>Save</c> except that tensors can be listed in the saved file as being
		///   a slice of a larger tensor.  <c>shapes_and_slices</c> specifies the shape of the
		///   larger tensor and the slice that this tensor covers. <c>shapes_and_slices</c> must
		///   have as many elements as <c>tensor_names</c>.
		///   
		///   Elements of the <c>shapes_and_slices</c> input must either be:
		///   
		///   *  The empty string, in which case the corresponding tensor is
		///   saved normally.
		///   *  A string of the form <c>dim0 dim1 ... dimN-1 slice-spec</c> where the
		///   <c>dimI</c> are the dimensions of the larger tensor and <c>slice-spec</c>
		///   specifies what part is covered by the tensor to save.
		///   
		///   <c>slice-spec</c> itself is a <c>:</c>-separated list: <c>slice0:slice1:...:sliceN-1</c>
		///   where each <c>sliceI</c> is either:
		///   
		///   *  The string <c>-</c> meaning that the slice covers all indices of this dimension
		///   *  <c>start,length</c> where <c>start</c> and <c>length</c> are integers.  In that
		///   case the slice covers <c>length</c> indices starting at <c>start</c>.
		///   
		///   See also <c>Save</c>.
		/// </remarks>
		public TF_Operation SaveSlices (TF_Output filename, TF_Output tensor_names, TF_Output shapes_and_slices, TF_Output[] data, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SaveSlices", MakeName ("SaveSlices", operName));
			c_api.TF_AddInput(desc, filename);
			c_api.TF_AddInput(desc, tensor_names);
			c_api.TF_AddInput(desc, shapes_and_slices);
			c_api.TF_AddInputList(desc, data[0], data.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Saves tensors in V2 checkpoint format.
		/// </summary>
		/// <param name="prefix">
		///   Must have a single element. The prefix of the V2 checkpoint to which we
		///   write the tensors.
		/// </param>
		/// <param name="tensor_names">
		///   shape {N}. The names of the tensors to be saved.
		/// </param>
		/// <param name="shape_and_slices">
		///   shape {N}.  The slice specs of the tensors to be saved.
		///   Empty strings indicate that they are non-partitioned tensors.
		/// </param>
		/// <param name="tensors">
		///   <c>N</c> tensors to save.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SaveV2'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   By default, saves the named tensors in full.  If the caller wishes to save
		///   specific slices of full tensors, "shape_and_slices" should be non-empty strings
		///   and correspondingly well-formed.
		/// </remarks>
		public TF_Operation SaveV2 (TF_Output prefix, TF_Output tensor_names, TF_Output shape_and_slices, TF_Output[] tensors, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SaveV2", MakeName ("SaveV2", operName));
			c_api.TF_AddInput(desc, prefix);
			c_api.TF_AddInput(desc, tensor_names);
			c_api.TF_AddInput(desc, shape_and_slices);
			c_api.TF_AddInputList(desc, tensors[0], tensors.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Outputs a <c>Summary</c> protocol buffer with scalar values.
		/// </summary>
		/// <param name="tags">
		///   Tags for the summary.
		/// </param>
		/// <param name="values">
		///   Same shape as <c>tags.  Values for the summary.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScalarSummary'.
		/// </param>
		/// <returns>
		///   Scalar.  Serialized <c>Summary</c> protocol buffer.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The input <c>tags</c> and <c>values</c> must have the same shape.  The generated summary
		///   has a summary value for each tag-value pair in <c>tags</c> and <c>values</c>.
		/// </remarks>
		public TF_Output ScalarSummary (TF_Output tags, TF_Output values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScalarSummary", MakeName ("ScalarSummary", operName));
			c_api.TF_AddInput(desc, tags);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var summary = new TF_Output (op, _idx++);
			return summary;
		}

		/// <summary>
		/// </summary>
		/// <param name="images">
		/// </param>
		/// <param name="size">
		/// </param>
		/// <param name="scale">
		/// </param>
		/// <param name="translation">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScaleAndTranslate'.
		/// </param>
		/// <param name="kernel_type">
		///   Optional argument
		/// </param>
		/// <param name="antialias">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ScaleAndTranslate (TF_Output images, TF_Output size, TF_Output scale, TF_Output translation, string kernel_type = null, bool? antialias = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScaleAndTranslate", MakeName ("ScaleAndTranslate", operName));
			c_api.TF_AddInput(desc, images);
			c_api.TF_AddInput(desc, size);
			c_api.TF_AddInput(desc, scale);
			c_api.TF_AddInput(desc, translation);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (kernel_type != null)
				c_api.TF_SetAttrString (desc, "kernel_type", kernel_type);
			
			if (antialias.HasValue)
				c_api.TF_SetAttrBool (desc, "antialias", Convert.ToByte(antialias.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var resized_images = new TF_Output (op, _idx++);
			return resized_images;
		}

		/// <summary>
		/// </summary>
		/// <param name="grads">
		/// </param>
		/// <param name="original_image">
		/// </param>
		/// <param name="scale">
		/// </param>
		/// <param name="translation">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScaleAndTranslateGrad'.
		/// </param>
		/// <param name="kernel_type">
		///   Optional argument
		/// </param>
		/// <param name="antialias">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ScaleAndTranslateGrad (TF_Output grads, TF_Output original_image, TF_Output scale, TF_Output translation, string kernel_type = null, bool? antialias = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScaleAndTranslateGrad", MakeName ("ScaleAndTranslateGrad", operName));
			c_api.TF_AddInput(desc, grads);
			c_api.TF_AddInput(desc, original_image);
			c_api.TF_AddInput(desc, scale);
			c_api.TF_AddInput(desc, translation);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (kernel_type != null)
				c_api.TF_SetAttrString (desc, "kernel_type", kernel_type);
			
			if (antialias.HasValue)
				c_api.TF_SetAttrBool (desc, "antialias", Convert.ToByte(antialias.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates a dataset successively reduces <c>f</c> over the elements of <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="initial_state">
		/// </param>
		/// <param name="other_arguments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScanDataset'.
		/// </param>
		/// <param name="preserve_cardinality">
		///   Optional argument
		/// </param>
		/// <param name="f">
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ScanDataset (TF_Output input_dataset, TF_Output[] initial_state, TF_Output[] other_arguments, TF_Function f, TF_DataType[] output_types, long[][] output_shapes, bool? preserve_cardinality = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScanDataset", MakeName ("ScanDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInputList(desc, initial_state[0], initial_state.Length);
			c_api.TF_AddInputList(desc, other_arguments[0], other_arguments.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "f", c_api.TF_FunctionName(f));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (preserve_cardinality.HasValue)
				c_api.TF_SetAttrBool (desc, "preserve_cardinality", Convert.ToByte(preserve_cardinality.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Adds sparse updates to a variable reference.
		/// </summary>
		/// <param name="reference">
		///   Should be from a <c>Variable</c> node.
		/// </param>
		/// <param name="indices">
		///   A tensor of indices into the first dimension of <c>ref</c>.
		/// </param>
		/// <param name="updates">
		///   A tensor of updated values to add to <c>ref</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterAdd'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, the addition will be protected by a lock;
		///   otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   = Same as <c>ref</c>.  Returned as a convenience for operations that want
		///   to use the updated values after the update is done.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation computes
		///   
		///   # Scalar indices
		///   ref[indices, ...] += updates[...]
		///   
		///   # Vector indices (for each i)
		///   ref[indices[i], ...] += updates[i, ...]
		///   
		///   # High rank indices (for each i, ..., j)
		///   ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]
		///   
		///   This operation outputs <c>ref</c> after the update is done.
		///   This makes it easier to chain operations that need to use the reset value.
		///   
		///   Duplicate entries are handled correctly: if multiple <c>indices</c> reference
		///   the same location, their contributions add.
		///   
		///   Requires <c>updates.shape = indices.shape + ref.shape[1:]</c> or <c>updates.shape = []</c>.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/ScatterAdd.png" alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		/// </remarks>
		public TF_Output ScatterAdd (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterAdd", MakeName ("ScatterAdd", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		///   Divides a variable reference by sparse updates.
		/// </summary>
		/// <param name="reference">
		///   Should be from a <c>Variable</c> node.
		/// </param>
		/// <param name="indices">
		///   A tensor of indices into the first dimension of <c>ref</c>.
		/// </param>
		/// <param name="updates">
		///   A tensor of values that <c>ref</c> is divided by.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterDiv'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, the operation will be protected by a lock;
		///   otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   = Same as <c>ref</c>.  Returned as a convenience for operations that want
		///   to use the updated values after the update is done.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation computes
		///   
		///    <code>
		///   # Scalar indices
		///   ref[indices, ...] /= updates[...]
		///   
		///   # Vector indices (for each i)
		///   ref[indices[i], ...] /= updates[i, ...]
		///   
		///   # High rank indices (for each i, ..., j)
		///   ref[indices[i, ..., j], ...] /= updates[i, ..., j, ...]
		///    </code>
		///   
		///   This operation outputs <c>ref</c> after the update is done.
		///   This makes it easier to chain operations that need to use the reset value.
		///   
		///   Duplicate entries are handled correctly: if multiple <c>indices</c> reference
		///   the same location, their contributions divide.
		///   
		///   Requires <c>updates.shape = indices.shape + ref.shape[1:]</c> or <c>updates.shape = []</c>.
		/// </remarks>
		public TF_Output ScatterDiv (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterDiv", MakeName ("ScatterDiv", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		///   Reduces sparse updates into a variable reference using the <c>max</c> operation.
		/// </summary>
		/// <param name="reference">
		///   Should be from a <c>Variable</c> node.
		/// </param>
		/// <param name="indices">
		///   A tensor of indices into the first dimension of <c>ref</c>.
		/// </param>
		/// <param name="updates">
		///   A tensor of updated values to reduce into <c>ref</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterMax'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, the update will be protected by a lock;
		///   otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   = Same as <c>ref</c>.  Returned as a convenience for operations that want
		///   to use the updated values after the update is done.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation computes
		///   
		///   # Scalar indices
		///   ref[indices, ...] = max(ref[indices, ...], updates[...])
		///   
		///   # Vector indices (for each i)
		///   ref[indices[i], ...] = max(ref[indices[i], ...], updates[i, ...])
		///   
		///   # High rank indices (for each i, ..., j)
		///   ref[indices[i, ..., j], ...] = max(ref[indices[i, ..., j], ...], updates[i, ..., j, ...])
		///   
		///   This operation outputs <c>ref</c> after the update is done.
		///   This makes it easier to chain operations that need to use the reset value.
		///   
		///   Duplicate entries are handled correctly: if multiple <c>indices</c> reference
		///   the same location, their contributions combine.
		///   
		///   Requires <c>updates.shape = indices.shape + ref.shape[1:]</c> or <c>updates.shape = []</c>.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/ScatterAdd.png" alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		/// </remarks>
		public TF_Output ScatterMax (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterMax", MakeName ("ScatterMax", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		///   Reduces sparse updates into a variable reference using the <c>min</c> operation.
		/// </summary>
		/// <param name="reference">
		///   Should be from a <c>Variable</c> node.
		/// </param>
		/// <param name="indices">
		///   A tensor of indices into the first dimension of <c>ref</c>.
		/// </param>
		/// <param name="updates">
		///   A tensor of updated values to reduce into <c>ref</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterMin'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, the update will be protected by a lock;
		///   otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   = Same as <c>ref</c>.  Returned as a convenience for operations that want
		///   to use the updated values after the update is done.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation computes
		///   
		///   # Scalar indices
		///   ref[indices, ...] = min(ref[indices, ...], updates[...])
		///   
		///   # Vector indices (for each i)
		///   ref[indices[i], ...] = min(ref[indices[i], ...], updates[i, ...])
		///   
		///   # High rank indices (for each i, ..., j)
		///   ref[indices[i, ..., j], ...] = min(ref[indices[i, ..., j], ...], updates[i, ..., j, ...])
		///   
		///   This operation outputs <c>ref</c> after the update is done.
		///   This makes it easier to chain operations that need to use the reset value.
		///   
		///   Duplicate entries are handled correctly: if multiple <c>indices</c> reference
		///   the same location, their contributions combine.
		///   
		///   Requires <c>updates.shape = indices.shape + ref.shape[1:]</c> or <c>updates.shape = []</c>.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/ScatterAdd.png" alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		/// </remarks>
		public TF_Output ScatterMin (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterMin", MakeName ("ScatterMin", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		///   Multiplies sparse updates into a variable reference.
		/// </summary>
		/// <param name="reference">
		///   Should be from a <c>Variable</c> node.
		/// </param>
		/// <param name="indices">
		///   A tensor of indices into the first dimension of <c>ref</c>.
		/// </param>
		/// <param name="updates">
		///   A tensor of updated values to multiply to <c>ref</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterMul'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, the operation will be protected by a lock;
		///   otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   = Same as <c>ref</c>.  Returned as a convenience for operations that want
		///   to use the updated values after the update is done.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation computes
		///   
		///    <code>
		///   # Scalar indices
		///   ref[indices, ...] *= updates[...]
		///   
		///   # Vector indices (for each i)
		///   ref[indices[i], ...] *= updates[i, ...]
		///   
		///   # High rank indices (for each i, ..., j)
		///   ref[indices[i, ..., j], ...] *= updates[i, ..., j, ...]
		///    </code>
		///   
		///   This operation outputs <c>ref</c> after the update is done.
		///   This makes it easier to chain operations that need to use the reset value.
		///   
		///   Duplicate entries are handled correctly: if multiple <c>indices</c> reference
		///   the same location, their contributions multiply.
		///   
		///   Requires <c>updates.shape = indices.shape + ref.shape[1:]</c> or <c>updates.shape = []</c>.
		/// </remarks>
		public TF_Output ScatterMul (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterMul", MakeName ("ScatterMul", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		///   Scatter <c>updates</c> into a new tensor according to <c>indices</c>.
		/// </summary>
		/// <param name="indices">
		///   Index tensor.
		/// </param>
		/// <param name="updates">
		///   Updates to scatter into output.
		/// </param>
		/// <param name="shape">
		///   1-D. The shape of the resulting tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterNd'.
		/// </param>
		/// <returns>
		///   A new tensor with the given shape and updates applied according
		///   to the indices.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Creates a new tensor by applying sparse <c>updates</c> to individual values or
		///   slices within a tensor (initially zero for numeric, empty for string) of
		///   the given <c>shape</c> according to indices.  This operator is the inverse of the
		///   <c>tf.gather_nd</c> operator which extracts values or slices from a given tensor.
		///   
		///   This operation is similar to tensor_scatter_add, except that the tensor is
		///   zero-initialized. Calling <c>tf.scatter_nd(indices, values, shape)</c> is identical
		///   to <c>tensor_scatter_add(tf.zeros(shape, values.dtype), indices, values)</c>
		///   
		///   If <c>indices</c> contains duplicates, then their updates are accumulated (summed).
		///   
		///   **WARNING**: The order in which updates are applied is nondeterministic, so the
		///   output will be nondeterministic if <c>indices</c> contains duplicates -- because
		///   of some numerical approximation issues, numbers summed in different order
		///   may yield different results.
		///   
		///   <c>indices</c> is an integer tensor containing indices into a new tensor of shape
		///   <c>shape</c>.  The last dimension of <c>indices</c> can be at most the rank of <c>shape</c>:
		///   
		///   indices.shape[-1] &amp;lt;= shape.rank
		///   
		///   The last dimension of <c>indices</c> corresponds to indices into elements
		///   (if <c>indices.shape[-1] = shape.rank</c>) or slices
		///   (if <c>indices.shape[-1] &amp;lt; shape.rank</c>) along dimension <c>indices.shape[-1]</c> of
		///   <c>shape</c>.  <c>updates</c> is a tensor with shape
		///   
		///   indices.shape[:-1] + shape[indices.shape[-1]:]
		///   
		///   The simplest form of scatter is to insert individual elements in a tensor by
		///   index. For example, say we want to insert 4 scattered elements in a rank-1
		///   tensor with 8 elements.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/ScatterNd1.png" alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		///   
		///   In Python, this scatter operation would look like this:
		///   
		///    <code>
		///   indices = tf.constant([[4], [3], [1], [7]])
		///   updates = tf.constant([9, 10, 11, 12])
		///   shape = tf.constant([8])
		///   scatter = tf.scatter_nd(indices, updates, shape)
		///   with tf.Session() as sess:
		///   print(sess.run(scatter))
		///    </code>
		///   
		///   The resulting tensor would look like this:
		///   
		///   [0, 11, 0, 10, 9, 0, 0, 12]
		///   
		///   We can also, insert entire slices of a higher rank tensor all at once. For
		///   example, if we wanted to insert two slices in the first dimension of a
		///   rank-3 tensor with two matrices of new values.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/ScatterNd2.png" alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		///   
		///   In Python, this scatter operation would look like this:
		///   
		///    <code>
		///   indices = tf.constant([[0], [2]])
		///   updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6],
		///   [7, 7, 7, 7], [8, 8, 8, 8]],
		///   [[5, 5, 5, 5], [6, 6, 6, 6],
		///   [7, 7, 7, 7], [8, 8, 8, 8]]])
		///   shape = tf.constant([4, 4, 4])
		///   scatter = tf.scatter_nd(indices, updates, shape)
		///   with tf.Session() as sess:
		///   print(sess.run(scatter))
		///    </code>
		///   
		///   The resulting tensor would look like this:
		///   
		///   [[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],
		///   [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],
		///   [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],
		///   [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]]
		///   
		///   Note that on CPU, if an out of bound index is found, an error is returned.
		///   On GPU, if an out of bound index is found, the index is ignored.
		/// </remarks>
		public TF_Output ScatterNd (TF_Output indices, TF_Output updates, TF_Output shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterNd", MakeName ("ScatterNd", operName));
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Applies sparse addition to individual values or slices in a Variable.
		/// </summary>
		/// <param name="reference">
		///   A mutable Tensor. Should be from a Variable node.
		/// </param>
		/// <param name="indices">
		///   A Tensor. Must be one of the following types: int32, int64.
		///   A tensor of indices into ref.
		/// </param>
		/// <param name="updates">
		///   A Tensor. Must have the same type as ref. A tensor of updated values
		///   to add to ref.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterNdAdd'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   An optional bool. Defaults to True. If True, the assignment will
		///   be protected by a lock; otherwise the behavior is undefined,
		///   but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Same as ref. Returned as a convenience for operations that want
		///   to use the updated values after the update is done.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   <c>ref</c> is a <c>Tensor</c> with rank <c>P</c> and <c>indices</c> is a <c>Tensor</c> of rank <c>Q</c>.
		///   
		///   <c>indices</c> must be integer tensor, containing indices into <c>ref</c>.
		///   It must be shape <c>[d_0, ..., d_{Q-2}, K]</c> where <c>0 &amp;lt; K &amp;lt;= P</c>.
		///   
		///   The innermost dimension of <c>indices</c> (with length <c>K</c>) corresponds to
		///   indices into elements (if <c>K = P</c>) or slices (if <c>K &amp;lt; P</c>) along the <c>K</c>th
		///   dimension of <c>ref</c>.
		///   
		///   <c>updates</c> is <c>Tensor</c> of rank <c>Q-1+P-K</c> with shape:
		///   
		///    <code>
		///   [d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]]
		///    </code>
		///   
		///   For example, say we want to add 4 scattered elements to a rank-1 tensor to
		///   8 elements. In Python, that addition would look like this:
		///   
		///    <code>
		///   ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
		///   indices = tf.constant([[4], [3], [1], [7]])
		///   updates = tf.constant([9, 10, 11, 12])
		///   add = tf.scatter_nd_add(ref, indices, updates)
		///   with tf.Session() as sess:
		///   print sess.run(add)
		///    </code>
		///   
		///   The resulting update to ref would look like this:
		///   
		///   [1, 13, 3, 14, 14, 6, 7, 20]
		///   
		///   See <c>tf.scatter_nd</c> for more details about how to make updates to
		///   slices.
		/// </remarks>
		public TF_Output ScatterNdAdd (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterNdAdd", MakeName ("ScatterNdAdd", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		///   Applies sparse addition to <c>input</c> using individual values or slices
		/// </summary>
		/// <param name="input">
		///   A Tensor.
		/// </param>
		/// <param name="indices">
		///   A Tensor. Must be one of the following types: <c>int32</c>, <c>int64</c>.
		///   A tensor of indices into <c>input</c>.
		/// </param>
		/// <param name="updates">
		///   A Tensor. Must have the same type as ref. A tensor of updated values
		///   to add to <c>input</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterNdNonAliasingAdd'.
		/// </param>
		/// <returns>
		///   A <c>Tensor</c> with the same shape as <c>input</c>, containing values of <c>input</c>
		///   updated with <c>updates</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   from <c>updates</c> according to indices <c>indices</c>.  The updates are non-aliasing:
		///   <c>input</c> is only modified in-place if no other operations will use it.
		///   Otherwise, a copy of <c>input</c> is made.  This operation has a gradient with
		///   respect to both <c>input</c> and <c>updates</c>.
		///   
		///   <c>input</c> is a <c>Tensor</c> with rank <c>P</c> and <c>indices</c> is a <c>Tensor</c> of rank <c>Q</c>.
		///   
		///   <c>indices</c> must be integer tensor, containing indices into <c>input</c>.
		///   It must be shape \\([d_0, ..., d_{Q-2}, K]\\) where <c>0 &amp;lt; K &amp;lt;= P</c>.
		///   
		///   The innermost dimension of <c>indices</c> (with length <c>K</c>) corresponds to
		///   indices into elements (if <c>K = P</c>) or <c>(P-K)</c>-dimensional slices
		///   (if <c>K &amp;lt; P</c>) along the <c>K</c>th dimension of <c>input</c>.
		///   
		///   <c>updates</c> is <c>Tensor</c> of rank <c>Q-1+P-K</c> with shape:
		///   
		///   $$[d_0, ..., d_{Q-2}, input.shape[K], ..., input.shape[P-1]].$$
		///   
		///   For example, say we want to add 4 scattered elements to a rank-1 tensor to 8
		///   elements. In Python, that addition would look like this:
		///   
		///   input = tf.constant([1, 2, 3, 4, 5, 6, 7, 8])
		///   indices = tf.constant([[4], [3], [1], [7]])
		///   updates = tf.constant([9, 10, 11, 12])
		///   output = tf.scatter_nd_non_aliasing_add(input, indices, updates)
		///   with tf.Session() as sess:
		///   print(sess.run(output))
		///   
		///   The resulting value <c>output</c> would look like this:
		///   
		///   [1, 13, 3, 14, 14, 6, 7, 20]
		///   
		///   See <c>tf.scatter_nd</c> for more details about how to make updates to slices.
		/// </remarks>
		public TF_Output ScatterNdNonAliasingAdd (TF_Output input, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterNdNonAliasingAdd", MakeName ("ScatterNdNonAliasingAdd", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Applies sparse subtraction to individual values or slices in a Variable.
		/// </summary>
		/// <param name="reference">
		///   A mutable Tensor. Should be from a Variable node.
		/// </param>
		/// <param name="indices">
		///   A Tensor. Must be one of the following types: int32, int64.
		///   A tensor of indices into ref.
		/// </param>
		/// <param name="updates">
		///   A Tensor. Must have the same type as ref. A tensor of updated values
		///   to subtract from ref.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterNdSub'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   An optional bool. Defaults to True. If True, the assignment will
		///   be protected by a lock; otherwise the behavior is undefined,
		///   but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Same as ref. Returned as a convenience for operations that want
		///   to use the updated values after the update is done.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   within a given variable according to <c>indices</c>.
		///   
		///   <c>ref</c> is a <c>Tensor</c> with rank <c>P</c> and <c>indices</c> is a <c>Tensor</c> of rank <c>Q</c>.
		///   
		///   <c>indices</c> must be integer tensor, containing indices into <c>ref</c>.
		///   It must be shape <c>[d_0, ..., d_{Q-2}, K]</c> where <c>0 &amp;lt; K &amp;lt;= P</c>.
		///   
		///   The innermost dimension of <c>indices</c> (with length <c>K</c>) corresponds to
		///   indices into elements (if <c>K = P</c>) or slices (if <c>K &amp;lt; P</c>) along the <c>K</c>th
		///   dimension of <c>ref</c>.
		///   
		///   <c>updates</c> is <c>Tensor</c> of rank <c>Q-1+P-K</c> with shape:
		///   
		///    <code>
		///   [d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]]
		///    </code>
		///   
		///   For example, say we want to subtract 4 scattered elements from a rank-1 tensor
		///   with 8 elements. In Python, that subtraction would look like this:
		///   
		///    <code>
		///   ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
		///   indices = tf.constant([[4], [3], [1], [7]])
		///   updates = tf.constant([9, 10, 11, 12])
		///   sub = tf.scatter_nd_sub(ref, indices, updates)
		///   with tf.Session() as sess:
		///   print sess.run(sub)
		///    </code>
		///   
		///   The resulting update to ref would look like this:
		///   
		///   [1, -9, 3, -6, -4, 6, 7, -4]
		///   
		///   See <c>tf.scatter_nd</c> for more details about how to make updates to
		///   slices.
		/// </remarks>
		public TF_Output ScatterNdSub (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterNdSub", MakeName ("ScatterNdSub", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		///   Applies sparse <c>updates</c> to individual values or slices within a given
		/// </summary>
		/// <param name="reference">
		///   A mutable Tensor. Should be from a Variable node.
		/// </param>
		/// <param name="indices">
		///   A Tensor. Must be one of the following types: int32, int64.
		///   A tensor of indices into ref.
		/// </param>
		/// <param name="updates">
		///   A Tensor. Must have the same type as ref. A tensor of updated
		///   values to add to ref.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterNdUpdate'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   An optional bool. Defaults to True. If True, the assignment will
		///   be protected by a lock; otherwise the behavior is undefined,
		///   but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Same as ref. Returned as a convenience for operations that want to
		///   use the updated values after the update is done.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   variable according to <c>indices</c>.
		///   
		///   <c>ref</c> is a <c>Tensor</c> with rank <c>P</c> and <c>indices</c> is a <c>Tensor</c> of rank <c>Q</c>.
		///   
		///   <c>indices</c> must be integer tensor, containing indices into <c>ref</c>.
		///   It must be shape \\([d_0, ..., d_{Q-2}, K]\\) where <c>0 &amp;lt; K &amp;lt;= P</c>.
		///   
		///   The innermost dimension of <c>indices</c> (with length <c>K</c>) corresponds to
		///   indices into elements (if <c>K = P</c>) or slices (if <c>K &amp;lt; P</c>) along the <c>K</c>th
		///   dimension of <c>ref</c>.
		///   
		///   <c>updates</c> is <c>Tensor</c> of rank <c>Q-1+P-K</c> with shape:
		///   
		///   $$[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].$$
		///   
		///   For example, say we want to update 4 scattered elements to a rank-1 tensor to
		///   8 elements. In Python, that update would look like this:
		///   
		///    <code>
		///   ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
		///   indices = tf.constant([[4], [3], [1] ,[7]])
		///   updates = tf.constant([9, 10, 11, 12])
		///   update = tf.scatter_nd_update(ref, indices, updates)
		///   with tf.Session() as sess:
		///   print sess.run(update)
		///    </code>
		///   
		///   The resulting update to ref would look like this:
		///   
		///   [1, 11, 3, 10, 9, 6, 7, 12]
		///   
		///   See <c>tf.scatter_nd</c> for more details about how to make updates to
		///   slices.
		///   
		///   See also <c>tf.scatter_update</c> and <c>tf.batch_scatter_update</c>.
		/// </remarks>
		public TF_Output ScatterNdUpdate (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterNdUpdate", MakeName ("ScatterNdUpdate", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		///   Subtracts sparse updates to a variable reference.
		/// </summary>
		/// <param name="reference">
		///   Should be from a <c>Variable</c> node.
		/// </param>
		/// <param name="indices">
		///   A tensor of indices into the first dimension of <c>ref</c>.
		/// </param>
		/// <param name="updates">
		///   A tensor of updated values to subtract from <c>ref</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterSub'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, the subtraction will be protected by a lock;
		///   otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   = Same as <c>ref</c>.  Returned as a convenience for operations that want
		///   to use the updated values after the update is done.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///    <code>
		///   # Scalar indices
		///   ref[indices, ...] -= updates[...]
		///   
		///   # Vector indices (for each i)
		///   ref[indices[i], ...] -= updates[i, ...]
		///   
		///   # High rank indices (for each i, ..., j)
		///   ref[indices[i, ..., j], ...] -= updates[i, ..., j, ...]
		///    </code>
		///   
		///   This operation outputs <c>ref</c> after the update is done.
		///   This makes it easier to chain operations that need to use the reset value.
		///   
		///   Duplicate entries are handled correctly: if multiple <c>indices</c> reference
		///   the same location, their (negated) contributions add.
		///   
		///   Requires <c>updates.shape = indices.shape + ref.shape[1:]</c> or <c>updates.shape = []</c>.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/ScatterSub.png" alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		/// </remarks>
		public TF_Output ScatterSub (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterSub", MakeName ("ScatterSub", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		///   Applies sparse updates to a variable reference.
		/// </summary>
		/// <param name="reference">
		///   Should be from a <c>Variable</c> node.
		/// </param>
		/// <param name="indices">
		///   A tensor of indices into the first dimension of <c>ref</c>.
		/// </param>
		/// <param name="updates">
		///   A tensor of updated values to store in <c>ref</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterUpdate'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, the assignment will be protected by a lock;
		///   otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   = Same as <c>ref</c>.  Returned as a convenience for operations that want
		///   to use the updated values after the update is done.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation computes
		///   
		///    <code>
		///   # Scalar indices
		///   ref[indices, ...] = updates[...]
		///   
		///   # Vector indices (for each i)
		///   ref[indices[i], ...] = updates[i, ...]
		///   
		///   # High rank indices (for each i, ..., j)
		///   ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]
		///    </code>
		///   
		///   This operation outputs <c>ref</c> after the update is done.
		///   This makes it easier to chain operations that need to use the reset value.
		///   
		///   If values in <c>ref</c> is to be updated more than once, because there are
		///   duplicate entries in <c>indices</c>, the order at which the updates happen
		///   for each value is undefined.
		///   
		///   Requires <c>updates.shape = indices.shape + ref.shape[1:]</c> or <c>updates.shape = []</c>.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/ScatterUpdate.png" alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		///   
		///   See also <c>tf.batch_scatter_update</c> and <c>tf.scatter_nd_update</c>.
		/// </remarks>
		public TF_Output ScatterUpdate (TF_Output reference, TF_Output indices, TF_Output updates, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ScatterUpdate", MakeName ("ScatterUpdate", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		///   Computes fingerprints of the input strings.
		/// </summary>
		/// <param name="input">
		///   vector of strings to compute fingerprints on.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SdcaFprint'.
		/// </param>
		/// <returns>
		///   a (N,2) shaped matrix where N is the number of elements in the input
		///   vector. Each row contains the low and high parts of the fingerprint.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SdcaFprint (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SdcaFprint", MakeName ("SdcaFprint", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Distributed version of Stochastic Dual Coordinate Ascent (SDCA) optimizer for
		/// </summary>
		/// <param name="sparse_example_indices">
		///   a list of vectors which contain example indices.
		/// </param>
		/// <param name="sparse_feature_indices">
		///   a list of vectors which contain feature indices.
		/// </param>
		/// <param name="sparse_feature_values">
		///   a list of vectors which contains feature value
		///   associated with each feature group.
		/// </param>
		/// <param name="dense_features">
		///   a list of matrices which contains the dense feature values.
		/// </param>
		/// <param name="example_weights">
		///   a vector which contains the weight associated with each
		///   example.
		/// </param>
		/// <param name="example_labels">
		///   a vector which contains the label/target associated with each
		///   example.
		/// </param>
		/// <param name="sparse_indices">
		///   a list of vectors where each value is the indices which has
		///   corresponding weights in sparse_weights. This field maybe omitted for the
		///   dense approach.
		/// </param>
		/// <param name="sparse_weights">
		///   a list of vectors where each value is the weight associated with
		///   a sparse feature group.
		/// </param>
		/// <param name="dense_weights">
		///   a list of vectors where the values are the weights associated
		///   with a dense feature group.
		/// </param>
		/// <param name="example_state_data">
		///   a list of vectors containing the example state data.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SdcaOptimizer'.
		/// </param>
		/// <param name="adaptative">
		///   Optional argument
		///   Whether to use Adaptive SDCA for the inner loop.
		/// </param>
		/// <param name="loss_type">
		///   Type of the primal loss. Currently SdcaSolver supports logistic,
		///   squared and hinge losses.
		/// </param>
		/// <param name="l1">
		///   Symmetric l1 regularization strength.
		/// </param>
		/// <param name="l2">
		///   Symmetric l2 regularization strength.
		/// </param>
		/// <param name="num_loss_partitions">
		///   Number of partitions of the global loss function.
		/// </param>
		/// <param name="num_inner_iterations">
		///   Number of iterations per mini-batch.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   out_example_state_data: a list of vectors containing the updated example state
		///   data.
		///   out_delta_sparse_weights: a list of vectors where each value is the delta
		///   weights associated with a sparse feature group.
		///   out_delta_dense_weights: a list of vectors where the values are the delta
		///   weights associated with a dense feature group.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   linear models with L1 + L2 regularization. As global optimization objective is
		///   strongly-convex, the optimizer optimizes the dual objective at each step. The
		///   optimizer applies each update one example at a time. Examples are sampled
		///   uniformly, and the optimizer is learning rate free and enjoys linear convergence
		///   rate.
		///   
		///   [Proximal Stochastic Dual Coordinate Ascent](http://arxiv.org/pdf/1211.2717v1.pdf).&amp;lt;br&amp;gt;
		///   Shai Shalev-Shwartz, Tong Zhang. 2012
		///   
		///   $$Loss Objective = \sum f_{i} (wx_{i}) + (l2 / 2) * |w|^2 + l1 * |w|$$
		///   
		///   [Adding vs. Averaging in Distributed Primal-Dual Optimization](http://arxiv.org/abs/1502.03508).&amp;lt;br&amp;gt;
		///   Chenxin Ma, Virginia Smith, Martin Jaggi, Michael I. Jordan,
		///   Peter Richtarik, Martin Takac. 2015
		///   
		///   [Stochastic Dual Coordinate Ascent with Adaptive Probabilities](https://arxiv.org/abs/1502.08053).&amp;lt;br&amp;gt;
		///   Dominik Csiba, Zheng Qu, Peter Richtarik. 2015
		/// </remarks>
		public (TF_Output out_example_state_data, TF_Output[] out_delta_sparse_weights, TF_Output[] out_delta_dense_weights) SdcaOptimizer (TF_Output[] sparse_example_indices, TF_Output[] sparse_feature_indices, TF_Output[] sparse_feature_values, TF_Output[] dense_features, TF_Output example_weights, TF_Output example_labels, TF_Output[] sparse_indices, TF_Output[] sparse_weights, TF_Output[] dense_weights, TF_Output example_state_data, string loss_type, float l1, float l2, long num_loss_partitions, long num_inner_iterations, bool? adaptative = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SdcaOptimizer", MakeName ("SdcaOptimizer", operName));
			c_api.TF_AddInputList(desc, sparse_example_indices[0], sparse_example_indices.Length);
			c_api.TF_AddInputList(desc, sparse_feature_indices[0], sparse_feature_indices.Length);
			c_api.TF_AddInputList(desc, sparse_feature_values[0], sparse_feature_values.Length);
			c_api.TF_AddInputList(desc, dense_features[0], dense_features.Length);
			c_api.TF_AddInput(desc, example_weights);
			c_api.TF_AddInput(desc, example_labels);
			c_api.TF_AddInputList(desc, sparse_indices[0], sparse_indices.Length);
			c_api.TF_AddInputList(desc, sparse_weights[0], sparse_weights.Length);
			c_api.TF_AddInputList(desc, dense_weights[0], dense_weights.Length);
			c_api.TF_AddInput(desc, example_state_data);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "loss_type", loss_type);
			c_api.TF_SetAttrFloat (desc, "l1", l1);
			c_api.TF_SetAttrFloat (desc, "l2", l2);
			c_api.TF_SetAttrInt (desc, "num_loss_partitions", num_loss_partitions);
			c_api.TF_SetAttrInt (desc, "num_inner_iterations", num_inner_iterations);
			if (adaptative.HasValue)
				c_api.TF_SetAttrBool (desc, "adaptative", Convert.ToByte(adaptative.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			var out_example_state_data = new TF_Output (op, _idx++);
			_n = c_api.TF_OperationOutputListLength(op, "out_delta_sparse_weights", status);
			var out_delta_sparse_weights = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				out_delta_sparse_weights [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "out_delta_dense_weights", status);
			var out_delta_dense_weights = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				out_delta_dense_weights [i] = new TF_Output (op, _idx++);
			
			return (out_example_state_data, out_delta_sparse_weights, out_delta_dense_weights);
		}

		/// <summary>
		///   Distributed version of Stochastic Dual Coordinate Ascent (SDCA) optimizer for
		/// </summary>
		/// <param name="sparse_example_indices">
		///   a list of vectors which contain example indices.
		/// </param>
		/// <param name="sparse_feature_indices">
		///   a list of vectors which contain feature indices.
		/// </param>
		/// <param name="sparse_feature_values">
		///   a list of vectors which contains feature value
		///   associated with each feature group.
		/// </param>
		/// <param name="dense_features">
		///   a list of matrices which contains the dense feature values.
		/// </param>
		/// <param name="example_weights">
		///   a vector which contains the weight associated with each
		///   example.
		/// </param>
		/// <param name="example_labels">
		///   a vector which contains the label/target associated with each
		///   example.
		/// </param>
		/// <param name="sparse_indices">
		///   a list of vectors where each value is the indices which has
		///   corresponding weights in sparse_weights. This field maybe omitted for the
		///   dense approach.
		/// </param>
		/// <param name="sparse_weights">
		///   a list of vectors where each value is the weight associated with
		///   a sparse feature group.
		/// </param>
		/// <param name="dense_weights">
		///   a list of vectors where the values are the weights associated
		///   with a dense feature group.
		/// </param>
		/// <param name="example_state_data">
		///   a list of vectors containing the example state data.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SdcaOptimizerV2'.
		/// </param>
		/// <param name="adaptive">
		///   Optional argument
		///   Whether to use Adaptive SDCA for the inner loop.
		/// </param>
		/// <param name="loss_type">
		///   Type of the primal loss. Currently SdcaSolver supports logistic,
		///   squared and hinge losses.
		/// </param>
		/// <param name="l1">
		///   Symmetric l1 regularization strength.
		/// </param>
		/// <param name="l2">
		///   Symmetric l2 regularization strength.
		/// </param>
		/// <param name="num_loss_partitions">
		///   Number of partitions of the global loss function.
		/// </param>
		/// <param name="num_inner_iterations">
		///   Number of iterations per mini-batch.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   out_example_state_data: a list of vectors containing the updated example state
		///   data.
		///   out_delta_sparse_weights: a list of vectors where each value is the delta
		///   weights associated with a sparse feature group.
		///   out_delta_dense_weights: a list of vectors where the values are the delta
		///   weights associated with a dense feature group.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   linear models with L1 + L2 regularization. As global optimization objective is
		///   strongly-convex, the optimizer optimizes the dual objective at each step. The
		///   optimizer applies each update one example at a time. Examples are sampled
		///   uniformly, and the optimizer is learning rate free and enjoys linear convergence
		///   rate.
		///   
		///   [Proximal Stochastic Dual Coordinate Ascent](http://arxiv.org/pdf/1211.2717v1.pdf).&amp;lt;br&amp;gt;
		///   Shai Shalev-Shwartz, Tong Zhang. 2012
		///   
		///   $$Loss Objective = \sum f_{i} (wx_{i}) + (l2 / 2) * |w|^2 + l1 * |w|$$
		///   
		///   [Adding vs. Averaging in Distributed Primal-Dual Optimization](http://arxiv.org/abs/1502.03508).&amp;lt;br&amp;gt;
		///   Chenxin Ma, Virginia Smith, Martin Jaggi, Michael I. Jordan,
		///   Peter Richtarik, Martin Takac. 2015
		///   
		///   [Stochastic Dual Coordinate Ascent with Adaptive Probabilities](https://arxiv.org/abs/1502.08053).&amp;lt;br&amp;gt;
		///   Dominik Csiba, Zheng Qu, Peter Richtarik. 2015
		/// </remarks>
		public (TF_Output out_example_state_data, TF_Output[] out_delta_sparse_weights, TF_Output[] out_delta_dense_weights) SdcaOptimizerV2 (TF_Output[] sparse_example_indices, TF_Output[] sparse_feature_indices, TF_Output[] sparse_feature_values, TF_Output[] dense_features, TF_Output example_weights, TF_Output example_labels, TF_Output[] sparse_indices, TF_Output[] sparse_weights, TF_Output[] dense_weights, TF_Output example_state_data, string loss_type, float l1, float l2, long num_loss_partitions, long num_inner_iterations, bool? adaptive = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SdcaOptimizerV2", MakeName ("SdcaOptimizerV2", operName));
			c_api.TF_AddInputList(desc, sparse_example_indices[0], sparse_example_indices.Length);
			c_api.TF_AddInputList(desc, sparse_feature_indices[0], sparse_feature_indices.Length);
			c_api.TF_AddInputList(desc, sparse_feature_values[0], sparse_feature_values.Length);
			c_api.TF_AddInputList(desc, dense_features[0], dense_features.Length);
			c_api.TF_AddInput(desc, example_weights);
			c_api.TF_AddInput(desc, example_labels);
			c_api.TF_AddInputList(desc, sparse_indices[0], sparse_indices.Length);
			c_api.TF_AddInputList(desc, sparse_weights[0], sparse_weights.Length);
			c_api.TF_AddInputList(desc, dense_weights[0], dense_weights.Length);
			c_api.TF_AddInput(desc, example_state_data);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "loss_type", loss_type);
			c_api.TF_SetAttrFloat (desc, "l1", l1);
			c_api.TF_SetAttrFloat (desc, "l2", l2);
			c_api.TF_SetAttrInt (desc, "num_loss_partitions", num_loss_partitions);
			c_api.TF_SetAttrInt (desc, "num_inner_iterations", num_inner_iterations);
			if (adaptive.HasValue)
				c_api.TF_SetAttrBool (desc, "adaptive", Convert.ToByte(adaptive.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			var out_example_state_data = new TF_Output (op, _idx++);
			_n = c_api.TF_OperationOutputListLength(op, "out_delta_sparse_weights", status);
			var out_delta_sparse_weights = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				out_delta_sparse_weights [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "out_delta_dense_weights", status);
			var out_delta_dense_weights = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				out_delta_dense_weights [i] = new TF_Output (op, _idx++);
			
			return (out_example_state_data, out_delta_sparse_weights, out_delta_dense_weights);
		}

		/// <summary>
		///   Applies L1 regularization shrink step on the parameters.
		/// </summary>
		/// <param name="weights">
		///   a list of vectors where each value is the weight associated with a
		///   feature group.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SdcaShrinkL1'.
		/// </param>
		/// <param name="l1">
		///   Symmetric l1 regularization strength.
		/// </param>
		/// <param name="l2">
		///   Symmetric l2 regularization strength. Should be a positive float.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation SdcaShrinkL1 (TF_Output[] weights, float l1, float l2, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SdcaShrinkL1", MakeName ("SdcaShrinkL1", operName));
			c_api.TF_AddInputList(desc, weights[0], weights.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFloat (desc, "l1", l1);
			c_api.TF_SetAttrFloat (desc, "l2", l2);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Computes the maximum along segments of a tensor.
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="segment_ids">
		///   A 1-D tensor whose size is equal to the size of <c>data</c>'s
		///   first dimension.  Values should be sorted and can be repeated.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SegmentMax'.
		/// </param>
		/// <returns>
		///   Has same shape as data, except for dimension 0 which
		///   has size <c>k</c>, the number of segments.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Read
		///   [the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)
		///   for an explanation of segments.
		///   
		///   Computes a tensor such that
		///   \\(output_i = \max_j(data_j)\\) where <c>max</c> is over <c>j</c> such
		///   that <c>segment_ids[j] == i</c>.
		///   
		///   If the max is empty for a given segment ID <c>i</c>, <c>output[i] = 0</c>.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/SegmentMax.png" alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		///   
		///   For example:
		///   
		///    <code>
		///   c = tf.constant([[1,2,3,4], [4, 3, 2, 1], [5,6,7,8]])
		///   tf.segment_max(c, tf.constant([0, 0, 1]))
		///   # ==&amp;gt; [[4, 3, 3, 4],
		///   #      [5, 6, 7, 8]]
		///    </code>
		///   
		/// </remarks>
		public TF_Output SegmentMax (TF_Output data, TF_Output segment_ids, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SegmentMax", MakeName ("SegmentMax", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, segment_ids);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the mean along segments of a tensor.
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="segment_ids">
		///   A 1-D tensor whose size is equal to the size of <c>data</c>'s
		///   first dimension.  Values should be sorted and can be repeated.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SegmentMean'.
		/// </param>
		/// <returns>
		///   Has same shape as data, except for dimension 0 which
		///   has size <c>k</c>, the number of segments.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Read
		///   [the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)
		///   for an explanation of segments.
		///   
		///   Computes a tensor such that
		///   \\(output_i = \frac{\sum_j data_j}{N}\\) where <c>mean</c> is
		///   over <c>j</c> such that <c>segment_ids[j] == i</c> and <c>N</c> is the total number of
		///   values summed.
		///   
		///   If the mean is empty for a given segment ID <c>i</c>, <c>output[i] = 0</c>.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/SegmentMean.png" alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		///   
		///   For example:
		///   
		///    <code>
		///   c = tf.constant([[1.0,2,3,4], [4, 3, 2, 1], [5,6,7,8]])
		///   tf.segment_mean(c, tf.constant([0, 0, 1]))
		///   # ==&amp;gt; [[2.5, 2.5, 2.5, 2.5],
		///   #      [5, 6, 7, 8]]
		///    </code>
		///   
		/// </remarks>
		public TF_Output SegmentMean (TF_Output data, TF_Output segment_ids, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SegmentMean", MakeName ("SegmentMean", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, segment_ids);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the minimum along segments of a tensor.
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="segment_ids">
		///   A 1-D tensor whose size is equal to the size of <c>data</c>'s
		///   first dimension.  Values should be sorted and can be repeated.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SegmentMin'.
		/// </param>
		/// <returns>
		///   Has same shape as data, except for dimension 0 which
		///   has size <c>k</c>, the number of segments.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Read
		///   [the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)
		///   for an explanation of segments.
		///   
		///   Computes a tensor such that
		///   \\(output_i = \min_j(data_j)\\) where <c>min</c> is over <c>j</c> such
		///   that <c>segment_ids[j] == i</c>.
		///   
		///   If the min is empty for a given segment ID <c>i</c>, <c>output[i] = 0</c>.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/SegmentMin.png" alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		///   
		///   For example:
		///   
		///    <code>
		///   c = tf.constant([[1,2,3,4], [4, 3, 2, 1], [5,6,7,8]])
		///   tf.segment_min(c, tf.constant([0, 0, 1]))
		///   # ==&amp;gt; [[1, 2, 2, 1],
		///   #      [5, 6, 7, 8]]
		///    </code>
		/// </remarks>
		public TF_Output SegmentMin (TF_Output data, TF_Output segment_ids, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SegmentMin", MakeName ("SegmentMin", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, segment_ids);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the product along segments of a tensor.
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="segment_ids">
		///   A 1-D tensor whose size is equal to the size of <c>data</c>'s
		///   first dimension.  Values should be sorted and can be repeated.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SegmentProd'.
		/// </param>
		/// <returns>
		///   Has same shape as data, except for dimension 0 which
		///   has size <c>k</c>, the number of segments.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Read
		///   [the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)
		///   for an explanation of segments.
		///   
		///   Computes a tensor such that
		///   \\(output_i = \prod_j data_j\\) where the product is over <c>j</c> such
		///   that <c>segment_ids[j] == i</c>.
		///   
		///   If the product is empty for a given segment ID <c>i</c>, <c>output[i] = 1</c>.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/SegmentProd.png" alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		///   
		///   For example:
		///   
		///    <code>
		///   c = tf.constant([[1,2,3,4], [4, 3, 2, 1], [5,6,7,8]])
		///   tf.segment_prod(c, tf.constant([0, 0, 1]))
		///   # ==&amp;gt; [[4, 6, 6, 4],
		///   #      [5, 6, 7, 8]]
		///    </code>
		///   
		/// </remarks>
		public TF_Output SegmentProd (TF_Output data, TF_Output segment_ids, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SegmentProd", MakeName ("SegmentProd", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, segment_ids);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the sum along segments of a tensor.
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="segment_ids">
		///   A 1-D tensor whose size is equal to the size of <c>data</c>'s
		///   first dimension.  Values should be sorted and can be repeated.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SegmentSum'.
		/// </param>
		/// <returns>
		///   Has same shape as data, except for dimension 0 which
		///   has size <c>k</c>, the number of segments.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Read
		///   [the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)
		///   for an explanation of segments.
		///   
		///   Computes a tensor such that
		///   \\(output_i = \sum_j data_j\\) where sum is over <c>j</c> such
		///   that <c>segment_ids[j] == i</c>.
		///   
		///   If the sum is empty for a given segment ID <c>i</c>, <c>output[i] = 0</c>.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/SegmentSum.png" alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		///   
		///   For example:
		///   
		///    <code>
		///   c = tf.constant([[1,2,3,4], [4, 3, 2, 1], [5,6,7,8]])
		///   tf.segment_sum(c, tf.constant([0, 0, 1]))
		///   # ==&amp;gt; [[5, 5, 5, 5],
		///   #      [5, 6, 7, 8]]
		///    </code>
		///   
		/// </remarks>
		public TF_Output SegmentSum (TF_Output data, TF_Output segment_ids, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SegmentSum", MakeName ("SegmentSum", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, segment_ids);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Selects elements from <c>x</c> or <c>y</c>, depending on <c>condition</c>.
		/// </summary>
		/// <param name="condition">
		/// </param>
		/// <param name="t">
		///   = A <c>Tensor</c> which may have the same shape as <c>condition</c>.
		///   If <c>condition</c> is rank 1, <c>x</c> may have higher rank,
		///   but its first dimension must match the size of <c>condition</c>.
		/// </param>
		/// <param name="e">
		///   = A <c>Tensor</c> with the same type and shape as <c>x</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Select'.
		/// </param>
		/// <returns>
		///   = A <c>Tensor</c> with the same type and shape as <c>x</c> and <c>y</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The <c>x</c>, and <c>y</c> tensors must all have the same shape, and the
		///   output will also have that shape.
		///   
		///   The <c>condition</c> tensor must be a scalar if <c>x</c> and <c>y</c> are scalars.
		///   If <c>x</c> and <c>y</c> are vectors or higher rank, then <c>condition</c> must be either a
		///   scalar, a vector with size matching the first dimension of <c>x</c>, or must have
		///   the same shape as <c>x</c>.
		///   
		///   The <c>condition</c> tensor acts as a mask that chooses, based on the value at each
		///   element, whether the corresponding element / row in the output should be
		///   taken from <c>x</c> (if true) or <c>y</c> (if false).
		///   
		///   If <c>condition</c> is a vector and <c>x</c> and <c>y</c> are higher rank matrices, then
		///   it chooses which row (outer dimension) to copy from <c>x</c> and <c>y</c>.
		///   If <c>condition</c> has the same shape as <c>x</c> and <c>y</c>, then it chooses which
		///   element to copy from <c>x</c> and <c>y</c>.
		///   
		///   For example:
		///   
		///    <code>
		///   # 'condition' tensor is [[True,  False]
		///   #                        [False, True]]
		///   # 't' is [[1, 2],
		///   #         [3, 4]]
		///   # 'e' is [[5, 6],
		///   #         [7, 8]]
		///   select(condition, t, e)  # =&amp;gt; [[1, 6], [7, 4]]
		///   
		///   
		///   # 'condition' tensor is [True, False]
		///   # 't' is [[1, 2],
		///   #         [3, 4]]
		///   # 'e' is [[5, 6],
		///   #         [7, 8]]
		///   select(condition, t, e) ==&amp;gt; [[1, 2],
		///   [7, 8]]
		///   
		///    </code>
		/// </remarks>
		public TF_Output Select (TF_Output condition, TF_Output t, TF_Output e, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Select", MakeName ("Select", operName));
			c_api.TF_AddInput(desc, condition);
			c_api.TF_AddInput(desc, t);
			c_api.TF_AddInput(desc, e);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="condition">
		/// </param>
		/// <param name="t">
		/// </param>
		/// <param name="e">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SelectV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SelectV2 (TF_Output condition, TF_Output t, TF_Output e, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SelectV2", MakeName ("SelectV2", operName));
			c_api.TF_AddInput(desc, condition);
			c_api.TF_AddInput(desc, t);
			c_api.TF_AddInput(desc, e);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the Eigen Decomposition of a batch of square self-adjoint matrices.
		/// </summary>
		/// <param name="input">
		///   Shape is <c>[..., M, M]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SelfAdjointEig'.
		/// </param>
		/// <returns>
		///   Shape is <c>[..., M+1, M]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The input is a tensor of shape <c>[..., M, M]</c> whose inner-most 2 dimensions
		///   form square matrices, with the same constraints as the single matrix
		///   SelfAdjointEig.
		///   
		///   The result is a [..., M+1, M] matrix with [..., 0,:] containing the
		///   eigenvalues, and subsequent [...,1:, :] containing the eigenvectors. The eigenvalues
		///   are sorted in non-decreasing order.
		/// </remarks>
		public TF_Output SelfAdjointEig (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SelfAdjointEig", MakeName ("SelfAdjointEig", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the eigen decomposition of one or more square self-adjoint matrices.
		/// </summary>
		/// <param name="input">
		///   <c>Tensor</c> input of shape <c>[N, N]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SelfAdjointEigV2'.
		/// </param>
		/// <param name="compute_v">
		///   Optional argument
		///   If <c>True</c> then eigenvectors will be computed and returned in <c>v</c>.
		///   Otherwise, only the eigenvalues will be computed.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   e: Eigenvalues. Shape is <c>[N]</c>.
		///   v: Eigenvectors. Shape is <c>[N, N]</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Computes the eigenvalues and (optionally) eigenvectors of each inner matrix in
		///   <c>input</c> such that <c>input[..., :, :] = v[..., :, :] * diag(e[..., :])</c>. The eigenvalues
		///   are sorted in non-decreasing order.
		///   
		///    <code>
		///   # a is a tensor.
		///   # e is a tensor of eigenvalues.
		///   # v is a tensor of eigenvectors.
		///   e, v = self_adjoint_eig(a)
		///   e = self_adjoint_eig(a, compute_v=False)
		///    </code>
		/// </remarks>
		public (TF_Output e, TF_Output v) SelfAdjointEigV2 (TF_Output input, bool? compute_v = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SelfAdjointEigV2", MakeName ("SelfAdjointEigV2", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (compute_v.HasValue)
				c_api.TF_SetAttrBool (desc, "compute_v", Convert.ToByte(compute_v.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var e = new TF_Output (op, _idx++);
			var v = new TF_Output (op, _idx++);
			return (e, v);
		}

		/// <summary>
		///   Computes scaled exponential linear: <c>scale * alpha * (exp(features) - 1)</c>
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Selu'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   if &amp;lt; 0, <c>scale * features</c> otherwise.
		///   
		///   To be used together with
		///   <c>initializer = tf.variance_scaling_initializer(factor=1.0, mode='FAN_IN')</c>.
		///   For correct dropout, use <c>tf.contrib.nn.alpha_dropout</c>.
		///   
		///   See [Self-Normalizing Neural Networks](https://arxiv.org/abs/1706.02515)
		/// </remarks>
		public TF_Output Selu (TF_Output features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Selu", MakeName ("Selu", operName));
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var activations = new TF_Output (op, _idx++);
			return activations;
		}

		/// <summary>
		///   Computes gradients for the scaled exponential linear (Selu) operation.
		/// </summary>
		/// <param name="gradients">
		///   The backpropagated gradients to the corresponding Selu operation.
		/// </param>
		/// <param name="outputs">
		///   The outputs of the corresponding Selu operation.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SeluGrad'.
		/// </param>
		/// <returns>
		///   The gradients: <c>gradients * (outputs + scale * alpha)</c>
		///   if outputs &amp;lt; 0, <c>scale * gradients</c> otherwise.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SeluGrad (TF_Output gradients, TF_Output outputs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SeluGrad", MakeName ("SeluGrad", operName));
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, outputs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var backprops = new TF_Output (op, _idx++);
			return backprops;
		}

		/// <summary>
		///   Performs gradient updates of embedding tables.
		/// </summary>
		/// <param name="inputs">
		///   A TensorList of gradients with which to update embedding tables.
		///   This argument has the same length and shapes as the return value of
		///   RecvTPUEmbeddingActivations, but contains gradients of the model's loss
		///   with respect to the embedding activations. The embedding tables are updated
		///   from these gradients via the optimizer specified in the TPU embedding
		///   configuration given to tpu.initialize_system.
		/// </param>
		/// <param name="learning_rates">
		///   A TensorList of float32 scalars, one for each dynamic learning
		///   rate tag: see the comments in
		///   //third_party/tensorflow/core/protobuf/tpu/optimization_parameters.proto.
		///   Multiple tables can share the same dynamic learning rate tag as specified
		///   in the configuration. If the learning rates for all tables are constant,
		///   this list should be empty.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SendTPUEmbeddingGradients'.
		/// </param>
		/// <param name="config">
		///   Serialized TPUEmbeddingConfiguration proto.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation SendTPUEmbeddingGradients (TF_Output[] inputs, TF_Output[] learning_rates, string config, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SendTPUEmbeddingGradients", MakeName ("SendTPUEmbeddingGradients", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			c_api.TF_AddInputList(desc, learning_rates[0], learning_rates.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "config", config);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Converts the given <c>resource_handle</c> representing an iterator to a variant tensor.
		/// </summary>
		/// <param name="resource_handle">
		///   A handle to an iterator resource.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SerializeIterator'.
		/// </param>
		/// <returns>
		///   A variant tensor storing the state of the iterator contained in the
		///   resource.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SerializeIterator (TF_Output resource_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SerializeIterator", MakeName ("SerializeIterator", operName));
			c_api.TF_AddInput(desc, resource_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var serialized = new TF_Output (op, _idx++);
			return serialized;
		}

		/// <summary>
		///   Serialize an <c>N</c>-minibatch <c>SparseTensor</c> into an <c>[N, 3]</c> <c>Tensor</c> object.
		/// </summary>
		/// <param name="sparse_indices">
		///   2-D.  The <c>indices</c> of the minibatch <c>SparseTensor</c>.
		/// </param>
		/// <param name="sparse_values">
		///   1-D.  The <c>values</c> of the minibatch <c>SparseTensor</c>.
		/// </param>
		/// <param name="sparse_shape">
		///   1-D.  The <c>shape</c> of the minibatch <c>SparseTensor</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SerializeManySparse'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		///   The <c>dtype</c> to use for serialization; the supported types are <c>string</c>
		///   (default) and <c>variant</c>.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The <c>SparseTensor</c> must have rank <c>R</c> greater than 1, and the first dimension
		///   is treated as the minibatch dimension.  Elements of the <c>SparseTensor</c>
		///   must be sorted in increasing order of this first dimension.  The serialized
		///   <c>SparseTensor</c> objects going into each row of <c>serialized_sparse</c> will have
		///   rank <c>R-1</c>.
		///   
		///   The minibatch size <c>N</c> is extracted from <c>sparse_shape[0]</c>.
		/// </remarks>
		public TF_Output SerializeManySparse (TF_Output sparse_indices, TF_Output sparse_values, TF_Output sparse_shape, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SerializeManySparse", MakeName ("SerializeManySparse", operName));
			c_api.TF_AddInput(desc, sparse_indices);
			c_api.TF_AddInput(desc, sparse_values);
			c_api.TF_AddInput(desc, sparse_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var serialized_sparse = new TF_Output (op, _idx++);
			return serialized_sparse;
		}

		/// <summary>
		///   Serialize a <c>SparseTensor</c> into a <c>[3]</c> <c>Tensor</c> object.
		/// </summary>
		/// <param name="sparse_indices">
		///   2-D.  The <c>indices</c> of the <c>SparseTensor</c>.
		/// </param>
		/// <param name="sparse_values">
		///   1-D.  The <c>values</c> of the <c>SparseTensor</c>.
		/// </param>
		/// <param name="sparse_shape">
		///   1-D.  The <c>shape</c> of the <c>SparseTensor</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SerializeSparse'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		///   The <c>dtype</c> to use for serialization; the supported types are <c>string</c>
		///   (default) and <c>variant</c>.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SerializeSparse (TF_Output sparse_indices, TF_Output sparse_values, TF_Output sparse_shape, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SerializeSparse", MakeName ("SerializeSparse", operName));
			c_api.TF_AddInput(desc, sparse_indices);
			c_api.TF_AddInput(desc, sparse_values);
			c_api.TF_AddInput(desc, sparse_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var serialized_sparse = new TF_Output (op, _idx++);
			return serialized_sparse;
		}

		/// <summary>
		///   Transforms a Tensor into a serialized TensorProto proto.
		/// </summary>
		/// <param name="tensor">
		///   A Tensor of type <c>T</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SerializeTensor'.
		/// </param>
		/// <returns>
		///   A serialized TensorProto proto of the input tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SerializeTensor (TF_Output tensor, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SerializeTensor", MakeName ("SerializeTensor", operName));
			c_api.TF_AddInput(desc, tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var serialized = new TF_Output (op, _idx++);
			return serialized;
		}

		/// <summary>
		///   Number of unique elements along last dimension of input <c>set</c>.
		/// </summary>
		/// <param name="set_indices">
		///   2D <c>Tensor</c>, indices of a <c>SparseTensor</c>.
		/// </param>
		/// <param name="set_values">
		///   1D <c>Tensor</c>, values of a <c>SparseTensor</c>.
		/// </param>
		/// <param name="set_shape">
		///   1D <c>Tensor</c>, shape of a <c>SparseTensor</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SetSize'.
		/// </param>
		/// <param name="validate_indices">
		///   Optional argument
		/// </param>
		/// <returns>
		///   For <c>set</c> ranked <c>n</c>, this is a <c>Tensor</c> with rank <c>n-1</c>, and the same 1st
		///   <c>n-1</c> dimensions as <c>set</c>. Each value is the number of unique elements in
		///   the corresponding <c>[0...n-1]</c> dimension of <c>set</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Input <c>set</c> is a <c>SparseTensor</c> represented by <c>set_indices</c>, <c>set_values</c>,
		///   and <c>set_shape</c>. The last dimension contains values in a set, duplicates are
		///   allowed but ignored.
		///   
		///   If <c>validate_indices</c> is <c>True</c>, this op validates the order and range of <c>set</c>
		///   indices.
		/// </remarks>
		public TF_Output SetSize (TF_Output set_indices, TF_Output set_values, TF_Output set_shape, bool? validate_indices = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SetSize", MakeName ("SetSize", operName));
			c_api.TF_AddInput(desc, set_indices);
			c_api.TF_AddInput(desc, set_values);
			c_api.TF_AddInput(desc, set_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (validate_indices.HasValue)
				c_api.TF_SetAttrBool (desc, "validate_indices", Convert.ToByte(validate_indices.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="stats_aggregator">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="counter_prefix">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SetStatsAggregatorDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SetStatsAggregatorDataset (TF_Output input_dataset, TF_Output stats_aggregator, TF_Output tag, TF_Output counter_prefix, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SetStatsAggregatorDataset", MakeName ("SetStatsAggregatorDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, stats_aggregator);
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, counter_prefix);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Returns the shape of a tensor.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Shape'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation returns a 1-D integer tensor representing the shape of <c>input</c>.
		///   
		///   For example:
		///   
		///    <code>
		///   # 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]
		///   shape(t) ==&amp;gt; [2, 2, 3]
		///    </code>
		/// </remarks>
		public TF_Output Shape (TF_Output input, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Shape", MakeName ("Shape", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns shape of tensors.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ShapeN'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation returns N 1-D integer tensors representing shape of <c>input[i]s</c>.
		/// </remarks>
		public TF_Output[] ShapeN (TF_Output[] input, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ShapeN", MakeName ("ShapeN", operName));
			c_api.TF_AddInputList(desc, input[0], input.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		///   Creates a <c>Dataset</c> that includes only 1/<c>num_shards</c> of this dataset.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="num_shards">
		///   An integer representing the number of shards operating in parallel.
		/// </param>
		/// <param name="index">
		///   An integer representing the current worker index.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ShardDataset'.
		/// </param>
		/// <param name="require_non_empty">
		///   Optional argument
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ShardDataset (TF_Output input_dataset, TF_Output num_shards, TF_Output index, TF_DataType[] output_types, long[][] output_shapes, bool? require_non_empty = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ShardDataset", MakeName ("ShardDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, num_shards);
			c_api.TF_AddInput(desc, index);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (require_non_empty.HasValue)
				c_api.TF_SetAttrBool (desc, "require_non_empty", Convert.ToByte(require_non_empty.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Generate a sharded filename. The filename is printf formatted as
		/// </summary>
		/// <param name="basename">
		/// </param>
		/// <param name="shard">
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ShardedFilename'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   %s-%05d-of-%05d, basename, shard, num_shards.
		/// </remarks>
		public TF_Output ShardedFilename (TF_Output basename, TF_Output shard, TF_Output num_shards, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ShardedFilename", MakeName ("ShardedFilename", operName));
			c_api.TF_AddInput(desc, basename);
			c_api.TF_AddInput(desc, shard);
			c_api.TF_AddInput(desc, num_shards);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var filename = new TF_Output (op, _idx++);
			return filename;
		}

		/// <summary>
		///   Generate a glob pattern matching all sharded file names.
		/// </summary>
		/// <param name="basename">
		/// </param>
		/// <param name="num_shards">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ShardedFilespec'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ShardedFilespec (TF_Output basename, TF_Output num_shards, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ShardedFilespec", MakeName ("ShardedFilespec", operName));
			c_api.TF_AddInput(desc, basename);
			c_api.TF_AddInput(desc, num_shards);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var filename = new TF_Output (op, _idx++);
			return filename;
		}

		/// <summary>
		///   Creates a dataset that shuffles and repeats elements from <c>input_dataset</c>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="buffer_size">
		///   The number of output elements to buffer in an iterator over
		///   this dataset. Compare with the <c>min_after_dequeue</c> attr when creating a
		///   <c>RandomShuffleQueue</c>.
		/// </param>
		/// <param name="seed">
		///   A scalar seed for the random number generator. If either <c>seed</c> or
		///   <c>seed2</c> is set to be non-zero, the random number generator is seeded
		///   by the given seed.  Otherwise, a random seed is used.
		/// </param>
		/// <param name="seed2">
		///   A second scalar seed to avoid seed collision.
		/// </param>
		/// <param name="count">
		///   A scalar representing the number of times the underlying dataset
		///   should be repeated. The default is <c>-1</c>, which results in infinite repetition.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ShuffleAndRepeatDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   pseudorandomly.
		/// </remarks>
		public TF_Output ShuffleAndRepeatDataset (TF_Output input_dataset, TF_Output buffer_size, TF_Output seed, TF_Output seed2, TF_Output count, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ShuffleAndRepeatDataset", MakeName ("ShuffleAndRepeatDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, buffer_size);
			c_api.TF_AddInput(desc, seed);
			c_api.TF_AddInput(desc, seed2);
			c_api.TF_AddInput(desc, count);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that shuffles elements from <c>input_dataset</c> pseudorandomly.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="buffer_size">
		///   The number of output elements to buffer in an iterator over
		///   this dataset. Compare with the <c>min_after_dequeue</c> attr when creating a
		///   <c>RandomShuffleQueue</c>.
		/// </param>
		/// <param name="seed">
		///   A scalar seed for the random number generator. If either <c>seed</c> or
		///   <c>seed2</c> is set to be non-zero, the random number generator is seeded
		///   by the given seed.  Otherwise, a random seed is used.
		/// </param>
		/// <param name="seed2">
		///   A second scalar seed to avoid seed collision.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ShuffleDataset'.
		/// </param>
		/// <param name="reshuffle_each_iteration">
		///   Optional argument
		///   If true, each iterator over this dataset will be given
		///   a different pseudorandomly generated seed, based on a sequence seeded by the
		///   <c>seed</c> and <c>seed2</c> inputs. If false, each iterator will be given the same
		///   seed, and repeated iteration over this dataset will yield the exact same
		///   sequence of results.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ShuffleDataset (TF_Output input_dataset, TF_Output buffer_size, TF_Output seed, TF_Output seed2, TF_DataType[] output_types, long[][] output_shapes, bool? reshuffle_each_iteration = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ShuffleDataset", MakeName ("ShuffleDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, buffer_size);
			c_api.TF_AddInput(desc, seed);
			c_api.TF_AddInput(desc, seed2);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (reshuffle_each_iteration.HasValue)
				c_api.TF_SetAttrBool (desc, "reshuffle_each_iteration", Convert.ToByte(reshuffle_each_iteration.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="buffer_size">
		/// </param>
		/// <param name="seed_generator">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ShuffleDatasetV2'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ShuffleDatasetV2 (TF_Output input_dataset, TF_Output buffer_size, TF_Output seed_generator, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ShuffleDatasetV2", MakeName ("ShuffleDatasetV2", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, buffer_size);
			c_api.TF_AddInput(desc, seed_generator);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Shuts down a running distributed TPU system.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ShutdownDistributedTPU'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   The op returns an error if no system is running.
		/// </remarks>
		public TF_Operation ShutdownDistributedTPU (string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ShutdownDistributedTPU", MakeName ("ShutdownDistributedTPU", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Computes sigmoid of <c>x</c> element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Sigmoid'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Specifically, <c>y = 1 / (1 + exp(-x))</c>.
		/// </remarks>
		public TF_Output Sigmoid (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Sigmoid", MakeName ("Sigmoid", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes the gradient of the sigmoid of <c>x</c> wrt its input.
		/// </summary>
		/// <param name="y">
		/// </param>
		/// <param name="dy">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SigmoidGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Specifically, <c>grad = dy * y * (1 - y)</c>, where <c>y = sigmoid(x)</c>, and
		///   <c>dy</c> is the corresponding input gradient.
		/// </remarks>
		public TF_Output SigmoidGrad (TF_Output y, TF_Output dy, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SigmoidGrad", MakeName ("SigmoidGrad", operName));
			c_api.TF_AddInput(desc, y);
			c_api.TF_AddInput(desc, dy);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Returns an element-wise indication of the sign of a number.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Sign'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   <c>y = sign(x) = -1</c> if <c>x &amp;lt; 0</c>; 0 if <c>x == 0</c>; 1 if <c>x &amp;gt; 0</c>.
		///   
		///   For complex numbers, <c>y = sign(x) = x / |x|</c> if <c>x != 0</c>, otherwise <c>y = 0</c>.
		/// </remarks>
		public TF_Output Sign (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Sign", MakeName ("Sign", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes sine of x element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Sin'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given an input tensor, this function computes sine of every
		///   element in the tensor. Input range is <c>(-inf, inf)</c> and
		///   output range is <c>[-1,1]</c>.
		///   
		///    <code>
		///   x = tf.constant([-float("inf"), -9, -0.5, 1, 1.2, 200, 10, float("inf")])
		///   tf.math.sin(x) ==&amp;gt; [nan -0.4121185 -0.47942555 0.84147096 0.9320391 -0.87329733 -0.54402107 nan]
		///    </code>
		/// </remarks>
		public TF_Output Sin (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Sin", MakeName ("Sin", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes hyperbolic sine of x element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Sinh'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given an input tensor, this function computes hyperbolic sine of every
		///   element in the tensor. Input range is <c>[-inf,inf]</c> and output range
		///   is <c>[-inf,inf]</c>.
		///   
		///    <code>
		///   x = tf.constant([-float("inf"), -9, -0.5, 1, 1.2, 2, 10, float("inf")])
		///   tf.math.sinh(x) ==&amp;gt; [-inf -4.0515420e+03 -5.2109528e-01 1.1752012e+00 1.5094614e+00 3.6268604e+00 1.1013232e+04 inf]
		///    </code>
		/// </remarks>
		public TF_Output Sinh (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Sinh", MakeName ("Sinh", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Returns the size of a tensor.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Size'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation returns an integer representing the number of elements in
		///   <c>input</c>.
		///   
		///   For example:
		///   
		///    <code>
		///   # 't' is [[[1, 1,, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]
		///   size(t) ==&amp;gt; 12
		///    </code>
		/// </remarks>
		public TF_Output Size (TF_Output input, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Size", MakeName ("Size", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates a dataset that skips <c>count</c> elements from the <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="count">
		///   A scalar representing the number of elements from the <c>input_dataset</c>
		///   that should be skipped.  If count is -1, skips everything.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SkipDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SkipDataset (TF_Output input_dataset, TF_Output count, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SkipDataset", MakeName ("SkipDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, count);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Parses a text file and creates a batch of examples.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Skipgram'.
		/// </param>
		/// <param name="window_size">
		///   Optional argument
		///   The number of words to predict to the left and right of the target.
		/// </param>
		/// <param name="min_count">
		///   Optional argument
		///   The minimum number of word occurrences for it to be included in the
		///   vocabulary.
		/// </param>
		/// <param name="subsample">
		///   Optional argument
		///   Threshold for word occurrence. Words that appear with higher
		///   frequency will be randomly down-sampled. Set to 0 to disable.
		/// </param>
		/// <param name="filename">
		///   The corpus's text file name.
		/// </param>
		/// <param name="batch_size">
		///   The size of produced batch.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   vocab_word: A vector of words in the corpus.
		///   vocab_freq: Frequencies of words. Sorted in the non-ascending order.
		///   words_per_epoch: Number of words per epoch in the data file.
		///   current_epoch: The current epoch number.
		///   total_words_processed: The total number of words processed so far.
		///   examples: A vector of word ids.
		///   labels: A vector of word ids.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output vocab_word, TF_Output vocab_freq, TF_Output words_per_epoch, TF_Output current_epoch, TF_Output total_words_processed, TF_Output examples, TF_Output labels) Skipgram (string filename, long batch_size, long? window_size = null, long? min_count = null, float? subsample = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Skipgram", MakeName ("Skipgram", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "filename", filename);
			c_api.TF_SetAttrInt (desc, "batch_size", batch_size);
			if (window_size.HasValue)
				c_api.TF_SetAttrInt (desc, "window_size", window_size.Value);
			
			if (min_count.HasValue)
				c_api.TF_SetAttrInt (desc, "min_count", min_count.Value);
			
			if (subsample.HasValue)
				c_api.TF_SetAttrFloat (desc, "subsample", subsample.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var vocab_word = new TF_Output (op, _idx++);
			var vocab_freq = new TF_Output (op, _idx++);
			var words_per_epoch = new TF_Output (op, _idx++);
			var current_epoch = new TF_Output (op, _idx++);
			var total_words_processed = new TF_Output (op, _idx++);
			var examples = new TF_Output (op, _idx++);
			var labels = new TF_Output (op, _idx++);
			return (vocab_word, vocab_freq, words_per_epoch, current_epoch, total_words_processed, examples, labels);
		}

		/// <summary>
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="sleep_microseconds">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SleepDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SleepDataset (TF_Output input_dataset, TF_Output sleep_microseconds, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SleepDataset", MakeName ("SleepDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, sleep_microseconds);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Return a slice from 'input'.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="begin">
		///   begin[i] specifies the offset into the 'i'th dimension of
		///   'input' to slice from.
		/// </param>
		/// <param name="size">
		///   size[i] specifies the number of elements of the 'i'th dimension
		///   of 'input' to slice. If size[i] is -1, all remaining elements in dimension
		///   i are included in the slice (i.e. this is equivalent to setting
		///   size[i] = input.dim_size(i) - begin[i]).
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Slice'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The output tensor is a tensor with dimensions described by 'size'
		///   whose values are extracted from 'input' starting at the offsets in
		///   'begin'.
		///   
		///   *Requirements*:
		///   0 &amp;lt;= begin[i] &amp;lt;= begin[i] + size[i] &amp;lt;= Di  for i in [0, n)
		/// </remarks>
		public TF_Output Slice (TF_Output input, TF_Output begin, TF_Output size, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Slice", MakeName ("Slice", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, begin);
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates a dataset that passes a sliding window over <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="window_size">
		///   A scalar representing the number of elements in the
		///   sliding window.
		/// </param>
		/// <param name="window_shift">
		///   A scalar representing the steps moving the sliding window
		///   forward in one iteration. It must be positive.
		/// </param>
		/// <param name="window_stride">
		///   A scalar representing the stride of the input elements of the sliding window.
		///   It must be positive.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SlidingWindowDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SlidingWindowDataset (TF_Output input_dataset, TF_Output window_size, TF_Output window_shift, TF_Output window_stride, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SlidingWindowDataset", MakeName ("SlidingWindowDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, window_size);
			c_api.TF_AddInput(desc, window_shift);
			c_api.TF_AddInput(desc, window_stride);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Returns a copy of the input tensor.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Snapshot'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Snapshot (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Snapshot", MakeName ("Snapshot", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates a dataset that will write to / read from a snapshot.
		/// </summary>
		/// <param name="input_dataset">
		///   A variant tensor representing the input dataset.
		/// </param>
		/// <param name="path">
		///   The path we should write snapshots to / read snapshots from.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SnapshotDataset'.
		/// </param>
		/// <param name="compression">
		///   Optional argument
		/// </param>
		/// <param name="reader_path_prefix">
		///   Optional argument
		/// </param>
		/// <param name="writer_path_prefix">
		///   Optional argument
		/// </param>
		/// <param name="shard_size_bytes">
		///   Optional argument
		/// </param>
		/// <param name="pending_snapshot_expiry_seconds">
		///   Optional argument
		/// </param>
		/// <param name="num_reader_threads">
		///   Optional argument
		/// </param>
		/// <param name="reader_buffer_size">
		///   Optional argument
		/// </param>
		/// <param name="num_writer_threads">
		///   Optional argument
		/// </param>
		/// <param name="writer_buffer_size">
		///   Optional argument
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This dataset attempts to determine whether a valid snapshot exists at the
		///   <c>snapshot_path</c>, and reads from the snapshot in lieu of using <c>input_dataset</c>.
		///   If not, it will run the preprocessing pipeline as usual, and write out a
		///   snapshot of the data processed for future use.
		/// </remarks>
		public TF_Output SnapshotDataset (TF_Output input_dataset, TF_Output path, TF_DataType[] output_types, long[][] output_shapes, string compression = null, string reader_path_prefix = null, string writer_path_prefix = null, long? shard_size_bytes = null, long? pending_snapshot_expiry_seconds = null, long? num_reader_threads = null, long? reader_buffer_size = null, long? num_writer_threads = null, long? writer_buffer_size = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SnapshotDataset", MakeName ("SnapshotDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, path);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			if (compression != null)
				c_api.TF_SetAttrString (desc, "compression", compression);
			
			if (reader_path_prefix != null)
				c_api.TF_SetAttrString (desc, "reader_path_prefix", reader_path_prefix);
			
			if (writer_path_prefix != null)
				c_api.TF_SetAttrString (desc, "writer_path_prefix", writer_path_prefix);
			
			if (shard_size_bytes.HasValue)
				c_api.TF_SetAttrInt (desc, "shard_size_bytes", shard_size_bytes.Value);
			
			if (pending_snapshot_expiry_seconds.HasValue)
				c_api.TF_SetAttrInt (desc, "pending_snapshot_expiry_seconds", pending_snapshot_expiry_seconds.Value);
			
			if (num_reader_threads.HasValue)
				c_api.TF_SetAttrInt (desc, "num_reader_threads", num_reader_threads.Value);
			
			if (reader_buffer_size.HasValue)
				c_api.TF_SetAttrInt (desc, "reader_buffer_size", reader_buffer_size.Value);
			
			if (num_writer_threads.HasValue)
				c_api.TF_SetAttrInt (desc, "num_writer_threads", num_writer_threads.Value);
			
			if (writer_buffer_size.HasValue)
				c_api.TF_SetAttrInt (desc, "writer_buffer_size", writer_buffer_size.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Computes softmax activations.
		/// </summary>
		/// <param name="logits">
		///   2-D with shape <c>[batch_size, num_classes]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Softmax'.
		/// </param>
		/// <returns>
		///   Same shape as <c>logits</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   For each batch <c>i</c> and class <c>j</c> we have
		///   
		///   $$softmax[i, j] = exp(logits[i, j]) / sum_j(exp(logits[i, j]))$$
		/// </remarks>
		public TF_Output Softmax (TF_Output logits, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Softmax", MakeName ("Softmax", operName));
			c_api.TF_AddInput(desc, logits);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var softmax = new TF_Output (op, _idx++);
			return softmax;
		}

		/// <summary>
		///   Computes softmax cross entropy cost and gradients to backpropagate.
		/// </summary>
		/// <param name="features">
		///   batch_size x num_classes matrix
		/// </param>
		/// <param name="labels">
		///   batch_size x num_classes matrix
		///   The caller must ensure that each batch of labels represents a valid
		///   probability distribution.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SoftmaxCrossEntropyWithLogits'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   loss: Per example loss (batch_size vector).
		///   backprop: backpropagated gradients (batch_size x num_classes matrix).
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Inputs are the logits, not probabilities.
		/// </remarks>
		public (TF_Output loss, TF_Output backprop) SoftmaxCrossEntropyWithLogits (TF_Output features, TF_Output labels, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SoftmaxCrossEntropyWithLogits", MakeName ("SoftmaxCrossEntropyWithLogits", operName));
			c_api.TF_AddInput(desc, features);
			c_api.TF_AddInput(desc, labels);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var loss = new TF_Output (op, _idx++);
			var backprop = new TF_Output (op, _idx++);
			return (loss, backprop);
		}

		/// <summary>
		///   Computes softplus: <c>log(exp(features) + 1)</c>.
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Softplus'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Softplus (TF_Output features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Softplus", MakeName ("Softplus", operName));
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var activations = new TF_Output (op, _idx++);
			return activations;
		}

		/// <summary>
		///   Computes softplus gradients for a softplus operation.
		/// </summary>
		/// <param name="gradients">
		///   The backpropagated gradients to the corresponding softplus operation.
		/// </param>
		/// <param name="features">
		///   The features passed as input to the corresponding softplus operation.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SoftplusGrad'.
		/// </param>
		/// <returns>
		///   The gradients: <c>gradients / (1 + exp(-features))</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SoftplusGrad (TF_Output gradients, TF_Output features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SoftplusGrad", MakeName ("SoftplusGrad", operName));
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var backprops = new TF_Output (op, _idx++);
			return backprops;
		}

		/// <summary>
		///   Computes softsign: <c>features / (abs(features) + 1)</c>.
		/// </summary>
		/// <param name="features">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Softsign'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Softsign (TF_Output features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Softsign", MakeName ("Softsign", operName));
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var activations = new TF_Output (op, _idx++);
			return activations;
		}

		/// <summary>
		///   Computes softsign gradients for a softsign operation.
		/// </summary>
		/// <param name="gradients">
		///   The backpropagated gradients to the corresponding softsign operation.
		/// </param>
		/// <param name="features">
		///   The features passed as input to the corresponding softsign operation.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SoftsignGrad'.
		/// </param>
		/// <returns>
		///   The gradients: <c>gradients / (1 + abs(features)) ** 2</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SoftsignGrad (TF_Output gradients, TF_Output features, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SoftsignGrad", MakeName ("SoftsignGrad", operName));
			c_api.TF_AddInput(desc, gradients);
			c_api.TF_AddInput(desc, features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var backprops = new TF_Output (op, _idx++);
			return backprops;
		}

		/// <summary>
		///   SpaceToBatch for 4-D tensors of type T.
		/// </summary>
		/// <param name="input">
		///   4-D with shape <c>[batch, height, width, depth]</c>.
		/// </param>
		/// <param name="paddings">
		///   2-D tensor of non-negative integers with shape <c>[2, 2]</c>. It specifies
		///   the padding of the input with zeros across the spatial dimensions as follows:
		///   
		///   paddings = [[pad_top, pad_bottom], [pad_left, pad_right]]
		///   
		///   The effective spatial dimensions of the zero-padded input tensor will be:
		///   
		///   height_pad = pad_top + height + pad_bottom
		///   width_pad = pad_left + width + pad_right
		///   
		///   The attr <c>block_size</c> must be greater than one. It indicates the block size.
		///   
		///   * Non-overlapping blocks of size <c>block_size x block size</c> in the height and
		///   width dimensions are rearranged into the batch dimension at each location.
		///   * The batch of the output tensor is <c>batch * block_size * block_size</c>.
		///   * Both height_pad and width_pad must be divisible by block_size.
		///   
		///   The shape of the output will be:
		///   
		///   [batch*block_size*block_size, height_pad/block_size, width_pad/block_size,
		///   depth]
		///   
		///   Some examples:
		///   
		///   (1) For the following input of shape <c>[1, 2, 2, 1]</c> and block_size of 2:
		///   
		///    <code>
		///   x = [[[[1], [2]], [[3], [4]]]]
		///    </code>
		///   
		///   The output tensor has shape <c>[4, 1, 1, 1]</c> and value:
		///   
		///    <code>
		///   [[[[1]]], [[[2]]], [[[3]]], [[[4]]]]
		///    </code>
		///   
		///   (2) For the following input of shape <c>[1, 2, 2, 3]</c> and block_size of 2:
		///   
		///    <code>
		///   x = [[[[1, 2, 3], [4, 5, 6]],
		///   [[7, 8, 9], [10, 11, 12]]]]
		///    </code>
		///   
		///   The output tensor has shape <c>[4, 1, 1, 3]</c> and value:
		///   
		///    <code>
		///   [[[[1, 2, 3]]], [[[4, 5, 6]]], [[[7, 8, 9]]], [[[10, 11, 12]]]]
		///    </code>
		///   
		///   (3) For the following input of shape <c>[1, 4, 4, 1]</c> and block_size of 2:
		///   
		///    <code>
		///   x = [[[[1],   [2],  [3],  [4]],
		///   [[5],   [6],  [7],  [8]],
		///   [[9],  [10], [11],  [12]],
		///   [[13], [14], [15],  [16]]]]
		///    </code>
		///   
		///   The output tensor has shape <c>[4, 2, 2, 1]</c> and value:
		///   
		///    <code>
		///   x = [[[[1], [3]], [[9], [11]]],
		///   [[[2], [4]], [[10], [12]]],
		///   [[[5], [7]], [[13], [15]]],
		///   [[[6], [8]], [[14], [16]]]]
		///    </code>
		///   
		///   (4) For the following input of shape <c>[2, 2, 4, 1]</c> and block_size of 2:
		///   
		///    <code>
		///   x = [[[[1],   [2],  [3],  [4]],
		///   [[5],   [6],  [7],  [8]]],
		///   [[[9],  [10], [11],  [12]],
		///   [[13], [14], [15],  [16]]]]
		///    </code>
		///   
		///   The output tensor has shape <c>[8, 1, 2, 1]</c> and value:
		///   
		///    <code>
		///   x = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],
		///   [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]
		///    </code>
		///   
		///   Among others, this operation is useful for reducing atrous convolution into
		///   regular convolution.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SpaceToBatch'.
		/// </param>
		/// <param name="block_size">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This is a legacy version of the more general SpaceToBatchND.
		///   
		///   Zero-pads and then rearranges (permutes) blocks of spatial data into batch.
		///   More specifically, this op outputs a copy of the input tensor where values from
		///   the <c>height</c> and <c>width</c> dimensions are moved to the <c>batch</c> dimension. After
		///   the zero-padding, both <c>height</c> and <c>width</c> of the input must be divisible by the
		///   block size.
		/// </remarks>
		public TF_Output SpaceToBatch (TF_Output input, TF_Output paddings, long block_size, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SpaceToBatch", MakeName ("SpaceToBatch", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, paddings);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "block_size", block_size);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   SpaceToBatch for N-D tensors of type T.
		/// </summary>
		/// <param name="input">
		///   N-D with shape <c>input_shape = [batch] + spatial_shape + remaining_shape</c>,
		///   where spatial_shape has <c>M</c> dimensions.
		/// </param>
		/// <param name="block_shape">
		///   1-D with shape <c>[M]</c>, all values must be &amp;gt;= 1.
		/// </param>
		/// <param name="paddings">
		///   2-D with shape <c>[M, 2]</c>, all values must be &amp;gt;= 0.
		///   <c>paddings[i] = [pad_start, pad_end]</c> specifies the padding for input dimension
		///   <c>i + 1</c>, which corresponds to spatial dimension <c>i</c>.  It is required that
		///   <c>block_shape[i]</c> divides <c>input_shape[i + 1] + pad_start + pad_end</c>.
		///   
		///   This operation is equivalent to the following steps:
		///   
		///   1. Zero-pad the start and end of dimensions <c>[1, ..., M]</c> of the
		///   input according to <c>paddings</c> to produce <c>padded</c> of shape <c>padded_shape</c>.
		///   
		///   2. Reshape <c>padded</c> to <c>reshaped_padded</c> of shape:
		///   
		///   [batch] +
		///   [padded_shape[1] / block_shape[0],
		///   block_shape[0],
		///   ...,
		///   padded_shape[M] / block_shape[M-1],
		///   block_shape[M-1]] +
		///   remaining_shape
		///   
		///   3. Permute dimensions of <c>reshaped_padded</c> to produce
		///   <c>permuted_reshaped_padded</c> of shape:
		///   
		///   block_shape +
		///   [batch] +
		///   [padded_shape[1] / block_shape[0],
		///   ...,
		///   padded_shape[M] / block_shape[M-1]] +
		///   remaining_shape
		///   
		///   4. Reshape <c>permuted_reshaped_padded</c> to flatten <c>block_shape</c> into the batch
		///   dimension, producing an output tensor of shape:
		///   
		///   [batch * prod(block_shape)] +
		///   [padded_shape[1] / block_shape[0],
		///   ...,
		///   padded_shape[M] / block_shape[M-1]] +
		///   remaining_shape
		///   
		///   Some examples:
		///   
		///   (1) For the following input of shape <c>[1, 2, 2, 1]</c>, <c>block_shape = [2, 2]</c>, and
		///   <c>paddings = [[0, 0], [0, 0]]</c>:
		///   
		///    <code>
		///   x = [[[[1], [2]], [[3], [4]]]]
		///    </code>
		///   
		///   The output tensor has shape <c>[4, 1, 1, 1]</c> and value:
		///   
		///    <code>
		///   [[[[1]]], [[[2]]], [[[3]]], [[[4]]]]
		///    </code>
		///   
		///   (2) For the following input of shape <c>[1, 2, 2, 3]</c>, <c>block_shape = [2, 2]</c>, and
		///   <c>paddings = [[0, 0], [0, 0]]</c>:
		///   
		///    <code>
		///   x = [[[[1, 2, 3], [4, 5, 6]],
		///   [[7, 8, 9], [10, 11, 12]]]]
		///    </code>
		///   
		///   The output tensor has shape <c>[4, 1, 1, 3]</c> and value:
		///   
		///    <code>
		///   [[[[1, 2, 3]]], [[[4, 5, 6]]], [[[7, 8, 9]]], [[[10, 11, 12]]]]
		///    </code>
		///   
		///   (3) For the following input of shape <c>[1, 4, 4, 1]</c>, <c>block_shape = [2, 2]</c>, and
		///   <c>paddings = [[0, 0], [0, 0]]</c>:
		///   
		///    <code>
		///   x = [[[[1],   [2],  [3],  [4]],
		///   [[5],   [6],  [7],  [8]],
		///   [[9],  [10], [11],  [12]],
		///   [[13], [14], [15],  [16]]]]
		///    </code>
		///   
		///   The output tensor has shape <c>[4, 2, 2, 1]</c> and value:
		///   
		///    <code>
		///   x = [[[[1], [3]], [[9], [11]]],
		///   [[[2], [4]], [[10], [12]]],
		///   [[[5], [7]], [[13], [15]]],
		///   [[[6], [8]], [[14], [16]]]]
		///    </code>
		///   
		///   (4) For the following input of shape <c>[2, 2, 4, 1]</c>, block_shape = <c>[2, 2]</c>, and
		///   paddings = <c>[[0, 0], [2, 0]]</c>:
		///   
		///    <code>
		///   x = [[[[1],   [2],  [3],  [4]],
		///   [[5],   [6],  [7],  [8]]],
		///   [[[9],  [10], [11],  [12]],
		///   [[13], [14], [15],  [16]]]]
		///    </code>
		///   
		///   The output tensor has shape <c>[8, 1, 3, 1]</c> and value:
		///   
		///    <code>
		///   x = [[[[0], [1], [3]]], [[[0], [9], [11]]],
		///   [[[0], [2], [4]]], [[[0], [10], [12]]],
		///   [[[0], [5], [7]]], [[[0], [13], [15]]],
		///   [[[0], [6], [8]]], [[[0], [14], [16]]]]
		///    </code>
		///   
		///   Among others, this operation is useful for reducing atrous convolution into
		///   regular convolution.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SpaceToBatchND'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation divides "spatial" dimensions <c>[1, ..., M]</c> of the input into a
		///   grid of blocks of shape <c>block_shape</c>, and interleaves these blocks with the
		///   "batch" dimension (0) such that in the output, the spatial dimensions
		///   <c>[1, ..., M]</c> correspond to the position within the grid, and the batch
		///   dimension combines both the position within a spatial block and the original
		///   batch position.  Prior to division into blocks, the spatial dimensions of the
		///   input are optionally zero padded according to <c>paddings</c>.  See below for a
		///   precise description.
		/// </remarks>
		public TF_Output SpaceToBatchND (TF_Output input, TF_Output block_shape, TF_Output paddings, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SpaceToBatchND", MakeName ("SpaceToBatchND", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, block_shape);
			c_api.TF_AddInput(desc, paddings);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   SpaceToDepth for tensors of type T.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SpaceToDepth'.
		/// </param>
		/// <param name="data_format">
		///   Optional argument
		/// </param>
		/// <param name="block_size">
		///   The size of the spatial block.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Rearranges blocks of spatial data, into depth. More specifically,
		///   this op outputs a copy of the input tensor where values from the <c>height</c>
		///   and <c>width</c> dimensions are moved to the <c>depth</c> dimension.
		///   The attr <c>block_size</c> indicates the input block size.
		///   
		///   * Non-overlapping blocks of size <c>block_size x block size</c> are rearranged
		///   into depth at each location.
		///   * The depth of the output tensor is <c>block_size * block_size * input_depth</c>.
		///   * The Y, X coordinates within each block of the input become the high order
		///   component of the output channel index.
		///   * The input tensor's height and width must be divisible by block_size.
		///   
		///   The <c>data_format</c> attr specifies the layout of the input and output tensors
		///   with the following options:
		///   "NHWC": <c>[ batch, height, width, channels ]</c>
		///   "NCHW": <c>[ batch, channels, height, width ]</c>
		///   "NCHW_VECT_C":
		///   <c>qint8 [ batch, channels / 4, height, width, 4 ]</c>
		///   
		///   It is useful to consider the operation as transforming a 6-D Tensor.
		///   e.g. for data_format = NHWC,
		///   Each element in the input tensor can be specified via 6 coordinates,
		///   ordered by decreasing memory layout significance as:
		///   n,oY,bY,oX,bX,iC  (where n=batch index, oX, oY means X or Y coordinates
		///   within the output image, bX, bY means coordinates
		///   within the input block, iC means input channels).
		///   The output would be a transpose to the following layout:
		///   n,oY,oX,bY,bX,iC
		///   
		///   This operation is useful for resizing the activations between convolutions
		///   (but keeping all data), e.g. instead of pooling. It is also useful for training
		///   purely convolutional models.
		///   
		///   For example, given an input of shape <c>[1, 2, 2, 1]</c>, data_format = "NHWC" and
		///   block_size = 2:
		///   
		///    <code>
		///   x = [[[[1], [2]],
		///   [[3], [4]]]]
		///    </code>
		///   
		///   This operation will output a tensor of shape <c>[1, 1, 1, 4]</c>:
		///   
		///    <code>
		///   [[[[1, 2, 3, 4]]]]
		///    </code>
		///   
		///   Here, the input has a batch of 1 and each batch element has shape <c>[2, 2, 1]</c>,
		///   the corresponding output will have a single element (i.e. width and height are
		///   both 1) and will have a depth of 4 channels (1 * block_size * block_size).
		///   The output element shape is <c>[1, 1, 4]</c>.
		///   
		///   For an input tensor with larger depth, here of shape <c>[1, 2, 2, 3]</c>, e.g.
		///   
		///    <code>
		///   x = [[[[1, 2, 3], [4, 5, 6]],
		///   [[7, 8, 9], [10, 11, 12]]]]
		///    </code>
		///   
		///   This operation, for block_size of 2, will return the following tensor of shape
		///   <c>[1, 1, 1, 12]</c>
		///   
		///    <code>
		///   [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]
		///    </code>
		///   
		///   Similarly, for the following input of shape <c>[1 4 4 1]</c>, and a block size of 2:
		///   
		///    <code>
		///   x = [[[[1],   [2],  [5],  [6]],
		///   [[3],   [4],  [7],  [8]],
		///   [[9],  [10], [13],  [14]],
		///   [[11], [12], [15],  [16]]]]
		///    </code>
		///   
		///   the operator will return the following tensor of shape <c>[1 2 2 4]</c>:
		///   
		///    <code>
		///   x = [[[[1, 2, 3, 4],
		///   [5, 6, 7, 8]],
		///   [[9, 10, 11, 12],
		///   [13, 14, 15, 16]]]]
		///    </code>
		/// </remarks>
		public TF_Output SpaceToDepth (TF_Output input, long block_size, string data_format = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SpaceToDepth", MakeName ("SpaceToDepth", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "block_size", block_size);
			if (data_format != null)
				c_api.TF_SetAttrString (desc, "data_format", data_format);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Applies a sparse gradient to a given accumulator.
		/// </summary>
		/// <param name="handle">
		///   The handle to a accumulator.
		/// </param>
		/// <param name="local_step">
		///   The local_step value at which the sparse gradient was computed.
		/// </param>
		/// <param name="gradient_indices">
		///   Indices of the sparse gradient to be accumulated. Must be a
		///   vector.
		/// </param>
		/// <param name="gradient_values">
		///   Values are the non-zero slices of the gradient, and must have
		///   the same first dimension as indices, i.e., the nnz represented by indices and
		///   values must be consistent.
		/// </param>
		/// <param name="gradient_shape">
		///   Shape of the sparse gradient to be accumulated.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseAccumulatorApplyGradient'.
		/// </param>
		/// <param name="has_known_shape">
		///   Boolean indicating whether gradient_shape is unknown, in which
		///   case the input is ignored during validation.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   Does not add if local_step is smaller than the accumulator's
		///   global_step.
		/// </remarks>
		public TF_Operation SparseAccumulatorApplyGradient (TF_Output handle, TF_Output local_step, TF_Output gradient_indices, TF_Output gradient_values, TF_Output gradient_shape, bool has_known_shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseAccumulatorApplyGradient", MakeName ("SparseAccumulatorApplyGradient", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, local_step);
			c_api.TF_AddInput(desc, gradient_indices);
			c_api.TF_AddInput(desc, gradient_values);
			c_api.TF_AddInput(desc, gradient_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrBool (desc, "has_known_shape", Convert.ToByte(has_known_shape));
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Extracts the average sparse gradient in a SparseConditionalAccumulator.
		/// </summary>
		/// <param name="handle">
		///   The handle to a SparseConditionalAccumulator.
		/// </param>
		/// <param name="num_required">
		///   Number of gradients required before we return an aggregate.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseAccumulatorTakeGradient'.
		/// </param>
		/// <param name="dtype">
		///   The data type of accumulated gradients. Needs to correspond to the type
		///   of the accumulator.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   indices: Indices of the average of the accumulated sparse gradients.
		///   values: Values of the average of the accumulated sparse gradients.
		///   shape: Shape of the average of the accumulated sparse gradients.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The op will blocks until sufficient (i.e., more than num_required)
		///   gradients have been accumulated. If the accumulator has already
		///   aggregated more than num_required gradients, it will return its
		///   average of the accumulated gradients.  Also automatically increments
		///   the recorded global_step in the accumulator by 1, and resets the
		///   aggregate to 0.
		/// </remarks>
		public (TF_Output indices, TF_Output values, TF_Output shape) SparseAccumulatorTakeGradient (TF_Output handle, TF_Output num_required, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseAccumulatorTakeGradient", MakeName ("SparseAccumulatorTakeGradient", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, num_required);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var indices = new TF_Output (op, _idx++);
			var values = new TF_Output (op, _idx++);
			var shape = new TF_Output (op, _idx++);
			return (indices, values, shape);
		}

		/// <summary>
		///   Adds two <c>SparseTensor</c> objects to produce another <c>SparseTensor</c>.
		/// </summary>
		/// <param name="a_indices">
		///   2-D.  The <c>indices</c> of the first <c>SparseTensor</c>, size <c>[nnz, ndims]</c> Matrix.
		/// </param>
		/// <param name="a_values">
		///   1-D.  The <c>values</c> of the first <c>SparseTensor</c>, size <c>[nnz]</c> Vector.
		/// </param>
		/// <param name="a_shape">
		///   1-D.  The <c>shape</c> of the first <c>SparseTensor</c>, size <c>[ndims]</c> Vector.
		/// </param>
		/// <param name="b_indices">
		///   2-D.  The <c>indices</c> of the second <c>SparseTensor</c>, size <c>[nnz, ndims]</c> Matrix.
		/// </param>
		/// <param name="b_values">
		///   1-D.  The <c>values</c> of the second <c>SparseTensor</c>, size <c>[nnz]</c> Vector.
		/// </param>
		/// <param name="b_shape">
		///   1-D.  The <c>shape</c> of the second <c>SparseTensor</c>, size <c>[ndims]</c> Vector.
		/// </param>
		/// <param name="thresh">
		///   0-D.  The magnitude threshold that determines if an output value/index
		///   pair takes space.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseAdd'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sum_indices:
		///   sum_values:
		///   sum_shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The input <c>SparseTensor</c> objects' indices are assumed ordered in standard
		///   lexicographic order.  If this is not the case, before this step run
		///   <c>SparseReorder</c> to restore index ordering.
		///   
		///   By default, if two values sum to zero at some index, the output <c>SparseTensor</c>
		///   would still include that particular location in its index, storing a zero in the
		///   corresponding value slot.  To override this, callers can specify <c>thresh</c>,
		///   indicating that if the sum has a magnitude strictly smaller than <c>thresh</c>, its
		///   corresponding value and index would then not be included.  In particular,
		///   <c>thresh == 0</c> (default) means everything is kept and actual thresholding happens
		///   only for a positive value.
		///   
		///   In the following shapes, <c>nnz</c> is the count after taking <c>thresh</c> into account.
		/// </remarks>
		public (TF_Output sum_indices, TF_Output sum_values, TF_Output sum_shape) SparseAdd (TF_Output a_indices, TF_Output a_values, TF_Output a_shape, TF_Output b_indices, TF_Output b_values, TF_Output b_shape, TF_Output thresh, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseAdd", MakeName ("SparseAdd", operName));
			c_api.TF_AddInput(desc, a_indices);
			c_api.TF_AddInput(desc, a_values);
			c_api.TF_AddInput(desc, a_shape);
			c_api.TF_AddInput(desc, b_indices);
			c_api.TF_AddInput(desc, b_values);
			c_api.TF_AddInput(desc, b_shape);
			c_api.TF_AddInput(desc, thresh);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var sum_indices = new TF_Output (op, _idx++);
			var sum_values = new TF_Output (op, _idx++);
			var sum_shape = new TF_Output (op, _idx++);
			return (sum_indices, sum_values, sum_shape);
		}

		/// <summary>
		///   The gradient operator for the SparseAdd op.
		/// </summary>
		/// <param name="backprop_val_grad">
		///   1-D with shape <c>[nnz(sum)]</c>.  The gradient with respect to
		///   the non-empty values of the sum.
		/// </param>
		/// <param name="a_indices">
		///   2-D.  The <c>indices</c> of the <c>SparseTensor</c> A, size <c>[nnz(A), ndims]</c>.
		/// </param>
		/// <param name="b_indices">
		///   2-D.  The <c>indices</c> of the <c>SparseTensor</c> B, size <c>[nnz(B), ndims]</c>.
		/// </param>
		/// <param name="sum_indices">
		///   2-D.  The <c>indices</c> of the sum <c>SparseTensor</c>, size
		///   <c>[nnz(sum), ndims]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseAddGrad'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   a_val_grad: 1-D with shape <c>[nnz(A)]</c>. The gradient with respect to the
		///   non-empty values of A.
		///   b_val_grad: 1-D with shape <c>[nnz(B)]</c>. The gradient with respect to the
		///   non-empty values of B.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The SparseAdd op calculates A + B, where A, B, and the sum are all represented
		///   as <c>SparseTensor</c> objects.  This op takes in the upstream gradient w.r.t.
		///   non-empty values of the sum, and outputs the gradients w.r.t. the non-empty
		///   values of A and B.
		/// </remarks>
		public (TF_Output a_val_grad, TF_Output b_val_grad) SparseAddGrad (TF_Output backprop_val_grad, TF_Output a_indices, TF_Output b_indices, TF_Output sum_indices, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseAddGrad", MakeName ("SparseAddGrad", operName));
			c_api.TF_AddInput(desc, backprop_val_grad);
			c_api.TF_AddInput(desc, a_indices);
			c_api.TF_AddInput(desc, b_indices);
			c_api.TF_AddInput(desc, sum_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var a_val_grad = new TF_Output (op, _idx++);
			var b_val_grad = new TF_Output (op, _idx++);
			return (a_val_grad, b_val_grad);
		}

		/// <summary>
		///   var: Should be from a Variable().
		/// </summary>
		/// <param name="var">
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum_update">
		///   : Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Learning rate. Must be a scalar.
		/// </param>
		/// <param name="rho">
		///   Decay factor. Must be a scalar.
		/// </param>
		/// <param name="epsilon">
		///   Constant factor. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var and accum.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyAdadelta'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, updating of the var and accum tensors will be protected by
		///   a lock; otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseApplyAdadelta (TF_Output var, TF_Output accum, TF_Output accum_update, TF_Output lr, TF_Output rho, TF_Output epsilon, TF_Output grad, TF_Output indices, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyAdadelta", MakeName ("SparseApplyAdadelta", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, accum_update);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update relevant entries in '*var' and '*accum' according to the adagrad scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Learning rate. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var and accum.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyAdagrad'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <param name="update_slots">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   That is for rows we have grad for, we update var and accum as follows:
		///   $$accum += grad * grad$$
		///   $$var -= lr * grad * (1 / sqrt(accum))$$
		/// </remarks>
		public TF_Output SparseApplyAdagrad (TF_Output var, TF_Output accum, TF_Output lr, TF_Output grad, TF_Output indices, bool? use_locking = null, bool? update_slots = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyAdagrad", MakeName ("SparseApplyAdagrad", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (update_slots.HasValue)
				c_api.TF_SetAttrBool (desc, "update_slots", Convert.ToByte(update_slots.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update entries in '*var' and '*accum' according to the proximal adagrad scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="gradient_accumulator">
		///   Should be from a Variable().
		/// </param>
		/// <param name="gradient_squared_accumulator">
		///   Should be from a Variable().
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var and accum.
		/// </param>
		/// <param name="lr">
		///   Learning rate. Must be a scalar.
		/// </param>
		/// <param name="l1">
		///   L1 regularization. Must be a scalar.
		/// </param>
		/// <param name="l2">
		///   L2 regularization. Must be a scalar.
		/// </param>
		/// <param name="global_step">
		///   Training step number. Must be a scalar.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyAdagradDA'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, updating of the var and accum tensors will be protected by
		///   a lock; otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseApplyAdagradDA (TF_Output var, TF_Output gradient_accumulator, TF_Output gradient_squared_accumulator, TF_Output grad, TF_Output indices, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output global_step, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyAdagradDA", MakeName ("SparseApplyAdagradDA", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, gradient_accumulator);
			c_api.TF_AddInput(desc, gradient_squared_accumulator);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, global_step);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update relevant entries in '*var' and '*accum' according to the adagrad scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Learning rate. Must be a scalar.
		/// </param>
		/// <param name="epsilon">
		///   Constant factor. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var and accum.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyAdagradV2'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <param name="update_slots">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   That is for rows we have grad for, we update var and accum as follows:
		///   $$accum += grad * grad$$
		///   $$var -= lr * grad * (1 / sqrt(accum))$$
		/// </remarks>
		public TF_Output SparseApplyAdagradV2 (TF_Output var, TF_Output accum, TF_Output lr, TF_Output epsilon, TF_Output grad, TF_Output indices, bool? use_locking = null, bool? update_slots = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyAdagradV2", MakeName ("SparseApplyAdagradV2", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (update_slots.HasValue)
				c_api.TF_SetAttrBool (desc, "update_slots", Convert.ToByte(update_slots.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update '*var' according to the centered RMSProp algorithm.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="mg">
		///   Should be from a Variable().
		/// </param>
		/// <param name="ms">
		///   Should be from a Variable().
		/// </param>
		/// <param name="mom">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="rho">
		///   Decay rate. Must be a scalar.
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="epsilon">
		///   Ridge term. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var, ms and mom.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyCenteredRMSProp'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var, mg, ms, and mom tensors is
		///   protected by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The centered RMSProp algorithm uses an estimate of the centered second moment
		///   (i.e., the variance) for normalization, as opposed to regular RMSProp, which
		///   uses the (uncentered) second moment. This often helps with training, but is
		///   slightly more expensive in terms of computation and memory.
		///   
		///   Note that in dense implementation of this algorithm, mg, ms, and mom will
		///   update even if the grad is zero, but in this sparse implementation, mg, ms,
		///   and mom will not update in iterations during which the grad is zero.
		///   
		///   mean_square = decay * mean_square + (1-decay) * gradient ** 2
		///   mean_grad = decay * mean_grad + (1-decay) * gradient
		///   Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)
		///   
		///   $$ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad$$
		///   $$mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)$$
		///   $$var &amp;lt;- var - mom$$
		/// </remarks>
		public TF_Output SparseApplyCenteredRMSProp (TF_Output var, TF_Output mg, TF_Output ms, TF_Output mom, TF_Output lr, TF_Output rho, TF_Output momentum, TF_Output epsilon, TF_Output grad, TF_Output indices, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyCenteredRMSProp", MakeName ("SparseApplyCenteredRMSProp", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, mg);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, momentum);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update relevant entries in '*var' according to the Ftrl-proximal scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="linear">
		///   Should be from a Variable().
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var and accum.
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="l1">
		///   L1 regularization. Must be a scalar.
		/// </param>
		/// <param name="l2">
		///   L2 regularization. Must be a scalar.
		/// </param>
		/// <param name="lr_power">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyFtrl'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   That is for rows we have grad for, we update var, accum and linear as follows:
		///   $$accum_new = accum + grad * grad$$
		///   $$linear += grad + (accum_{new}^{-lr_{power}} - accum^{-lr_{power}} / lr * var$$
		///   $$quadratic = 1.0 / (accum_{new}^{lr_{power}} * lr) + 2 * l2$$
		///   $$var = (sign(linear) * l1 - linear) / quadratic\ if\ |linear| &amp;gt; l1\ else\ 0.0$$
		///   $$accum = accum_{new}$$
		/// </remarks>
		public TF_Output SparseApplyFtrl (TF_Output var, TF_Output accum, TF_Output linear, TF_Output grad, TF_Output indices, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output lr_power, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyFtrl", MakeName ("SparseApplyFtrl", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, linear);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, lr_power);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update relevant entries in '*var' according to the Ftrl-proximal scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="linear">
		///   Should be from a Variable().
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var and accum.
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="l1">
		///   L1 regularization. Must be a scalar.
		/// </param>
		/// <param name="l2">
		///   L2 shrinkage regulariation. Must be a scalar.
		/// </param>
		/// <param name="l2_shrinkage">
		/// </param>
		/// <param name="lr_power">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyFtrlV2'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   That is for rows we have grad for, we update var, accum and linear as follows:
		///   grad_with_shrinkage = grad + 2 * l2_shrinkage * var
		///   accum_new = accum + grad_with_shrinkage * grad_with_shrinkage
		///   linear += grad_with_shrinkage +
		///   (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
		///   quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
		///   var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0
		///   accum = accum_new
		/// </remarks>
		public TF_Output SparseApplyFtrlV2 (TF_Output var, TF_Output accum, TF_Output linear, TF_Output grad, TF_Output indices, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output l2_shrinkage, TF_Output lr_power, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyFtrlV2", MakeName ("SparseApplyFtrlV2", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, linear);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, l2_shrinkage);
			c_api.TF_AddInput(desc, lr_power);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update relevant entries in '*var' and '*accum' according to the momentum scheme.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Learning rate. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var and accum.
		/// </param>
		/// <param name="momentum">
		///   Momentum. Must be a scalar.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyMomentum'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var and accum tensors will be protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <param name="use_nesterov">
		///   Optional argument
		///   If <c>True</c>, the tensor passed to compute grad will be
		///   var - lr * momentum * accum, so in the end, the var you get is actually
		///   var - lr * momentum * accum.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Set use_nesterov = True if you want to use Nesterov momentum.
		///   
		///   That is for rows we have grad for, we update var and accum as follows:
		///   
		///   $$accum = accum * momentum + grad$$
		///   $$var -= lr * accum$$
		/// </remarks>
		public TF_Output SparseApplyMomentum (TF_Output var, TF_Output accum, TF_Output lr, TF_Output grad, TF_Output indices, TF_Output momentum, bool? use_locking = null, bool? use_nesterov = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyMomentum", MakeName ("SparseApplyMomentum", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, momentum);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			if (use_nesterov.HasValue)
				c_api.TF_SetAttrBool (desc, "use_nesterov", Convert.ToByte(use_nesterov.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Sparse update entries in '*var' and '*accum' according to FOBOS algorithm.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="accum">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Learning rate. Must be a scalar.
		/// </param>
		/// <param name="l1">
		///   L1 regularization. Must be a scalar.
		/// </param>
		/// <param name="l2">
		///   L2 regularization. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var and accum.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyProximalAdagrad'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, updating of the var and accum tensors will be protected by
		///   a lock; otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   That is for rows we have grad for, we update var and accum as follows:
		///   $$accum += grad * grad$$
		///   $$prox_v = var$$
		///   $$prox_v -= lr * grad * (1 / sqrt(accum))$$
		///   $$var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}$$
		/// </remarks>
		public TF_Output SparseApplyProximalAdagrad (TF_Output var, TF_Output accum, TF_Output lr, TF_Output l1, TF_Output l2, TF_Output grad, TF_Output indices, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyProximalAdagrad", MakeName ("SparseApplyProximalAdagrad", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, accum);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Sparse update '*var' as FOBOS algorithm with fixed learning rate.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="alpha">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="l1">
		///   L1 regularization. Must be a scalar.
		/// </param>
		/// <param name="l2">
		///   L2 regularization. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var and accum.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyProximalGradientDescent'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If True, the subtraction will be protected by a lock;
		///   otherwise the behavior is undefined, but may exhibit less contention.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   That is for rows we have grad for, we update var as follows:
		///   $$prox_v = var - alpha * grad$$
		///   $$var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}$$
		/// </remarks>
		public TF_Output SparseApplyProximalGradientDescent (TF_Output var, TF_Output alpha, TF_Output l1, TF_Output l2, TF_Output grad, TF_Output indices, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyProximalGradientDescent", MakeName ("SparseApplyProximalGradientDescent", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, alpha);
			c_api.TF_AddInput(desc, l1);
			c_api.TF_AddInput(desc, l2);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Update '*var' according to the RMSProp algorithm.
		/// </summary>
		/// <param name="var">
		///   Should be from a Variable().
		/// </param>
		/// <param name="ms">
		///   Should be from a Variable().
		/// </param>
		/// <param name="mom">
		///   Should be from a Variable().
		/// </param>
		/// <param name="lr">
		///   Scaling factor. Must be a scalar.
		/// </param>
		/// <param name="rho">
		///   Decay rate. Must be a scalar.
		/// </param>
		/// <param name="momentum">
		/// </param>
		/// <param name="epsilon">
		///   Ridge term. Must be a scalar.
		/// </param>
		/// <param name="grad">
		///   The gradient.
		/// </param>
		/// <param name="indices">
		///   A vector of indices into the first dimension of var, ms and mom.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyRMSProp'.
		/// </param>
		/// <param name="use_locking">
		///   Optional argument
		///   If <c>True</c>, updating of the var, ms, and mom tensors is protected
		///   by a lock; otherwise the behavior is undefined, but may exhibit less
		///   contention.
		/// </param>
		/// <returns>
		///   Same as "var".
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Note that in dense implementation of this algorithm, ms and mom will
		///   update even if the grad is zero, but in this sparse implementation, ms
		///   and mom will not update in iterations during which the grad is zero.
		///   
		///   mean_square = decay * mean_square + (1-decay) * gradient ** 2
		///   Delta = learning_rate * gradient / sqrt(mean_square + epsilon)
		///   
		///   $$ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad$$
		///   $$mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)$$
		///   $$var &amp;lt;- var - mom$$
		/// </remarks>
		public TF_Output SparseApplyRMSProp (TF_Output var, TF_Output ms, TF_Output mom, TF_Output lr, TF_Output rho, TF_Output momentum, TF_Output epsilon, TF_Output grad, TF_Output indices, bool? use_locking = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseApplyRMSProp", MakeName ("SparseApplyRMSProp", operName));
			c_api.TF_AddInput(desc, var);
			c_api.TF_AddInput(desc, ms);
			c_api.TF_AddInput(desc, mom);
			c_api.TF_AddInput(desc, lr);
			c_api.TF_AddInput(desc, rho);
			c_api.TF_AddInput(desc, momentum);
			c_api.TF_AddInput(desc, epsilon);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (use_locking.HasValue)
				c_api.TF_SetAttrBool (desc, "use_locking", Convert.ToByte(use_locking.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Concatenates a list of <c>SparseTensor</c> along the specified dimension.
		/// </summary>
		/// <param name="indices">
		///   2-D.  Indices of each input <c>SparseTensor</c>.
		/// </param>
		/// <param name="values">
		///   1-D.  Non-empty values of each <c>SparseTensor</c>.
		/// </param>
		/// <param name="shapes">
		///   1-D.  Shapes of each <c>SparseTensor</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseConcat'.
		/// </param>
		/// <param name="concat_dim">
		///   Dimension to concatenate along. Must be in range [-rank, rank),
		///   where rank is the number of dimensions in each input <c>SparseTensor</c>.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices: 2-D.  Indices of the concatenated <c>SparseTensor</c>.
		///   output_values: 1-D.  Non-empty values of the concatenated <c>SparseTensor</c>.
		///   output_shape: 1-D.  Shape of the concatenated <c>SparseTensor</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Concatenation is with respect to the dense versions of these sparse tensors.
		///   It is assumed that each input is a <c>SparseTensor</c> whose elements are ordered
		///   along increasing dimension number.
		///   
		///   All inputs' shapes must match, except for the concat dimension.  The
		///   <c>indices</c>, <c>values</c>, and <c>shapes</c> lists must have the same length.
		///   
		///   The output shape is identical to the inputs', except along the concat
		///   dimension, where it is the sum of the inputs' sizes along that dimension.
		///   
		///   The output elements will be resorted to preserve the sort order along
		///   increasing dimension number.
		///   
		///   This op runs in <c>O(M log M)</c> time, where <c>M</c> is the total number of non-empty
		///   values across all inputs. This is due to the need for an internal sort in
		///   order to concatenate efficiently across an arbitrary dimension.
		///   
		///   For example, if <c>concat_dim = 1</c> and the inputs are
		///   
		///   sp_inputs[0]: shape = [2, 3]
		///   [0, 2]: "a"
		///   [1, 0]: "b"
		///   [1, 1]: "c"
		///   
		///   sp_inputs[1]: shape = [2, 4]
		///   [0, 1]: "d"
		///   [0, 2]: "e"
		///   
		///   then the output will be
		///   
		///   shape = [2, 7]
		///   [0, 2]: "a"
		///   [0, 4]: "d"
		///   [0, 5]: "e"
		///   [1, 0]: "b"
		///   [1, 1]: "c"
		///   
		///   Graphically this is equivalent to doing
		///   
		///   [    a] concat [  d e  ] = [    a   d e  ]
		///   [b c  ]        [       ]   [b c          ]
		/// </remarks>
		public (TF_Output output_indices, TF_Output output_values, TF_Output output_shape) SparseConcat (TF_Output[] indices, TF_Output[] values, TF_Output[] shapes, long concat_dim, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseConcat", MakeName ("SparseConcat", operName));
			c_api.TF_AddInputList(desc, indices[0], indices.Length);
			c_api.TF_AddInputList(desc, values[0], values.Length);
			c_api.TF_AddInputList(desc, shapes[0], shapes.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "concat_dim", concat_dim);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_indices = new TF_Output (op, _idx++);
			var output_values = new TF_Output (op, _idx++);
			var output_shape = new TF_Output (op, _idx++);
			return (output_indices, output_values, output_shape);
		}

		/// <summary>
		///   A conditional accumulator for aggregating sparse gradients.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseConditionalAccumulator'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this accumulator is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this accumulator will be shared under the given name
		///   across multiple sessions.
		/// </param>
		/// <param name="reduction_type">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		///   The type of the value being accumulated.
		/// </param>
		/// <param name="shape">
		///   The shape of the values.
		/// </param>
		/// <returns>
		///   The handle to the accumulator.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The accumulator accepts gradients marked with local_step greater or
		///   equal to the most recent global_step known to the accumulator. The
		///   average can be extracted from the accumulator, provided sufficient
		///   gradients have been accumulated. Extracting the average automatically
		///   resets the aggregate to 0, and increments the global_step recorded by
		///   the accumulator.
		/// </remarks>
		public TF_Output SparseConditionalAccumulator (TF_DataType dtype, long[] shape, string container = null, string shared_name = null, string reduction_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseConditionalAccumulator", MakeName ("SparseConditionalAccumulator", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (reduction_type != null)
				c_api.TF_SetAttrString (desc, "reduction_type", reduction_type);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Generates sparse cross from a list of sparse and dense tensors.
		/// </summary>
		/// <param name="indices">
		///   2-D.  Indices of each input <c>SparseTensor</c>.
		/// </param>
		/// <param name="values">
		///   1-D.   values of each <c>SparseTensor</c>.
		/// </param>
		/// <param name="shapes">
		///   1-D.   Shapes of each <c>SparseTensor</c>.
		/// </param>
		/// <param name="dense_inputs">
		///   2-D.    Columns represented by dense <c>Tensor</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseCross'.
		/// </param>
		/// <param name="hashed_output">
		///   If true, returns the hash of the cross instead of the string.
		///   This will allow us avoiding string manipulations.
		/// </param>
		/// <param name="num_buckets">
		///   It is used if hashed_output is true.
		///   output = hashed_value%num_buckets if num_buckets &amp;gt; 0 else hashed_value.
		/// </param>
		/// <param name="hash_key">
		///   Specify the hash_key that will be used by the <c>FingerprintCat64</c>
		///   function to combine the crosses fingerprints.
		/// </param>
		/// <param name="out_type">
		/// </param>
		/// <param name="internal_type">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices: 2-D.  Indices of the concatenated <c>SparseTensor</c>.
		///   output_values: 1-D.  Non-empty values of the concatenated or hashed
		///   <c>SparseTensor</c>.
		///   output_shape: 1-D.  Shape of the concatenated <c>SparseTensor</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The op takes two lists, one of 2D <c>SparseTensor</c> and one of 2D <c>Tensor</c>, each
		///   representing features of one feature column. It outputs a 2D <c>SparseTensor</c> with
		///   the batchwise crosses of these features.
		///   
		///   For example, if the inputs are
		///   
		///   inputs[0]: SparseTensor with shape = [2, 2]
		///   [0, 0]: "a"
		///   [1, 0]: "b"
		///   [1, 1]: "c"
		///   
		///   inputs[1]: SparseTensor with shape = [2, 1]
		///   [0, 0]: "d"
		///   [1, 0]: "e"
		///   
		///   inputs[2]: Tensor [["f"], ["g"]]
		///   
		///   then the output will be
		///   
		///   shape = [2, 2]
		///   [0, 0]: "a_X_d_X_f"
		///   [1, 0]: "b_X_e_X_g"
		///   [1, 1]: "c_X_e_X_g"
		///   
		///   if hashed_output=true then the output will be
		///   
		///   shape = [2, 2]
		///   [0, 0]: FingerprintCat64(
		///   Fingerprint64("f"), FingerprintCat64(
		///   Fingerprint64("d"), Fingerprint64("a")))
		///   [1, 0]: FingerprintCat64(
		///   Fingerprint64("g"), FingerprintCat64(
		///   Fingerprint64("e"), Fingerprint64("b")))
		///   [1, 1]: FingerprintCat64(
		///   Fingerprint64("g"), FingerprintCat64(
		///   Fingerprint64("e"), Fingerprint64("c")))
		/// </remarks>
		public (TF_Output output_indices, TF_Output output_values, TF_Output output_shape) SparseCross (TF_Output[] indices, TF_Output[] values, TF_Output[] shapes, TF_Output[] dense_inputs, bool hashed_output, long num_buckets, long hash_key, TF_DataType out_type, TF_DataType internal_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseCross", MakeName ("SparseCross", operName));
			c_api.TF_AddInputList(desc, indices[0], indices.Length);
			c_api.TF_AddInputList(desc, values[0], values.Length);
			c_api.TF_AddInputList(desc, shapes[0], shapes.Length);
			c_api.TF_AddInputList(desc, dense_inputs[0], dense_inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrBool (desc, "hashed_output", Convert.ToByte(hashed_output));
			c_api.TF_SetAttrInt (desc, "num_buckets", num_buckets);
			c_api.TF_SetAttrInt (desc, "hash_key", hash_key);
			c_api.TF_SetAttrType (desc, "out_type", out_type);
			c_api.TF_SetAttrType (desc, "internal_type", internal_type);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_indices = new TF_Output (op, _idx++);
			var output_values = new TF_Output (op, _idx++);
			var output_shape = new TF_Output (op, _idx++);
			return (output_indices, output_values, output_shape);
		}

		/// <summary>
		///   Adds up a SparseTensor and a dense Tensor, using these special rules:
		/// </summary>
		/// <param name="sp_indices">
		///   2-D.  <c>N x R</c> matrix with the indices of non-empty values in a
		///   SparseTensor, possibly not in canonical ordering.
		/// </param>
		/// <param name="sp_values">
		///   1-D.  <c>N</c> non-empty values corresponding to <c>sp_indices</c>.
		/// </param>
		/// <param name="sp_shape">
		///   1-D.  Shape of the input SparseTensor.
		/// </param>
		/// <param name="dense">
		///   <c>R</c>-D.  The dense Tensor operand.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseDenseCwiseAdd'.
		/// </param>
		/// <returns>
		///   1-D.  The <c>N</c> values that are operated on.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   (1) Broadcasts the dense side to have the same shape as the sparse side, if
		///   eligible;
		///   (2) Then, only the dense values pointed to by the indices of the SparseTensor
		///   participate in the cwise addition.
		///   
		///   By these rules, the result is a logical SparseTensor with exactly the same
		///   indices and shape, but possibly with different non-zero values.  The output of
		///   this Op is the resultant non-zero values.
		/// </remarks>
		public TF_Output SparseDenseCwiseAdd (TF_Output sp_indices, TF_Output sp_values, TF_Output sp_shape, TF_Output dense, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseDenseCwiseAdd", MakeName ("SparseDenseCwiseAdd", operName));
			c_api.TF_AddInput(desc, sp_indices);
			c_api.TF_AddInput(desc, sp_values);
			c_api.TF_AddInput(desc, sp_shape);
			c_api.TF_AddInput(desc, dense);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Component-wise divides a SparseTensor by a dense Tensor.
		/// </summary>
		/// <param name="sp_indices">
		///   2-D.  <c>N x R</c> matrix with the indices of non-empty values in a
		///   SparseTensor, possibly not in canonical ordering.
		/// </param>
		/// <param name="sp_values">
		///   1-D.  <c>N</c> non-empty values corresponding to <c>sp_indices</c>.
		/// </param>
		/// <param name="sp_shape">
		///   1-D.  Shape of the input SparseTensor.
		/// </param>
		/// <param name="dense">
		///   <c>R</c>-D.  The dense Tensor operand.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseDenseCwiseDiv'.
		/// </param>
		/// <returns>
		///   1-D.  The <c>N</c> values that are operated on.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   *Limitation*: this Op only broadcasts the dense side to the sparse side, but not
		///   the other direction.
		/// </remarks>
		public TF_Output SparseDenseCwiseDiv (TF_Output sp_indices, TF_Output sp_values, TF_Output sp_shape, TF_Output dense, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseDenseCwiseDiv", MakeName ("SparseDenseCwiseDiv", operName));
			c_api.TF_AddInput(desc, sp_indices);
			c_api.TF_AddInput(desc, sp_values);
			c_api.TF_AddInput(desc, sp_shape);
			c_api.TF_AddInput(desc, dense);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Component-wise multiplies a SparseTensor by a dense Tensor.
		/// </summary>
		/// <param name="sp_indices">
		///   2-D.  <c>N x R</c> matrix with the indices of non-empty values in a
		///   SparseTensor, possibly not in canonical ordering.
		/// </param>
		/// <param name="sp_values">
		///   1-D.  <c>N</c> non-empty values corresponding to <c>sp_indices</c>.
		/// </param>
		/// <param name="sp_shape">
		///   1-D.  Shape of the input SparseTensor.
		/// </param>
		/// <param name="dense">
		///   <c>R</c>-D.  The dense Tensor operand.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseDenseCwiseMul'.
		/// </param>
		/// <returns>
		///   1-D.  The <c>N</c> values that are operated on.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The output locations corresponding to the implicitly zero elements in the sparse
		///   tensor will be zero (i.e., will not take up storage space), regardless of the
		///   contents of the dense tensor (even if it's +/-INF and that INF*0 == NaN).
		///   
		///   *Limitation*: this Op only broadcasts the dense side to the sparse side, but not
		///   the other direction.
		/// </remarks>
		public TF_Output SparseDenseCwiseMul (TF_Output sp_indices, TF_Output sp_values, TF_Output sp_shape, TF_Output dense, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseDenseCwiseMul", MakeName ("SparseDenseCwiseMul", operName));
			c_api.TF_AddInput(desc, sp_indices);
			c_api.TF_AddInput(desc, sp_values);
			c_api.TF_AddInput(desc, sp_shape);
			c_api.TF_AddInput(desc, dense);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Fills empty rows in the input 2-D <c>SparseTensor</c> with a default value.
		/// </summary>
		/// <param name="indices">
		///   2-D. the indices of the sparse tensor.
		/// </param>
		/// <param name="values">
		///   1-D. the values of the sparse tensor.
		/// </param>
		/// <param name="dense_shape">
		///   1-D. the shape of the sparse tensor.
		/// </param>
		/// <param name="default_value">
		///   0-D. default value to insert into location <c>[row, 0, ..., 0]</c>
		///   for rows missing from the input sparse tensor.
		///   output indices: 2-D. the indices of the filled sparse tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseFillEmptyRows'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices:
		///   output_values: 1-D. the values of the filled sparse tensor.
		///   empty_row_indicator: 1-D. whether the dense row was missing in the
		///   input sparse tensor.
		///   reverse_index_map: 1-D. a map from the input indices to the output indices.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The input <c>SparseTensor</c> is represented via the tuple of inputs
		///   (<c>indices</c>, <c>values</c>, <c>dense_shape</c>).  The output <c>SparseTensor</c> has the
		///   same <c>dense_shape</c> but with indices <c>output_indices</c> and values
		///   <c>output_values</c>.
		///   
		///   This op inserts a single entry for every row that doesn't have any values.
		///   The index is created as <c>[row, 0, ..., 0]</c> and the inserted value
		///   is <c>default_value</c>.
		///   
		///   For example, suppose <c>sp_input</c> has shape <c>[5, 6]</c> and non-empty values:
		///   
		///   [0, 1]: a
		///   [0, 3]: b
		///   [2, 0]: c
		///   [3, 1]: d
		///   
		///   Rows 1 and 4 are empty, so the output will be of shape <c>[5, 6]</c> with values:
		///   
		///   [0, 1]: a
		///   [0, 3]: b
		///   [1, 0]: default_value
		///   [2, 0]: c
		///   [3, 1]: d
		///   [4, 0]: default_value
		///   
		///   The output <c>SparseTensor</c> will be in row-major order and will have the
		///   same shape as the input.
		///   
		///   This op also returns an indicator vector shaped <c>[dense_shape[0]]</c> such that
		///   
		///   empty_row_indicator[i] = True iff row i was an empty row.
		///   
		///   And a reverse index map vector shaped <c>[indices.shape[0]]</c> that is used during
		///   backpropagation,
		///   
		///   reverse_index_map[j] = out_j s.t. indices[j, :] == output_indices[out_j, :]
		/// </remarks>
		public (TF_Output output_indices, TF_Output output_values, TF_Output empty_row_indicator, TF_Output reverse_index_map) SparseFillEmptyRows (TF_Output indices, TF_Output values, TF_Output dense_shape, TF_Output default_value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseFillEmptyRows", MakeName ("SparseFillEmptyRows", operName));
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, values);
			c_api.TF_AddInput(desc, dense_shape);
			c_api.TF_AddInput(desc, default_value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_indices = new TF_Output (op, _idx++);
			var output_values = new TF_Output (op, _idx++);
			var empty_row_indicator = new TF_Output (op, _idx++);
			var reverse_index_map = new TF_Output (op, _idx++);
			return (output_indices, output_values, empty_row_indicator, reverse_index_map);
		}

		/// <summary>
		///   The gradient of SparseFillEmptyRows.
		/// </summary>
		/// <param name="reverse_index_map">
		///   1-D.  The reverse index map from SparseFillEmptyRows.
		/// </param>
		/// <param name="grad_values">
		///   1-D.  The gradients from backprop.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseFillEmptyRowsGrad'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   d_values: 1-D.  The backprop into values.
		///   d_default_value: 0-D.  The backprop into default_value.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Takes vectors reverse_index_map, shaped <c>[N]</c>, and grad_values,
		///   shaped <c>[N_full]</c>, where <c>N_full &amp;gt;= N</c> and copies data into either
		///   <c>d_values</c> or <c>d_default_value</c>.  Here <c>d_values</c> is shaped <c>[N]</c> and
		///   <c>d_default_value</c> is a scalar.
		///   
		///   d_values[j] = grad_values[reverse_index_map[j]]
		///   d_default_value = sum_{k : 0 .. N_full - 1} (
		///   grad_values[k] * 1{k not in reverse_index_map})
		/// </remarks>
		public (TF_Output d_values, TF_Output d_default_value) SparseFillEmptyRowsGrad (TF_Output reverse_index_map, TF_Output grad_values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseFillEmptyRowsGrad", MakeName ("SparseFillEmptyRowsGrad", operName));
			c_api.TF_AddInput(desc, reverse_index_map);
			c_api.TF_AddInput(desc, grad_values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var d_values = new TF_Output (op, _idx++);
			var d_default_value = new TF_Output (op, _idx++);
			return (d_values, d_default_value);
		}

		/// <summary>
		///   Multiply matrix "a" by matrix "b".
		/// </summary>
		/// <param name="a">
		/// </param>
		/// <param name="b">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseMatMul'.
		/// </param>
		/// <param name="transpose_a">
		///   Optional argument
		/// </param>
		/// <param name="transpose_b">
		///   Optional argument
		/// </param>
		/// <param name="a_is_sparse">
		///   Optional argument
		/// </param>
		/// <param name="b_is_sparse">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The inputs must be two-dimensional matrices and the inner dimension of "a" must
		///   match the outer dimension of "b". Both "a" and "b" must be <c>Tensor</c>s not
		///   <c>SparseTensor</c>s.  This op is optimized for the case where at least one of "a" or
		///   "b" is sparse, in the sense that they have a large proportion of zero values.
		///   The breakeven for using this versus a dense matrix multiply on one platform was
		///   30% zero values in the sparse matrix.
		///   
		///   The gradient computation of this operation will only take advantage of sparsity
		///   in the input gradient when that gradient comes from a Relu.
		/// </remarks>
		public TF_Output SparseMatMul (TF_Output a, TF_Output b, bool? transpose_a = null, bool? transpose_b = null, bool? a_is_sparse = null, bool? b_is_sparse = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseMatMul", MakeName ("SparseMatMul", operName));
			c_api.TF_AddInput(desc, a);
			c_api.TF_AddInput(desc, b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (transpose_a.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_a", Convert.ToByte(transpose_a.Value));
			
			if (transpose_b.HasValue)
				c_api.TF_SetAttrBool (desc, "transpose_b", Convert.ToByte(transpose_b.Value));
			
			if (a_is_sparse.HasValue)
				c_api.TF_SetAttrBool (desc, "a_is_sparse", Convert.ToByte(a_is_sparse.Value));
			
			if (b_is_sparse.HasValue)
				c_api.TF_SetAttrBool (desc, "b_is_sparse", Convert.ToByte(b_is_sparse.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var product = new TF_Output (op, _idx++);
			return product;
		}

		/// <summary>
		///   Computes the max of elements across dimensions of a SparseTensor.
		/// </summary>
		/// <param name="input_indices">
		///   2-D.  <c>N x R</c> matrix with the indices of non-empty values in a
		///   SparseTensor, possibly not in canonical ordering.
		/// </param>
		/// <param name="input_values">
		///   1-D.  <c>N</c> non-empty values corresponding to <c>input_indices</c>.
		/// </param>
		/// <param name="input_shape">
		///   1-D.  Shape of the input SparseTensor.
		/// </param>
		/// <param name="reduction_axes">
		///   1-D.  Length-<c>K</c> vector containing the reduction axes.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReduceMax'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		///   If true, retain reduced dimensions with length 1.
		/// </param>
		/// <returns>
		///   <c>R-K</c>-D.  The reduced Tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This Op takes a SparseTensor and is the sparse counterpart to
		///   <c>tf.reduce_max()</c>.  In particular, this Op also returns a dense <c>Tensor</c>
		///   instead of a sparse one.
		///   
		///   Reduces <c>sp_input</c> along the dimensions given in <c>reduction_axes</c>.  Unless
		///   <c>keep_dims</c> is true, the rank of the tensor is reduced by 1 for each entry in
		///   <c>reduction_axes</c>. If <c>keep_dims</c> is true, the reduced dimensions are retained
		///   with length 1.
		///   
		///   If <c>reduction_axes</c> has no entries, all dimensions are reduced, and a tensor
		///   with a single element is returned.  Additionally, the axes can be negative,
		///   which are interpreted according to the indexing rules in Python.
		/// </remarks>
		public TF_Output SparseReduceMax (TF_Output input_indices, TF_Output input_values, TF_Output input_shape, TF_Output reduction_axes, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseReduceMax", MakeName ("SparseReduceMax", operName));
			c_api.TF_AddInput(desc, input_indices);
			c_api.TF_AddInput(desc, input_values);
			c_api.TF_AddInput(desc, input_shape);
			c_api.TF_AddInput(desc, reduction_axes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the max of elements across dimensions of a SparseTensor.
		/// </summary>
		/// <param name="input_indices">
		///   2-D.  <c>N x R</c> matrix with the indices of non-empty values in a
		///   SparseTensor, possibly not in canonical ordering.
		/// </param>
		/// <param name="input_values">
		///   1-D.  <c>N</c> non-empty values corresponding to <c>input_indices</c>.
		/// </param>
		/// <param name="input_shape">
		///   1-D.  Shape of the input SparseTensor.
		/// </param>
		/// <param name="reduction_axes">
		///   1-D.  Length-<c>K</c> vector containing the reduction axes.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReduceMaxSparse'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		///   If true, retain reduced dimensions with length 1.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices:
		///   output_values:
		///   output_shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   This Op takes a SparseTensor and is the sparse counterpart to
		///   <c>tf.reduce_max()</c>.  In contrast to SparseReduceMax, this Op returns a
		///   SparseTensor.
		///   
		///   Reduces <c>sp_input</c> along the dimensions given in <c>reduction_axes</c>.  Unless
		///   <c>keep_dims</c> is true, the rank of the tensor is reduced by 1 for each entry in
		///   <c>reduction_axes</c>. If <c>keep_dims</c> is true, the reduced dimensions are retained
		///   with length 1.
		///   
		///   If <c>reduction_axes</c> has no entries, all dimensions are reduced, and a tensor
		///   with a single element is returned.  Additionally, the axes can be negative,
		///   which are interpreted according to the indexing rules in Python.
		/// </remarks>
		public (TF_Output output_indices, TF_Output output_values, TF_Output output_shape) SparseReduceMaxSparse (TF_Output input_indices, TF_Output input_values, TF_Output input_shape, TF_Output reduction_axes, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseReduceMaxSparse", MakeName ("SparseReduceMaxSparse", operName));
			c_api.TF_AddInput(desc, input_indices);
			c_api.TF_AddInput(desc, input_values);
			c_api.TF_AddInput(desc, input_shape);
			c_api.TF_AddInput(desc, reduction_axes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_indices = new TF_Output (op, _idx++);
			var output_values = new TF_Output (op, _idx++);
			var output_shape = new TF_Output (op, _idx++);
			return (output_indices, output_values, output_shape);
		}

		/// <summary>
		///   Computes the sum of elements across dimensions of a SparseTensor.
		/// </summary>
		/// <param name="input_indices">
		///   2-D.  <c>N x R</c> matrix with the indices of non-empty values in a
		///   SparseTensor, possibly not in canonical ordering.
		/// </param>
		/// <param name="input_values">
		///   1-D.  <c>N</c> non-empty values corresponding to <c>input_indices</c>.
		/// </param>
		/// <param name="input_shape">
		///   1-D.  Shape of the input SparseTensor.
		/// </param>
		/// <param name="reduction_axes">
		///   1-D.  Length-<c>K</c> vector containing the reduction axes.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReduceSum'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		///   If true, retain reduced dimensions with length 1.
		/// </param>
		/// <returns>
		///   <c>R-K</c>-D.  The reduced Tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This Op takes a SparseTensor and is the sparse counterpart to
		///   <c>tf.reduce_sum()</c>.  In particular, this Op also returns a dense <c>Tensor</c>
		///   instead of a sparse one.
		///   
		///   Reduces <c>sp_input</c> along the dimensions given in <c>reduction_axes</c>.  Unless
		///   <c>keep_dims</c> is true, the rank of the tensor is reduced by 1 for each entry in
		///   <c>reduction_axes</c>. If <c>keep_dims</c> is true, the reduced dimensions are retained
		///   with length 1.
		///   
		///   If <c>reduction_axes</c> has no entries, all dimensions are reduced, and a tensor
		///   with a single element is returned.  Additionally, the axes can be negative,
		///   which are interpreted according to the indexing rules in Python.
		/// </remarks>
		public TF_Output SparseReduceSum (TF_Output input_indices, TF_Output input_values, TF_Output input_shape, TF_Output reduction_axes, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseReduceSum", MakeName ("SparseReduceSum", operName));
			c_api.TF_AddInput(desc, input_indices);
			c_api.TF_AddInput(desc, input_values);
			c_api.TF_AddInput(desc, input_shape);
			c_api.TF_AddInput(desc, reduction_axes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the sum of elements across dimensions of a SparseTensor.
		/// </summary>
		/// <param name="input_indices">
		///   2-D.  <c>N x R</c> matrix with the indices of non-empty values in a
		///   SparseTensor, possibly not in canonical ordering.
		/// </param>
		/// <param name="input_values">
		///   1-D.  <c>N</c> non-empty values corresponding to <c>input_indices</c>.
		/// </param>
		/// <param name="input_shape">
		///   1-D.  Shape of the input SparseTensor.
		/// </param>
		/// <param name="reduction_axes">
		///   1-D.  Length-<c>K</c> vector containing the reduction axes.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReduceSumSparse'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		///   If true, retain reduced dimensions with length 1.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices:
		///   output_values:
		///   output_shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   This Op takes a SparseTensor and is the sparse counterpart to
		///   <c>tf.reduce_sum()</c>.  In contrast to SparseReduceSum, this Op returns a
		///   SparseTensor.
		///   
		///   Reduces <c>sp_input</c> along the dimensions given in <c>reduction_axes</c>.  Unless
		///   <c>keep_dims</c> is true, the rank of the tensor is reduced by 1 for each entry in
		///   <c>reduction_axes</c>. If <c>keep_dims</c> is true, the reduced dimensions are retained
		///   with length 1.
		///   
		///   If <c>reduction_axes</c> has no entries, all dimensions are reduced, and a tensor
		///   with a single element is returned.  Additionally, the axes can be negative,
		///   which are interpreted according to the indexing rules in Python.
		/// </remarks>
		public (TF_Output output_indices, TF_Output output_values, TF_Output output_shape) SparseReduceSumSparse (TF_Output input_indices, TF_Output input_values, TF_Output input_shape, TF_Output reduction_axes, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseReduceSumSparse", MakeName ("SparseReduceSumSparse", operName));
			c_api.TF_AddInput(desc, input_indices);
			c_api.TF_AddInput(desc, input_values);
			c_api.TF_AddInput(desc, input_shape);
			c_api.TF_AddInput(desc, reduction_axes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_indices = new TF_Output (op, _idx++);
			var output_values = new TF_Output (op, _idx++);
			var output_shape = new TF_Output (op, _idx++);
			return (output_indices, output_values, output_shape);
		}

		/// <summary>
		///   Reorders a SparseTensor into the canonical, row-major ordering.
		/// </summary>
		/// <param name="input_indices">
		///   2-D.  <c>N x R</c> matrix with the indices of non-empty values in a
		///   SparseTensor, possibly not in canonical ordering.
		/// </param>
		/// <param name="input_values">
		///   1-D.  <c>N</c> non-empty values corresponding to <c>input_indices</c>.
		/// </param>
		/// <param name="input_shape">
		///   1-D.  Shape of the input SparseTensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReorder'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices: 2-D.  <c>N x R</c> matrix with the same indices as input_indices, but
		///   in canonical row-major ordering.
		///   output_values: 1-D.  <c>N</c> non-empty values corresponding to <c>output_indices</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Note that by convention, all sparse ops preserve the canonical ordering along
		///   increasing dimension number. The only time ordering can be violated is during
		///   manual manipulation of the indices and values vectors to add entries.
		///   
		///   Reordering does not affect the shape of the SparseTensor.
		///   
		///   If the tensor has rank <c>R</c> and <c>N</c> non-empty values, <c>input_indices</c> has
		///   shape <c>[N, R]</c>, input_values has length <c>N</c>, and input_shape has length <c>R</c>.
		/// </remarks>
		public (TF_Output output_indices, TF_Output output_values) SparseReorder (TF_Output input_indices, TF_Output input_values, TF_Output input_shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseReorder", MakeName ("SparseReorder", operName));
			c_api.TF_AddInput(desc, input_indices);
			c_api.TF_AddInput(desc, input_values);
			c_api.TF_AddInput(desc, input_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_indices = new TF_Output (op, _idx++);
			var output_values = new TF_Output (op, _idx++);
			return (output_indices, output_values);
		}

		/// <summary>
		///   Reshapes a SparseTensor to represent values in a new dense shape.
		/// </summary>
		/// <param name="input_indices">
		///   2-D.  <c>N x R_in</c> matrix with the indices of non-empty values in a
		///   SparseTensor.
		/// </param>
		/// <param name="input_shape">
		///   1-D.  <c>R_in</c> vector with the input SparseTensor's dense shape.
		/// </param>
		/// <param name="new_shape">
		///   1-D.  <c>R_out</c> vector with the requested new dense shape.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReshape'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices: 2-D.  <c>N x R_out</c> matrix with the updated indices of non-empty
		///   values in the output SparseTensor.
		///   output_shape: 1-D.  <c>R_out</c> vector with the full dense shape of the output
		///   SparseTensor.  This is the same as <c>new_shape</c> but with any -1 dimensions
		///   filled in.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   This operation has the same semantics as reshape on the represented dense
		///   tensor.  The <c>input_indices</c> are recomputed based on the requested <c>new_shape</c>.
		///   
		///   If one component of <c>new_shape</c> is the special value -1, the size of that
		///   dimension is computed so that the total dense size remains constant.  At
		///   most one component of <c>new_shape</c> can be -1.  The number of dense elements
		///   implied by <c>new_shape</c> must be the same as the number of dense elements
		///   originally implied by <c>input_shape</c>.
		///   
		///   Reshaping does not affect the order of values in the SparseTensor.
		///   
		///   If the input tensor has rank <c>R_in</c> and <c>N</c> non-empty values, and <c>new_shape</c>
		///   has length <c>R_out</c>, then <c>input_indices</c> has shape <c>[N, R_in]</c>,
		///   <c>input_shape</c> has length <c>R_in</c>, <c>output_indices</c> has shape <c>[N, R_out]</c>, and
		///   <c>output_shape</c> has length <c>R_out</c>.
		/// </remarks>
		public (TF_Output output_indices, TF_Output output_shape) SparseReshape (TF_Output input_indices, TF_Output input_shape, TF_Output new_shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseReshape", MakeName ("SparseReshape", operName));
			c_api.TF_AddInput(desc, input_indices);
			c_api.TF_AddInput(desc, input_shape);
			c_api.TF_AddInput(desc, new_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_indices = new TF_Output (op, _idx++);
			var output_shape = new TF_Output (op, _idx++);
			return (output_indices, output_shape);
		}

		/// <summary>
		///   Computes the mean along sparse segments of a tensor.
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="indices">
		///   A 1-D tensor. Has same rank as <c>segment_ids</c>.
		/// </param>
		/// <param name="segment_ids">
		///   A 1-D tensor. Values should be sorted and can be repeated.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentMean'.
		/// </param>
		/// <returns>
		///   Has same shape as data, except for dimension 0 which
		///   has size <c>k</c>, the number of segments.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   See <c>tf.sparse.segment_sum</c> for usage examples.
		///   
		///   Like <c>SegmentMean</c>, but <c>segment_ids</c> can have rank less than <c>data</c>'s first
		///   dimension, selecting a subset of dimension 0, specified by <c>indices</c>.
		/// </remarks>
		public TF_Output SparseSegmentMean (TF_Output data, TF_Output indices, TF_Output segment_ids, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSegmentMean", MakeName ("SparseSegmentMean", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, segment_ids);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes gradients for SparseSegmentMean.
		/// </summary>
		/// <param name="grad">
		///   gradient propagated to the SparseSegmentMean op.
		/// </param>
		/// <param name="indices">
		///   indices passed to the corresponding SparseSegmentMean op.
		/// </param>
		/// <param name="segment_ids">
		///   segment_ids passed to the corresponding SparseSegmentMean op.
		/// </param>
		/// <param name="output_dim0">
		///   dimension 0 of "data" passed to SparseSegmentMean op.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentMeanGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Returns tensor "output" with same shape as grad, except for dimension 0 whose
		///   value is output_dim0.
		/// </remarks>
		public TF_Output SparseSegmentMeanGrad (TF_Output grad, TF_Output indices, TF_Output segment_ids, TF_Output output_dim0, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSegmentMeanGrad", MakeName ("SparseSegmentMeanGrad", operName));
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, segment_ids);
			c_api.TF_AddInput(desc, output_dim0);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the mean along sparse segments of a tensor.
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="indices">
		///   A 1-D tensor. Has same rank as <c>segment_ids</c>.
		/// </param>
		/// <param name="segment_ids">
		///   A 1-D tensor. Values should be sorted and can be repeated.
		/// </param>
		/// <param name="num_segments">
		///   Should equal the number of distinct segment IDs.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentMeanWithNumSegments'.
		/// </param>
		/// <returns>
		///   Has same shape as data, except for dimension 0 which has size
		///   <c>num_segments</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Like <c>SparseSegmentMean</c>, but allows missing ids in <c>segment_ids</c>. If an id is
		///   misisng, the <c>output</c> tensor at that position will be zeroed.
		///   
		///   Read
		///   [the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)
		///   for an explanation of segments.
		/// </remarks>
		public TF_Output SparseSegmentMeanWithNumSegments (TF_Output data, TF_Output indices, TF_Output segment_ids, TF_Output num_segments, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSegmentMeanWithNumSegments", MakeName ("SparseSegmentMeanWithNumSegments", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, segment_ids);
			c_api.TF_AddInput(desc, num_segments);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the sum along sparse segments of a tensor divided by the sqrt of N.
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="indices">
		///   A 1-D tensor. Has same rank as <c>segment_ids</c>.
		/// </param>
		/// <param name="segment_ids">
		///   A 1-D tensor. Values should be sorted and can be repeated.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentSqrtN'.
		/// </param>
		/// <returns>
		///   Has same shape as data, except for dimension 0 which
		///   has size <c>k</c>, the number of segments.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   N is the size of the segment being reduced.
		///   
		///   See <c>tf.sparse.segment_sum</c> for usage examples.
		///   
		/// </remarks>
		public TF_Output SparseSegmentSqrtN (TF_Output data, TF_Output indices, TF_Output segment_ids, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSegmentSqrtN", MakeName ("SparseSegmentSqrtN", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, segment_ids);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes gradients for SparseSegmentSqrtN.
		/// </summary>
		/// <param name="grad">
		///   gradient propagated to the SparseSegmentSqrtN op.
		/// </param>
		/// <param name="indices">
		///   indices passed to the corresponding SparseSegmentSqrtN op.
		/// </param>
		/// <param name="segment_ids">
		///   segment_ids passed to the corresponding SparseSegmentSqrtN op.
		/// </param>
		/// <param name="output_dim0">
		///   dimension 0 of "data" passed to SparseSegmentSqrtN op.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentSqrtNGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Returns tensor "output" with same shape as grad, except for dimension 0 whose
		///   value is output_dim0.
		/// </remarks>
		public TF_Output SparseSegmentSqrtNGrad (TF_Output grad, TF_Output indices, TF_Output segment_ids, TF_Output output_dim0, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSegmentSqrtNGrad", MakeName ("SparseSegmentSqrtNGrad", operName));
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, segment_ids);
			c_api.TF_AddInput(desc, output_dim0);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the sum along sparse segments of a tensor divided by the sqrt of N.
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="indices">
		///   A 1-D tensor. Has same rank as <c>segment_ids</c>.
		/// </param>
		/// <param name="segment_ids">
		///   A 1-D tensor. Values should be sorted and can be repeated.
		/// </param>
		/// <param name="num_segments">
		///   Should equal the number of distinct segment IDs.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentSqrtNWithNumSegments'.
		/// </param>
		/// <returns>
		///   Has same shape as data, except for dimension 0 which
		///   has size <c>k</c>, the number of segments.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   N is the size of the segment being reduced.
		///   
		///   Like <c>SparseSegmentSqrtN</c>, but allows missing ids in <c>segment_ids</c>. If an id is
		///   misisng, the <c>output</c> tensor at that position will be zeroed.
		///   
		///   Read
		///   [the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)
		///   for an explanation of segments.
		/// </remarks>
		public TF_Output SparseSegmentSqrtNWithNumSegments (TF_Output data, TF_Output indices, TF_Output segment_ids, TF_Output num_segments, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSegmentSqrtNWithNumSegments", MakeName ("SparseSegmentSqrtNWithNumSegments", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, segment_ids);
			c_api.TF_AddInput(desc, num_segments);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the sum along sparse segments of a tensor.
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="indices">
		///   A 1-D tensor. Has same rank as <c>segment_ids</c>.
		/// </param>
		/// <param name="segment_ids">
		///   A 1-D tensor. Values should be sorted and can be repeated.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentSum'.
		/// </param>
		/// <returns>
		///   Has same shape as data, except for dimension 0 which
		///   has size <c>k</c>, the number of segments.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Read
		///   [the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)
		///   for an explanation of segments.
		///   
		///   Like <c>SegmentSum</c>, but <c>segment_ids</c> can have rank less than <c>data</c>'s first
		///   dimension, selecting a subset of dimension 0, specified by <c>indices</c>.
		///   
		///   For example:
		///   
		///    <code>
		///   c = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])
		///   
		///   # Select two rows, one segment.
		///   tf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 0]))
		///   # =&amp;gt; [[0 0 0 0]]
		///   
		///   # Select two rows, two segment.
		///   tf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 1]))
		///   # =&amp;gt; [[ 1  2  3  4]
		///   #     [-1 -2 -3 -4]]
		///   
		///   # Select all rows, two segments.
		///   tf.sparse_segment_sum(c, tf.constant([0, 1, 2]), tf.constant([0, 0, 1]))
		///   # =&amp;gt; [[0 0 0 0]
		///   #     [5 6 7 8]]
		///   
		///   # Which is equivalent to:
		///   tf.segment_sum(c, tf.constant([0, 0, 1]))
		///    </code>
		/// </remarks>
		public TF_Output SparseSegmentSum (TF_Output data, TF_Output indices, TF_Output segment_ids, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSegmentSum", MakeName ("SparseSegmentSum", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, segment_ids);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the sum along sparse segments of a tensor.
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="indices">
		///   A 1-D tensor. Has same rank as <c>segment_ids</c>.
		/// </param>
		/// <param name="segment_ids">
		///   A 1-D tensor. Values should be sorted and can be repeated.
		/// </param>
		/// <param name="num_segments">
		///   Should equal the number of distinct segment IDs.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentSumWithNumSegments'.
		/// </param>
		/// <returns>
		///   Has same shape as data, except for dimension 0 which
		///   has size <c>num_segments</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Like <c>SparseSegmentSum</c>, but allows missing ids in <c>segment_ids</c>. If an id is
		///   misisng, the <c>output</c> tensor at that position will be zeroed.
		///   
		///   Read
		///   [the section on segmentation](https://tensorflow.org/api_docs/python/tf/sparse#Segmentation)
		///   for an explanation of segments.
		///   
		///   For example:
		///   
		///    <code>
		///   c = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])
		///   
		///   tf.sparse_segment_sum_with_num_segments(
		///   c, tf.constant([0, 1]), tf.constant([0, 0]), num_segments=3)
		///   # =&amp;gt; [[0 0 0 0]
		///   #     [0 0 0 0]
		///   #     [0 0 0 0]]
		///   
		///   tf.sparse_segment_sum_with_num_segments(c,
		///   tf.constant([0, 1]),
		///   tf.constant([0, 2],
		///   num_segments=4))
		///   # =&amp;gt; [[ 1  2  3  4]
		///   #     [ 0  0  0  0]
		///   #     [-1 -2 -3 -4]
		///   #     [ 0  0  0  0]]
		///    </code>
		/// </remarks>
		public TF_Output SparseSegmentSumWithNumSegments (TF_Output data, TF_Output indices, TF_Output segment_ids, TF_Output num_segments, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSegmentSumWithNumSegments", MakeName ("SparseSegmentSumWithNumSegments", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, segment_ids);
			c_api.TF_AddInput(desc, num_segments);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Slice a <c>SparseTensor</c> based on the <c>start</c> and <c>size</c>.
		/// </summary>
		/// <param name="indices">
		///   2-D tensor represents the indices of the sparse tensor.
		/// </param>
		/// <param name="values">
		///   1-D tensor represents the values of the sparse tensor.
		/// </param>
		/// <param name="shape">
		///   1-D. tensor represents the shape of the sparse tensor.
		/// </param>
		/// <param name="start">
		///   1-D. tensor represents the start of the slice.
		/// </param>
		/// <param name="size">
		///   1-D. tensor represents the size of the slice.
		///   output indices: A list of 1-D tensors represents the indices of the output
		///   sparse tensors.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSlice'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices:
		///   output_values: A list of 1-D tensors represents the values of the output sparse
		///   tensors.
		///   output_shape: A list of 1-D tensors represents the shape of the output sparse
		///   tensors.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   For example, if the input is
		///   
		///   input_tensor = shape = [2, 7]
		///   [    a   d e  ]
		///   [b c          ]
		///   
		///   Graphically the output tensors are:
		///   
		///   sparse_slice([0, 0], [2, 4]) = shape = [2, 4]
		///   [    a  ]
		///   [b c    ]
		///   
		///   sparse_slice([0, 4], [2, 3]) = shape = [2, 3]
		///   [ d e  ]
		///   [      ]
		/// </remarks>
		public (TF_Output output_indices, TF_Output output_values, TF_Output output_shape) SparseSlice (TF_Output indices, TF_Output values, TF_Output shape, TF_Output start, TF_Output size, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSlice", MakeName ("SparseSlice", operName));
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, values);
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, start);
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_indices = new TF_Output (op, _idx++);
			var output_values = new TF_Output (op, _idx++);
			var output_shape = new TF_Output (op, _idx++);
			return (output_indices, output_values, output_shape);
		}

		/// <summary>
		///   The gradient operator for the SparseSlice op.
		/// </summary>
		/// <param name="backprop_val_grad">
		///   1-D. The gradient with respect to
		///   the non-empty values of the sliced <c>SparseTensor</c>.
		/// </param>
		/// <param name="input_indices">
		///   2-D.  The <c>indices</c> of the input <c>SparseTensor</c>.
		/// </param>
		/// <param name="input_start">
		///   1-D. tensor represents the start of the slice.
		/// </param>
		/// <param name="output_indices">
		///   2-D.  The <c>indices</c> of the sliced <c>SparseTensor</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSliceGrad'.
		/// </param>
		/// <returns>
		///   1-D. The gradient with respect to the non-empty values of input <c>SparseTensor</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op takes in the upstream gradient w.r.t. non-empty values of
		///   the sliced <c>SparseTensor</c>, and outputs the gradients w.r.t.
		///   the non-empty values of input <c>SparseTensor</c>.
		/// </remarks>
		public TF_Output SparseSliceGrad (TF_Output backprop_val_grad, TF_Output input_indices, TF_Output input_start, TF_Output output_indices, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSliceGrad", MakeName ("SparseSliceGrad", operName));
			c_api.TF_AddInput(desc, backprop_val_grad);
			c_api.TF_AddInput(desc, input_indices);
			c_api.TF_AddInput(desc, input_start);
			c_api.TF_AddInput(desc, output_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var val_grad = new TF_Output (op, _idx++);
			return val_grad;
		}

		/// <summary>
		///   Applies softmax to a batched N-D <c>SparseTensor</c>.
		/// </summary>
		/// <param name="sp_indices">
		///   2-D.  <c>NNZ x R</c> matrix with the indices of non-empty values in a
		///   SparseTensor, in canonical ordering.
		/// </param>
		/// <param name="sp_values">
		///   1-D.  <c>NNZ</c> non-empty values corresponding to <c>sp_indices</c>.
		/// </param>
		/// <param name="sp_shape">
		///   1-D.  Shape of the input SparseTensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSoftmax'.
		/// </param>
		/// <returns>
		///   1-D.  The <c>NNZ</c> values for the result <c>SparseTensor</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The inputs represent an N-D SparseTensor  with logical shape <c>[..., B, C]</c>
		///   (where <c>N &amp;gt;= 2</c>), and with indices sorted in the canonical lexicographic order.
		///   
		///   This op is equivalent to applying the normal <c>tf.nn.softmax()</c> to each innermost
		///   logical submatrix with shape <c>[B, C]</c>, but with the catch that *the implicitly
		///   zero elements do not participate*.  Specifically, the algorithm is equivalent
		///   to the following:
		///   
		///   (1) Applies <c>tf.nn.softmax()</c> to a densified view of each innermost submatrix
		///   with shape <c>[B, C]</c>, along the size-C dimension;
		///   (2) Masks out the original implicitly-zero locations;
		///   (3) Renormalizes the remaining elements.
		///   
		///   Hence, the <c>SparseTensor</c> result has exactly the same non-zero indices and
		///   shape.
		/// </remarks>
		public TF_Output SparseSoftmax (TF_Output sp_indices, TF_Output sp_values, TF_Output sp_shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSoftmax", MakeName ("SparseSoftmax", operName));
			c_api.TF_AddInput(desc, sp_indices);
			c_api.TF_AddInput(desc, sp_values);
			c_api.TF_AddInput(desc, sp_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes softmax cross entropy cost and gradients to backpropagate.
		/// </summary>
		/// <param name="features">
		///   batch_size x num_classes matrix
		/// </param>
		/// <param name="labels">
		///   batch_size vector with values in [0, num_classes).
		///   This is the label for the given minibatch entry.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSoftmaxCrossEntropyWithLogits'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   loss: Per example loss (batch_size vector).
		///   backprop: backpropagated gradients (batch_size x num_classes matrix).
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Unlike <c>SoftmaxCrossEntropyWithLogits</c>, this operation does not accept
		///   a matrix of label probabilities, but rather a single label per row
		///   of features.  This label is considered to have probability 1.0 for the
		///   given row.
		///   
		///   Inputs are the logits, not probabilities.
		/// </remarks>
		public (TF_Output loss, TF_Output backprop) SparseSoftmaxCrossEntropyWithLogits (TF_Output features, TF_Output labels, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSoftmaxCrossEntropyWithLogits", MakeName ("SparseSoftmaxCrossEntropyWithLogits", operName));
			c_api.TF_AddInput(desc, features);
			c_api.TF_AddInput(desc, labels);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var loss = new TF_Output (op, _idx++);
			var backprop = new TF_Output (op, _idx++);
			return (loss, backprop);
		}

		/// <summary>
		///   Returns the element-wise max of two SparseTensors.
		/// </summary>
		/// <param name="a_indices">
		///   2-D.  <c>N x R</c> matrix with the indices of non-empty values in a
		///   SparseTensor, in the canonical lexicographic ordering.
		/// </param>
		/// <param name="a_values">
		///   1-D.  <c>N</c> non-empty values corresponding to <c>a_indices</c>.
		/// </param>
		/// <param name="a_shape">
		///   1-D.  Shape of the input SparseTensor.
		/// </param>
		/// <param name="b_indices">
		///   counterpart to <c>a_indices</c> for the other operand.
		/// </param>
		/// <param name="b_values">
		///   counterpart to <c>a_values</c> for the other operand; must be of the same dtype.
		/// </param>
		/// <param name="b_shape">
		///   counterpart to <c>a_shape</c> for the other operand; the two shapes must be equal.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSparseMaximum'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices: 2-D.  The indices of the output SparseTensor.
		///   output_values: 1-D.  The values of the output SparseTensor.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Assumes the two SparseTensors have the same shape, i.e., no broadcasting.
		/// </remarks>
		public (TF_Output output_indices, TF_Output output_values) SparseSparseMaximum (TF_Output a_indices, TF_Output a_values, TF_Output a_shape, TF_Output b_indices, TF_Output b_values, TF_Output b_shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSparseMaximum", MakeName ("SparseSparseMaximum", operName));
			c_api.TF_AddInput(desc, a_indices);
			c_api.TF_AddInput(desc, a_values);
			c_api.TF_AddInput(desc, a_shape);
			c_api.TF_AddInput(desc, b_indices);
			c_api.TF_AddInput(desc, b_values);
			c_api.TF_AddInput(desc, b_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_indices = new TF_Output (op, _idx++);
			var output_values = new TF_Output (op, _idx++);
			return (output_indices, output_values);
		}

		/// <summary>
		///   Returns the element-wise min of two SparseTensors.
		/// </summary>
		/// <param name="a_indices">
		///   2-D.  <c>N x R</c> matrix with the indices of non-empty values in a
		///   SparseTensor, in the canonical lexicographic ordering.
		/// </param>
		/// <param name="a_values">
		///   1-D.  <c>N</c> non-empty values corresponding to <c>a_indices</c>.
		/// </param>
		/// <param name="a_shape">
		///   1-D.  Shape of the input SparseTensor.
		/// </param>
		/// <param name="b_indices">
		///   counterpart to <c>a_indices</c> for the other operand.
		/// </param>
		/// <param name="b_values">
		///   counterpart to <c>a_values</c> for the other operand; must be of the same dtype.
		/// </param>
		/// <param name="b_shape">
		///   counterpart to <c>a_shape</c> for the other operand; the two shapes must be equal.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSparseMinimum'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices: 2-D.  The indices of the output SparseTensor.
		///   output_values: 1-D.  The values of the output SparseTensor.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Assumes the two SparseTensors have the same shape, i.e., no broadcasting.
		/// </remarks>
		public (TF_Output output_indices, TF_Output output_values) SparseSparseMinimum (TF_Output a_indices, TF_Output a_values, TF_Output a_shape, TF_Output b_indices, TF_Output b_values, TF_Output b_shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSparseMinimum", MakeName ("SparseSparseMinimum", operName));
			c_api.TF_AddInput(desc, a_indices);
			c_api.TF_AddInput(desc, a_values);
			c_api.TF_AddInput(desc, a_shape);
			c_api.TF_AddInput(desc, b_indices);
			c_api.TF_AddInput(desc, b_values);
			c_api.TF_AddInput(desc, b_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_indices = new TF_Output (op, _idx++);
			var output_values = new TF_Output (op, _idx++);
			return (output_indices, output_values);
		}

		/// <summary>
		///   Split a <c>SparseTensor</c> into <c>num_split</c> tensors along one dimension.
		/// </summary>
		/// <param name="split_dim">
		///   0-D.  The dimension along which to split.  Must be in the range
		///   <c>[0, rank(shape))</c>.
		/// </param>
		/// <param name="indices">
		///   2-D tensor represents the indices of the sparse tensor.
		/// </param>
		/// <param name="values">
		///   1-D tensor represents the values of the sparse tensor.
		/// </param>
		/// <param name="shape">
		///   1-D. tensor represents the shape of the sparse tensor.
		///   output indices: A list of 1-D tensors represents the indices of the output
		///   sparse tensors.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSplit'.
		/// </param>
		/// <param name="num_split">
		///   The number of ways to split.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_indices:
		///   output_values: A list of 1-D tensors represents the values of the output sparse
		///   tensors.
		///   output_shape: A list of 1-D tensors represents the shape of the output sparse
		///   tensors.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   If the <c>shape[split_dim]</c> is not an integer multiple of <c>num_split</c>. Slices
		///   <c>[0 : shape[split_dim] % num_split]</c> gets one extra dimension.
		///   For example, if <c>split_dim = 1</c> and <c>num_split = 2</c> and the input is
		///   
		///   input_tensor = shape = [2, 7]
		///   [    a   d e  ]
		///   [b c          ]
		///   
		///   Graphically the output tensors are:
		///   
		///   output_tensor[0] = shape = [2, 4]
		///   [    a  ]
		///   [b c    ]
		///   
		///   output_tensor[1] = shape = [2, 3]
		///   [ d e  ]
		///   [      ]
		/// </remarks>
		public (TF_Output[] output_indices, TF_Output[] output_values, TF_Output[] output_shape) SparseSplit (TF_Output split_dim, TF_Output indices, TF_Output values, TF_Output shape, long num_split, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseSplit", MakeName ("SparseSplit", operName));
			c_api.TF_AddInput(desc, split_dim);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, values);
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_split", num_split);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output_indices", status);
			var output_indices = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output_indices [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "output_values", status);
			var output_values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output_values [i] = new TF_Output (op, _idx++);
			
			_n = c_api.TF_OperationOutputListLength(op, "output_shape", status);
			var output_shape = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output_shape [i] = new TF_Output (op, _idx++);
			
			return (output_indices, output_values, output_shape);
		}

		/// <summary>
		///   Adds up a <c>SparseTensor</c> and a dense <c>Tensor</c>, producing a dense <c>Tensor</c>.
		/// </summary>
		/// <param name="a_indices">
		///   2-D.  The <c>indices</c> of the <c>SparseTensor</c>, with shape <c>[nnz, ndims]</c>.
		/// </param>
		/// <param name="a_values">
		///   1-D.  The <c>values</c> of the <c>SparseTensor</c>, with shape <c>[nnz]</c>.
		/// </param>
		/// <param name="a_shape">
		///   1-D.  The <c>shape</c> of the <c>SparseTensor</c>, with shape <c>[ndims]</c>.
		/// </param>
		/// <param name="b">
		///   <c>ndims</c>-D Tensor.  With shape <c>a_shape</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseTensorDenseAdd'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This Op does not require <c>a_indices</c> be sorted in standard lexicographic order.
		/// </remarks>
		public TF_Output SparseTensorDenseAdd (TF_Output a_indices, TF_Output a_values, TF_Output a_shape, TF_Output b, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseTensorDenseAdd", MakeName ("SparseTensorDenseAdd", operName));
			c_api.TF_AddInput(desc, a_indices);
			c_api.TF_AddInput(desc, a_values);
			c_api.TF_AddInput(desc, a_shape);
			c_api.TF_AddInput(desc, b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Multiply SparseTensor (of rank 2) "A" by dense matrix "B".
		/// </summary>
		/// <param name="a_indices">
		///   2-D.  The <c>indices</c> of the <c>SparseTensor</c>, size <c>[nnz, 2]</c> Matrix.
		/// </param>
		/// <param name="a_values">
		///   1-D.  The <c>values</c> of the <c>SparseTensor</c>, size <c>[nnz]</c> Vector.
		/// </param>
		/// <param name="a_shape">
		///   1-D.  The <c>shape</c> of the <c>SparseTensor</c>, size <c>[2]</c> Vector.
		/// </param>
		/// <param name="b">
		///   2-D.  A dense Matrix.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseTensorDenseMatMul'.
		/// </param>
		/// <param name="adjoint_a">
		///   Optional argument
		///   Use the adjoint of A in the matrix multiply.  If A is complex, this
		///   is transpose(conj(A)).  Otherwise it's transpose(A).
		/// </param>
		/// <param name="adjoint_b">
		///   Optional argument
		///   Use the adjoint of B in the matrix multiply.  If B is complex, this
		///   is transpose(conj(B)).  Otherwise it's transpose(B).
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   No validity checking is performed on the indices of A.  However, the following
		///   input format is recommended for optimal behavior:
		///   
		///   if adjoint_a == false:
		///   A should be sorted in lexicographically increasing order.  Use SparseReorder
		///   if you're not sure.
		///   if adjoint_a == true:
		///   A should be sorted in order of increasing dimension 1 (i.e., "column major"
		///   order instead of "row major" order).
		/// </remarks>
		public TF_Output SparseTensorDenseMatMul (TF_Output a_indices, TF_Output a_values, TF_Output a_shape, TF_Output b, bool? adjoint_a = null, bool? adjoint_b = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseTensorDenseMatMul", MakeName ("SparseTensorDenseMatMul", operName));
			c_api.TF_AddInput(desc, a_indices);
			c_api.TF_AddInput(desc, a_values);
			c_api.TF_AddInput(desc, a_shape);
			c_api.TF_AddInput(desc, b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (adjoint_a.HasValue)
				c_api.TF_SetAttrBool (desc, "adjoint_a", Convert.ToByte(adjoint_a.Value));
			
			if (adjoint_b.HasValue)
				c_api.TF_SetAttrBool (desc, "adjoint_b", Convert.ToByte(adjoint_b.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var product = new TF_Output (op, _idx++);
			return product;
		}

		/// <summary>
		///   Creates a dataset that splits a SparseTensor into elements row-wise.
		/// </summary>
		/// <param name="indices">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="dense_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseTensorSliceDataset'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SparseTensorSliceDataset (TF_Output indices, TF_Output values, TF_Output dense_shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseTensorSliceDataset", MakeName ("SparseTensorSliceDataset", operName));
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, values);
			c_api.TF_AddInput(desc, dense_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Converts a sparse representation into a dense tensor.
		/// </summary>
		/// <param name="sparse_indices">
		///   0-D, 1-D, or 2-D.  <c>sparse_indices[i]</c> contains the complete
		///   index where <c>sparse_values[i]</c> will be placed.
		/// </param>
		/// <param name="output_shape">
		///   1-D.  Shape of the dense output tensor.
		/// </param>
		/// <param name="sparse_values">
		///   1-D.  Values corresponding to each row of <c>sparse_indices</c>,
		///   or a scalar value to be used for all sparse indices.
		/// </param>
		/// <param name="default_value">
		///   Scalar value to set for indices not specified in
		///   <c>sparse_indices</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseToDense'.
		/// </param>
		/// <param name="validate_indices">
		///   Optional argument
		///   If true, indices are checked to make sure they are sorted in
		///   lexicographic order and that there are no repeats.
		/// </param>
		/// <returns>
		///   Dense output tensor of shape <c>output_shape</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Builds an array <c>dense</c> with shape <c>output_shape</c> such that
		///   
		///    <code>
		///   # If sparse_indices is scalar
		///   dense[i] = (i == sparse_indices ? sparse_values : default_value)
		///   
		///   # If sparse_indices is a vector, then for each i
		///   dense[sparse_indices[i]] = sparse_values[i]
		///   
		///   # If sparse_indices is an n by d matrix, then for each i in [0, n)
		///   dense[sparse_indices[i][0], ..., sparse_indices[i][d-1]] = sparse_values[i]
		///    </code>
		///   
		///   All other values in <c>dense</c> are set to <c>default_value</c>.  If <c>sparse_values</c> is a
		///   scalar, all sparse indices are set to this single value.
		///   
		///   Indices should be sorted in lexicographic order, and indices must not
		///   contain any repeats. If <c>validate_indices</c> is true, these properties
		///   are checked during execution.
		/// </remarks>
		public TF_Output SparseToDense (TF_Output sparse_indices, TF_Output output_shape, TF_Output sparse_values, TF_Output default_value, bool? validate_indices = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseToDense", MakeName ("SparseToDense", operName));
			c_api.TF_AddInput(desc, sparse_indices);
			c_api.TF_AddInput(desc, output_shape);
			c_api.TF_AddInput(desc, sparse_values);
			c_api.TF_AddInput(desc, default_value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (validate_indices.HasValue)
				c_api.TF_SetAttrBool (desc, "validate_indices", Convert.ToByte(validate_indices.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var dense = new TF_Output (op, _idx++);
			return dense;
		}

		/// <summary>
		///   Applies set operation along last dimension of 2 <c>SparseTensor</c> inputs.
		/// </summary>
		/// <param name="set1_indices">
		///   2D <c>Tensor</c>, indices of a <c>SparseTensor</c>. Must be in row-major
		///   order.
		/// </param>
		/// <param name="set1_values">
		///   1D <c>Tensor</c>, values of a <c>SparseTensor</c>. Must be in row-major
		///   order.
		/// </param>
		/// <param name="set1_shape">
		///   1D <c>Tensor</c>, shape of a <c>SparseTensor</c>. <c>set1_shape[0...n-1]</c> must
		///   be the same as <c>set2_shape[0...n-1]</c>, <c>set1_shape[n]</c> is the
		///   max set size across <c>0...n-1</c> dimensions.
		/// </param>
		/// <param name="set2_indices">
		///   2D <c>Tensor</c>, indices of a <c>SparseTensor</c>. Must be in row-major
		///   order.
		/// </param>
		/// <param name="set2_values">
		///   1D <c>Tensor</c>, values of a <c>SparseTensor</c>. Must be in row-major
		///   order.
		/// </param>
		/// <param name="set2_shape">
		///   1D <c>Tensor</c>, shape of a <c>SparseTensor</c>. <c>set2_shape[0...n-1]</c> must
		///   be the same as <c>set1_shape[0...n-1]</c>, <c>set2_shape[n]</c> is the
		///   max set size across <c>0...n-1</c> dimensions.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseToSparseSetOperation'.
		/// </param>
		/// <param name="validate_indices">
		///   Optional argument
		/// </param>
		/// <param name="set_operation">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   result_indices: 2D indices of a <c>SparseTensor</c>.
		///   result_values: 1D values of a <c>SparseTensor</c>.
		///   result_shape: 1D <c>Tensor</c> shape of a <c>SparseTensor</c>. <c>result_shape[0...n-1]</c> is
		///   the same as the 1st <c>n-1</c> dimensions of <c>set1</c> and <c>set2</c>, <c>result_shape[n]</c>
		///   is the max result set size across all <c>0...n-1</c> dimensions.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   See SetOperationOp::SetOperationFromContext for values of <c>set_operation</c>.
		///   
		///   If <c>validate_indices</c> is <c>True</c>, <c>SparseToSparseSetOperation</c> validates the
		///   order and range of <c>set1</c> and <c>set2</c> indices.
		///   
		///   Input <c>set1</c> is a <c>SparseTensor</c> represented by <c>set1_indices</c>, <c>set1_values</c>,
		///   and <c>set1_shape</c>. For <c>set1</c> ranked <c>n</c>, 1st <c>n-1</c> dimensions must be the same
		///   as <c>set2</c>. Dimension <c>n</c> contains values in a set, duplicates are allowed but
		///   ignored.
		///   
		///   Input <c>set2</c> is a <c>SparseTensor</c> represented by <c>set2_indices</c>, <c>set2_values</c>,
		///   and <c>set2_shape</c>. For <c>set2</c> ranked <c>n</c>, 1st <c>n-1</c> dimensions must be the same
		///   as <c>set1</c>. Dimension <c>n</c> contains values in a set, duplicates are allowed but
		///   ignored.
		///   
		///   If <c>validate_indices</c> is <c>True</c>, this op validates the order and range of <c>set1</c>
		///   and <c>set2</c> indices.
		///   
		///   Output <c>result</c> is a <c>SparseTensor</c> represented by <c>result_indices</c>,
		///   <c>result_values</c>, and <c>result_shape</c>. For <c>set1</c> and <c>set2</c> ranked <c>n</c>, this
		///   has rank <c>n</c> and the same 1st <c>n-1</c> dimensions as <c>set1</c> and <c>set2</c>. The <c>nth</c>
		///   dimension contains the result of <c>set_operation</c> applied to the corresponding
		///   <c>[0...n-1]</c> dimension of <c>set</c>.
		/// </remarks>
		public (TF_Output result_indices, TF_Output result_values, TF_Output result_shape) SparseToSparseSetOperation (TF_Output set1_indices, TF_Output set1_values, TF_Output set1_shape, TF_Output set2_indices, TF_Output set2_values, TF_Output set2_shape, string set_operation, bool? validate_indices = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SparseToSparseSetOperation", MakeName ("SparseToSparseSetOperation", operName));
			c_api.TF_AddInput(desc, set1_indices);
			c_api.TF_AddInput(desc, set1_values);
			c_api.TF_AddInput(desc, set1_shape);
			c_api.TF_AddInput(desc, set2_indices);
			c_api.TF_AddInput(desc, set2_values);
			c_api.TF_AddInput(desc, set2_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "set_operation", set_operation);
			if (validate_indices.HasValue)
				c_api.TF_SetAttrBool (desc, "validate_indices", Convert.ToByte(validate_indices.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var result_indices = new TF_Output (op, _idx++);
			var result_values = new TF_Output (op, _idx++);
			var result_shape = new TF_Output (op, _idx++);
			return (result_indices, result_values, result_shape);
		}

		/// <summary>
		///   Splits a tensor into <c>num_split</c> tensors along one dimension.
		/// </summary>
		/// <param name="split_dim">
		///   0-D.  The dimension along which to split.  Must be in the range
		///   <c>[-rank(value), rank(value))</c>.
		/// </param>
		/// <param name="value">
		///   The tensor to split.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Split'.
		/// </param>
		/// <param name="num_split">
		///   The number of ways to split.  Must evenly divide
		///   <c>value.shape[split_dim]</c>.
		/// </param>
		/// <returns>
		///   They are identically shaped tensors, whose shape matches that of <c>value</c>
		///   except along <c>axis</c>, where their sizes are
		///   <c>values.shape[split_dim] / num_split</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] Split (TF_Output split_dim, TF_Output value, long num_split, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Split", MakeName ("Split", operName));
			c_api.TF_AddInput(desc, split_dim);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_split", num_split);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		///   Splits a tensor into <c>num_split</c> tensors along one dimension.
		/// </summary>
		/// <param name="value">
		///   The tensor to split.
		/// </param>
		/// <param name="size_splits">
		///   list containing the sizes of each output tensor along the split
		///   dimension. Must sum to the dimension of value along split_dim.
		///   Can contain one -1 indicating that dimension is to be inferred.
		/// </param>
		/// <param name="split_dim">
		///   0-D.  The dimension along which to split.  Must be in the range
		///   <c>[-rank(value), rank(value))</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SplitV'.
		/// </param>
		/// <param name="num_split">
		/// </param>
		/// <returns>
		///   Tensors whose shape matches that of <c>value</c>
		///   except along <c>axis</c>, where their sizes are
		///   <c>size_splits[i]</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] SplitV (TF_Output value, TF_Output size_splits, TF_Output split_dim, long num_split, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SplitV", MakeName ("SplitV", operName));
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, size_splits);
			c_api.TF_AddInput(desc, split_dim);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_split", num_split);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		///   Creates a dataset that executes a SQL query and emits rows of the result set.
		/// </summary>
		/// <param name="driver_name">
		///   The database type. Currently, the only supported type is 'sqlite'.
		/// </param>
		/// <param name="data_source_name">
		///   A connection string to connect to the database.
		/// </param>
		/// <param name="query">
		///   A SQL query to execute.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SqlDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SqlDataset (TF_Output driver_name, TF_Output data_source_name, TF_Output query, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SqlDataset", MakeName ("SqlDataset", operName));
			c_api.TF_AddInput(desc, driver_name);
			c_api.TF_AddInput(desc, data_source_name);
			c_api.TF_AddInput(desc, query);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Computes square root of x element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Sqrt'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   I.e., \\(y = \sqrt{x} = x^{1/2}\\).
		/// </remarks>
		public TF_Output Sqrt (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Sqrt", MakeName ("Sqrt", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes the gradient for the sqrt of <c>x</c> wrt its input.
		/// </summary>
		/// <param name="y">
		/// </param>
		/// <param name="dy">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SqrtGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Specifically, <c>grad = dy * 0.5 / y</c>, where <c>y = sqrt(x)</c>, and <c>dy</c>
		///   is the corresponding input gradient.
		/// </remarks>
		public TF_Output SqrtGrad (TF_Output y, TF_Output dy, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SqrtGrad", MakeName ("SqrtGrad", operName));
			c_api.TF_AddInput(desc, y);
			c_api.TF_AddInput(desc, dy);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Computes square of x element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Square'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   I.e., \\(y = x * x = x^2\\).
		/// </remarks>
		public TF_Output Square (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Square", MakeName ("Square", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Returns (x - y)(x - y) element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SquaredDifference'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   *NOTE*: <c>SquaredDifference</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output SquaredDifference (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SquaredDifference", MakeName ("SquaredDifference", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Removes dimensions of size 1 from the shape of a tensor.
		/// </summary>
		/// <param name="input">
		///   The <c>input</c> to squeeze.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Squeeze'.
		/// </param>
		/// <param name="squeeze_dims">
		///   Optional argument
		///   If specified, only squeezes the dimensions listed. The dimension
		///   index starts at 0. It is an error to squeeze a dimension that is not 1. Must
		///   be in the range <c>[-rank(input), rank(input))</c>.
		/// </param>
		/// <returns>
		///   Contains the same data as <c>input</c>, but has one or more dimensions of
		///   size 1 removed.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given a tensor <c>input</c>, this operation returns a tensor of the same type with
		///   all dimensions of size 1 removed. If you don't want to remove all size 1
		///   dimensions, you can remove specific size 1 dimensions by specifying
		///   <c>axis</c>.
		///   
		///   For example:
		///   
		///    <code>
		///   # 't' is a tensor of shape [1, 2, 1, 3, 1, 1]
		///   shape(squeeze(t)) ==&amp;gt; [2, 3]
		///    </code>
		///   
		///   Or, to remove specific size 1 dimensions:
		///   
		///    <code>
		///   # 't' is a tensor of shape [1, 2, 1, 3, 1, 1]
		///   shape(squeeze(t, [2, 4])) ==&amp;gt; [1, 2, 3, 1]
		///    </code>
		/// </remarks>
		public TF_Output Squeeze (TF_Output input, long[] squeeze_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Squeeze", MakeName ("Squeeze", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (squeeze_dims != null)
				c_api.TF_SetAttrIntList (desc, "squeeze_dims", ref squeeze_dims[0], squeeze_dims.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Deprecated, use StackV2.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Stack'.
		/// </param>
		/// <param name="stack_name">
		///   Optional argument
		/// </param>
		/// <param name="elem_type">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Stack (TF_DataType elem_type, string stack_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Stack", MakeName ("Stack", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "elem_type", elem_type);
			if (stack_name != null)
				c_api.TF_SetAttrString (desc, "stack_name", stack_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Deprecated, use StackCloseV2.
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StackClose'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation StackClose (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StackClose", MakeName ("StackClose", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Delete the stack from its resource container.
		/// </summary>
		/// <param name="handle">
		///   The handle to a stack.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StackCloseV2'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation StackCloseV2 (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StackCloseV2", MakeName ("StackCloseV2", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Deprecated, use StackPopV2.
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StackPop'.
		/// </param>
		/// <param name="elem_type">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StackPop (TF_Output handle, TF_DataType elem_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StackPop", MakeName ("StackPop", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "elem_type", elem_type);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var elem = new TF_Output (op, _idx++);
			return elem;
		}

		/// <summary>
		///   Pop the element at the top of the stack.
		/// </summary>
		/// <param name="handle">
		///   The handle to a stack.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StackPopV2'.
		/// </param>
		/// <param name="elem_type">
		///   The type of the elem that is popped.
		/// </param>
		/// <returns>
		///   The tensor that is popped from the top of the stack.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StackPopV2 (TF_Output handle, TF_DataType elem_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StackPopV2", MakeName ("StackPopV2", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "elem_type", elem_type);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var elem = new TF_Output (op, _idx++);
			return elem;
		}

		/// <summary>
		///   Deprecated, use StackPushV2.
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="elem">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StackPush'.
		/// </param>
		/// <param name="swap_memory">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StackPush (TF_Output handle, TF_Output elem, bool? swap_memory = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StackPush", MakeName ("StackPush", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, elem);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (swap_memory.HasValue)
				c_api.TF_SetAttrBool (desc, "swap_memory", Convert.ToByte(swap_memory.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Push an element onto the stack.
		/// </summary>
		/// <param name="handle">
		///   The handle to a stack.
		/// </param>
		/// <param name="elem">
		///   The tensor to be pushed onto the stack.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StackPushV2'.
		/// </param>
		/// <param name="swap_memory">
		///   Optional argument
		///   Swap <c>elem</c> to CPU. Default to false.
		/// </param>
		/// <returns>
		///   The same tensor as the input 'elem'.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StackPushV2 (TF_Output handle, TF_Output elem, bool? swap_memory = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StackPushV2", MakeName ("StackPushV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, elem);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (swap_memory.HasValue)
				c_api.TF_SetAttrBool (desc, "swap_memory", Convert.ToByte(swap_memory.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   A stack that produces elements in first-in last-out order.
		/// </summary>
		/// <param name="max_size">
		///   The maximum size of the stack if non-negative. If negative, the stack
		///   size is unlimited.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StackV2'.
		/// </param>
		/// <param name="stack_name">
		///   Optional argument
		///   Overrides the name used for the temporary stack resource. Default
		///   value is the name of the 'Stack' op (which is guaranteed unique).
		/// </param>
		/// <param name="elem_type">
		///   The type of the elements on the stack.
		/// </param>
		/// <returns>
		///   The handle to the stack.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StackV2 (TF_Output max_size, TF_DataType elem_type, string stack_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StackV2", MakeName ("StackV2", operName));
			c_api.TF_AddInput(desc, max_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "elem_type", elem_type);
			if (stack_name != null)
				c_api.TF_SetAttrString (desc, "stack_name", stack_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Stage values similar to a lightweight Enqueue.
		/// </summary>
		/// <param name="values">
		///   a list of tensors
		///   dtypes A list of data types that inserted values should adhere to.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Stage'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		///   Maximum number of elements in the Staging Area. If &amp;gt; 0, inserts
		///   on the container will block when the capacity is reached.
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		///   The maximum number of bytes allowed for Tensors in the Staging Area.
		///   If &amp;gt; 0, inserts will block until sufficient space is available.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this queue is placed in the given container. Otherwise,
		///   a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   It is necessary to match this name to the matching Unstage Op.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   The basic functionality of this Op is similar to a queue with many
		///   fewer capabilities and options.  This Op is optimized for performance.
		/// </remarks>
		public TF_Operation Stage (TF_Output[] values, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Stage", MakeName ("Stage", operName));
			c_api.TF_AddInputList(desc, values[0], values.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Op removes all elements in the underlying container.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StageClear'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation StageClear (TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StageClear", MakeName ("StageClear", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Op peeks at the values at the specified index.  If the
		/// </summary>
		/// <param name="index">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StagePeek'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   underlying container does not contain sufficient elements
		///   this op will block until it does.   This Op is optimized for
		///   performance.
		/// </remarks>
		public TF_Output[] StagePeek (TF_Output index, TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StagePeek", MakeName ("StagePeek", operName));
			c_api.TF_AddInput(desc, index);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "values", status);
			var values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				values [i] = new TF_Output (op, _idx++);
			
			return values;
		}

		/// <summary>
		///   Op returns the number of elements in the underlying container.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StageSize'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StageSize (TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StageSize", MakeName ("StageSize", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		///   returns <c>f(inputs)</c>, where <c>f</c>'s body is placed and partitioned.
		/// </summary>
		/// <param name="args">
		///   A list of input tensors.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatefulPartitionedCall'.
		/// </param>
		/// <param name="config">
		///   Optional argument
		/// </param>
		/// <param name="config_proto">
		///   Optional argument
		/// </param>
		/// <param name="executor_type">
		///   Optional argument
		/// </param>
		/// <param name="Tout">
		///   A list of output types.
		/// </param>
		/// <param name="f">
		///   A function that takes 'args', a list of tensors, and returns 'output',
		///   another list of tensors. Input and output types are specified by 'Tin'
		///   and 'Tout'. The function body of f will be placed and partitioned across
		///   devices, setting this op apart from the regular Call op. This op is
		///   stateful.
		/// </param>
		/// <returns>
		///   A list of return values.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] StatefulPartitionedCall (TF_Output[] args, TF_DataType[] Tout, TF_Function f, string config = null, string config_proto = null, string executor_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatefulPartitionedCall", MakeName ("StatefulPartitionedCall", operName));
			c_api.TF_AddInputList(desc, args[0], args.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "Tout", Tout);
			c_api.TF_SetAttrFuncName (desc, "f", c_api.TF_FunctionName(f));
			if (config != null)
				c_api.TF_SetAttrString (desc, "config", config);
			
			if (config_proto != null)
				c_api.TF_SetAttrString (desc, "config_proto", config_proto);
			
			if (executor_type != null)
				c_api.TF_SetAttrString (desc, "executor_type", executor_type);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="resource">
		/// </param>
		/// <param name="algorithm">
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <param name="counts">
		/// </param>
		/// <param name="probs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatefulRandomBinomial'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StatefulRandomBinomial (TF_Output resource, TF_Output algorithm, TF_Output shape, TF_Output counts, TF_Output probs, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatefulRandomBinomial", MakeName ("StatefulRandomBinomial", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, algorithm);
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, counts);
			c_api.TF_AddInput(desc, probs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Outputs random values from a normal distribution. This op is deprecated in favor of op 'StatefulStandardNormalV2'
		/// </summary>
		/// <param name="resource">
		///   The handle of the resource variable that stores the state of the RNG.
		/// </param>
		/// <param name="shape">
		///   The shape of the output tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatefulStandardNormal'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		///   The type of the output.
		/// </param>
		/// <returns>
		///   A tensor of the specified shape filled with random normal values.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The generated values will have mean 0 and standard deviation 1.
		/// </remarks>
		public TF_Output StatefulStandardNormal (TF_Output resource, TF_Output shape, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatefulStandardNormal", MakeName ("StatefulStandardNormal", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Outputs random values from a normal distribution.
		/// </summary>
		/// <param name="resource">
		///   The handle of the resource variable that stores the state of the RNG.
		/// </param>
		/// <param name="algorithm">
		///   The RNG algorithm.
		/// </param>
		/// <param name="shape">
		///   The shape of the output tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatefulStandardNormalV2'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		///   The type of the output.
		/// </param>
		/// <returns>
		///   A tensor of the specified shape filled with random normal values.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The generated values will have mean 0 and standard deviation 1.
		/// </remarks>
		public TF_Output StatefulStandardNormalV2 (TF_Output resource, TF_Output algorithm, TF_Output shape, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatefulStandardNormalV2", MakeName ("StatefulStandardNormalV2", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, algorithm);
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Outputs random values from a truncated normal distribution.
		/// </summary>
		/// <param name="resource">
		///   The handle of the resource variable that stores the state of the RNG.
		/// </param>
		/// <param name="algorithm">
		///   The RNG algorithm.
		/// </param>
		/// <param name="shape">
		///   The shape of the output tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatefulTruncatedNormal'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		///   The type of the output.
		/// </param>
		/// <returns>
		///   Random values with specified shape.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The generated values follow a normal distribution with mean 0 and standard
		///   deviation 1, except that values whose magnitude is more than 2 standard
		///   deviations from the mean are dropped and re-picked.
		/// </remarks>
		public TF_Output StatefulTruncatedNormal (TF_Output resource, TF_Output algorithm, TF_Output shape, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatefulTruncatedNormal", MakeName ("StatefulTruncatedNormal", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, algorithm);
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Outputs random values from a uniform distribution.
		/// </summary>
		/// <param name="resource">
		///   The handle of the resource variable that stores the state of the RNG.
		/// </param>
		/// <param name="algorithm">
		///   The RNG algorithm.
		/// </param>
		/// <param name="shape">
		///   The shape of the output tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatefulUniform'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		///   The type of the output.
		/// </param>
		/// <returns>
		///   Random values with specified shape.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The generated values follow a uniform distribution in the range <c>[0, 1)</c>. The
		///   lower bound 0 is included in the range, while the upper bound 1 is excluded.
		/// </remarks>
		public TF_Output StatefulUniform (TF_Output resource, TF_Output algorithm, TF_Output shape, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatefulUniform", MakeName ("StatefulUniform", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, algorithm);
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Outputs random integers from a uniform distribution.
		/// </summary>
		/// <param name="resource">
		///   The handle of the resource variable that stores the state of the RNG.
		/// </param>
		/// <param name="algorithm">
		///   The RNG algorithm.
		/// </param>
		/// <param name="shape">
		///   The shape of the output tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatefulUniformFullInt'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		///   The type of the output.
		/// </param>
		/// <returns>
		///   Random values with specified shape.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The generated values are uniform integers covering the whole range of <c>dtype</c>.
		/// </remarks>
		public TF_Output StatefulUniformFullInt (TF_Output resource, TF_Output algorithm, TF_Output shape, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatefulUniformFullInt", MakeName ("StatefulUniformFullInt", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, algorithm);
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Outputs random integers from a uniform distribution.
		/// </summary>
		/// <param name="resource">
		///   The handle of the resource variable that stores the state of the RNG.
		/// </param>
		/// <param name="algorithm">
		///   The RNG algorithm.
		/// </param>
		/// <param name="shape">
		///   The shape of the output tensor.
		/// </param>
		/// <param name="minval">
		///   Minimum value (inclusive, scalar).
		/// </param>
		/// <param name="maxval">
		///   Maximum value (exclusive, scalar).
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatefulUniformInt'.
		/// </param>
		/// <returns>
		///   Random values with specified shape.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The generated values are uniform integers in the range <c>[minval, maxval)</c>.
		///   The lower bound <c>minval</c> is included in the range, while the upper bound
		///   <c>maxval</c> is excluded.
		///   
		///   The random integers are slightly biased unless <c>maxval - minval</c> is an exact
		///   power of two.  The bias is small for values of <c>maxval - minval</c> significantly
		///   smaller than the range of the output (either <c>2^32</c> or <c>2^64</c>).
		/// </remarks>
		public TF_Output StatefulUniformInt (TF_Output resource, TF_Output algorithm, TF_Output shape, TF_Output minval, TF_Output maxval, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatefulUniformInt", MakeName ("StatefulUniformInt", operName));
			c_api.TF_AddInput(desc, resource);
			c_api.TF_AddInput(desc, algorithm);
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, minval);
			c_api.TF_AddInput(desc, maxval);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   output = cond ? then_branch(input) : else_branch(input)
		/// </summary>
		/// <param name="cond">
		///   A Tensor. If the tensor is a scalar of non-boolean type, the
		///   scalar is converted to a boolean according to the
		///   following rule: if the scalar is a numerical value, non-zero means
		///   <c>True</c> and zero means False; if the scalar is a string, non-empty
		///   means <c>True</c> and empty means <c>False</c>. If the tensor is not a scalar,
		///   being empty means False and being non-empty means True.
		///   
		///   This should only be used when the if then/else body functions do not
		///   have stateful ops.
		/// </param>
		/// <param name="input">
		///   A list of input tensors.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatelessIf'.
		/// </param>
		/// <param name="output_shapes">
		///   Optional argument
		/// </param>
		/// <param name="Tout">
		///   A list of output types.
		/// </param>
		/// <param name="then_branch">
		///   A function that takes 'inputs' and returns a list of tensors, whose
		///   types are the same as what else_branch returns.
		/// </param>
		/// <param name="else_branch">
		///   A function that takes 'inputs' and returns a list of tensors, whose
		///   types are the same as what then_branch returns.
		/// </param>
		/// <returns>
		///   A list of return values.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] StatelessIf (TF_Output cond, TF_Output[] input, TF_DataType[] Tout, TF_Function then_branch, TF_Function else_branch, long[][] output_shapes = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatelessIf", MakeName ("StatelessIf", operName));
			c_api.TF_AddInput(desc, cond);
			c_api.TF_AddInputList(desc, input[0], input.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "Tout", Tout);
			c_api.TF_SetAttrFuncName (desc, "then_branch", c_api.TF_FunctionName(then_branch));
			c_api.TF_SetAttrFuncName (desc, "else_branch", c_api.TF_FunctionName(else_branch));
			if (output_shapes != null)
				c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		///   Draws samples from a multinomial distribution.
		/// </summary>
		/// <param name="logits">
		///   2-D Tensor with shape <c>[batch_size, num_classes]</c>.  Each slice <c>[i, :]</c>
		///   represents the unnormalized log probabilities for all classes.
		/// </param>
		/// <param name="num_samples">
		///   0-D.  Number of independent samples to draw for each row slice.
		/// </param>
		/// <param name="seed">
		///   2 seeds (shape [2]).
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatelessMultinomial'.
		/// </param>
		/// <param name="output_dtype">
		///   Optional argument
		/// </param>
		/// <returns>
		///   2-D Tensor with shape <c>[batch_size, num_samples]</c>.  Each slice <c>[i, :]</c>
		///   contains the drawn class labels with range <c>[0, num_classes)</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StatelessMultinomial (TF_Output logits, TF_Output num_samples, TF_Output seed, TF_DataType? output_dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatelessMultinomial", MakeName ("StatelessMultinomial", operName));
			c_api.TF_AddInput(desc, logits);
			c_api.TF_AddInput(desc, num_samples);
			c_api.TF_AddInput(desc, seed);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (output_dtype.HasValue)
				c_api.TF_SetAttrType (desc, "output_dtype", output_dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Outputs deterministic pseudorandom values from a normal distribution.
		/// </summary>
		/// <param name="shape">
		///   The shape of the output tensor.
		/// </param>
		/// <param name="seed">
		///   2 seeds (shape [2]).
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatelessRandomNormal'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		///   The type of the output.
		/// </param>
		/// <returns>
		///   Random values with specified shape.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The generated values will have mean 0 and standard deviation 1.
		///   
		///   The outputs are a deterministic function of <c>shape</c> and <c>seed</c>.
		/// </remarks>
		public TF_Output StatelessRandomNormal (TF_Output shape, TF_Output seed, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatelessRandomNormal", MakeName ("StatelessRandomNormal", operName));
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, seed);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Outputs deterministic pseudorandom random values from a uniform distribution.
		/// </summary>
		/// <param name="shape">
		///   The shape of the output tensor.
		/// </param>
		/// <param name="seed">
		///   2 seeds (shape [2]).
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatelessRandomUniform'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		///   The type of the output.
		/// </param>
		/// <returns>
		///   Random values with specified shape.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The generated values follow a uniform distribution in the range <c>[0, 1)</c>. The
		///   lower bound 0 is included in the range, while the upper bound 1 is excluded.
		///   
		///   The outputs are a deterministic function of <c>shape</c> and <c>seed</c>.
		/// </remarks>
		public TF_Output StatelessRandomUniform (TF_Output shape, TF_Output seed, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatelessRandomUniform", MakeName ("StatelessRandomUniform", operName));
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, seed);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Outputs deterministic pseudorandom random integers from a uniform distribution.
		/// </summary>
		/// <param name="shape">
		///   The shape of the output tensor.
		/// </param>
		/// <param name="seed">
		///   2 seeds (shape [2]).
		/// </param>
		/// <param name="minval">
		///   Minimum value (inclusive, scalar).
		/// </param>
		/// <param name="maxval">
		///   Maximum value (exclusive, scalar).
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatelessRandomUniformInt'.
		/// </param>
		/// <returns>
		///   Random values with specified shape.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The generated values follow a uniform distribution in the range <c>[minval, maxval)</c>.
		///   
		///   The outputs are a deterministic function of <c>shape</c>, <c>seed</c>, <c>minval</c>, and <c>maxval</c>.
		/// </remarks>
		public TF_Output StatelessRandomUniformInt (TF_Output shape, TF_Output seed, TF_Output minval, TF_Output maxval, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatelessRandomUniformInt", MakeName ("StatelessRandomUniformInt", operName));
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, seed);
			c_api.TF_AddInput(desc, minval);
			c_api.TF_AddInput(desc, maxval);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Outputs deterministic pseudorandom values from a truncated normal distribution.
		/// </summary>
		/// <param name="shape">
		///   The shape of the output tensor.
		/// </param>
		/// <param name="seed">
		///   2 seeds (shape [2]).
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatelessTruncatedNormal'.
		/// </param>
		/// <param name="dtype">
		///   Optional argument
		///   The type of the output.
		/// </param>
		/// <returns>
		///   Random values with specified shape.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The generated values follow a normal distribution with mean 0 and standard
		///   deviation 1, except that values whose magnitude is more than 2 standard
		///   deviations from the mean are dropped and re-picked.
		///   
		///   The outputs are a deterministic function of <c>shape</c> and <c>seed</c>.
		/// </remarks>
		public TF_Output StatelessTruncatedNormal (TF_Output shape, TF_Output seed, TF_DataType? dtype = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatelessTruncatedNormal", MakeName ("StatelessTruncatedNormal", operName));
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, seed);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (dtype.HasValue)
				c_api.TF_SetAttrType (desc, "dtype", dtype.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   output = input; While (Cond(output)) { output = Body(output) }
		/// </summary>
		/// <param name="input">
		///   A list of input tensors whose types are T.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatelessWhile'.
		/// </param>
		/// <param name="output_shapes">
		///   Optional argument
		/// </param>
		/// <param name="parallel_iterations">
		///   Optional argument
		/// </param>
		/// <param name="cond">
		///   A function takes 'input' and returns a tensor.  If the tensor is
		///   a scalar of non-boolean, the scalar is converted to a boolean
		///   according to the following rule: if the scalar is a numerical
		///   value, non-zero means True and zero means False; if the scalar is
		///   a string, non-empty means True and empty means False. If the
		///   tensor is not a scalar, non-emptiness means True and False
		///   otherwise.
		///   
		///   This should only be used when the while condition and body functions
		///   do not have stateful ops.
		/// </param>
		/// <param name="body">
		///   A function that takes a list of tensors and returns another
		///   list of tensors. Both lists have the same types as specified
		///   by T.
		/// </param>
		/// <returns>
		///   A list of output tensors whose types are T.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] StatelessWhile (TF_Output[] input, TF_Function cond, TF_Function body, long[][] output_shapes = null, long? parallel_iterations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatelessWhile", MakeName ("StatelessWhile", operName));
			c_api.TF_AddInputList(desc, input[0], input.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "cond", c_api.TF_FunctionName(cond));
			c_api.TF_SetAttrFuncName (desc, "body", c_api.TF_FunctionName(body));
			if (output_shapes != null)
				c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			
			if (parallel_iterations.HasValue)
				c_api.TF_SetAttrInt (desc, "parallel_iterations", parallel_iterations.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		///   Check if the input matches the regex pattern.
		/// </summary>
		/// <param name="input">
		///   A string tensor of the text to be processed.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StaticRegexFullMatch'.
		/// </param>
		/// <param name="pattern">
		///   The regular expression to match the input.
		/// </param>
		/// <returns>
		///   A bool tensor with the same shape as <c>input</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The input is a string tensor of any shape. The pattern is the
		///   regular expression to be matched with every element of the input tensor.
		///   The boolean values (True or False) of the output tensor indicate
		///   if the input matches the regex pattern provided.
		///   
		///   The pattern follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)
		/// </remarks>
		public TF_Output StaticRegexFullMatch (TF_Output input, string pattern, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StaticRegexFullMatch", MakeName ("StaticRegexFullMatch", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "pattern", pattern);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Replaces the match of pattern in input with rewrite.
		/// </summary>
		/// <param name="input">
		///   The text to be processed.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StaticRegexReplace'.
		/// </param>
		/// <param name="replace_global">
		///   Optional argument
		///   If True, the replacement is global, otherwise the replacement
		///   is done only on the first match.
		/// </param>
		/// <param name="pattern">
		///   The regular expression to match the input.
		/// </param>
		/// <param name="rewrite">
		///   The rewrite to be applied to the matched expression.
		/// </param>
		/// <returns>
		///   The text after applying pattern and rewrite.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   It follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)
		/// </remarks>
		public TF_Output StaticRegexReplace (TF_Output input, string pattern, string rewrite, bool? replace_global = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StaticRegexReplace", MakeName ("StaticRegexReplace", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "pattern", pattern);
			c_api.TF_SetAttrString (desc, "rewrite", rewrite);
			if (replace_global.HasValue)
				c_api.TF_SetAttrBool (desc, "replace_global", Convert.ToByte(replace_global.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates a statistics manager resource.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatsAggregatorHandle'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StatsAggregatorHandle (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatsAggregatorHandle", MakeName ("StatsAggregatorHandle", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatsAggregatorHandleV2'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StatsAggregatorHandleV2 (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatsAggregatorHandleV2", MakeName ("StatsAggregatorHandleV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Set a summary_writer_interface to record statistics using given stats_aggregator.
		/// </summary>
		/// <param name="stats_aggregator">
		/// </param>
		/// <param name="summary">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatsAggregatorSetSummaryWriter'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation StatsAggregatorSetSummaryWriter (TF_Output stats_aggregator, TF_Output summary, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatsAggregatorSetSummaryWriter", MakeName ("StatsAggregatorSetSummaryWriter", operName));
			c_api.TF_AddInput(desc, stats_aggregator);
			c_api.TF_AddInput(desc, summary);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Produces a summary of any statistics recorded by the given statistics manager.
		/// </summary>
		/// <param name="iterator">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StatsAggregatorSummary'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StatsAggregatorSummary (TF_Output iterator, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StatsAggregatorSummary", MakeName ("StatsAggregatorSummary", operName));
			c_api.TF_AddInput(desc, iterator);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var summary = new TF_Output (op, _idx++);
			return summary;
		}

		/// <summary>
		///   Stops gradient computation.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StopGradient'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   When executed in a graph, this op outputs its input tensor as-is.
		///   
		///   When building ops to compute gradients, this op prevents the contribution of
		///   its inputs to be taken into account.  Normally, the gradient generator adds ops
		///   to a graph to compute the derivatives of a specified 'loss' by recursively
		///   finding out inputs that contributed to its computation.  If you insert this op
		///   in the graph it inputs are masked from the gradient generator.  They are not
		///   taken into account for computing gradients.
		///   
		///   This is useful any time you want to compute a value with TensorFlow but need
		///   to pretend that the value was a constant. Some examples include:
		///   
		///   *  The *EM* algorithm where the *M-step* should not involve backpropagation
		///   through the output of the *E-step*.
		///   *  Contrastive divergence training of Boltzmann machines where, when
		///   differentiating the energy function, the training must not backpropagate
		///   through the graph that generated the samples from the model.
		///   *  Adversarial training, where no backprop should happen through the adversarial
		///   example generation process.
		/// </remarks>
		public TF_Output StopGradient (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StopGradient", MakeName ("StopGradient", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Return a strided slice from <c>input</c>.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="begin">
		///   <c>begin[k]</c> specifies the offset into the <c>k</c>th range specification.
		///   The exact dimension this corresponds to will be determined by context.
		///   Out-of-bounds values will be silently clamped. If the <c>k</c>th bit of
		///   <c>begin_mask</c> then <c>begin[k]</c> is ignored and the full range of the
		///   appropriate dimension is used instead. Negative values causes indexing
		///   to start from the highest element e.g. If <c>foo==[1,2,3]</c> then <c>foo[-1]==3</c>.
		/// </param>
		/// <param name="end">
		///   <c>end[i]</c> is like <c>begin</c> with the exception that <c>end_mask</c> is
		///   used to determine full ranges.
		/// </param>
		/// <param name="strides">
		///   <c>strides[i]</c> specifies the increment in the <c>i</c>th specification
		///   after extracting a given element. Negative indices will reverse
		///   the original order. Out or range values are
		///   clamped to <c>[0,dim[i]) if slice[i]&amp;gt;0</c> or <c>[-1,dim[i]-1] if slice[i] &amp;lt; 0</c>
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StridedSlice'.
		/// </param>
		/// <param name="begin_mask">
		///   Optional argument
		///   a bitmask where a bit i being 1 means to ignore the begin
		///   value and instead use the largest interval possible. At runtime
		///   begin[i] will be replaced with <c>[0, n-1)</c> if <c>stride[i] &amp;gt; 0</c> or
		///   <c>[-1, n-1]</c> if <c>stride[i] &amp;lt; 0</c>
		/// </param>
		/// <param name="end_mask">
		///   Optional argument
		///   analogous to <c>begin_mask</c>
		/// </param>
		/// <param name="ellipsis_mask">
		///   Optional argument
		///   a bitmask where bit <c>i</c> being 1 means the <c>i</c>th
		///   position is actually an ellipsis. One bit at most can be 1.
		///   If <c>ellipsis_mask == 0</c>, then an implicit ellipsis mask of <c>1 &amp;lt;&amp;lt; (m+1)</c>
		///   is provided. This means that <c>foo[3:5] == foo[3:5, ...]</c>. An ellipsis
		///   implicitly creates as many range specifications as necessary to fully
		///   specify the sliced range for every dimension. For example for a 4-dimensional
		///   tensor <c>foo</c> the slice <c>foo[2, ..., 5:8]</c> implies <c>foo[2, :, :, 5:8]</c>.
		/// </param>
		/// <param name="new_axis_mask">
		///   Optional argument
		///   a bitmask where bit <c>i</c> being 1 means the <c>i</c>th
		///   specification creates a new shape 1 dimension. For example
		///   <c>foo[:4, tf.newaxis, :2]</c> would produce a shape <c>(4, 1, 2)</c> tensor.
		/// </param>
		/// <param name="shrink_axis_mask">
		///   Optional argument
		///   a bitmask where bit <c>i</c> implies that the <c>i</c>th
		///   specification should shrink the dimensionality. begin and end
		///   must imply a slice of size 1 in the dimension. For example in
		///   python one might do <c>foo[:, 3, :]</c> which would result in
		///   <c>shrink_axis_mask</c> being 2.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Note, most python users will want to use the Python <c>Tensor.__getitem__</c>
		///   or <c>Variable.__getitem__</c> rather than this op directly.
		///   
		///   The goal of this op is to produce a new tensor with a subset of
		///   the elements from the <c>n</c> dimensional <c>input</c> tensor. The subset is chosen using
		///   a sequence of <c>m</c> sparse range specifications encoded into the arguments
		///   of this function. Note, in some cases
		///   <c>m</c> could be equal to <c>n</c>, but this need not be the case. Each
		///   range specification entry can be one of the following:
		///   
		///   - An ellipsis (...). Ellipses are used to imply zero or more
		///   dimensions of full-dimension selection and are produced using
		///   <c>ellipsis_mask</c>. For example, <c>foo[...]</c> is the identity slice.
		///   
		///   - A new axis. This is used to insert a new shape=1 dimension and is
		///   produced using <c>new_axis_mask</c>. For example, <c>foo[:, ...]</c> where
		///   <c>foo</c> is shape <c>(3, 4)</c> produces a <c>(1, 3, 4)</c> tensor.
		///   
		///   
		///   - A range <c>begin:end:stride</c>. This is used to specify how much to choose from
		///   a given dimension. <c>stride</c> can be any integer but 0.  <c>begin</c> is an integer
		///   which represents the index of the first value to select while <c>end</c> represents
		///   the index of the last value to select. The number of values selected in each
		///   dimension is <c>end - begin</c> if <c>stride &amp;gt; 0</c> and <c>begin - end</c> if <c>stride &amp;lt; 0</c>.
		///   <c>begin</c> and <c>end</c> can be negative where <c>-1</c> is the last element, <c>-2</c> is
		///   the second to last. <c>begin_mask</c> controls whether to replace the explicitly
		///   given <c>begin</c> with an implicit effective value of <c>0</c> if <c>stride &amp;gt; 0</c> and
		///   <c>-1</c> if <c>stride &amp;lt; 0</c>. <c>end_mask</c> is analogous but produces the number
		///   required to create the largest open interval. For example, given a shape
		///   <c>(3,)</c> tensor <c>foo[:]</c>, the effective <c>begin</c> and <c>end</c> are <c>0</c> and <c>3</c>. Do
		///   not assume this is equivalent to <c>foo[0:-1]</c> which has an effective <c>begin</c>
		///   and <c>end</c> of <c>0</c> and <c>2</c>. Another example is <c>foo[-2::-1]</c> which reverses the
		///   first dimension of a tensor while dropping the last two (in the original
		///   order elements). For example <c>foo = [1,2,3,4]; foo[-2::-1]</c> is <c>[4,3]</c>.
		///   
		///   - A single index. This is used to keep only elements that have a given
		///   index. For example (<c>foo[2, :]</c> on a shape <c>(5,6)</c> tensor produces a
		///   shape <c>(6,)</c> tensor. This is encoded in <c>begin</c> and <c>end</c> and
		///   <c>shrink_axis_mask</c>.
		///   
		///   Each conceptual range specification is encoded in the op's argument. This
		///   encoding is best understand by considering a non-trivial example. In
		///   particular,
		///   <c>foo[1, 2:4, None, ..., :-3:-1, :]</c> will be encoded as
		///   
		///    <code>
		///   begin = [1, 2, x, x, 0, x] # x denotes don't care (usually 0)
		///   end = [2, 4, x, x, -3, x]
		///   strides = [1, 1, x, x, -1, 1]
		///   begin_mask = 1&amp;lt;&amp;lt;4 | 1 &amp;lt;&amp;lt; 5 = 48
		///   end_mask = 1&amp;lt;&amp;lt;5 = 32
		///   ellipsis_mask = 1&amp;lt;&amp;lt;3 = 8
		///   new_axis_mask = 1&amp;lt;&amp;lt;2 4
		///   shrink_axis_mask = 1&amp;lt;&amp;lt;0
		///    </code>
		///   
		///   In this case if <c>foo.shape</c> is (5, 5, 5, 5, 5, 5) the final shape of
		///   the slice becomes (2, 1, 5, 5, 2, 5).
		///   Let us walk step by step through each argument specification.
		///   
		///   1.  The first argument in the example slice is turned into <c>begin = 1</c> and
		///   <c>end = begin + 1 = 2</c>. To disambiguate from the original spec <c>2:4</c> we
		///   also set the appropriate bit in <c>shrink_axis_mask</c>.
		///   
		///   2. <c>2:4</c> is contributes 2, 4, 1 to begin, end, and stride. All masks have
		///   zero bits contributed.
		///   
		///   3. None is a synonym for <c>tf.newaxis</c>. This means insert a dimension of size 1
		///   dimension in the final shape. Dummy values are contributed to begin,
		///   end and stride, while the new_axis_mask bit is set.
		///   
		///   4. <c>...</c> grab the full ranges from as many dimensions as needed to
		///   fully specify a slice for every dimension of the input shape.
		///   
		///   5. <c>:-3:-1</c> shows the use of negative indices. A negative index <c>i</c> associated
		///   with a dimension that has shape <c>s</c> is converted to a positive index
		///   <c>s + i</c>. So <c>-1</c> becomes <c>s-1</c> (i.e. the last element). This conversion
		///   is done internally so begin, end and strides receive x, -3, and -1.
		///   The appropriate begin_mask bit is set to indicate the start range is the
		///   full range (ignoring the x).
		///   
		///   6. <c>:</c> indicates that the entire contents of the corresponding dimension
		///   is selected. This is equivalent to <c>::</c> or <c>0::1</c>. begin, end, and strides
		///   receive 0, 0, and 1, respectively. The appropriate bits in <c>begin_mask</c> and
		///   <c>end_mask</c> are also set.
		///   
		///   *Requirements*:
		///   <c>0 != strides[i] for i in [0, m)</c>
		///   <c>ellipsis_mask must be a power of two (only one ellipsis)</c>
		/// </remarks>
		public TF_Output StridedSlice (TF_Output input, TF_Output begin, TF_Output end, TF_Output strides, long? begin_mask = null, long? end_mask = null, long? ellipsis_mask = null, long? new_axis_mask = null, long? shrink_axis_mask = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StridedSlice", MakeName ("StridedSlice", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, begin);
			c_api.TF_AddInput(desc, end);
			c_api.TF_AddInput(desc, strides);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (begin_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "begin_mask", begin_mask.Value);
			
			if (end_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "end_mask", end_mask.Value);
			
			if (ellipsis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "ellipsis_mask", ellipsis_mask.Value);
			
			if (new_axis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "new_axis_mask", new_axis_mask.Value);
			
			if (shrink_axis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "shrink_axis_mask", shrink_axis_mask.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Assign <c>value</c> to the sliced l-value reference of <c>ref</c>.
		/// </summary>
		/// <param name="reference">
		/// </param>
		/// <param name="begin">
		/// </param>
		/// <param name="end">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StridedSliceAssign'.
		/// </param>
		/// <param name="begin_mask">
		///   Optional argument
		/// </param>
		/// <param name="end_mask">
		///   Optional argument
		/// </param>
		/// <param name="ellipsis_mask">
		///   Optional argument
		/// </param>
		/// <param name="new_axis_mask">
		///   Optional argument
		/// </param>
		/// <param name="shrink_axis_mask">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The values of <c>value</c> are assigned to the positions in the variable
		///   <c>ref</c> that are selected by the slice parameters. The slice parameters
		///   <c>begin</c>, <c>end</c>, <c>strides</c>, etc. work exactly as in <c>StridedSlice</c>.
		///   
		///   NOTE this op currently does not support broadcasting and so <c>value</c>'s
		///   shape must be exactly the shape produced by the slice of <c>ref</c>.
		/// </remarks>
		public TF_Output StridedSliceAssign (TF_Output reference, TF_Output begin, TF_Output end, TF_Output strides, TF_Output value, long? begin_mask = null, long? end_mask = null, long? ellipsis_mask = null, long? new_axis_mask = null, long? shrink_axis_mask = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StridedSliceAssign", MakeName ("StridedSliceAssign", operName));
			c_api.TF_AddInput(desc, reference);
			c_api.TF_AddInput(desc, begin);
			c_api.TF_AddInput(desc, end);
			c_api.TF_AddInput(desc, strides);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (begin_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "begin_mask", begin_mask.Value);
			
			if (end_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "end_mask", end_mask.Value);
			
			if (ellipsis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "ellipsis_mask", ellipsis_mask.Value);
			
			if (new_axis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "new_axis_mask", new_axis_mask.Value);
			
			if (shrink_axis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "shrink_axis_mask", shrink_axis_mask.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_ref = new TF_Output (op, _idx++);
			return output_ref;
		}

		/// <summary>
		///   Returns the gradient of <c>StridedSlice</c>.
		/// </summary>
		/// <param name="shape">
		/// </param>
		/// <param name="begin">
		/// </param>
		/// <param name="end">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="dy">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StridedSliceGrad'.
		/// </param>
		/// <param name="begin_mask">
		///   Optional argument
		/// </param>
		/// <param name="end_mask">
		///   Optional argument
		/// </param>
		/// <param name="ellipsis_mask">
		///   Optional argument
		/// </param>
		/// <param name="new_axis_mask">
		///   Optional argument
		/// </param>
		/// <param name="shrink_axis_mask">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Since <c>StridedSlice</c> cuts out pieces of its <c>input</c> which is size
		///   <c>shape</c>, its gradient will have the same shape (which is passed here
		///   as <c>shape</c>). The gradient will be zero in any element that the slice
		///   does not select.
		///   
		///   Arguments are the same as StridedSliceGrad with the exception that
		///   <c>dy</c> is the input gradient to be propagated and <c>shape</c> is the
		///   shape of <c>StridedSlice</c>'s <c>input</c>.
		/// </remarks>
		public TF_Output StridedSliceGrad (TF_Output shape, TF_Output begin, TF_Output end, TF_Output strides, TF_Output dy, long? begin_mask = null, long? end_mask = null, long? ellipsis_mask = null, long? new_axis_mask = null, long? shrink_axis_mask = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StridedSliceGrad", MakeName ("StridedSliceGrad", operName));
			c_api.TF_AddInput(desc, shape);
			c_api.TF_AddInput(desc, begin);
			c_api.TF_AddInput(desc, end);
			c_api.TF_AddInput(desc, strides);
			c_api.TF_AddInput(desc, dy);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (begin_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "begin_mask", begin_mask.Value);
			
			if (end_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "end_mask", end_mask.Value);
			
			if (ellipsis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "ellipsis_mask", ellipsis_mask.Value);
			
			if (new_axis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "new_axis_mask", new_axis_mask.Value);
			
			if (shrink_axis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "shrink_axis_mask", shrink_axis_mask.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Formats a string template using a list of tensors.
		/// </summary>
		/// <param name="inputs">
		///   The list of tensors to format into the placeholder string.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringFormat'.
		/// </param>
		/// <param name="template">
		///   Optional argument
		///   A string, the template to format tensor summaries into.
		/// </param>
		/// <param name="placeholder">
		///   Optional argument
		///   A string, at each placeholder in the template a subsequent tensor summary will be inserted.
		/// </param>
		/// <param name="summarize">
		///   Optional argument
		///   When formatting the tensor summaries print the first and last summarize entries of each tensor dimension.
		/// </param>
		/// <returns>
		///   = The resulting string scalar.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Formats a string template using a list of tensors, pretty-printing tensor summaries.
		/// </remarks>
		public TF_Output StringFormat (TF_Output[] inputs, string template = null, string placeholder = null, long? summarize = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringFormat", MakeName ("StringFormat", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (template != null)
				c_api.TF_SetAttrString (desc, "template", template);
			
			if (placeholder != null)
				c_api.TF_SetAttrString (desc, "placeholder", placeholder);
			
			if (summarize.HasValue)
				c_api.TF_SetAttrInt (desc, "summarize", summarize.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Joins the strings in the given list of string tensors into one tensor;
		/// </summary>
		/// <param name="inputs">
		///   A list of string tensors.  The tensors must all have the same shape,
		///   or be scalars.  Scalars may be mixed in; these will be broadcast to the shape
		///   of non-scalar inputs.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringJoin'.
		/// </param>
		/// <param name="separator">
		///   Optional argument
		///   string, an optional join separator.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   with the given separator (default is an empty separator).
		/// </remarks>
		public TF_Output StringJoin (TF_Output[] inputs, string separator = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringJoin", MakeName ("StringJoin", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (separator != null)
				c_api.TF_SetAttrString (desc, "separator", separator);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   String lengths of <c>input</c>.
		/// </summary>
		/// <param name="input">
		///   The string for which to compute the length.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringLength'.
		/// </param>
		/// <param name="unit">
		///   Optional argument
		///   The unit that is counted to compute string length.  One of: <c>"BYTE"</c> (for
		///   the number of bytes in each string) or <c>"UTF8_CHAR"</c> (for the number of UTF-8
		///   encoded Unicode code points in each string).  Results are undefined
		///   if <c>unit=UTF8_CHAR</c> and the <c>input</c> strings do not contain structurally
		///   valid UTF-8.
		/// </param>
		/// <returns>
		///   Integer tensor that has the same shape as <c>input</c>. The output contains the
		///   element-wise string lengths of <c>input</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Computes the length of each string given in the input tensor.
		/// </remarks>
		public TF_Output StringLength (TF_Output input, string unit = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringLength", MakeName ("StringLength", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (unit != null)
				c_api.TF_SetAttrString (desc, "unit", unit);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringLower'.
		/// </param>
		/// <param name="encoding">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StringLower (TF_Output input, string encoding = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringLower", MakeName ("StringLower", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (encoding != null)
				c_api.TF_SetAttrString (desc, "encoding", encoding);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates ngrams from ragged string data.
		/// </summary>
		/// <param name="data">
		///   The values tensor of the ragged string tensor to make ngrams out of. Must be a
		///   1D string tensor.
		/// </param>
		/// <param name="data_splits">
		///   The splits tensor of the ragged string tensor to make ngrams out of.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringNGrams'.
		/// </param>
		/// <param name="separator">
		///   The string to append between elements of the token. Use "" for no separator.
		/// </param>
		/// <param name="ngram_widths">
		///   The sizes of the ngrams to create.
		/// </param>
		/// <param name="left_pad">
		///   The string to use to pad the left side of the ngram sequence. Only used if
		///   pad_width != 0.
		/// </param>
		/// <param name="right_pad">
		///   The string to use to pad the right side of the ngram sequence. Only used if
		///   pad_width != 0.
		/// </param>
		/// <param name="pad_width">
		///   The number of padding elements to add to each side of each
		///   sequence. Note that padding will never be greater than 'ngram_widths'-1
		///   regardless of this value. If <c>pad_width=-1</c>, then add <c>max(ngram_widths)-1</c>
		///   elements.
		/// </param>
		/// <param name="preserve_short_sequences">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   ngrams: The values tensor of the output ngrams ragged tensor.
		///   ngrams_splits: The splits tensor of the output ngrams ragged tensor.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   This op accepts a ragged tensor with 1 ragged dimension containing only
		///   strings and outputs a ragged tensor with 1 ragged dimension containing ngrams
		///   of that string, joined along the innermost axis.
		/// </remarks>
		public (TF_Output ngrams, TF_Output ngrams_splits) StringNGrams (TF_Output data, TF_Output data_splits, string separator, long[] ngram_widths, string left_pad, string right_pad, long pad_width, bool preserve_short_sequences, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringNGrams", MakeName ("StringNGrams", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, data_splits);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "separator", separator);
			c_api.TF_SetAttrIntList (desc, "ngram_widths", ref ngram_widths[0], ngram_widths.Length);
			c_api.TF_SetAttrString (desc, "left_pad", left_pad);
			c_api.TF_SetAttrString (desc, "right_pad", right_pad);
			c_api.TF_SetAttrInt (desc, "pad_width", pad_width);
			c_api.TF_SetAttrBool (desc, "preserve_short_sequences", Convert.ToByte(preserve_short_sequences));
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var ngrams = new TF_Output (op, _idx++);
			var ngrams_splits = new TF_Output (op, _idx++);
			return (ngrams, ngrams_splits);
		}

		/// <summary>
		///   Split elements of <c>input</c> based on <c>delimiter</c> into a <c>SparseTensor</c>.
		/// </summary>
		/// <param name="input">
		///   1-D. Strings to split.
		/// </param>
		/// <param name="delimiter">
		///   0-D. Delimiter characters (bytes), or empty string.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringSplit'.
		/// </param>
		/// <param name="skip_empty">
		///   Optional argument
		///   A <c>bool</c>. If <c>True</c>, skip the empty strings from the result.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   indices: A dense matrix of int64 representing the indices of the sparse tensor.
		///   values: A vector of strings corresponding to the splited values.
		///   shape: a length-2 vector of int64 representing the shape of the sparse
		///   tensor, where the first value is N and the second value is the maximum number
		///   of tokens in a single input entry.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Let N be the size of source (typically N will be the batch size). Split each
		///   element of <c>input</c> based on <c>delimiter</c> and return a <c>SparseTensor</c>
		///   containing the splitted tokens. Empty tokens are ignored.
		///   
		///   <c>delimiter</c> can be empty, or a string of split characters. If <c>delimiter</c> is an
		///   empty string, each element of <c>input</c> is split into individual single-byte
		///   character strings, including splitting of UTF-8 multibyte sequences. Otherwise
		///   every character of <c>delimiter</c> is a potential split point.
		///   
		///   For example:
		///   N = 2, input[0] is 'hello world' and input[1] is 'a b c', then the output
		///   will be
		///   
		///   indices = [0, 0;
		///   0, 1;
		///   1, 0;
		///   1, 1;
		///   1, 2]
		///   shape = [2, 3]
		///   values = ['hello', 'world', 'a', 'b', 'c']
		/// </remarks>
		public (TF_Output indices, TF_Output values, TF_Output shape) StringSplit (TF_Output input, TF_Output delimiter, bool? skip_empty = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringSplit", MakeName ("StringSplit", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, delimiter);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (skip_empty.HasValue)
				c_api.TF_SetAttrBool (desc, "skip_empty", Convert.ToByte(skip_empty.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var indices = new TF_Output (op, _idx++);
			var values = new TF_Output (op, _idx++);
			var shape = new TF_Output (op, _idx++);
			return (indices, values, shape);
		}

		/// <summary>
		///   Split elements of <c>source</c> based on <c>sep</c> into a <c>SparseTensor</c>.
		/// </summary>
		/// <param name="input">
		///   <c>1-D</c> string <c>Tensor</c>, the strings to split.
		/// </param>
		/// <param name="sep">
		///   <c>0-D</c> string <c>Tensor</c>, the delimiter character.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringSplitV2'.
		/// </param>
		/// <param name="maxsplit">
		///   Optional argument
		///   An <c>int</c>. If <c>maxsplit &amp;gt; 0</c>, limit of the split of the result.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   indices:
		///   values:
		///   shape:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Let N be the size of source (typically N will be the batch size). Split each
		///   element of <c>source</c> based on <c>sep</c> and return a <c>SparseTensor</c>
		///   containing the split tokens. Empty tokens are ignored.
		///   
		///   For example, N = 2, source[0] is 'hello world' and source[1] is 'a b c',
		///   then the output will be
		///    <code>
		///   st.indices = [0, 0;
		///   0, 1;
		///   1, 0;
		///   1, 1;
		///   1, 2]
		///   st.shape = [2, 3]
		///   st.values = ['hello', 'world', 'a', 'b', 'c']
		///    </code>
		///   
		///   If <c>sep</c> is given, consecutive delimiters are not grouped together and are
		///   deemed to delimit empty strings. For example, source of <c>"1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;&amp;lt;&amp;gt;3"</c> and
		///   sep of <c>"&amp;lt;&amp;gt;"</c> returns <c>["1", "2", "", "3"]</c>. If <c>sep</c> is None or an empty
		///   string, consecutive whitespace are regarded as a single separator, and the
		///   result will contain no empty strings at the startor end if the string has
		///   leading or trailing whitespace.
		///   
		///   Note that the above mentioned behavior matches python's str.split.
		/// </remarks>
		public (TF_Output indices, TF_Output values, TF_Output shape) StringSplitV2 (TF_Output input, TF_Output sep, long? maxsplit = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringSplitV2", MakeName ("StringSplitV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, sep);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (maxsplit.HasValue)
				c_api.TF_SetAttrInt (desc, "maxsplit", maxsplit.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var indices = new TF_Output (op, _idx++);
			var values = new TF_Output (op, _idx++);
			var shape = new TF_Output (op, _idx++);
			return (indices, values, shape);
		}

		/// <summary>
		///   Strip leading and trailing whitespaces from the Tensor.
		/// </summary>
		/// <param name="input">
		///   A string <c>Tensor</c> of any shape.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringStrip'.
		/// </param>
		/// <returns>
		///   A string <c>Tensor</c> of the same shape as the input.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StringStrip (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringStrip", MakeName ("StringStrip", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Converts each string in the input Tensor to its hash mod by a number of buckets.
		/// </summary>
		/// <param name="string_tensor">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringToHashBucket'.
		/// </param>
		/// <param name="num_buckets">
		///   The number of buckets.
		/// </param>
		/// <returns>
		///   A Tensor of the same shape as the input <c>string_tensor</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The hash function is deterministic on the content of the string within the
		///   process.
		///   
		///   Note that the hash function may change from time to time.
		///   This functionality will be deprecated and it's recommended to use
		///   <c>tf.string_to_hash_bucket_fast()</c> or <c>tf.string_to_hash_bucket_strong()</c>.
		/// </remarks>
		public TF_Output StringToHashBucket (TF_Output string_tensor, long num_buckets, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringToHashBucket", MakeName ("StringToHashBucket", operName));
			c_api.TF_AddInput(desc, string_tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_buckets", num_buckets);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Converts each string in the input Tensor to its hash mod by a number of buckets.
		/// </summary>
		/// <param name="input">
		///   The strings to assign a hash bucket.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringToHashBucketFast'.
		/// </param>
		/// <param name="num_buckets">
		///   The number of buckets.
		/// </param>
		/// <returns>
		///   A Tensor of the same shape as the input <c>string_tensor</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The hash function is deterministic on the content of the string within the
		///   process and will never change. However, it is not suitable for cryptography.
		///   This function may be used when CPU time is scarce and inputs are trusted or
		///   unimportant. There is a risk of adversaries constructing inputs that all hash
		///   to the same bucket. To prevent this problem, use a strong hash function with
		///   <c>tf.string_to_hash_bucket_strong</c>.
		/// </remarks>
		public TF_Output StringToHashBucketFast (TF_Output input, long num_buckets, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringToHashBucketFast", MakeName ("StringToHashBucketFast", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_buckets", num_buckets);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Converts each string in the input Tensor to its hash mod by a number of buckets.
		/// </summary>
		/// <param name="input">
		///   The strings to assign a hash bucket.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringToHashBucketStrong'.
		/// </param>
		/// <param name="num_buckets">
		///   The number of buckets.
		/// </param>
		/// <param name="key">
		///   The key used to seed the hash function, passed as a list of two uint64
		///   elements.
		/// </param>
		/// <returns>
		///   A Tensor of the same shape as the input <c>string_tensor</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The hash function is deterministic on the content of the string within the
		///   process. The hash function is a keyed hash function, where attribute <c>key</c>
		///   defines the key of the hash function. <c>key</c> is an array of 2 elements.
		///   
		///   A strong hash is important when inputs may be malicious, e.g. URLs with
		///   additional components. Adversaries could try to make their inputs hash to the
		///   same bucket for a denial-of-service attack or to skew the results. A strong
		///   hash can be used to make it difficult to find inputs with a skewed hash value
		///   distribution over buckets. This requires that the hash function is
		///   seeded by a high-entropy (random) "key" unknown to the adversary.
		///   
		///   The additional robustness comes at a cost of roughly 4x higher compute
		///   time than <c>tf.string_to_hash_bucket_fast</c>.
		/// </remarks>
		public TF_Output StringToHashBucketStrong (TF_Output input, long num_buckets, long[] key, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringToHashBucketStrong", MakeName ("StringToHashBucketStrong", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_buckets", num_buckets);
			c_api.TF_SetAttrIntList (desc, "key", ref key[0], key.Length);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Converts each string in the input Tensor to the specified numeric type.
		/// </summary>
		/// <param name="string_tensor">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringToNumber'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		///   The numeric type to interpret each string in <c>string_tensor</c> as.
		/// </param>
		/// <returns>
		///   A Tensor of the same shape as the input <c>string_tensor</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   (Note that int32 overflow results in an error while float overflow
		///   results in a rounded value.)
		/// </remarks>
		public TF_Output StringToNumber (TF_Output string_tensor, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringToNumber", MakeName ("StringToNumber", operName));
			c_api.TF_AddInput(desc, string_tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'StringUpper'.
		/// </param>
		/// <param name="encoding">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output StringUpper (TF_Output input, string encoding = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "StringUpper", MakeName ("StringUpper", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (encoding != null)
				c_api.TF_SetAttrString (desc, "encoding", encoding);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns x - y element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Sub'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   *NOTE*: <c>Subtract</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output Sub (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Sub", MakeName ("Sub", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Return substrings from <c>Tensor</c> of strings.
		/// </summary>
		/// <param name="input">
		///   Tensor of strings
		/// </param>
		/// <param name="pos">
		///   Scalar defining the position of first character in each substring
		/// </param>
		/// <param name="len">
		///   Scalar defining the number of characters to include in each substring
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Substr'.
		/// </param>
		/// <param name="unit">
		///   Optional argument
		///   The unit that is used to create the substring.  One of: <c>"BYTE"</c> (for
		///   defining position and length by bytes) or <c>"UTF8_CHAR"</c> (for the UTF-8
		///   encoded Unicode code points).  The default is <c>"BYTE"</c>. Results are undefined if
		///   <c>unit=UTF8_CHAR</c> and the <c>input</c> strings do not contain structurally valid
		///   UTF-8.
		/// </param>
		/// <returns>
		///   Tensor of substrings
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   For each string in the input <c>Tensor</c>, creates a substring starting at index
		///   <c>pos</c> with a total length of <c>len</c>.
		///   
		///   If <c>len</c> defines a substring that would extend beyond the length of the input
		///   string, then as many characters as possible are used.
		///   
		///   A negative <c>pos</c> indicates distance within the string backwards from the end.
		///   
		///   If <c>pos</c> specifies an index which is out of range for any of the input strings,
		///   then an <c>InvalidArgumentError</c> is thrown.
		///   
		///   <c>pos</c> and <c>len</c> must have the same shape, otherwise a <c>ValueError</c> is thrown on
		///   Op creation.
		///   
		///   *NOTE*: <c>Substr</c> supports broadcasting up to two dimensions. More about
		///   broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		///   
		///   ---
		///   
		///   Examples
		///   
		///   Using scalar <c>pos</c> and <c>len</c>:
		///   
		///    <code>
		///   input = [b'Hello', b'World']
		///   position = 1
		///   length = 3
		///   
		///   output = [b'ell', b'orl']
		///    </code>
		///   
		///   Using <c>pos</c> and <c>len</c> with same shape as <c>input</c>:
		///   
		///    <code>
		///   input = [[b'ten', b'eleven', b'twelve'],
		///   [b'thirteen', b'fourteen', b'fifteen'],
		///   [b'sixteen', b'seventeen', b'eighteen']]
		///   position = [[1, 2, 3],
		///   [1, 2, 3],
		///   [1, 2, 3]]
		///   length =   [[2, 3, 4],
		///   [4, 3, 2],
		///   [5, 5, 5]]
		///   
		///   output = [[b'en', b'eve', b'lve'],
		///   [b'hirt', b'urt', b'te'],
		///   [b'ixtee', b'vente', b'hteen']]
		///    </code>
		///   
		///   Broadcasting <c>pos</c> and <c>len</c> onto <c>input</c>:
		///   
		///    <code>
		///   input = [[b'ten', b'eleven', b'twelve'],
		///   [b'thirteen', b'fourteen', b'fifteen'],
		///   [b'sixteen', b'seventeen', b'eighteen'],
		///   [b'nineteen', b'twenty', b'twentyone']]
		///   position = [1, 2, 3]
		///   length =   [1, 2, 3]
		///   
		///   output = [[b'e', b'ev', b'lve'],
		///   [b'h', b'ur', b'tee'],
		///   [b'i', b've', b'hte'],
		///   [b'i', b'en', b'nty']]
		///    </code>
		///   
		///   Broadcasting <c>input</c> onto <c>pos</c> and <c>len</c>:
		///   
		///    <code>
		///   input = b'thirteen'
		///   position = [1, 5, 7]
		///   length =   [3, 2, 1]
		///   
		///   output = [b'hir', b'ee', b'n']
		///    </code>
		/// </remarks>
		public TF_Output Substr (TF_Output input, TF_Output pos, TF_Output len, string unit = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Substr", MakeName ("Substr", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, pos);
			c_api.TF_AddInput(desc, len);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (unit != null)
				c_api.TF_SetAttrString (desc, "unit", unit);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the sum of elements across dimensions of a tensor.
		/// </summary>
		/// <param name="input">
		///   The tensor to reduce.
		/// </param>
		/// <param name="reduction_indices">
		///   The dimensions to reduce. Must be in the range
		///   <c>[-rank(input), rank(input))</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Sum'.
		/// </param>
		/// <param name="keep_dims">
		///   Optional argument
		///   If true, retain reduced dimensions with length 1.
		/// </param>
		/// <returns>
		///   The reduced tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Reduces <c>input</c> along the dimensions given in <c>axis</c>. Unless
		///   <c>keep_dims</c> is true, the rank of the tensor is reduced by 1 for each entry in
		///   <c>axis</c>. If <c>keep_dims</c> is true, the reduced dimensions are
		///   retained with length 1.
		/// </remarks>
		public TF_Output Sum (TF_Output input, TF_Output reduction_indices, bool? keep_dims = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Sum", MakeName ("Sum", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, reduction_indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (keep_dims.HasValue)
				c_api.TF_SetAttrBool (desc, "keep_dims", Convert.ToByte(keep_dims.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SummaryWriter'.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output SummaryWriter (string shared_name = null, string container = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SummaryWriter", MakeName ("SummaryWriter", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var writer = new TF_Output (op, _idx++);
			return writer;
		}

		/// <summary>
		///   Computes the singular value decompositions of one or more matrices.
		/// </summary>
		/// <param name="input">
		///   A tensor of shape <c>[..., M, N]</c> whose inner-most 2 dimensions
		///   form matrices of size <c>[M, N]</c>. Let <c>P</c> be the minimum of <c>M</c> and <c>N</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Svd'.
		/// </param>
		/// <param name="compute_uv">
		///   Optional argument
		///   If true, left and right singular vectors will be
		///   computed and returned in <c>u</c> and <c>v</c>, respectively.
		///   If false, <c>u</c> and <c>v</c> are not set and should never referenced.
		/// </param>
		/// <param name="full_matrices">
		///   Optional argument
		///   If true, compute full-sized <c>u</c> and <c>v</c>. If false
		///   (the default), compute only the leading <c>P</c> singular vectors.
		///   Ignored if <c>compute_uv</c> is <c>False</c>.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   s: Singular values. Shape is <c>[..., P]</c>.
		///   u: Left singular vectors. If <c>full_matrices</c> is <c>False</c> then shape is
		///   <c>[..., M, P]</c>; if <c>full_matrices</c> is <c>True</c> then shape is
		///   <c>[..., M, M]</c>. Undefined if <c>compute_uv</c> is <c>False</c>.
		///   v: Left singular vectors. If <c>full_matrices</c> is <c>False</c> then shape is
		///   <c>[..., N, P]</c>. If <c>full_matrices</c> is <c>True</c> then shape is <c>[..., N, N]</c>.
		///   Undefined if <c>compute_uv</c> is false.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Computes the SVD of each inner matrix in <c>input</c> such that
		///   <c>input[..., :, :] = u[..., :, :] * diag(s[..., :, :]) * transpose(v[..., :, :])</c>
		///   
		///    <code>
		///   # a is a tensor containing a batch of matrices.
		///   # s is a tensor of singular values for each matrix.
		///   # u is the tensor containing of left singular vectors for each matrix.
		///   # v is the tensor containing of right singular vectors for each matrix.
		///   s, u, v = svd(a)
		///   s, _, _ = svd(a, compute_uv=False)
		///    </code>
		/// </remarks>
		public (TF_Output s, TF_Output u, TF_Output v) Svd (TF_Output input, bool? compute_uv = null, bool? full_matrices = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Svd", MakeName ("Svd", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (compute_uv.HasValue)
				c_api.TF_SetAttrBool (desc, "compute_uv", Convert.ToByte(compute_uv.Value));
			
			if (full_matrices.HasValue)
				c_api.TF_SetAttrBool (desc, "full_matrices", Convert.ToByte(full_matrices.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var s = new TF_Output (op, _idx++);
			var u = new TF_Output (op, _idx++);
			var v = new TF_Output (op, _idx++);
			return (s, u, v);
		}

		/// <summary>
		///   Forwards <c>data</c> to the output port determined by <c>pred</c>.
		/// </summary>
		/// <param name="data">
		///   The tensor to be forwarded to the appropriate output.
		/// </param>
		/// <param name="pred">
		///   A scalar that specifies which output port will receive data.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Switch'.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_false: If <c>pred</c> is false, data will be forwarded to this output.
		///   output_true: If <c>pred</c> is true, data will be forwarded to this output.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   If <c>pred</c> is true, the <c>data</c> input is forwarded to <c>output_true</c>. Otherwise,
		///   the data goes to <c>output_false</c>.
		///   
		///   See also <c>RefSwitch</c> and <c>Merge</c>.
		/// </remarks>
		public (TF_Output output_false, TF_Output output_true) Switch (TF_Output data, TF_Output pred, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Switch", MakeName ("Switch", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, pred);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_false = new TF_Output (op, _idx++);
			var output_true = new TF_Output (op, _idx++);
			return (output_false, output_true);
		}

		/// <summary>
		///   Computes the gradient function for function f via backpropagation.
		/// </summary>
		/// <param name="input">
		///   a list of input tensors of size N + M;
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'SymbolicGradient'.
		/// </param>
		/// <param name="Tout">
		///   the type list for the input list.
		/// </param>
		/// <param name="f">
		///   The function we want to compute the gradient for.
		///   
		///   The function 'f' must be a numerical function which takes N inputs and
		///   produces M outputs. Its gradient function 'g', which is computed by
		///   this SymbolicGradient op is a function taking N + M inputs and
		///   produces N outputs.
		///   
		///   I.e. if we have
		///   (y1, y2, ..., y_M) = f(x1, x2, ..., x_N),
		///   then, g is
		///   (dL/dx1, dL/dx2, ..., dL/dx_N) = g(x1, x2, ..., x_N,
		///   dL/dy1, dL/dy2, ..., dL/dy_M),
		///   
		///   where L is a scalar-value function of (x1, x2, ..., xN) (e.g., the
		///   loss function). dL/dx_i is the partial derivative of L with respect
		///   to x_i.
		///   
		///   (Needs some math expert to say the comment above better.)
		/// </param>
		/// <returns>
		///   a list of output tensors of size N;
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] SymbolicGradient (TF_Output[] input, TF_DataType[] Tout, TF_Function f, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "SymbolicGradient", MakeName ("SymbolicGradient", operName));
			c_api.TF_AddInputList(desc, input[0], input.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "Tout", Tout);
			c_api.TF_SetAttrFuncName (desc, "f", c_api.TF_FunctionName(f));
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		///   Creates a dataset that contains <c>count</c> elements from the <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="count">
		///   A scalar representing the number of elements from the <c>input_dataset</c>
		///   that should be taken. A value of <c>-1</c> indicates that all of <c>input_dataset</c>
		///   is taken.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TakeDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TakeDataset (TF_Output input_dataset, TF_Output count, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TakeDataset", MakeName ("TakeDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, count);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Read <c>SparseTensors</c> from a <c>SparseTensorsMap</c> and concatenate them.
		/// </summary>
		/// <param name="sparse_handles">
		///   1-D, The <c>N</c> serialized <c>SparseTensor</c> objects.
		///   Shape: <c>[N]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TakeManySparseFromTensorsMap'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   The container name for the <c>SparseTensorsMap</c> read by this op.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   The shared name for the <c>SparseTensorsMap</c> read by this op.
		///   It should not be blank; rather the <c>shared_name</c> or unique Operation name
		///   of the Op that created the original <c>SparseTensorsMap</c> should be used.
		/// </param>
		/// <param name="dtype">
		///   The <c>dtype</c> of the <c>SparseTensor</c> objects stored in the
		///   <c>SparseTensorsMap</c>.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sparse_indices: 2-D.  The <c>indices</c> of the minibatch <c>SparseTensor</c>.
		///   sparse_values: 1-D.  The <c>values</c> of the minibatch <c>SparseTensor</c>.
		///   sparse_shape: 1-D.  The <c>shape</c> of the minibatch <c>SparseTensor</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The input <c>sparse_handles</c> must be an <c>int64</c> matrix of shape <c>[N, 1]</c> where
		///   <c>N</c> is the minibatch size and the rows correspond to the output handles of
		///   <c>AddSparseToTensorsMap</c> or <c>AddManySparseToTensorsMap</c>.  The ranks of the
		///   original <c>SparseTensor</c> objects that went into the given input ops must all
		///   match.  When the final <c>SparseTensor</c> is created, it has rank one
		///   higher than the ranks of the incoming <c>SparseTensor</c> objects
		///   (they have been concatenated along a new row dimension on the left).
		///   
		///   The output <c>SparseTensor</c> object's shape values for all dimensions but the
		///   first are the max across the input <c>SparseTensor</c> objects' shape values
		///   for the corresponding dimensions.  Its first shape value is <c>N</c>, the minibatch
		///   size.
		///   
		///   The input <c>SparseTensor</c> objects' indices are assumed ordered in
		///   standard lexicographic order.  If this is not the case, after this
		///   step run <c>SparseReorder</c> to restore index ordering.
		///   
		///   For example, if the handles represent an input, which is a <c>[2, 3]</c> matrix
		///   representing two original <c>SparseTensor</c> objects:
		///   
		///    <code>
		///   index = [ 0]
		///   [10]
		///   [20]
		///   values = [1, 2, 3]
		///   shape = [50]
		///    </code>
		///   
		///   and
		///   
		///    <code>
		///   index = [ 2]
		///   [10]
		///   values = [4, 5]
		///   shape = [30]
		///    </code>
		///   
		///   then the final <c>SparseTensor</c> will be:
		///   
		///    <code>
		///   index = [0  0]
		///   [0 10]
		///   [0 20]
		///   [1  2]
		///   [1 10]
		///   values = [1, 2, 3, 4, 5]
		///   shape = [2 50]
		///    </code>
		/// </remarks>
		public (TF_Output sparse_indices, TF_Output sparse_values, TF_Output sparse_shape) TakeManySparseFromTensorsMap (TF_Output sparse_handles, TF_DataType dtype, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TakeManySparseFromTensorsMap", MakeName ("TakeManySparseFromTensorsMap", operName));
			c_api.TF_AddInput(desc, sparse_handles);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var sparse_indices = new TF_Output (op, _idx++);
			var sparse_values = new TF_Output (op, _idx++);
			var sparse_shape = new TF_Output (op, _idx++);
			return (sparse_indices, sparse_values, sparse_shape);
		}

		/// <summary>
		///   Creates a dataset that stops iteration when predicate<c> is false.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="other_arguments">
		///   A list of tensors, typically values that were captured when
		///   building a closure for <c>predicate</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TakeWhileDataset'.
		/// </param>
		/// <param name="predicate">
		///   A function returning a scalar boolean.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The <c>predicate</c> function must return a scalar boolean and accept the
		///   following arguments:
		///   
		///   * One tensor for each component of an element of <c>input_dataset</c>.
		///   * One tensor for each value in <c>other_arguments</c>.
		/// </remarks>
		public TF_Output TakeWhileDataset (TF_Output input_dataset, TF_Output[] other_arguments, TF_Function predicate, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TakeWhileDataset", MakeName ("TakeWhileDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInputList(desc, other_arguments[0], other_arguments.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "predicate", c_api.TF_FunctionName(predicate));
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Computes tan of x element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Tan'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given an input tensor, this function computes tangent of every
		///   element in the tensor. Input range is <c>(-inf, inf)</c> and
		///   output range is <c>(-inf, inf)</c>. If input lies outside the boundary, <c>nan</c>
		///   is returned.
		///   
		///    <code>
		///   x = tf.constant([-float("inf"), -9, -0.5, 1, 1.2, 200, 10000, float("inf")])
		///   tf.math.tan(x) ==&amp;gt; [nan 0.45231566 -0.5463025 1.5574077 2.572152 -1.7925274 0.32097113 nan]
		///    </code>
		/// </remarks>
		public TF_Output Tan (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Tan", MakeName ("Tan", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes hyperbolic tangent of <c>x</c> element-wise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Tanh'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Given an input tensor, this function computes hyperbolic tangent of every
		///   element in the tensor. Input range is <c>[-inf, inf]</c> and
		///   output range is <c>[-1,1]</c>.
		///   
		///    <code>
		///   x = tf.constant([-float("inf"), -5, -0.5, 1, 1.2, 2, 3, float("inf")])
		///   tf.math.tanh(x) ==&amp;gt; [-1. -0.99990916 -0.46211717 0.7615942 0.8336547 0.9640276 0.9950547 1.]
		///    </code>
		/// </remarks>
		public TF_Output Tanh (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Tanh", MakeName ("Tanh", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Computes the gradient for the tanh of <c>x</c> wrt its input.
		/// </summary>
		/// <param name="y">
		/// </param>
		/// <param name="dy">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TanhGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Specifically, <c>grad = dy * (1 - y*y)</c>, where <c>y = tanh(x)</c>, and <c>dy</c>
		///   is the corresponding input gradient.
		/// </remarks>
		public TF_Output TanhGrad (TF_Output y, TF_Output dy, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TanhGrad", MakeName ("TanhGrad", operName));
			c_api.TF_AddInput(desc, y);
			c_api.TF_AddInput(desc, dy);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Returns a tensor that may be mutated, but only persists within a single step.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TemporaryVariable'.
		/// </param>
		/// <param name="var_name">
		///   Optional argument
		///   Overrides the name used for the temporary variable resource. Default
		///   value is the name of the 'TemporaryVariable' op (which is guaranteed unique).
		/// </param>
		/// <param name="shape">
		///   The shape of the variable tensor.
		/// </param>
		/// <param name="dtype">
		///   The type of elements in the variable tensor.
		/// </param>
		/// <returns>
		///   A reference to the variable tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This is an experimental op for internal use only and it is possible to use this
		///   op in unsafe ways.  DO NOT USE unless you fully understand the risks.
		///   
		///   It is the caller's responsibility to ensure that 'ref' is eventually passed to a
		///   matching 'DestroyTemporaryVariable' op after all other uses have completed.
		///   
		///   Outputs a ref to the tensor state so it may be read or modified.
		///   
		///   E.g.
		///   var = state_ops._temporary_variable([1, 2], types.float_)
		///   var_name = var.op.name
		///   var = state_ops.assign(var, [[4.0, 5.0]])
		///   var = state_ops.assign_add(var, [[6.0, 7.0]])
		///   final = state_ops._destroy_temporary_variable(var, var_name=var_name)
		/// </remarks>
		public TF_Output TemporaryVariable (long[] shape, TF_DataType dtype, string var_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TemporaryVariable", MakeName ("TemporaryVariable", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (var_name != null)
				c_api.TF_SetAttrString (desc, "var_name", var_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var reference = new TF_Output (op, _idx++);
			return reference;
		}

		/// <summary>
		/// </summary>
		/// <param name="size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArray'.
		/// </param>
		/// <param name="dynamic_size">
		///   Optional argument
		/// </param>
		/// <param name="clear_after_read">
		///   Optional argument
		/// </param>
		/// <param name="tensor_array_name">
		///   Optional argument
		/// </param>
		/// <param name="element_shape">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArray (TF_Output size, TF_DataType dtype, bool? dynamic_size = null, bool? clear_after_read = null, string tensor_array_name = null, long[] element_shape = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArray", MakeName ("TensorArray", operName));
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (dynamic_size.HasValue)
				c_api.TF_SetAttrBool (desc, "dynamic_size", Convert.ToByte(dynamic_size.Value));
			
			if (clear_after_read.HasValue)
				c_api.TF_SetAttrBool (desc, "clear_after_read", Convert.ToByte(clear_after_read.Value));
			
			if (tensor_array_name != null)
				c_api.TF_SetAttrString (desc, "tensor_array_name", tensor_array_name);
			
			if (element_shape != null)
				c_api.TF_SetAttrShape (desc, "element_shape", ref element_shape[0], element_shape.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayClose'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation TensorArrayClose (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayClose", MakeName ("TensorArrayClose", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Deprecated. Use TensorArrayCloseV3
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayCloseV2'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation TensorArrayCloseV2 (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayCloseV2", MakeName ("TensorArrayCloseV2", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Delete the TensorArray from its resource container.
		/// </summary>
		/// <param name="handle">
		///   The handle to a TensorArray (output of TensorArray or TensorArrayGrad).
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayCloseV3'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   This enables the user to close and release the resource in the middle
		///   of a step/run.
		/// </remarks>
		public TF_Operation TensorArrayCloseV3 (TF_Output handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayCloseV3", MakeName ("TensorArrayCloseV3", operName));
			c_api.TF_AddInput(desc, handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayConcat'.
		/// </param>
		/// <param name="element_shape_except0">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   value:
		///   lengths:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output value, TF_Output lengths) TensorArrayConcat (TF_Output handle, TF_Output flow_in, TF_DataType dtype, long[] element_shape_except0 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayConcat", MakeName ("TensorArrayConcat", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (element_shape_except0 != null)
				c_api.TF_SetAttrShape (desc, "element_shape_except0", ref element_shape_except0[0], element_shape_except0.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			var lengths = new TF_Output (op, _idx++);
			return (value, lengths);
		}

		/// <summary>
		///   Deprecated. Use TensorArrayConcatV3
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayConcatV2'.
		/// </param>
		/// <param name="element_shape_except0">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   value:
		///   lengths:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		public (TF_Output value, TF_Output lengths) TensorArrayConcatV2 (TF_Output handle, TF_Output flow_in, TF_DataType dtype, long[] element_shape_except0 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayConcatV2", MakeName ("TensorArrayConcatV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (element_shape_except0 != null)
				c_api.TF_SetAttrShape (desc, "element_shape_except0", ref element_shape_except0[0], element_shape_except0.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			var lengths = new TF_Output (op, _idx++);
			return (value, lengths);
		}

		/// <summary>
		///   Concat the elements from the TensorArray into value <c>value</c>.
		/// </summary>
		/// <param name="handle">
		///   The handle to a TensorArray.
		/// </param>
		/// <param name="flow_in">
		///   A float scalar that enforces proper chaining of operations.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayConcatV3'.
		/// </param>
		/// <param name="element_shape_except0">
		///   Optional argument
		///   The expected shape of an element, if known,
		///   excluding the first dimension. Used to validate the shapes of
		///   TensorArray elements. If this shape is not fully specified, concatenating
		///   zero-size TensorArrays is an error.
		/// </param>
		/// <param name="dtype">
		///   The type of the elem that is returned.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   value: All of the elements in the TensorArray, concatenated along the first
		///   axis.
		///   lengths: A vector of the row sizes of the original T elements in the
		///   value output.  In the example above, this would be the values:
		///   <c>(n1, n2, ..., n(T-1))</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Takes <c>T</c> elements of shapes
		///   
		///    <code>
		///   (n0 x d0 x d1 x ...), (n1 x d0 x d1 x ...), ..., (n(T-1) x d0 x d1 x ...)
		///    </code>
		///   
		///   and concatenates them into a Tensor of shape:
		///   
		///    <code>
		///    (n0 + n1 + ... + n(T-1) x d0 x d1 x ...)
		///    </code>
		///   
		///   All elements must have the same shape (excepting the first dimension).
		/// </remarks>
		public (TF_Output value, TF_Output lengths) TensorArrayConcatV3 (TF_Output handle, TF_Output flow_in, TF_DataType dtype, long[] element_shape_except0 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayConcatV3", MakeName ("TensorArrayConcatV3", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (element_shape_except0 != null)
				c_api.TF_SetAttrShape (desc, "element_shape_except0", ref element_shape_except0[0], element_shape_except0.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			var lengths = new TF_Output (op, _idx++);
			return (value, lengths);
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGather'.
		/// </param>
		/// <param name="element_shape">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayGather (TF_Output handle, TF_Output indices, TF_Output flow_in, TF_DataType dtype, long[] element_shape = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayGather", MakeName ("TensorArrayGather", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (element_shape != null)
				c_api.TF_SetAttrShape (desc, "element_shape", ref element_shape[0], element_shape.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			return value;
		}

		/// <summary>
		///   Deprecated. Use TensorArrayGatherV3
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGatherV2'.
		/// </param>
		/// <param name="element_shape">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayGatherV2 (TF_Output handle, TF_Output indices, TF_Output flow_in, TF_DataType dtype, long[] element_shape = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayGatherV2", MakeName ("TensorArrayGatherV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (element_shape != null)
				c_api.TF_SetAttrShape (desc, "element_shape", ref element_shape[0], element_shape.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			return value;
		}

		/// <summary>
		///   Gather specific elements from the TensorArray into output <c>value</c>.
		/// </summary>
		/// <param name="handle">
		///   The handle to a TensorArray.
		/// </param>
		/// <param name="indices">
		///   The locations in the TensorArray from which to read tensor elements.
		/// </param>
		/// <param name="flow_in">
		///   A float scalar that enforces proper chaining of operations.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGatherV3'.
		/// </param>
		/// <param name="element_shape">
		///   Optional argument
		///   The expected shape of an element, if known. Used to
		///   validate the shapes of TensorArray elements. If this shape is not
		///   fully specified, gathering zero-size TensorArrays is an error.
		/// </param>
		/// <param name="dtype">
		///   The type of the elem that is returned.
		/// </param>
		/// <returns>
		///   All of the elements in the TensorArray, concatenated along a new
		///   axis (the new dimension 0).
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   All elements selected by <c>indices</c> must have the same shape.
		/// </remarks>
		public TF_Output TensorArrayGatherV3 (TF_Output handle, TF_Output indices, TF_Output flow_in, TF_DataType dtype, long[] element_shape = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayGatherV3", MakeName ("TensorArrayGatherV3", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (element_shape != null)
				c_api.TF_SetAttrShape (desc, "element_shape", ref element_shape[0], element_shape.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			return value;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGrad'.
		/// </param>
		/// <param name="source">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayGrad (TF_Output handle, TF_Output flow_in, string source, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayGrad", MakeName ("TensorArrayGrad", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "source", source);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var grad_handle = new TF_Output (op, _idx++);
			return grad_handle;
		}

		/// <summary>
		///   Deprecated. Use TensorArrayGradV3
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGradV2'.
		/// </param>
		/// <param name="source">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayGradV2 (TF_Output handle, TF_Output flow_in, string source, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayGradV2", MakeName ("TensorArrayGradV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "source", source);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var grad_handle = new TF_Output (op, _idx++);
			return grad_handle;
		}

		/// <summary>
		///   Creates a TensorArray for storing the gradients of values in the given handle.
		/// </summary>
		/// <param name="handle">
		///   The handle to the forward TensorArray.
		/// </param>
		/// <param name="flow_in">
		///   A float scalar that enforces proper chaining of operations.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGradV3'.
		/// </param>
		/// <param name="source">
		///   The gradient source string, used to decide which gradient TensorArray
		///   to return.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   grad_handle:
		///   flow_out:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   If the given TensorArray gradient already exists, returns a reference to it.
		///   
		///   Locks the size of the original TensorArray by disabling its dynamic size flag.
		///   
		///   **A note about the input flow_in:**
		///   
		///   The handle flow_in forces the execution of the gradient lookup to occur
		///   only after certain other operations have occurred.  For example, when
		///   the forward TensorArray is dynamically sized, writes to this TensorArray
		///   may resize the object.  The gradient TensorArray is statically sized based
		///   on the size of the forward TensorArray when this operation executes.
		///   Furthermore, the size of the forward TensorArray is frozen by this call.
		///   As a result, the flow is used to ensure that the call to generate the gradient
		///   TensorArray only happens after all writes are executed.
		///   
		///   In the case of dynamically sized TensorArrays, gradient computation should
		///   only be performed on read operations that have themselves been chained via
		///   flow to occur only after all writes have executed. That way the final size
		///   of the forward TensorArray is known when this operation is called.
		///   
		///   **A note about the source attribute:**
		///   
		///   TensorArray gradient calls use an accumulator TensorArray object.  If
		///   multiple gradients are calculated and run in the same session, the multiple
		///   gradient nodes may accidentally flow through the same accumulator TensorArray.
		///   This double counts and generally breaks the TensorArray gradient flow.
		///   
		///   The solution is to identify which gradient call this particular
		///   TensorArray gradient is being called in.  This is performed by identifying
		///   a unique string (e.g. "gradients", "gradients_1", ...) from the input
		///   gradient Tensor's name.  This string is used as a suffix when creating
		///   the TensorArray gradient object here (the attribute <c>source</c>).
		///   
		///   The attribute <c>source</c> is added as a suffix to the forward TensorArray's
		///   name when performing the creation / lookup, so that each separate gradient
		///   calculation gets its own TensorArray accumulator.
		/// </remarks>
		public (TF_Output grad_handle, TF_Output flow_out) TensorArrayGradV3 (TF_Output handle, TF_Output flow_in, string source, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayGradV3", MakeName ("TensorArrayGradV3", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "source", source);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var grad_handle = new TF_Output (op, _idx++);
			var flow_out = new TF_Output (op, _idx++);
			return (grad_handle, flow_out);
		}

		/// <summary>
		///   Creates a TensorArray for storing multiple gradients of values in the given handle.
		/// </summary>
		/// <param name="handle">
		///   The handle to the forward TensorArray.
		/// </param>
		/// <param name="flow_in">
		///   A float scalar that enforces proper chaining of operations.
		/// </param>
		/// <param name="shape_to_prepend">
		///   An int32 vector representing a shape. Elements in the gradient accumulator will
		///   have shape which is this shape_to_prepend value concatenated with shape of the
		///   elements in the TensorArray corresponding to the input handle.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGradWithShape'.
		/// </param>
		/// <param name="source">
		///   The gradient source string, used to decide which gradient TensorArray
		///   to return.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   grad_handle:
		///   flow_out:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Similar to TensorArrayGradV3. However it creates an accumulator with an
		///   expanded shape compared to the input TensorArray whose gradient is being
		///   computed. This enables multiple gradients for the same TensorArray to be
		///   calculated using the same accumulator.
		/// </remarks>
		public (TF_Output grad_handle, TF_Output flow_out) TensorArrayGradWithShape (TF_Output handle, TF_Output flow_in, TF_Output shape_to_prepend, string source, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayGradWithShape", MakeName ("TensorArrayGradWithShape", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			c_api.TF_AddInput(desc, shape_to_prepend);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "source", source);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var grad_handle = new TF_Output (op, _idx++);
			var flow_out = new TF_Output (op, _idx++);
			return (grad_handle, flow_out);
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayPack'.
		/// </param>
		/// <param name="element_shape">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayPack (TF_Output handle, TF_Output flow_in, TF_DataType dtype, long[] element_shape = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayPack", MakeName ("TensorArrayPack", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (element_shape != null)
				c_api.TF_SetAttrShape (desc, "element_shape", ref element_shape[0], element_shape.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			return value;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="index">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayRead'.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayRead (TF_Output handle, TF_Output index, TF_Output flow_in, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayRead", MakeName ("TensorArrayRead", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, index);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			return value;
		}

		/// <summary>
		///   Deprecated. Use TensorArrayReadV3
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="index">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayReadV2'.
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayReadV2 (TF_Output handle, TF_Output index, TF_Output flow_in, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayReadV2", MakeName ("TensorArrayReadV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, index);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			return value;
		}

		/// <summary>
		///   Read an element from the TensorArray into output <c>value</c>.
		/// </summary>
		/// <param name="handle">
		///   The handle to a TensorArray.
		/// </param>
		/// <param name="index">
		/// </param>
		/// <param name="flow_in">
		///   A float scalar that enforces proper chaining of operations.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayReadV3'.
		/// </param>
		/// <param name="dtype">
		///   The type of the elem that is returned.
		/// </param>
		/// <returns>
		///   The tensor that is read from the TensorArray.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayReadV3 (TF_Output handle, TF_Output index, TF_Output flow_in, TF_DataType dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayReadV3", MakeName ("TensorArrayReadV3", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, index);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var value = new TF_Output (op, _idx++);
			return value;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayScatter'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayScatter (TF_Output handle, TF_Output indices, TF_Output value, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayScatter", MakeName ("TensorArrayScatter", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var flow_out = new TF_Output (op, _idx++);
			return flow_out;
		}

		/// <summary>
		///   Deprecated. Use TensorArrayScatterV3
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayScatterV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayScatterV2 (TF_Output handle, TF_Output indices, TF_Output value, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayScatterV2", MakeName ("TensorArrayScatterV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var flow_out = new TF_Output (op, _idx++);
			return flow_out;
		}

		/// <summary>
		///   Scatter the data from the input value into specific TensorArray elements.
		/// </summary>
		/// <param name="handle">
		///   The handle to a TensorArray.
		/// </param>
		/// <param name="indices">
		///   The locations at which to write the tensor elements.
		/// </param>
		/// <param name="value">
		///   The concatenated tensor to write to the TensorArray.
		/// </param>
		/// <param name="flow_in">
		///   A float scalar that enforces proper chaining of operations.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayScatterV3'.
		/// </param>
		/// <returns>
		///   A float scalar that enforces proper chaining of operations.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   <c>indices</c> must be a vector, its length must match the first dim of <c>value</c>.
		/// </remarks>
		public TF_Output TensorArrayScatterV3 (TF_Output handle, TF_Output indices, TF_Output value, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayScatterV3", MakeName ("TensorArrayScatterV3", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var flow_out = new TF_Output (op, _idx++);
			return flow_out;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArraySize'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArraySize (TF_Output handle, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArraySize", MakeName ("TensorArraySize", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		///   Deprecated. Use TensorArraySizeV3
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArraySizeV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArraySizeV2 (TF_Output handle, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArraySizeV2", MakeName ("TensorArraySizeV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		///   Get the current size of the TensorArray.
		/// </summary>
		/// <param name="handle">
		///   The handle to a TensorArray (output of TensorArray or TensorArrayGrad).
		/// </param>
		/// <param name="flow_in">
		///   A float scalar that enforces proper chaining of operations.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArraySizeV3'.
		/// </param>
		/// <returns>
		///   The current size of the TensorArray.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArraySizeV3 (TF_Output handle, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArraySizeV3", MakeName ("TensorArraySizeV3", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var size = new TF_Output (op, _idx++);
			return size;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="lengths">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArraySplit'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArraySplit (TF_Output handle, TF_Output value, TF_Output lengths, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArraySplit", MakeName ("TensorArraySplit", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, lengths);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var flow_out = new TF_Output (op, _idx++);
			return flow_out;
		}

		/// <summary>
		///   Deprecated. Use TensorArraySplitV3
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="lengths">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArraySplitV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArraySplitV2 (TF_Output handle, TF_Output value, TF_Output lengths, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArraySplitV2", MakeName ("TensorArraySplitV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, lengths);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var flow_out = new TF_Output (op, _idx++);
			return flow_out;
		}

		/// <summary>
		///   Split the data from the input value into TensorArray elements.
		/// </summary>
		/// <param name="handle">
		///   The handle to a TensorArray.
		/// </param>
		/// <param name="value">
		///   The concatenated tensor to write to the TensorArray.
		/// </param>
		/// <param name="lengths">
		///   The vector of lengths, how to split the rows of value into the
		///   TensorArray.
		/// </param>
		/// <param name="flow_in">
		///   A float scalar that enforces proper chaining of operations.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArraySplitV3'.
		/// </param>
		/// <returns>
		///   A float scalar that enforces proper chaining of operations.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Assuming that <c>lengths</c> takes on values
		///   
		///    <code>
		///    (n0, n1, ..., n(T-1))
		///    </code>
		///   
		///   and that <c>value</c> has shape
		///   
		///    <code>
		///   (n0 + n1 + ... + n(T-1) x d0 x d1 x ...)<c></c><c>,
		///   
		///   this splits values into a TensorArray with T tensors.
		///   
		///   TensorArray index t will be the subtensor of values with starting position
		///   
		///    </code>
		///    (n0 + n1 + ... + n(t-1), 0, 0, ...)
		///    <code>
		///   
		///   and having size
		///   
		///    </code>
		///    nt x d0 x d1 x ...
		///    <code>
		/// </remarks>
		public TF_Output TensorArraySplitV3 (TF_Output handle, TF_Output value, TF_Output lengths, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArraySplitV3", MakeName ("TensorArraySplitV3", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, lengths);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var flow_out = new TF_Output (op, _idx++);
			return flow_out;
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayUnpack'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayUnpack (TF_Output handle, TF_Output value, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayUnpack", MakeName ("TensorArrayUnpack", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var flow_out = new TF_Output (op, _idx++);
			return flow_out;
		}

		/// <summary>
		///   Deprecated. Use TensorArrayV3
		/// </summary>
		/// <param name="size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayV2'.
		/// </param>
		/// <param name="element_shape">
		///   Optional argument
		/// </param>
		/// <param name="dynamic_size">
		///   Optional argument
		/// </param>
		/// <param name="clear_after_read">
		///   Optional argument
		/// </param>
		/// <param name="tensor_array_name">
		///   Optional argument
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayV2 (TF_Output size, TF_DataType dtype, long[] element_shape = null, bool? dynamic_size = null, bool? clear_after_read = null, string tensor_array_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayV2", MakeName ("TensorArrayV2", operName));
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (element_shape != null)
				c_api.TF_SetAttrShape (desc, "element_shape", ref element_shape[0], element_shape.Length);
			
			if (dynamic_size.HasValue)
				c_api.TF_SetAttrBool (desc, "dynamic_size", Convert.ToByte(dynamic_size.Value));
			
			if (clear_after_read.HasValue)
				c_api.TF_SetAttrBool (desc, "clear_after_read", Convert.ToByte(clear_after_read.Value));
			
			if (tensor_array_name != null)
				c_api.TF_SetAttrString (desc, "tensor_array_name", tensor_array_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   An array of Tensors of given size.
		/// </summary>
		/// <param name="size">
		///   The size of the array.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayV3'.
		/// </param>
		/// <param name="element_shape">
		///   Optional argument
		///   The expected shape of an element, if known. Used to
		///   validate the shapes of TensorArray elements. If this shape is not
		///   fully specified, gathering zero-size TensorArrays is an error.
		/// </param>
		/// <param name="dynamic_size">
		///   Optional argument
		///   A boolean that determines whether writes to the TensorArray
		///   are allowed to grow the size.  By default, this is not allowed.
		/// </param>
		/// <param name="clear_after_read">
		///   Optional argument
		///   If true (default), Tensors in the TensorArray are cleared
		///   after being read.  This disables multiple read semantics but allows early
		///   release of memory.
		/// </param>
		/// <param name="identical_element_shapes">
		///   Optional argument
		///   If true (default is false), then all
		///   elements in the TensorArray will be expected to have have identical shapes.
		///   This allows certain behaviors, like dynamically checking for
		///   consistent shapes on write, and being able to fill in properly
		///   shaped zero tensors on stack -- even if the element_shape attribute
		///   is not fully defined.
		/// </param>
		/// <param name="tensor_array_name">
		///   Optional argument
		///   Overrides the name used for the temporary tensor_array
		///   resource. Default value is the name of the 'TensorArray' op (which
		///   is guaranteed unique).
		/// </param>
		/// <param name="dtype">
		///   The type of the elements on the tensor_array.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   handle: The handle to the TensorArray.
		///   flow: A scalar used to control gradient flow.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Write data via Write and read via Read or Pack.
		/// </remarks>
		public (TF_Output handle, TF_Output flow) TensorArrayV3 (TF_Output size, TF_DataType dtype, long[] element_shape = null, bool? dynamic_size = null, bool? clear_after_read = null, bool? identical_element_shapes = null, string tensor_array_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayV3", MakeName ("TensorArrayV3", operName));
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (element_shape != null)
				c_api.TF_SetAttrShape (desc, "element_shape", ref element_shape[0], element_shape.Length);
			
			if (dynamic_size.HasValue)
				c_api.TF_SetAttrBool (desc, "dynamic_size", Convert.ToByte(dynamic_size.Value));
			
			if (clear_after_read.HasValue)
				c_api.TF_SetAttrBool (desc, "clear_after_read", Convert.ToByte(clear_after_read.Value));
			
			if (identical_element_shapes.HasValue)
				c_api.TF_SetAttrBool (desc, "identical_element_shapes", Convert.ToByte(identical_element_shapes.Value));
			
			if (tensor_array_name != null)
				c_api.TF_SetAttrString (desc, "tensor_array_name", tensor_array_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			var flow = new TF_Output (op, _idx++);
			return (handle, flow);
		}

		/// <summary>
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="index">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayWrite'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayWrite (TF_Output handle, TF_Output index, TF_Output value, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayWrite", MakeName ("TensorArrayWrite", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, index);
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var flow_out = new TF_Output (op, _idx++);
			return flow_out;
		}

		/// <summary>
		///   Deprecated. Use TensorArrayGradV3
		/// </summary>
		/// <param name="handle">
		/// </param>
		/// <param name="index">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="flow_in">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayWriteV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayWriteV2 (TF_Output handle, TF_Output index, TF_Output value, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayWriteV2", MakeName ("TensorArrayWriteV2", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, index);
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var flow_out = new TF_Output (op, _idx++);
			return flow_out;
		}

		/// <summary>
		///   Push an element onto the tensor_array.
		/// </summary>
		/// <param name="handle">
		///   The handle to a TensorArray.
		/// </param>
		/// <param name="index">
		///   The position to write to inside the TensorArray.
		/// </param>
		/// <param name="value">
		///   The tensor to write to the TensorArray.
		/// </param>
		/// <param name="flow_in">
		///   A float scalar that enforces proper chaining of operations.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayWriteV3'.
		/// </param>
		/// <returns>
		///   A float scalar that enforces proper chaining of operations.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorArrayWriteV3 (TF_Output handle, TF_Output index, TF_Output value, TF_Output flow_in, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorArrayWriteV3", MakeName ("TensorArrayWriteV3", operName));
			c_api.TF_AddInput(desc, handle);
			c_api.TF_AddInput(desc, index);
			c_api.TF_AddInput(desc, value);
			c_api.TF_AddInput(desc, flow_in);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var flow_out = new TF_Output (op, _idx++);
			return flow_out;
		}

		/// <summary>
		///   Creates a dataset that emits <c>components</c> as a tuple of tensors once.
		/// </summary>
		/// <param name="components">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorDataset'.
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorDataset (TF_Output[] components, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorDataset", MakeName ("TensorDataset", operName));
			c_api.TF_AddInputList(desc, components[0], components.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a tree resource and returns a handle to it.
		/// </summary>
		/// <param name="tree_handle">
		///   Handle to the tree resource to be created.
		/// </param>
		/// <param name="tree_config">
		///   Serialized proto string of the boosted_trees.Tree.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorForestCreateTreeVariable'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation TensorForestCreateTreeVariable (TF_Output tree_handle, TF_Output tree_config, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorForestCreateTreeVariable", MakeName ("TensorForestCreateTreeVariable", operName));
			c_api.TF_AddInput(desc, tree_handle);
			c_api.TF_AddInput(desc, tree_config);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Deserializes a proto into the tree handle
		/// </summary>
		/// <param name="tree_handle">
		///   Handle to the tree resource to be restored.
		/// </param>
		/// <param name="tree_config">
		///   Serialied proto string of the boosted_trees.Tree proto.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorForestTreeDeserialize'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation TensorForestTreeDeserialize (TF_Output tree_handle, TF_Output tree_config, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorForestTreeDeserialize", MakeName ("TensorForestTreeDeserialize", operName));
			c_api.TF_AddInput(desc, tree_handle);
			c_api.TF_AddInput(desc, tree_config);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Checks whether a tree has been initialized.
		/// </summary>
		/// <param name="tree_handle">
		///   Handle to the tree.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorForestTreeIsInitializedOp'.
		/// </param>
		/// <returns>
		///   Whether the tree is initialized.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorForestTreeIsInitializedOp (TF_Output tree_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorForestTreeIsInitializedOp", MakeName ("TensorForestTreeIsInitializedOp", operName));
			c_api.TF_AddInput(desc, tree_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var is_initialized = new TF_Output (op, _idx++);
			return is_initialized;
		}

		/// <summary>
		///   Output the logits for the given input data
		/// </summary>
		/// <param name="tree_handle">
		///   Handle to the tree resource.
		/// </param>
		/// <param name="dense_features">
		///   Rank 2 dense features tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorForestTreePredict'.
		/// </param>
		/// <param name="logits_dimension">
		///   Scalar, dimension of the logits.
		/// </param>
		/// <returns>
		///   The logits predictions from the tree for each instance in the batch.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorForestTreePredict (TF_Output tree_handle, TF_Output dense_features, long logits_dimension, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorForestTreePredict", MakeName ("TensorForestTreePredict", operName));
			c_api.TF_AddInput(desc, tree_handle);
			c_api.TF_AddInput(desc, dense_features);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "logits_dimension", logits_dimension);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var logits = new TF_Output (op, _idx++);
			return logits;
		}

		/// <summary>
		///   Creates a handle to a TensorForestTreeResource
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorForestTreeResourceHandleOp'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorForestTreeResourceHandleOp (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorForestTreeResourceHandleOp", MakeName ("TensorForestTreeResourceHandleOp", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var resource = new TF_Output (op, _idx++);
			return resource;
		}

		/// <summary>
		///   Serializes the tree handle to a proto
		/// </summary>
		/// <param name="tree_handle">
		///   Handle to the tree resource to be serialized.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorForestTreeSerialize'.
		/// </param>
		/// <returns>
		///   Serialied proto string of the tree resource.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorForestTreeSerialize (TF_Output tree_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorForestTreeSerialize", MakeName ("TensorForestTreeSerialize", operName));
			c_api.TF_AddInput(desc, tree_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var tree_config = new TF_Output (op, _idx++);
			return tree_config;
		}

		/// <summary>
		///   Get the number of nodes in a tree
		/// </summary>
		/// <param name="tree_handle">
		///   Handle to the tree resource.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorForestTreeSize'.
		/// </param>
		/// <returns>
		///   The size of the tree.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorForestTreeSize (TF_Output tree_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorForestTreeSize", MakeName ("TensorForestTreeSize", operName));
			c_api.TF_AddInput(desc, tree_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var tree_size = new TF_Output (op, _idx++);
			return tree_size;
		}

		/// <summary>
		///   Concats all tensors in the list along the 0th dimension.
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListConcat'.
		/// </param>
		/// <param name="element_shape">
		///   Optional argument
		/// </param>
		/// <param name="element_dtype">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   tensor:
		///   lengths:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Requires that all tensors have the same shape except the first dimension.
		///   
		///   input_handle: The input list.
		///   tensor: The concated result.
		///   lengths: Output tensor containing sizes of the 0th dimension of tensors in the list, used for computing the gradient.
		///   
		/// </remarks>
		public (TF_Output tensor, TF_Output lengths) TensorListConcat (TF_Output input_handle, TF_DataType element_dtype, long[] element_shape = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListConcat", MakeName ("TensorListConcat", operName));
			c_api.TF_AddInput(desc, input_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "element_dtype", element_dtype);
			if (element_shape != null)
				c_api.TF_SetAttrShape (desc, "element_shape", ref element_shape[0], element_shape.Length);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var tensor = new TF_Output (op, _idx++);
			var lengths = new TF_Output (op, _idx++);
			return (tensor, lengths);
		}

		/// <summary>
		/// </summary>
		/// <param name="input_a">
		/// </param>
		/// <param name="input_b">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListConcatLists'.
		/// </param>
		/// <param name="element_dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorListConcatLists (TF_Output input_a, TF_Output input_b, TF_DataType element_dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListConcatLists", MakeName ("TensorListConcatLists", operName));
			c_api.TF_AddInput(desc, input_a);
			c_api.TF_AddInput(desc, input_b);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "element_dtype", element_dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Concats all tensors in the list along the 0th dimension.
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="element_shape">
		/// </param>
		/// <param name="leading_dims">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListConcatV2'.
		/// </param>
		/// <param name="element_dtype">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   tensor:
		///   lengths:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Requires that all tensors have the same shape except the first dimension.
		///   
		///   input_handle: The input list.
		///   element_shape: The shape of the uninitialized elements in the list. If the first
		///   dimension is not -1, it is assumed that all list elements have the same
		///   leading dim.
		///   leading_dims: The list of leading dims of uninitialized list elements. Used if
		///   the leading dim of input_handle.element_shape or the element_shape input arg
		///   is not already set.
		///   tensor: The concated result.
		///   lengths: Output tensor containing sizes of the 0th dimension of tensors in the list, used for computing the gradient.
		///   
		/// </remarks>
		public (TF_Output tensor, TF_Output lengths) TensorListConcatV2 (TF_Output input_handle, TF_Output element_shape, TF_Output leading_dims, TF_DataType element_dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListConcatV2", MakeName ("TensorListConcatV2", operName));
			c_api.TF_AddInput(desc, input_handle);
			c_api.TF_AddInput(desc, element_shape);
			c_api.TF_AddInput(desc, leading_dims);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "element_dtype", element_dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var tensor = new TF_Output (op, _idx++);
			var lengths = new TF_Output (op, _idx++);
			return (tensor, lengths);
		}

		/// <summary>
		///   The shape of the elements of the given list, as a tensor.
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListElementShape'.
		/// </param>
		/// <param name="shape_type">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   input_handle: the list
		///   element_shape: the shape of elements of the list
		/// </remarks>
		public TF_Output TensorListElementShape (TF_Output input_handle, TF_DataType shape_type, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListElementShape", MakeName ("TensorListElementShape", operName));
			c_api.TF_AddInput(desc, input_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "shape_type", shape_type);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var element_shape = new TF_Output (op, _idx++);
			return element_shape;
		}

		/// <summary>
		///   Creates a TensorList which, when stacked, has the value of <c>tensor</c>.
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="element_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListFromTensor'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Each tensor in the result list corresponds to one row of the input tensor.
		///   
		///   tensor: The input tensor.
		///   output_handle: The list.
		/// </remarks>
		public TF_Output TensorListFromTensor (TF_Output tensor, TF_Output element_shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListFromTensor", MakeName ("TensorListFromTensor", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, element_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			return output_handle;
		}

		/// <summary>
		///   Creates a Tensor by indexing into the TensorList.
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="element_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListGather'.
		/// </param>
		/// <param name="element_dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Each row in the produced Tensor corresponds to the element in the TensorList
		///   specified by the given index (see <c>tf.gather</c>).
		///   
		///   input_handle: The input tensor list.
		///   indices: The indices used to index into the list.
		///   values: The tensor.
		/// </remarks>
		public TF_Output TensorListGather (TF_Output input_handle, TF_Output indices, TF_Output element_shape, TF_DataType element_dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListGather", MakeName ("TensorListGather", operName));
			c_api.TF_AddInput(desc, input_handle);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, element_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "element_dtype", element_dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var values = new TF_Output (op, _idx++);
			return values;
		}

		/// <summary>
		///   Returns the item in the list with the given index.
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="index">
		/// </param>
		/// <param name="element_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListGetItem'.
		/// </param>
		/// <param name="element_dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   input_handle: the list
		///   index: the position in the list from which an element will be retrieved
		///   item: the element at that position
		///   
		///   
		/// </remarks>
		public TF_Output TensorListGetItem (TF_Output input_handle, TF_Output index, TF_Output element_shape, TF_DataType element_dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListGetItem", MakeName ("TensorListGetItem", operName));
			c_api.TF_AddInput(desc, input_handle);
			c_api.TF_AddInput(desc, index);
			c_api.TF_AddInput(desc, element_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "element_dtype", element_dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var item = new TF_Output (op, _idx++);
			return item;
		}

		/// <summary>
		///   Returns the number of tensors in the input tensor list.
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListLength'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   input_handle: the input list
		///   length: the number of tensors in the list
		/// </remarks>
		public TF_Output TensorListLength (TF_Output input_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListLength", MakeName ("TensorListLength", operName));
			c_api.TF_AddInput(desc, input_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var length = new TF_Output (op, _idx++);
			return length;
		}

		/// <summary>
		///   Returns the last element of the input list as well as a list with all but that element.
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="element_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListPopBack'.
		/// </param>
		/// <param name="element_dtype">
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   output_handle:
		///   tensor:
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   Fails if the list is empty.
		///   
		///   input_handle: the input list
		///   tensor: the withdrawn last element of the list
		///   element_dtype: the type of elements in the list
		///   element_shape: the shape of the output tensor
		/// </remarks>
		public (TF_Output output_handle, TF_Output tensor) TensorListPopBack (TF_Output input_handle, TF_Output element_shape, TF_DataType element_dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListPopBack", MakeName ("TensorListPopBack", operName));
			c_api.TF_AddInput(desc, input_handle);
			c_api.TF_AddInput(desc, element_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "element_dtype", element_dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			var tensor = new TF_Output (op, _idx++);
			return (output_handle, tensor);
		}

		/// <summary>
		///   Returns a list which has the passed-in <c>Tensor</c> as last element and the other elements of the given list in <c>input_handle</c>.
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="tensor">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListPushBack'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   tensor: The tensor to put on the list.
		///   input_handle: The old list.
		///   output_handle: A list with the elements of the old list followed by tensor.
		///   element_dtype: the type of elements in the list.
		///   element_shape: a shape compatible with that of elements in the list.
		/// </remarks>
		public TF_Output TensorListPushBack (TF_Output input_handle, TF_Output tensor, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListPushBack", MakeName ("TensorListPushBack", operName));
			c_api.TF_AddInput(desc, input_handle);
			c_api.TF_AddInput(desc, tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			return output_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_handles">
		/// </param>
		/// <param name="tensor">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListPushBackBatch'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorListPushBackBatch (TF_Output input_handles, TF_Output tensor, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListPushBackBatch", MakeName ("TensorListPushBackBatch", operName));
			c_api.TF_AddInput(desc, input_handles);
			c_api.TF_AddInput(desc, tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_handles = new TF_Output (op, _idx++);
			return output_handles;
		}

		/// <summary>
		///   List of the given size with empty elements.
		/// </summary>
		/// <param name="element_shape">
		/// </param>
		/// <param name="num_elements">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListReserve'.
		/// </param>
		/// <param name="element_dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   element_shape: the shape of the future elements of the list
		///   num_elements: the number of elements to reserve
		///   handle: the output list
		///   element_dtype: the desired type of elements in the list.
		/// </remarks>
		public TF_Output TensorListReserve (TF_Output element_shape, TF_Output num_elements, TF_DataType element_dtype, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListReserve", MakeName ("TensorListReserve", operName));
			c_api.TF_AddInput(desc, element_shape);
			c_api.TF_AddInput(desc, num_elements);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "element_dtype", element_dtype);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Resizes the list.
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="size">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListResize'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   
		///   input_handle: the input list
		///   size: size of the output list
		///   
		/// </remarks>
		public TF_Output TensorListResize (TF_Output input_handle, TF_Output size, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListResize", MakeName ("TensorListResize", operName));
			c_api.TF_AddInput(desc, input_handle);
			c_api.TF_AddInput(desc, size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			return output_handle;
		}

		/// <summary>
		///   Creates a TensorList by indexing into a Tensor.
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="element_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListScatter'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Each member of the TensorList corresponds to one row of the input tensor,
		///   specified by the given index (see <c>tf.gather</c>).
		///   
		///   tensor: The input tensor.
		///   indices: The indices used to index into the list.
		///   element_shape: The shape of the elements in the list (can be less specified than
		///   the shape of the tensor).
		///   output_handle: The TensorList.
		/// </remarks>
		public TF_Output TensorListScatter (TF_Output tensor, TF_Output indices, TF_Output element_shape, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListScatter", MakeName ("TensorListScatter", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, element_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			return output_handle;
		}

		/// <summary>
		///   Scatters tensor at indices in an input list.
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="tensor">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListScatterIntoExistingList'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Each member of the TensorList corresponds to one row of the input tensor,
		///   specified by the given index (see <c>tf.gather</c>).
		///   
		///   input_handle: The list to scatter into.
		///   tensor: The input tensor.
		///   indices: The indices used to index into the list.
		///   output_handle: The TensorList.
		/// </remarks>
		public TF_Output TensorListScatterIntoExistingList (TF_Output input_handle, TF_Output tensor, TF_Output indices, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListScatterIntoExistingList", MakeName ("TensorListScatterIntoExistingList", operName));
			c_api.TF_AddInput(desc, input_handle);
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, indices);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			return output_handle;
		}

		/// <summary>
		///   Creates a TensorList by indexing into a Tensor.
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="indices">
		/// </param>
		/// <param name="element_shape">
		/// </param>
		/// <param name="num_elements">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListScatterV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Each member of the TensorList corresponds to one row of the input tensor,
		///   specified by the given index (see <c>tf.gather</c>).
		///   
		///   tensor: The input tensor.
		///   indices: The indices used to index into the list.
		///   element_shape: The shape of the elements in the list (can be less specified than
		///   the shape of the tensor).
		///   num_elements: The size of the output list. Must be large enough to accommodate
		///   the largest index in indices. If -1, the list is just large enough to include
		///   the largest index in indices.
		///   output_handle: The TensorList.
		/// </remarks>
		public TF_Output TensorListScatterV2 (TF_Output tensor, TF_Output indices, TF_Output element_shape, TF_Output num_elements, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListScatterV2", MakeName ("TensorListScatterV2", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, element_shape);
			c_api.TF_AddInput(desc, num_elements);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			return output_handle;
		}

		/// <summary>
		///   Sets the index-th position of the list to contain the given tensor.
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="index">
		/// </param>
		/// <param name="item">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListSetItem'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   input_handle: the list
		///   index: the position in the list to which the tensor will be assigned
		///   item: the element to be assigned to that position
		///   output_handle: the new list, with the element in the proper position
		///   
		/// </remarks>
		public TF_Output TensorListSetItem (TF_Output input_handle, TF_Output index, TF_Output item, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListSetItem", MakeName ("TensorListSetItem", operName));
			c_api.TF_AddInput(desc, input_handle);
			c_api.TF_AddInput(desc, index);
			c_api.TF_AddInput(desc, item);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			return output_handle;
		}

		/// <summary>
		///   Splits a tensor into a list.
		/// </summary>
		/// <param name="tensor">
		/// </param>
		/// <param name="element_shape">
		/// </param>
		/// <param name="lengths">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListSplit'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   list[i] corresponds to lengths[i] tensors from the input tensor.
		///   The tensor must have rank at least 1 and contain exactly sum(lengths) elements.
		///   
		///   tensor: The input tensor.
		///   element_shape: A shape compatible with that of elements in the tensor.
		///   lengths: Vector of sizes of the 0th dimension of tensors in the list.
		///   output_handle: The list.
		/// </remarks>
		public TF_Output TensorListSplit (TF_Output tensor, TF_Output element_shape, TF_Output lengths, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListSplit", MakeName ("TensorListSplit", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, element_shape);
			c_api.TF_AddInput(desc, lengths);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			return output_handle;
		}

		/// <summary>
		///   Stacks all tensors in the list.
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="element_shape">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListStack'.
		/// </param>
		/// <param name="num_elements">
		///   Optional argument
		/// </param>
		/// <param name="element_dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Requires that all tensors have the same shape.
		///   
		///   input_handle: the input list
		///   tensor: the gathered result
		///   num_elements: optional. If not -1, the number of elements in the list.
		///   
		/// </remarks>
		public TF_Output TensorListStack (TF_Output input_handle, TF_Output element_shape, TF_DataType element_dtype, long? num_elements = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorListStack", MakeName ("TensorListStack", operName));
			c_api.TF_AddInput(desc, input_handle);
			c_api.TF_AddInput(desc, element_shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "element_dtype", element_dtype);
			if (num_elements.HasValue)
				c_api.TF_SetAttrInt (desc, "num_elements", num_elements.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var tensor = new TF_Output (op, _idx++);
			return tensor;
		}

		/// <summary>
		///   Adds sparse <c>updates</c> to an existing tensor according to <c>indices</c>.
		/// </summary>
		/// <param name="tensor">
		///   Tensor to copy/update.
		/// </param>
		/// <param name="indices">
		///   Index tensor.
		/// </param>
		/// <param name="updates">
		///   Updates to scatter into output.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorScatterAdd'.
		/// </param>
		/// <returns>
		///   A new tensor copied from tensor and updates added according to the indices.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation creates a new tensor by adding sparse <c>updates</c> to the passed
		///   in <c>tensor</c>.
		///   This operation is very similar to <c>tf.scatter_nd_add</c>, except that the updates
		///   are added onto an existing tensor (as opposed to a variable). If the memory
		///   for the existing tensor cannot be re-used, a copy is made and updated.
		///   
		///   <c>indices</c> is an integer tensor containing indices into a new tensor of shape
		///   <c>shape</c>.  The last dimension of <c>indices</c> can be at most the rank of <c>shape</c>:
		///   
		///   indices.shape[-1] &amp;lt;= shape.rank
		///   
		///   The last dimension of <c>indices</c> corresponds to indices into elements
		///   (if <c>indices.shape[-1] = shape.rank</c>) or slices
		///   (if <c>indices.shape[-1] &amp;lt; shape.rank</c>) along dimension <c>indices.shape[-1]</c> of
		///   <c>shape</c>.  <c>updates</c> is a tensor with shape
		///   
		///   indices.shape[:-1] + shape[indices.shape[-1]:]
		///   
		///   The simplest form of tensor_scatter_add is to add individual elements to a
		///   tensor by index. For example, say we want to add 4 elements in a rank-1
		///   tensor with 8 elements.
		///   
		///   In Python, this scatter add operation would look like this:
		///   
		///    <code>
		///   indices = tf.constant([[4], [3], [1], [7]])
		///   updates = tf.constant([9, 10, 11, 12])
		///   tensor = tf.ones([8], dtype=tf.int32)
		///   updated = tf.tensor_scatter_add(tensor, indices, updates)
		///   with tf.Session() as sess:
		///   print(sess.run(scatter))
		///    </code>
		///   
		///   The resulting tensor would look like this:
		///   
		///   [1, 12, 1, 11, 10, 1, 1, 13]
		///   
		///   We can also, insert entire slices of a higher rank tensor all at once. For
		///   example, if we wanted to insert two slices in the first dimension of a
		///   rank-3 tensor with two matrices of new values.
		///   
		///   In Python, this scatter add operation would look like this:
		///   
		///    <code>
		///   indices = tf.constant([[0], [2]])
		///   updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6],
		///   [7, 7, 7, 7], [8, 8, 8, 8]],
		///   [[5, 5, 5, 5], [6, 6, 6, 6],
		///   [7, 7, 7, 7], [8, 8, 8, 8]]])
		///   tensor = tf.ones([4, 4, 4])
		///   updated = tf.tensor_scatter_add(tensor, indices, updates)
		///   with tf.Session() as sess:
		///   print(sess.run(scatter))
		///    </code>
		///   
		///   The resulting tensor would look like this:
		///   
		///   [[[6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8], [9, 9, 9, 9]],
		///   [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],
		///   [[6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8], [9, 9, 9, 9]],
		///   [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]]
		///   
		///   Note that on CPU, if an out of bound index is found, an error is returned.
		///   On GPU, if an out of bound index is found, the index is ignored.
		/// </remarks>
		public TF_Output TensorScatterAdd (TF_Output tensor, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorScatterAdd", MakeName ("TensorScatterAdd", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Subtracts sparse <c>updates</c> from an existing tensor according to <c>indices</c>.
		/// </summary>
		/// <param name="tensor">
		///   Tensor to copy/update.
		/// </param>
		/// <param name="indices">
		///   Index tensor.
		/// </param>
		/// <param name="updates">
		///   Updates to scatter into output.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorScatterSub'.
		/// </param>
		/// <returns>
		///   A new tensor copied from tensor and updates subtracted according to the indices.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation creates a new tensor by subtracting sparse <c>updates</c> from the
		///   passed in <c>tensor</c>.
		///   This operation is very similar to <c>tf.scatter_nd_sub</c>, except that the updates
		///   are subtracted from an existing tensor (as opposed to a variable). If the memory
		///   for the existing tensor cannot be re-used, a copy is made and updated.
		///   
		///   <c>indices</c> is an integer tensor containing indices into a new tensor of shape
		///   <c>shape</c>.  The last dimension of <c>indices</c> can be at most the rank of <c>shape</c>:
		///   
		///   indices.shape[-1] &amp;lt;= shape.rank
		///   
		///   The last dimension of <c>indices</c> corresponds to indices into elements
		///   (if <c>indices.shape[-1] = shape.rank</c>) or slices
		///   (if <c>indices.shape[-1] &amp;lt; shape.rank</c>) along dimension <c>indices.shape[-1]</c> of
		///   <c>shape</c>.  <c>updates</c> is a tensor with shape
		///   
		///   indices.shape[:-1] + shape[indices.shape[-1]:]
		///   
		///   The simplest form of tensor_scatter_sub is to subtract individual elements
		///   from a tensor by index. For example, say we want to insert 4 scattered elements
		///   in a rank-1 tensor with 8 elements.
		///   
		///   In Python, this scatter subtract operation would look like this:
		///   
		///    <code>
		///   indices = tf.constant([[4], [3], [1], [7]])
		///   updates = tf.constant([9, 10, 11, 12])
		///   tensor = tf.ones([8], dtype=tf.int32)
		///   updated = tf.tensor_scatter_sub(tensor, indices, updates)
		///   with tf.Session() as sess:
		///   print(sess.run(scatter))
		///    </code>
		///   
		///   The resulting tensor would look like this:
		///   
		///   [1, -10, 1, -9, -8, 1, 1, -11]
		///   
		///   We can also, insert entire slices of a higher rank tensor all at once. For
		///   example, if we wanted to insert two slices in the first dimension of a
		///   rank-3 tensor with two matrices of new values.
		///   
		///   In Python, this scatter add operation would look like this:
		///   
		///    <code>
		///   indices = tf.constant([[0], [2]])
		///   updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6],
		///   [7, 7, 7, 7], [8, 8, 8, 8]],
		///   [[5, 5, 5, 5], [6, 6, 6, 6],
		///   [7, 7, 7, 7], [8, 8, 8, 8]]])
		///   tensor = tf.ones([4, 4, 4])
		///   updated = tf.tensor_scatter_sub(tensor, indices, updates)
		///   with tf.Session() as sess:
		///   print(sess.run(scatter))
		///    </code>
		///   
		///   The resulting tensor would look like this:
		///   
		///   [[[-4, -4, -4, -4], [-5, -5, -5, -5], [-6, -6, -6, -6], [-7, -7, -7, -7]],
		///   [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],
		///   [[-4, -4, -4, -4], [-5, -5, -5, -5], [-6, -6, -6, -6], [-7, -7, -7, -7]],
		///   [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]]
		///   
		///   Note that on CPU, if an out of bound index is found, an error is returned.
		///   On GPU, if an out of bound index is found, the index is ignored.
		/// </remarks>
		public TF_Output TensorScatterSub (TF_Output tensor, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorScatterSub", MakeName ("TensorScatterSub", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Scatter <c>updates</c> into an existing tensor according to <c>indices</c>.
		/// </summary>
		/// <param name="tensor">
		///   Tensor to copy/update.
		/// </param>
		/// <param name="indices">
		///   Index tensor.
		/// </param>
		/// <param name="updates">
		///   Updates to scatter into output.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorScatterUpdate'.
		/// </param>
		/// <returns>
		///   A new tensor with the given shape and updates applied according
		///   to the indices.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation creates a new tensor by applying sparse <c>updates</c> to the passed
		///   in <c>tensor</c>.
		///   This operation is very similar to <c>tf.scatter_nd</c>, except that the updates are
		///   scattered onto an existing tensor (as opposed to a zero-tensor). If the memory
		///   for the existing tensor cannot be re-used, a copy is made and updated.
		///   
		///   If <c>indices</c> contains duplicates, then their updates are accumulated (summed).
		///   
		///   **WARNING**: The order in which updates are applied is nondeterministic, so the
		///   output will be nondeterministic if <c>indices</c> contains duplicates -- because
		///   of some numerical approximation issues, numbers summed in different order
		///   may yield different results.
		///   
		///   <c>indices</c> is an integer tensor containing indices into a new tensor of shape
		///   <c>shape</c>.  The last dimension of <c>indices</c> can be at most the rank of <c>shape</c>:
		///   
		///   indices.shape[-1] &amp;lt;= shape.rank
		///   
		///   The last dimension of <c>indices</c> corresponds to indices into elements
		///   (if <c>indices.shape[-1] = shape.rank</c>) or slices
		///   (if <c>indices.shape[-1] &amp;lt; shape.rank</c>) along dimension <c>indices.shape[-1]</c> of
		///   <c>shape</c>.  <c>updates</c> is a tensor with shape
		///   
		///   indices.shape[:-1] + shape[indices.shape[-1]:]
		///   
		///   The simplest form of scatter is to insert individual elements in a tensor by
		///   index. For example, say we want to insert 4 scattered elements in a rank-1
		///   tensor with 8 elements.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/ScatterNd1.png" alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		///   
		///   In Python, this scatter operation would look like this:
		///   
		///    <code>
		///   indices = tf.constant([[4], [3], [1], [7]])
		///   updates = tf.constant([9, 10, 11, 12])
		///   tensor = tf.ones([8], dtype=tf.int32)
		///   updated = tf.tensor_scatter_update(tensor, indices, updates)
		///   with tf.Session() as sess:
		///   print(sess.run(scatter))
		///    </code>
		///   
		///   The resulting tensor would look like this:
		///   
		///   [1, 11, 1, 10, 9, 1, 1, 12]
		///   
		///   We can also, insert entire slices of a higher rank tensor all at once. For
		///   example, if we wanted to insert two slices in the first dimension of a
		///   rank-3 tensor with two matrices of new values.
		///   
		///   In Python, this scatter operation would look like this:
		///   
		///    <code>
		///   indices = tf.constant([[0], [2]])
		///   updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6],
		///   [7, 7, 7, 7], [8, 8, 8, 8]],
		///   [[5, 5, 5, 5], [6, 6, 6, 6],
		///   [7, 7, 7, 7], [8, 8, 8, 8]]])
		///   tensor = tf.ones([4, 4, 4])
		///   updated = tf.tensor_scatter_update(tensor, indices, updates)
		///   with tf.Session() as sess:
		///   print(sess.run(scatter))
		///    </code>
		///   
		///   The resulting tensor would look like this:
		///   
		///   [[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],
		///   [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],
		///   [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],
		///   [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]]
		///   
		///   Note that on CPU, if an out of bound index is found, an error is returned.
		///   On GPU, if an out of bound index is found, the index is ignored.
		/// </remarks>
		public TF_Output TensorScatterUpdate (TF_Output tensor, TF_Output indices, TF_Output updates, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorScatterUpdate", MakeName ("TensorScatterUpdate", operName));
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, updates);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates a dataset that emits each dim-0 slice of <c>components</c> once.
		/// </summary>
		/// <param name="components">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorSliceDataset'.
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorSliceDataset (TF_Output[] components, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorSliceDataset", MakeName ("TensorSliceDataset", operName));
			c_api.TF_AddInputList(desc, components[0], components.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Assign <c>value</c> to the sliced l-value reference of <c>input</c>.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="begin">
		/// </param>
		/// <param name="end">
		/// </param>
		/// <param name="strides">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorStridedSliceUpdate'.
		/// </param>
		/// <param name="begin_mask">
		///   Optional argument
		/// </param>
		/// <param name="end_mask">
		///   Optional argument
		/// </param>
		/// <param name="ellipsis_mask">
		///   Optional argument
		/// </param>
		/// <param name="new_axis_mask">
		///   Optional argument
		/// </param>
		/// <param name="shrink_axis_mask">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The values of <c>value</c> are assigned to the positions in the tensor <c>input</c> that
		///   are selected by the slice parameters. The slice parameters <c>begin</c> <c>end</c>
		///   <c>strides</c> etc. work exactly as in <c>StridedSlice</c>.
		///   
		///   NOTE this op currently does not support broadcasting and so <c>value</c>'s shape
		///   must be exactly the shape produced by the slice of <c>input</c>.
		/// </remarks>
		public TF_Output TensorStridedSliceUpdate (TF_Output input, TF_Output begin, TF_Output end, TF_Output strides, TF_Output value, long? begin_mask = null, long? end_mask = null, long? ellipsis_mask = null, long? new_axis_mask = null, long? shrink_axis_mask = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorStridedSliceUpdate", MakeName ("TensorStridedSliceUpdate", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, begin);
			c_api.TF_AddInput(desc, end);
			c_api.TF_AddInput(desc, strides);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (begin_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "begin_mask", begin_mask.Value);
			
			if (end_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "end_mask", end_mask.Value);
			
			if (ellipsis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "ellipsis_mask", ellipsis_mask.Value);
			
			if (new_axis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "new_axis_mask", new_axis_mask.Value);
			
			if (shrink_axis_mask.HasValue)
				c_api.TF_SetAttrInt (desc, "shrink_axis_mask", shrink_axis_mask.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Outputs a <c>Summary</c> protocol buffer with a tensor.
		/// </summary>
		/// <param name="tensor">
		///   A tensor to serialize.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorSummary'.
		/// </param>
		/// <param name="description">
		///   Optional argument
		///   A json-encoded SummaryDescription proto.
		/// </param>
		/// <param name="labels">
		///   Optional argument
		///   An unused list of strings.
		/// </param>
		/// <param name="display_name">
		///   Optional argument
		///   An unused string.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op is being phased out in favor of TensorSummaryV2, which lets callers pass
		///   a tag as well as a serialized SummaryMetadata proto string that contains
		///   plugin-specific data. We will keep this op to maintain backwards compatibility.
		/// </remarks>
		public TF_Output TensorSummary (TF_Output tensor, string description = null, string[] labels = null, string display_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorSummary", MakeName ("TensorSummary", operName));
			c_api.TF_AddInput(desc, tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (description != null)
				c_api.TF_SetAttrString (desc, "description", description);
			
			if (labels != null)
				c_api.TF_SetAttrStringList (desc, "labels", labels);
			
			if (display_name != null)
				c_api.TF_SetAttrString (desc, "display_name", display_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var summary = new TF_Output (op, _idx++);
			return summary;
		}

		/// <summary>
		///   Outputs a <c>Summary</c> protocol buffer with a tensor and per-plugin data.
		/// </summary>
		/// <param name="tag">
		///   A string attached to this summary. Used for organization in TensorBoard.
		/// </param>
		/// <param name="tensor">
		///   A tensor to serialize.
		/// </param>
		/// <param name="serialized_summary_metadata">
		///   A serialized SummaryMetadata proto. Contains plugin
		///   data.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorSummaryV2'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TensorSummaryV2 (TF_Output tag, TF_Output tensor, TF_Output serialized_summary_metadata, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TensorSummaryV2", MakeName ("TensorSummaryV2", operName));
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, serialized_summary_metadata);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var summary = new TF_Output (op, _idx++);
			return summary;
		}

		/// <summary>
		///   Creates a dataset that emits the lines of one or more text files.
		/// </summary>
		/// <param name="filenames">
		///   A scalar or a vector containing the name(s) of the file(s) to be
		///   read.
		/// </param>
		/// <param name="compression_type">
		///   A scalar containing either (i) the empty string (no
		///   compression), (ii) "ZLIB", or (iii) "GZIP".
		/// </param>
		/// <param name="buffer_size">
		///   A scalar containing the number of bytes to buffer.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TextLineDataset'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TextLineDataset (TF_Output filenames, TF_Output compression_type, TF_Output buffer_size, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TextLineDataset", MakeName ("TextLineDataset", operName));
			c_api.TF_AddInput(desc, filenames);
			c_api.TF_AddInput(desc, compression_type);
			c_api.TF_AddInput(desc, buffer_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   A Reader that outputs the lines of a file delimited by '\n'.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TextLineReader'.
		/// </param>
		/// <param name="skip_header_lines">
		///   Optional argument
		///   Number of lines to skip from the beginning of every file.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this reader is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this reader is named in the given bucket
		///   with this shared_name. Otherwise, the node name is used instead.
		/// </param>
		/// <returns>
		///   The handle to reference the Reader.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TextLineReader (long? skip_header_lines = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TextLineReader", MakeName ("TextLineReader", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (skip_header_lines.HasValue)
				c_api.TF_SetAttrInt (desc, "skip_header_lines", skip_header_lines.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		///   A Reader that outputs the lines of a file delimited by '\n'.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TextLineReaderV2'.
		/// </param>
		/// <param name="skip_header_lines">
		///   Optional argument
		///   Number of lines to skip from the beginning of every file.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this reader is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this reader is named in the given bucket
		///   with this shared_name. Otherwise, the node name is used instead.
		/// </param>
		/// <returns>
		///   The handle to reference the Reader.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TextLineReaderV2 (long? skip_header_lines = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TextLineReaderV2", MakeName ("TextLineReaderV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (skip_header_lines.HasValue)
				c_api.TF_SetAttrInt (desc, "skip_header_lines", skip_header_lines.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		///   Creates a dataset that emits the records from one or more TFRecord files.
		/// </summary>
		/// <param name="filenames">
		///   A scalar or vector containing the name(s) of the file(s) to be
		///   read.
		/// </param>
		/// <param name="compression_type">
		///   A scalar containing either (i) the empty string (no
		///   compression), (ii) "ZLIB", or (iii) "GZIP".
		/// </param>
		/// <param name="buffer_size">
		///   A scalar representing the number of bytes to buffer. A value of
		///   0 means no buffering will be performed.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TFRecordDataset'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TFRecordDataset (TF_Output filenames, TF_Output compression_type, TF_Output buffer_size, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TFRecordDataset", MakeName ("TFRecordDataset", operName));
			c_api.TF_AddInput(desc, filenames);
			c_api.TF_AddInput(desc, compression_type);
			c_api.TF_AddInput(desc, buffer_size);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   A Reader that outputs the records from a TensorFlow Records file.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TFRecordReader'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this reader is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this reader is named in the given bucket
		///   with this shared_name. Otherwise, the node name is used instead.
		/// </param>
		/// <param name="compression_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The handle to reference the Reader.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TFRecordReader (string container = null, string shared_name = null, string compression_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TFRecordReader", MakeName ("TFRecordReader", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (compression_type != null)
				c_api.TF_SetAttrString (desc, "compression_type", compression_type);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		///   A Reader that outputs the records from a TensorFlow Records file.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TFRecordReaderV2'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this reader is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this reader is named in the given bucket
		///   with this shared_name. Otherwise, the node name is used instead.
		/// </param>
		/// <param name="compression_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The handle to reference the Reader.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TFRecordReaderV2 (string container = null, string shared_name = null, string compression_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TFRecordReaderV2", MakeName ("TFRecordReaderV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			if (compression_type != null)
				c_api.TF_SetAttrString (desc, "compression_type", compression_type);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		///   Creates a dataset that uses a custom thread pool to compute <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="thread_pool">
		///   A resource produced by the ThreadPoolHandle op.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ThreadPoolDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ThreadPoolDataset (TF_Output input_dataset, TF_Output thread_pool, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ThreadPoolDataset", MakeName ("ThreadPoolDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, thread_pool);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Creates a dataset that uses a custom thread pool to compute <c>input_dataset</c>.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ThreadPoolHandle'.
		/// </param>
		/// <param name="max_intra_op_parallelism">
		///   Optional argument
		///   The maximum degree of parallelism to use within operations that execute on this
		///   threadpool.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="num_threads">
		///   The number of threads in the thread pool.
		/// </param>
		/// <param name="display_name">
		///   A human-readable name for the threads that may be visible in some
		///   visualizations.
		///   threadpool.
		/// </param>
		/// <returns>
		///   A resource that can be consumed by one or more ExperimentalThreadPoolDataset
		///   ops.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ThreadPoolHandle (long num_threads, string display_name, long? max_intra_op_parallelism = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ThreadPoolHandle", MakeName ("ThreadPoolHandle", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_threads", num_threads);
			c_api.TF_SetAttrString (desc, "display_name", display_name);
			if (max_intra_op_parallelism.HasValue)
				c_api.TF_SetAttrInt (desc, "max_intra_op_parallelism", max_intra_op_parallelism.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Generates labels for candidate sampling with a learned unigram distribution.
		/// </summary>
		/// <param name="true_classes">
		///   A batch_size * num_true matrix, in which each row contains the
		///   IDs of the num_true target_classes in the corresponding original label.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ThreadUnsafeUnigramCandidateSampler'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either seed or seed2 are set to be non-zero, the random number
		///   generator is seeded by the given seed.  Otherwise, it is seeded by a
		///   random seed.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   An second seed to avoid seed collision.
		/// </param>
		/// <param name="num_true">
		///   Number of true labels per context.
		/// </param>
		/// <param name="num_sampled">
		///   Number of candidates to randomly sample.
		/// </param>
		/// <param name="unique">
		///   If unique is true, we sample with rejection, so that all sampled
		///   candidates in a batch are unique. This requires some approximation to
		///   estimate the post-rejection sampling probabilities.
		/// </param>
		/// <param name="range_max">
		///   The sampler will sample integers from the interval [0, range_max).
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sampled_candidates: A vector of length num_sampled, in which each element is
		///   the ID of a sampled candidate.
		///   true_expected_count: A batch_size * num_true matrix, representing
		///   the number of times each candidate is expected to occur in a batch
		///   of sampled candidates. If unique=true, then this is a probability.
		///   sampled_expected_count: A vector of length num_sampled, for each sampled
		///   candidate representing the number of times the candidate is expected
		///   to occur in a batch of sampled candidates.  If unique=true, then this is a
		///   probability.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   See explanations of candidate sampling and the data formats at
		///   go/candidate-sampling.
		///   
		///   For each batch, this op picks a single set of sampled candidate labels.
		///   
		///   The advantages of sampling candidates per-batch are simplicity and the
		///   possibility of efficient dense matrix multiplication. The disadvantage is that
		///   the sampled candidates must be chosen independently of the context and of the
		///   true labels.
		/// </remarks>
		public (TF_Output sampled_candidates, TF_Output true_expected_count, TF_Output sampled_expected_count) ThreadUnsafeUnigramCandidateSampler (TF_Output true_classes, long num_true, long num_sampled, bool unique, long range_max, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ThreadUnsafeUnigramCandidateSampler", MakeName ("ThreadUnsafeUnigramCandidateSampler", operName));
			c_api.TF_AddInput(desc, true_classes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_true", num_true);
			c_api.TF_SetAttrInt (desc, "num_sampled", num_sampled);
			c_api.TF_SetAttrBool (desc, "unique", Convert.ToByte(unique));
			c_api.TF_SetAttrInt (desc, "range_max", range_max);
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var sampled_candidates = new TF_Output (op, _idx++);
			var true_expected_count = new TF_Output (op, _idx++);
			var sampled_expected_count = new TF_Output (op, _idx++);
			return (sampled_candidates, true_expected_count, sampled_expected_count);
		}

		/// <summary>
		///   Constructs a tensor by tiling a given tensor.
		/// </summary>
		/// <param name="input">
		///   1-D or higher.
		/// </param>
		/// <param name="multiples">
		///   1-D. Length must be the same as the number of dimensions in <c>input</c>
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Tile'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation creates a new tensor by replicating <c>input</c> <c>multiples</c> times.
		///   The output tensor's i'th dimension has <c>input.dims(i) * multiples[i]</c> elements,
		///   and the values of <c>input</c> are replicated <c>multiples[i]</c> times along the 'i'th
		///   dimension. For example, tiling <c>[a b c d]</c> by <c>[2]</c> produces
		///   <c>[a b c d a b c d]</c>.
		/// </remarks>
		public TF_Output Tile (TF_Output input, TF_Output multiples, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Tile", MakeName ("Tile", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, multiples);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns the gradient of <c>Tile</c>.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="multiples">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TileGrad'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Since <c>Tile</c> takes an input and repeats the input <c>multiples</c> times
		///   along each dimension, <c>TileGrad</c> takes in <c>multiples</c> and aggregates
		///   each repeated tile of <c>input</c> into <c>output</c>.
		/// </remarks>
		public TF_Output TileGrad (TF_Output input, TF_Output multiples, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TileGrad", MakeName ("TileGrad", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, multiples);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Provides the time since epoch in seconds.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Timestamp'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Returns the timestamp as a <c>float64</c> for seconds since the Unix epoch.
		///   
		///   Note: the timestamp is computed when the op is executed, not when it is added
		///   to the graph.
		/// </remarks>
		public TF_Output Timestamp (string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Timestamp", MakeName ("Timestamp", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var ts = new TF_Output (op, _idx++);
			return ts;
		}

		/// <summary>
		///   Finds values and indices of the <c>k</c> largest elements for the last dimension.
		/// </summary>
		/// <param name="input">
		///   1-D or higher with last dimension at least <c>k</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TopK'.
		/// </param>
		/// <param name="sorted">
		///   Optional argument
		///   If true the resulting <c>k</c> elements will be sorted by the values in
		///   descending order.
		/// </param>
		/// <param name="k">
		///   Number of top elements to look for along the last dimension (along each
		///   row for matrices).
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   values: The <c>k</c> largest elements along each last dimensional slice.
		///   indices: The indices of <c>values</c> within the last dimension of <c>input</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   If the input is a vector (rank-1), finds the <c>k</c> largest entries in the vector
		///   and outputs their values and indices as vectors.  Thus <c>values[j]</c> is the
		///   <c>j</c>-th largest entry in <c>input</c>, and its index is <c>indices[j]</c>.
		///   
		///   For matrices (resp. higher rank input), computes the top <c>k</c> entries in each
		///   row (resp. vector along the last dimension).  Thus,
		///   
		///   values.shape = indices.shape = input.shape[:-1] + [k]
		///   
		///   If two elements are equal, the lower-index element appears first.
		///   
		///   If <c>k</c> varies dynamically, use <c>TopKV2</c> below.
		/// </remarks>
		public (TF_Output values, TF_Output indices) TopK (TF_Output input, long k, bool? sorted = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TopK", MakeName ("TopK", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "k", k);
			if (sorted.HasValue)
				c_api.TF_SetAttrBool (desc, "sorted", Convert.ToByte(sorted.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var values = new TF_Output (op, _idx++);
			var indices = new TF_Output (op, _idx++);
			return (values, indices);
		}

		/// <summary>
		///   Finds values and indices of the <c>k</c> largest elements for the last dimension.
		/// </summary>
		/// <param name="input">
		///   1-D or higher with last dimension at least <c>k</c>.
		/// </param>
		/// <param name="k">
		///   0-D.  Number of top elements to look for along the last dimension (along each
		///   row for matrices).
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TopKV2'.
		/// </param>
		/// <param name="sorted">
		///   Optional argument
		///   If true the resulting <c>k</c> elements will be sorted by the values in
		///   descending order.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   values: The <c>k</c> largest elements along each last dimensional slice.
		///   indices: The indices of <c>values</c> within the last dimension of <c>input</c>.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   If the input is a vector (rank-1), finds the <c>k</c> largest entries in the vector
		///   and outputs their values and indices as vectors.  Thus <c>values[j]</c> is the
		///   <c>j</c>-th largest entry in <c>input</c>, and its index is <c>indices[j]</c>.
		///   
		///   For matrices (resp. higher rank input), computes the top <c>k</c> entries in each
		///   row (resp. vector along the last dimension).  Thus,
		///   
		///   values.shape = indices.shape = input.shape[:-1] + [k]
		///   
		///   If two elements are equal, the lower-index element appears first.
		/// </remarks>
		public (TF_Output values, TF_Output indices) TopKV2 (TF_Output input, TF_Output k, bool? sorted = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TopKV2", MakeName ("TopKV2", operName));
			c_api.TF_AddInput(desc, input);
			c_api.TF_AddInput(desc, k);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (sorted.HasValue)
				c_api.TF_SetAttrBool (desc, "sorted", Convert.ToByte(sorted.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var values = new TF_Output (op, _idx++);
			var indices = new TF_Output (op, _idx++);
			return (values, indices);
		}

		/// <summary>
		///   CompilationResultProto indicating the status of the TPU compilation.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TPUCompilationResult'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TPUCompilationResult (string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TPUCompilationResult", MakeName ("TPUCompilationResult", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   An op enabling differentiation of TPU Embeddings.
		/// </summary>
		/// <param name="embedding_variable">
		///   A trainable variable, enabling optimizers to find this op.
		/// </param>
		/// <param name="sliced_activations">
		///   The embedding activations Tensor to return.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TPUEmbeddingActivations'.
		/// </param>
		/// <param name="table_id">
		///   The id of the table in the embedding layer configuration from which
		///   these activations were computed.
		/// </param>
		/// <param name="lookup_id">
		///   Identifier of the set of embedding indices which produced these
		///   activations.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This op simply returns its first input, which is assumed to have been sliced
		///   from the Tensors returned by TPUEmbeddingDequeueActivations. The presence of
		///   this op, and its first argument being a trainable Variable, enables automatic
		///   differentiation of graphs containing embeddings via the TPU Embedding Python
		///   libraries.
		/// </remarks>
		public TF_Output TPUEmbeddingActivations (TF_Output embedding_variable, TF_Output sliced_activations, long table_id, long lookup_id, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TPUEmbeddingActivations", MakeName ("TPUEmbeddingActivations", operName));
			c_api.TF_AddInput(desc, embedding_variable);
			c_api.TF_AddInput(desc, sliced_activations);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "table_id", table_id);
			c_api.TF_SetAttrInt (desc, "lookup_id", lookup_id);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   A TPU core selector Op.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TPUOrdinalSelector'.
		/// </param>
		/// <returns>
		///   A vector 1 or more TPU cores.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This Op produces a set of TPU cores (for warm-up) or a single TPU core
		///   (for regular inference) to execute the TPU program on. The output is
		///   consumed by TPUPartitionedCall.
		/// </remarks>
		public TF_Output TPUOrdinalSelector (string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TPUOrdinalSelector", MakeName ("TPUOrdinalSelector", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var device_ordinals = new TF_Output (op, _idx++);
			return device_ordinals;
		}

		/// <summary>
		///   Calls a function placed on a specified TPU device.
		/// </summary>
		/// <param name="args">
		///   The arguments to the function.
		/// </param>
		/// <param name="device_ordinal">
		///   The TPU device ordinal to run the function on.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TPUPartitionedCall'.
		/// </param>
		/// <param name="Tout">
		///   The types of the outputs of the function.
		/// </param>
		/// <param name="f">
		///   The function to call.
		/// </param>
		/// <returns>
		///   The output of the function call.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] TPUPartitionedCall (TF_Output[] args, TF_Output device_ordinal, TF_DataType[] Tout, TF_Function f, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TPUPartitionedCall", MakeName ("TPUPartitionedCall", operName));
			c_api.TF_AddInputList(desc, args[0], args.Length);
			c_api.TF_AddInput(desc, device_ordinal);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "Tout", Tout);
			c_api.TF_SetAttrFuncName (desc, "f", c_api.TF_FunctionName(f));
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		///   Connects N inputs to an N-way replicated TPU computation.
		/// </summary>
		/// <param name="inputs">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TPUReplicatedInput'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output TPUReplicatedInput (TF_Output[] inputs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TPUReplicatedInput", MakeName ("TPUReplicatedInput", operName));
			c_api.TF_AddInputList(desc, inputs[0], inputs.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Connects outputs of an N-way replicated computation to N outputs.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TPUReplicatedOutput'.
		/// </param>
		/// <param name="num_replicas">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] TPUReplicatedOutput (TF_Output input, long num_replicas, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TPUReplicatedOutput", MakeName ("TPUReplicatedOutput", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_replicas", num_replicas);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "outputs", status);
			var outputs = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				outputs [i] = new TF_Output (op, _idx++);
			
			return outputs;
		}

		/// <summary>
		///   Metadata indicaitng how the TPU computation should be replicated.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TPUReplicateMetadata'.
		/// </param>
		/// <param name="num_cores_per_replica">
		///   Optional argument
		///   Number of cores per replica. Used for model parallelism.
		/// </param>
		/// <param name="topology">
		///   Optional argument
		///   TopologyProto indicating the topology of the TPU pod slice.
		/// </param>
		/// <param name="use_tpu">
		///   Optional argument
		///   Whether to place the computation on the TPU.
		/// </param>
		/// <param name="device_assignment">
		///   Optional argument
		///   The assignment of devices for the computation.
		/// </param>
		/// <param name="computation_shape">
		///   Optional argument
		///   DEPRECATED. Use num_cores_per_replica instead.
		/// </param>
		/// <param name="host_compute_core">
		///   Optional argument
		/// </param>
		/// <param name="padding_map">
		///   Optional argument
		/// </param>
		/// <param name="step_marker_location">
		///   Optional argument
		/// </param>
		/// <param name="allow_soft_placement">
		///   Optional argument
		/// </param>
		/// <param name="num_replicas">
		///   Number of replicas of the computation
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation TPUReplicateMetadata (long num_replicas, long? num_cores_per_replica = null, string topology = null, bool? use_tpu = null, long[] device_assignment = null, long[] computation_shape = null, string[] host_compute_core = null, string[] padding_map = null, string step_marker_location = null, bool? allow_soft_placement = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TPUReplicateMetadata", MakeName ("TPUReplicateMetadata", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_replicas", num_replicas);
			if (num_cores_per_replica.HasValue)
				c_api.TF_SetAttrInt (desc, "num_cores_per_replica", num_cores_per_replica.Value);
			
			if (topology != null)
				c_api.TF_SetAttrString (desc, "topology", topology);
			
			if (use_tpu.HasValue)
				c_api.TF_SetAttrBool (desc, "use_tpu", Convert.ToByte(use_tpu.Value));
			
			if (device_assignment != null)
				c_api.TF_SetAttrIntList (desc, "device_assignment", ref device_assignment[0], device_assignment.Length);
			
			if (computation_shape != null)
				c_api.TF_SetAttrIntList (desc, "computation_shape", ref computation_shape[0], computation_shape.Length);
			
			if (host_compute_core != null)
				c_api.TF_SetAttrStringList (desc, "host_compute_core", host_compute_core);
			
			if (padding_map != null)
				c_api.TF_SetAttrStringList (desc, "padding_map", padding_map);
			
			if (step_marker_location != null)
				c_api.TF_SetAttrString (desc, "step_marker_location", step_marker_location);
			
			if (allow_soft_placement.HasValue)
				c_api.TF_SetAttrBool (desc, "allow_soft_placement", Convert.ToByte(allow_soft_placement.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Shuffle dimensions of x according to a permutation.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="perm">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Transpose'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The output <c>y</c> has the same rank as <c>x</c>. The shapes of <c>x</c> and <c>y</c> satisfy:
		///   <c>y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]</c>
		/// </remarks>
		public TF_Output Transpose (TF_Output x, TF_Output perm, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Transpose", MakeName ("Transpose", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, perm);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Calculate product with tridiagonal matrix.
		/// </summary>
		/// <param name="superdiag">
		///   Tensor of shape <c>[..., 1, M]</c>, representing superdiagonals of
		///   tri-diagonal matrices to the left of multiplication. Last element is ingored.
		/// </param>
		/// <param name="maindiag">
		///   Tensor of shape <c>[..., 1, M]</c>, representing main diagonals of tri-diagonal
		///   matrices to the left of multiplication.
		/// </param>
		/// <param name="subdiag">
		///   Tensor of shape <c>[..., 1, M]</c>, representing subdiagonals of tri-diagonal
		///   matrices to the left of multiplication. First element is ingored.
		/// </param>
		/// <param name="rhs">
		///   Tensor of shape <c>[..., M, N]</c>, representing MxN matrices to the right of
		///   multiplication.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TridiagonalMatMul'.
		/// </param>
		/// <returns>
		///   Tensor of shape <c>[..., M, N]</c> containing the product.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Calculates product of two matrices, where left matrix is a tridiagonal matrix.
		/// </remarks>
		public TF_Output TridiagonalMatMul (TF_Output superdiag, TF_Output maindiag, TF_Output subdiag, TF_Output rhs, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TridiagonalMatMul", MakeName ("TridiagonalMatMul", operName));
			c_api.TF_AddInput(desc, superdiag);
			c_api.TF_AddInput(desc, maindiag);
			c_api.TF_AddInput(desc, subdiag);
			c_api.TF_AddInput(desc, rhs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Solves tridiagonal systems of equations.
		/// </summary>
		/// <param name="diagonals">
		///   Tensor of shape <c>[..., 3, M]</c> whose innermost 2 dimensions represent the
		///   tridiagonal matrices with three rows being the superdiagonal, diagonals, and
		///   subdiagonals, in order. The last element of the superdiagonal and the first
		///   element of the subdiagonal is ignored.
		/// </param>
		/// <param name="rhs">
		///   Tensor of shape <c>[..., M, K]</c>, representing K right-hand sides per each
		///   left-hand side.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TridiagonalSolve'.
		/// </param>
		/// <param name="partial_pivoting">
		///   Optional argument
		///   Whether to apply partial pivoting. Partial pivoting makes the procedure more
		///   stable, but slower.
		/// </param>
		/// <returns>
		///   Tensor of shape <c>[..., M, K]</c> containing the solutions
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Solves tridiagonal systems of equations.
		///   Supports batch dimensions and multiple right-hand sides per each left-hand
		///   side.
		///   On CPU, solution is computed via Gaussian elimination with or without partial
		///   pivoting, depending on <c>partial_pivoting</c> attribute. On GPU, Nvidia's cuSPARSE
		///   library is used: https://docs.nvidia.com/cuda/cusparse/index.html#gtsv
		/// </remarks>
		public TF_Output TridiagonalSolve (TF_Output diagonals, TF_Output rhs, bool? partial_pivoting = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TridiagonalSolve", MakeName ("TridiagonalSolve", operName));
			c_api.TF_AddInput(desc, diagonals);
			c_api.TF_AddInput(desc, rhs);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (partial_pivoting.HasValue)
				c_api.TF_SetAttrBool (desc, "partial_pivoting", Convert.ToByte(partial_pivoting.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns x / y element-wise for integer types.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TruncateDiv'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Truncation designates that negative numbers will round fractional quantities
		///   toward zero. I.e. -7 / 5 = -1. This matches C semantics but it is different
		///   than Python semantics. See <c>FloorDiv</c> for a division function that matches
		///   Python Semantics.
		///   
		///   *NOTE*: <c>TruncateDiv</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output TruncateDiv (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TruncateDiv", MakeName ("TruncateDiv", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Outputs random values from a truncated normal distribution.
		/// </summary>
		/// <param name="shape">
		///   The shape of the output tensor.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TruncatedNormal'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either <c>seed</c> or <c>seed2</c> are set to be non-zero, the random number
		///   generator is seeded by the given seed.  Otherwise, it is seeded by a
		///   random seed.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   A second seed to avoid seed collision.
		/// </param>
		/// <param name="dtype">
		///   The type of the output.
		/// </param>
		/// <returns>
		///   A tensor of the specified shape filled with random truncated normal
		///   values.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The generated values follow a normal distribution with mean 0 and standard
		///   deviation 1, except that values whose magnitude is more than 2 standard
		///   deviations from the mean are dropped and re-picked.
		/// </remarks>
		public TF_Output TruncatedNormal (TF_Output shape, TF_DataType dtype, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TruncatedNormal", MakeName ("TruncatedNormal", operName));
			c_api.TF_AddInput(desc, shape);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Returns element-wise remainder of division. This emulates C semantics in that
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TruncateMod'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   the result here is consistent with a truncating divide. E.g. <c>truncate(x / y) *
		///   y + truncate_mod(x, y) = x</c>.
		///   
		///   *NOTE*: <c>TruncateMod</c> supports broadcasting. More about broadcasting
		///   [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
		/// </remarks>
		public TF_Output TruncateMod (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TruncateMod", MakeName ("TruncateMod", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Perform batches of RPC requests.
		/// </summary>
		/// <param name="address">
		///   <c>0-D</c> or <c>1-D</c>.  The address (i.e. host_name:port) of the RPC server.
		///   If this tensor has more than 1 element, then multiple parallel rpc requests
		///   are sent.  This argument broadcasts with <c>method</c> and <c>request</c>.
		/// </param>
		/// <param name="method">
		///   <c>0-D</c> or <c>1-D</c>.  The method address on the RPC server.
		///   If this tensor has more than 1 element, then multiple parallel rpc requests
		///   are sent.  This argument broadcasts with <c>address</c> and <c>request</c>.
		/// </param>
		/// <param name="request">
		///   <c>0-D</c> or <c>1-D</c>.  Serialized proto strings: the rpc request argument.
		///   If this tensor has more than 1 element, then multiple parallel rpc requests
		///   are sent.  This argument broadcasts with <c>address</c> and <c>method</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'TryRpc'.
		/// </param>
		/// <param name="protocol">
		///   Optional argument
		///   RPC protocol to use.  Empty string means use the default protocol.
		///   Options include 'grpc'.
		/// </param>
		/// <param name="fail_fast">
		///   Optional argument
		///   <c>boolean</c>. If <c>true</c> (default), then failures to connect
		///   (i.e., the server does not immediately respond) cause an RPC failure.
		/// </param>
		/// <param name="timeout_in_ms">
		///   Optional argument
		///   <c>int</c>. If <c>0</c> (default), then the kernel will run the RPC
		///   request and only time out if the RPC deadline passes or the session times out.
		///   If this value is greater than <c>0</c>, then the op will raise an exception if
		///   the RPC takes longer than <c>timeout_in_ms</c>.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   response: Same shape as <c>request</c>. Serialized proto strings: the rpc responses.
		///   status_code: Same shape as <c>request</c>.  Values correspond to tensorflow Status enum codes.
		///   status_message: Same shape as <c>request</c>.  Values correspond to Status messages
		///   returned from the RPC calls.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   This op asynchronously performs either a single RPC request, or a batch
		///   of requests.  RPC requests are defined by three main parameters:
		///   
		///   - <c>address</c> (the host+port or BNS address of the request)
		///   - <c>method</c> (the method name for the request)
		///   - <c>request</c> (the serialized proto string, or vector of strings,
		///   of the RPC request argument).
		///   
		///   For example, if you have an RPC service running on port localhost:2345,
		///   and its interface is configured with the following proto declaration:
		///   
		///    <code>
		///   service MyService {
		///   rpc MyMethod(MyRequestProto) returns (MyResponseProto) {
		///   }
		///   };
		///    </code>
		///   
		///   then call this op with arguments:
		///   
		///    <code>
		///   address = "localhost:2345"
		///   method = "MyService/MyMethod"
		///    </code>
		///   
		///   The <c>request</c> tensor is a string tensor representing serialized <c>MyRequestProto</c>
		///   strings; and the output string tensor <c>response</c> will have the same shape
		///   and contain (upon successful completion) corresponding serialized
		///   <c>MyResponseProto</c> strings.
		///   
		///   For example, to send a single, empty, <c>MyRequestProto</c>, call
		///   this op with <c>request = ""</c>.  To send 5 **parallel** empty requests,
		///   call this op with <c>request = ["", "", "", "", ""]</c>.
		///   
		///   More generally, one can create a batch of <c>MyRequestProto</c> serialized protos
		///   from regular batched tensors using the <c>encode_proto</c> op, and convert
		///   the response <c>MyResponseProto</c> serialized protos to batched tensors
		///   using the <c>decode_proto</c> op.
		///   
		///   **NOTE** Working with serialized proto strings is faster than instantiating
		///   actual proto objects in memory, so no performance degradation is expected
		///   compared to writing custom kernels for this workflow.
		///   
		///   Unlike the standard <c>Rpc</c> op, if the connection fails or the remote worker
		///   returns an error status, this op does **not** reraise the exception.
		///   Instead, the <c>status_code</c> and <c>status_message</c> entry for the corresponding RPC
		///   call is set with the error returned from the RPC call.  The <c>response</c> tensor
		///   will contain valid response values for those minibatch entries whose RPCs did
		///   not fail; the rest of the entries will have empty strings.
		/// </remarks>
		public (TF_Output response, TF_Output status_code, TF_Output status_message) TryRpc (TF_Output address, TF_Output method, TF_Output request, string protocol = null, bool? fail_fast = null, long? timeout_in_ms = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "TryRpc", MakeName ("TryRpc", operName));
			c_api.TF_AddInput(desc, address);
			c_api.TF_AddInput(desc, method);
			c_api.TF_AddInput(desc, request);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (protocol != null)
				c_api.TF_SetAttrString (desc, "protocol", protocol);
			
			if (fail_fast.HasValue)
				c_api.TF_SetAttrBool (desc, "fail_fast", Convert.ToByte(fail_fast.Value));
			
			if (timeout_in_ms.HasValue)
				c_api.TF_SetAttrInt (desc, "timeout_in_ms", timeout_in_ms.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var response = new TF_Output (op, _idx++);
			var status_code = new TF_Output (op, _idx++);
			var status_message = new TF_Output (op, _idx++);
			return (response, status_code, status_message);
		}

		/// <summary>
		///   Reverses the operation of Batch for a single output Tensor.
		/// </summary>
		/// <param name="batched_tensor">
		/// </param>
		/// <param name="batch_index">
		/// </param>
		/// <param name="id">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Unbatch'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="timeout_micros">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   An instance of Unbatch either receives an empty batched_tensor, in which case it
		///   asynchronously waits until the values become available from a concurrently
		///   running instance of Unbatch with the same container and shared_name, or receives
		///   a non-empty batched_tensor in which case it finalizes all other concurrently
		///   running instances and outputs its own element from the batch.
		///   
		///   batched_tensor: The possibly transformed output of Batch. The size of the first
		///   dimension should remain unchanged by the transformations for the operation to
		///   work.
		///   batch_index: The matching batch_index obtained from Batch.
		///   id: The id scalar emitted by Batch.
		///   unbatched_tensor: The Tensor corresponding to this execution.
		///   timeout_micros: Maximum amount of time (in microseconds) to wait to receive the
		///   batched input tensor associated with a given invocation of the op.
		///   container: Container to control resource sharing.
		///   shared_name: Instances of Unbatch with the same container and shared_name are
		///   assumed to possibly belong to the same batch. If left empty, the op name will
		///   be used as the shared name.
		/// </remarks>
		public TF_Output Unbatch (TF_Output batched_tensor, TF_Output batch_index, TF_Output id, long timeout_micros, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Unbatch", MakeName ("Unbatch", operName));
			c_api.TF_AddInput(desc, batched_tensor);
			c_api.TF_AddInput(desc, batch_index);
			c_api.TF_AddInput(desc, id);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "timeout_micros", timeout_micros);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var unbatched_tensor = new TF_Output (op, _idx++);
			return unbatched_tensor;
		}

		/// <summary>
		///   A dataset that splits the elements of its input into multiple elements.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnbatchDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output UnbatchDataset (TF_Output input_dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnbatchDataset", MakeName ("UnbatchDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Gradient of Unbatch.
		/// </summary>
		/// <param name="original_input">
		/// </param>
		/// <param name="batch_index">
		/// </param>
		/// <param name="grad">
		/// </param>
		/// <param name="id">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnbatchGrad'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Acts like Batch but using the given batch_index index of batching things as they
		///   become available. This ensures that the gradients are propagated back in the
		///   same session which did the forward pass.
		///   
		///   original_input: The input to the Unbatch operation this is the gradient of.
		///   batch_index: The batch_index given to the Unbatch operation this is the gradient
		///   of.
		///   grad: The downstream gradient.
		///   id: The id scalar emitted by Batch.
		///   batched_grad: The return value, either an empty tensor or the batched gradient.
		///   container: Container to control resource sharing.
		///   shared_name: Instances of UnbatchGrad with the same container and shared_name
		///   are assumed to possibly belong to the same batch. If left empty, the op name
		///   will be used as the shared name.
		/// </remarks>
		public TF_Output UnbatchGrad (TF_Output original_input, TF_Output batch_index, TF_Output grad, TF_Output id, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnbatchGrad", MakeName ("UnbatchGrad", operName));
			c_api.TF_AddInput(desc, original_input);
			c_api.TF_AddInput(desc, batch_index);
			c_api.TF_AddInput(desc, grad);
			c_api.TF_AddInput(desc, id);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var batched_grad = new TF_Output (op, _idx++);
			return batched_grad;
		}

		/// <summary>
		///   Decodes each string in <c>input</c> into a sequence of Unicode code points.
		/// </summary>
		/// <param name="input">
		///   The text to be decoded. Can have any shape. Note that the output is flattened
		///   to a vector of char values.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnicodeDecode'.
		/// </param>
		/// <param name="errors">
		///   Optional argument
		///   Error handling policy when there is invalid formatting found in the input.
		///   The value of 'strict' will cause the operation to produce a InvalidArgument
		///   error on any invalid input formatting. A value of 'replace' (the default) will
		///   cause the operation to replace any invalid formatting in the input with the
		///   <c>replacement_char</c> codepoint. A value of 'ignore' will cause the operation to
		///   skip any invalid formatting in the input and produce no corresponding output
		///   character.
		/// </param>
		/// <param name="replacement_char">
		///   Optional argument
		///   The replacement character codepoint to be used in place of any invalid
		///   formatting in the input when <c>errors='replace'</c>. Any valid unicode codepoint may
		///   be used. The default value is the default unicode replacement character is
		///   0xFFFD or U+65533.)
		/// </param>
		/// <param name="replace_control_characters">
		///   Optional argument
		///   Whether to replace the C0 control characters (00-1F) with the
		///   <c>replacement_char</c>. Default is false.
		/// </param>
		/// <param name="Tsplits">
		///   Optional argument
		/// </param>
		/// <param name="input_encoding">
		///   Text encoding of the input strings. This is any of the encodings supported
		///   by ICU ucnv algorithmic converters. Examples: <c>"UTF-16", "US ASCII", "UTF-8"</c>.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   row_splits: A 1D int32 tensor containing the row splits.
		///   char_values: A 1D int32 Tensor containing the decoded codepoints.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The character codepoints for all strings are returned using a single vector
		///   <c>char_values</c>, with strings expanded to characters in row-major order.
		///   
		///   The <c>row_splits</c> tensor indicates where the codepoints for
		///   each input string begin and end within the <c>char_values</c> tensor.
		///   In particular, the values for the <c>i</c>th
		///   string (in row-major order) are stored in the slice
		///   <c>[row_splits[i]:row_splits[i+1]]</c>. Thus:
		///   
		///   * <c>char_values[row_splits[i]+j]</c> is the Unicode codepoint for the <c>j</c>th
		///   character in the <c>i</c>th string (in row-major order).
		///   * <c>row_splits[i+1] - row_splits[i]</c> is the number of characters in the <c>i</c>th
		///   string (in row-major order).
		/// </remarks>
		public (TF_Output row_splits, TF_Output char_values) UnicodeDecode (TF_Output input, string input_encoding, string errors = null, long? replacement_char = null, bool? replace_control_characters = null, TF_DataType? Tsplits = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnicodeDecode", MakeName ("UnicodeDecode", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "input_encoding", input_encoding);
			if (errors != null)
				c_api.TF_SetAttrString (desc, "errors", errors);
			
			if (replacement_char.HasValue)
				c_api.TF_SetAttrInt (desc, "replacement_char", replacement_char.Value);
			
			if (replace_control_characters.HasValue)
				c_api.TF_SetAttrBool (desc, "replace_control_characters", Convert.ToByte(replace_control_characters.Value));
			
			if (Tsplits.HasValue)
				c_api.TF_SetAttrType (desc, "Tsplits", Tsplits.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var row_splits = new TF_Output (op, _idx++);
			var char_values = new TF_Output (op, _idx++);
			return (row_splits, char_values);
		}

		/// <summary>
		///   Decodes each string in <c>input</c> into a sequence of Unicode code points.
		/// </summary>
		/// <param name="input">
		///   The text to be decoded. Can have any shape. Note that the output is flattened
		///   to a vector of char values.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnicodeDecodeWithOffsets'.
		/// </param>
		/// <param name="errors">
		///   Optional argument
		///   Error handling policy when there is invalid formatting found in the input.
		///   The value of 'strict' will cause the operation to produce a InvalidArgument
		///   error on any invalid input formatting. A value of 'replace' (the default) will
		///   cause the operation to replace any invalid formatting in the input with the
		///   <c>replacement_char</c> codepoint. A value of 'ignore' will cause the operation to
		///   skip any invalid formatting in the input and produce no corresponding output
		///   character.
		/// </param>
		/// <param name="replacement_char">
		///   Optional argument
		///   The replacement character codepoint to be used in place of any invalid
		///   formatting in the input when <c>errors='replace'</c>. Any valid unicode codepoint may
		///   be used. The default value is the default unicode replacement character is
		///   0xFFFD or U+65533.)
		/// </param>
		/// <param name="replace_control_characters">
		///   Optional argument
		///   Whether to replace the C0 control characters (00-1F) with the
		///   <c>replacement_char</c>. Default is false.
		/// </param>
		/// <param name="Tsplits">
		///   Optional argument
		/// </param>
		/// <param name="input_encoding">
		///   Text encoding of the input strings. This is any of the encodings supported
		///   by ICU ucnv algorithmic converters. Examples: <c>"UTF-16", "US ASCII", "UTF-8"</c>.
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   row_splits: A 1D int32 tensor containing the row splits.
		///   char_values: A 1D int32 Tensor containing the decoded codepoints.
		///   char_to_byte_starts: A 1D int32 Tensor containing the byte index in the input string where each
		///   character in <c>char_values</c> starts.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   The character codepoints for all strings are returned using a single vector
		///   <c>char_values</c>, with strings expanded to characters in row-major order.
		///   Similarly, the character start byte offsets are returned using a single vector
		///   <c>char_to_byte_starts</c>, with strings expanded in row-major order.
		///   
		///   The <c>row_splits</c> tensor indicates where the codepoints and start offsets for
		///   each input string begin and end within the <c>char_values</c> and
		///   <c>char_to_byte_starts</c> tensors.  In particular, the values for the <c>i</c>th
		///   string (in row-major order) are stored in the slice
		///   <c>[row_splits[i]:row_splits[i+1]]</c>. Thus:
		///   
		///   * <c>char_values[row_splits[i]+j]</c> is the Unicode codepoint for the <c>j</c>th
		///   character in the <c>i</c>th string (in row-major order).
		///   * <c>char_to_bytes_starts[row_splits[i]+j]</c> is the start byte offset for the <c>j</c>th
		///   character in the <c>i</c>th string (in row-major order).
		///   * <c>row_splits[i+1] - row_splits[i]</c> is the number of characters in the <c>i</c>th
		///   string (in row-major order).
		/// </remarks>
		public (TF_Output row_splits, TF_Output char_values, TF_Output char_to_byte_starts) UnicodeDecodeWithOffsets (TF_Output input, string input_encoding, string errors = null, long? replacement_char = null, bool? replace_control_characters = null, TF_DataType? Tsplits = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnicodeDecodeWithOffsets", MakeName ("UnicodeDecodeWithOffsets", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "input_encoding", input_encoding);
			if (errors != null)
				c_api.TF_SetAttrString (desc, "errors", errors);
			
			if (replacement_char.HasValue)
				c_api.TF_SetAttrInt (desc, "replacement_char", replacement_char.Value);
			
			if (replace_control_characters.HasValue)
				c_api.TF_SetAttrBool (desc, "replace_control_characters", Convert.ToByte(replace_control_characters.Value));
			
			if (Tsplits.HasValue)
				c_api.TF_SetAttrType (desc, "Tsplits", Tsplits.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var row_splits = new TF_Output (op, _idx++);
			var char_values = new TF_Output (op, _idx++);
			var char_to_byte_starts = new TF_Output (op, _idx++);
			return (row_splits, char_values, char_to_byte_starts);
		}

		/// <summary>
		///   Encode a tensor of ints into unicode strings.
		/// </summary>
		/// <param name="input_values">
		///   A 1D tensor containing the unicode codepoints that should be encoded.
		/// </param>
		/// <param name="input_splits">
		///   A 1D tensor specifying how the unicode codepoints should be split into strings.
		///   In particular, <c>output[i]</c> is constructed by encoding the codepoints in the
		///   slice <c>input_values[input_splits[i]:input_splits[i+1]]</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnicodeEncode'.
		/// </param>
		/// <param name="errors">
		///   Optional argument
		///   Error handling policy when there is invalid formatting found in the input.
		///   The value of 'strict' will cause the operation to produce a InvalidArgument
		///   error on any invalid input formatting. A value of 'replace' (the default) will
		///   cause the operation to replace any invalid formatting in the input with the
		///   <c>replacement_char</c> codepoint. A value of 'ignore' will cause the operation to
		///   skip any invalid formatting in the input and produce no corresponding output
		///   character.
		/// </param>
		/// <param name="replacement_char">
		///   Optional argument
		///   The replacement character codepoint to be used in place of any invalid
		///   formatting in the input when <c>errors='replace'</c>. Any valid unicode codepoint may
		///   be used. The default value is the default unicode replacement character is
		///   0xFFFD (U+65533).
		/// </param>
		/// <param name="output_encoding">
		///   Unicode encoding of the output strings. Valid encodings are: <c>"UTF-8",
		///   "UTF-16-BE", and "UTF-32-BE"</c>.
		/// </param>
		/// <returns>
		///   The 1-D Tensor of strings encoded from the provided unicode codepoints.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Returns a vector of strings, where <c>output[i]</c> is constructed by encoding the
		///   Unicode codepoints in <c>input_values[input_splits[i]:input_splits[i+1]]</c>
		///   using <c>output_encoding</c>.
		///   
		///   ---
		///   
		///   Example:
		///   
		///    <code>
		///   input_values = [72, 101, 108, 108, 111, 87, 111, 114, 108, 100]
		///   input_splits = [0, 5, 10]
		///   output_encoding = 'UTF-8'
		///   
		///   output = ['Hello', 'World']
		///    </code>
		/// </remarks>
		public TF_Output UnicodeEncode (TF_Output input_values, TF_Output input_splits, string output_encoding, string errors = null, long? replacement_char = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnicodeEncode", MakeName ("UnicodeEncode", operName));
			c_api.TF_AddInput(desc, input_values);
			c_api.TF_AddInput(desc, input_splits);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "output_encoding", output_encoding);
			if (errors != null)
				c_api.TF_SetAttrString (desc, "errors", errors);
			
			if (replacement_char.HasValue)
				c_api.TF_SetAttrInt (desc, "replacement_char", replacement_char.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Determine the script codes of a given tensor of Unicode integer code points.
		/// </summary>
		/// <param name="input">
		///   A Tensor of int32 Unicode code points.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnicodeScript'.
		/// </param>
		/// <returns>
		///   A Tensor of int32 script codes corresponding to each input code point.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation converts Unicode code points to script codes corresponding to
		///   each code point. Script codes correspond to International Components for
		///   Unicode (ICU) UScriptCode values. See http://icu-project.org/apiref/icu4c/uscript_8h.html.
		///   Returns -1 (USCRIPT_INVALID_CODE) for invalid codepoints. Output shape will
		///   match input shape.
		/// </remarks>
		public TF_Output UnicodeScript (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnicodeScript", MakeName ("UnicodeScript", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Transcode the input text from a source encoding to a destination encoding.
		/// </summary>
		/// <param name="input">
		///   The text to be processed. Can have any shape.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnicodeTranscode'.
		/// </param>
		/// <param name="errors">
		///   Optional argument
		///   Error handling policy when there is invalid formatting found in the input.
		///   The value of 'strict' will cause the operation to produce a InvalidArgument
		///   error on any invalid input formatting. A value of 'replace' (the default) will
		///   cause the operation to replace any invalid formatting in the input with the
		///   <c>replacement_char</c> codepoint. A value of 'ignore' will cause the operation to
		///   skip any invalid formatting in the input and produce no corresponding output
		///   character.
		/// </param>
		/// <param name="replacement_char">
		///   Optional argument
		///   The replacement character codepoint to be used in place of any invalid
		///   formatting in the input when <c>errors='replace'</c>. Any valid unicode codepoint may
		///   be used. The default value is the default unicode replacement character is
		///   0xFFFD or U+65533.)
		///   
		///   Note that for UTF-8, passing a replacement character expressible in 1 byte, such
		///   as ' ', will preserve string alignment to the source since invalid bytes will be
		///   replaced with a 1-byte replacement. For UTF-16-BE and UTF-16-LE, any 1 or 2 byte
		///   replacement character will preserve byte alignment to the source.
		/// </param>
		/// <param name="replace_control_characters">
		///   Optional argument
		///   Whether to replace the C0 control characters (00-1F) with the
		///   <c>replacement_char</c>. Default is false.
		/// </param>
		/// <param name="input_encoding">
		///   Text encoding of the input strings. This is any of the encodings supported
		///   by ICU ucnv algorithmic converters. Examples: <c>"UTF-16", "US ASCII", "UTF-8"</c>.
		/// </param>
		/// <param name="output_encoding">
		///   The unicode encoding to use in the output. Must be one of
		///   <c>"UTF-8", "UTF-16-BE", "UTF-32-BE"</c>. Multi-byte encodings will be big-endian.
		/// </param>
		/// <returns>
		///   A string tensor containing unicode text encoded using <c>output_encoding</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The input is a string tensor of any shape. The output is a string tensor of
		///   the same shape containing the transcoded strings. Output strings are always
		///   valid unicode. If the input contains invalid encoding positions, the
		///   <c>errors</c> attribute sets the policy for how to deal with them. If the default
		///   error-handling policy is used, invalid formatting will be substituted in the
		///   output by the <c>replacement_char</c>. If the errors policy is to <c>ignore</c>, any
		///   invalid encoding positions in the input are skipped and not included in the
		///   output. If it set to <c>strict</c> then any invalid formatting will result in an
		///   InvalidArgument error.
		///   
		///   This operation can be used with <c>output_encoding = input_encoding</c> to enforce
		///   correct formatting for inputs even if they are already in the desired encoding.
		///   
		///   If the input is prefixed by a Byte Order Mark needed to determine encoding
		///   (e.g. if the encoding is UTF-16 and the BOM indicates big-endian), then that
		///   BOM will be consumed and not emitted into the output. If the input encoding
		///   is marked with an explicit endianness (e.g. UTF-16-BE), then the BOM is
		///   interpreted as a non-breaking-space and is preserved in the output (including
		///   always for UTF-8).
		///   
		///   The end result is that if the input is marked as an explicit endianness the
		///   transcoding is faithful to all codepoints in the source. If it is not marked
		///   with an explicit endianness, the BOM is not considered part of the string itself
		///   but as metadata, and so is not preserved in the output.
		/// </remarks>
		public TF_Output UnicodeTranscode (TF_Output input, string input_encoding, string output_encoding, string errors = null, long? replacement_char = null, bool? replace_control_characters = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnicodeTranscode", MakeName ("UnicodeTranscode", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrString (desc, "input_encoding", input_encoding);
			c_api.TF_SetAttrString (desc, "output_encoding", output_encoding);
			if (errors != null)
				c_api.TF_SetAttrString (desc, "errors", errors);
			
			if (replacement_char.HasValue)
				c_api.TF_SetAttrInt (desc, "replacement_char", replacement_char.Value);
			
			if (replace_control_characters.HasValue)
				c_api.TF_SetAttrBool (desc, "replace_control_characters", Convert.ToByte(replace_control_characters.Value));
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Generates labels for candidate sampling with a uniform distribution.
		/// </summary>
		/// <param name="true_classes">
		///   A batch_size * num_true matrix, in which each row contains the
		///   IDs of the num_true target_classes in the corresponding original label.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UniformCandidateSampler'.
		/// </param>
		/// <param name="seed">
		///   Optional argument
		///   If either seed or seed2 are set to be non-zero, the random number
		///   generator is seeded by the given seed.  Otherwise, it is seeded by a
		///   random seed.
		/// </param>
		/// <param name="seed2">
		///   Optional argument
		///   An second seed to avoid seed collision.
		/// </param>
		/// <param name="num_true">
		///   Number of true labels per context.
		/// </param>
		/// <param name="num_sampled">
		///   Number of candidates to randomly sample.
		/// </param>
		/// <param name="unique">
		///   If unique is true, we sample with rejection, so that all sampled
		///   candidates in a batch are unique. This requires some approximation to
		///   estimate the post-rejection sampling probabilities.
		/// </param>
		/// <param name="range_max">
		///   The sampler will sample integers from the interval [0, range_max).
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   sampled_candidates: A vector of length num_sampled, in which each element is
		///   the ID of a sampled candidate.
		///   true_expected_count: A batch_size * num_true matrix, representing
		///   the number of times each candidate is expected to occur in a batch
		///   of sampled candidates. If unique=true, then this is a probability.
		///   sampled_expected_count: A vector of length num_sampled, for each sampled
		///   candidate representing the number of times the candidate is expected
		///   to occur in a batch of sampled candidates.  If unique=true, then this is a
		///   probability.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   See explanations of candidate sampling and the data formats at
		///   go/candidate-sampling.
		///   
		///   For each batch, this op picks a single set of sampled candidate labels.
		///   
		///   The advantages of sampling candidates per-batch are simplicity and the
		///   possibility of efficient dense matrix multiplication. The disadvantage is that
		///   the sampled candidates must be chosen independently of the context and of the
		///   true labels.
		/// </remarks>
		public (TF_Output sampled_candidates, TF_Output true_expected_count, TF_Output sampled_expected_count) UniformCandidateSampler (TF_Output true_classes, long num_true, long num_sampled, bool unique, long range_max, long? seed = null, long? seed2 = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UniformCandidateSampler", MakeName ("UniformCandidateSampler", operName));
			c_api.TF_AddInput(desc, true_classes);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num_true", num_true);
			c_api.TF_SetAttrInt (desc, "num_sampled", num_sampled);
			c_api.TF_SetAttrBool (desc, "unique", Convert.ToByte(unique));
			c_api.TF_SetAttrInt (desc, "range_max", range_max);
			if (seed.HasValue)
				c_api.TF_SetAttrInt (desc, "seed", seed.Value);
			
			if (seed2.HasValue)
				c_api.TF_SetAttrInt (desc, "seed2", seed2.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var sampled_candidates = new TF_Output (op, _idx++);
			var true_expected_count = new TF_Output (op, _idx++);
			var sampled_expected_count = new TF_Output (op, _idx++);
			return (sampled_candidates, true_expected_count, sampled_expected_count);
		}

		/// <summary>
		///   Finds unique elements in a 1-D tensor.
		/// </summary>
		/// <param name="x">
		///   1-D.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Unique'.
		/// </param>
		/// <param name="out_idx">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   y: 1-D.
		///   idx: 1-D.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   This operation returns a tensor <c>y</c> containing all of the unique elements of <c>x</c>
		///   sorted in the same order that they occur in <c>x</c>. This operation also returns a
		///   tensor <c>idx</c> the same size as <c>x</c> that contains the index of each value of <c>x</c>
		///   in the unique output <c>y</c>. In other words:
		///   
		///   <c>y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]</c>
		///   
		///   For example:
		///   
		///    <code>
		///   # tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]
		///   y, idx = unique(x)
		///   y ==&amp;gt; [1, 2, 4, 7, 8]
		///   idx ==&amp;gt; [0, 0, 1, 2, 2, 2, 3, 4, 4]
		///    </code>
		/// </remarks>
		public (TF_Output y, TF_Output idx) Unique (TF_Output x, TF_DataType? out_idx = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Unique", MakeName ("Unique", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_idx.HasValue)
				c_api.TF_SetAttrType (desc, "out_idx", out_idx.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			var idx = new TF_Output (op, _idx++);
			return (y, idx);
		}

		/// <summary>
		///   Creates a dataset that contains the unique elements of <c>input_dataset</c>.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UniqueDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output UniqueDataset (TF_Output input_dataset, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UniqueDataset", MakeName ("UniqueDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Finds unique elements along an axis of a tensor.
		/// </summary>
		/// <param name="x">
		///   A <c>Tensor</c>.
		/// </param>
		/// <param name="axis">
		///   A <c>Tensor</c> of type <c>int32</c> (default: None). The axis of the Tensor to
		///   find the unique elements.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UniqueV2'.
		/// </param>
		/// <param name="out_idx">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   y: A <c>Tensor</c>. Unique elements along the <c>axis</c> of <c>Tensor</c> x.
		///   idx: A 1-D Tensor. Has the same type as x that contains the index of each
		///   value of x in the output y.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   This operation either returns a tensor <c>y</c> containing unique elements
		///   along the <c>axis</c> of a tensor. The returned unique elements is sorted
		///   in the same order as they occur along <c>axis</c> in <c>x</c>.
		///   This operation also returns a tensor <c>idx</c> that is the same size as
		///   the number of the elements in <c>x</c> along the <c>axis</c> dimension. It
		///   contains the index in the unique output <c>y</c>.
		///   In other words, for an <c>1-D</c> tensor <c>x</c> with <c>axis = None:
		///   
		///   </c>y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]<c>
		///   
		///   For example:
		///   
		///    <code>
		///   # tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]
		///   y, idx = unique(x)
		///   y ==&amp;gt; [1, 2, 4, 7, 8]
		///   idx ==&amp;gt; [0, 0, 1, 2, 2, 2, 3, 4, 4]
		///    </code>
		///   
		///   For an </c>2-D<c> tensor </c>x<c> with </c>axis = 0<c>:
		///   
		///    <code>
		///   # tensor 'x' is [[1, 0, 0],
		///   #                [1, 0, 0],
		///   #                [2, 0, 0]]
		///   y, idx = unique(x, axis=0)
		///   y ==&amp;gt; [[1, 0, 0],
		///   [2, 0, 0]]
		///   idx ==&amp;gt; [0, 0, 1]
		///    </code>
		///   
		///   For an </c>2-D<c> tensor </c>x<c> with </c>axis = 1<c>:
		///   
		///    <code>
		///   # tensor 'x' is [[1, 0, 0],
		///   #                [1, 0, 0],
		///   #                [2, 0, 0]]
		///   y, idx = unique(x, axis=1)
		///   y ==&amp;gt; [[1, 0],
		///   [1, 0],
		///   [2, 0]]
		///   idx ==&amp;gt; [0, 1, 1]
		///    </code>
		/// </remarks>
		public (TF_Output y, TF_Output idx) UniqueV2 (TF_Output x, TF_Output axis, TF_DataType? out_idx = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UniqueV2", MakeName ("UniqueV2", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, axis);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_idx.HasValue)
				c_api.TF_SetAttrType (desc, "out_idx", out_idx.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			var idx = new TF_Output (op, _idx++);
			return (y, idx);
		}

		/// <summary>
		///   Finds unique elements in a 1-D tensor.
		/// </summary>
		/// <param name="x">
		///   1-D.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UniqueWithCounts'.
		/// </param>
		/// <param name="out_idx">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   y: 1-D.
		///   idx: 1-D.
		///   count: 1-D.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   This operation returns a tensor <c>y</c> containing all of the unique elements of <c>x</c>
		///   sorted in the same order that they occur in <c>x</c>. This operation also returns a
		///   tensor <c>idx</c> the same size as <c>x</c> that contains the index of each value of <c>x</c>
		///   in the unique output <c>y</c>. Finally, it returns a third tensor <c>count</c> that
		///   contains the count of each element of <c>y</c> in <c>x</c>. In other words:
		///   
		///   <c>y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]</c>
		///   
		///   For example:
		///   
		///    <code>
		///   # tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]
		///   y, idx, count = unique_with_counts(x)
		///   y ==&amp;gt; [1, 2, 4, 7, 8]
		///   idx ==&amp;gt; [0, 0, 1, 2, 2, 2, 3, 4, 4]
		///   count ==&amp;gt; [2, 1, 3, 1, 2]
		///    </code>
		/// </remarks>
		public (TF_Output y, TF_Output idx, TF_Output count) UniqueWithCounts (TF_Output x, TF_DataType? out_idx = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UniqueWithCounts", MakeName ("UniqueWithCounts", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_idx.HasValue)
				c_api.TF_SetAttrType (desc, "out_idx", out_idx.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			var idx = new TF_Output (op, _idx++);
			var count = new TF_Output (op, _idx++);
			return (y, idx, count);
		}

		/// <summary>
		///   Finds unique elements along an axis of a tensor.
		/// </summary>
		/// <param name="x">
		///   A <c>Tensor</c>.
		/// </param>
		/// <param name="axis">
		///   A <c>Tensor</c> of type <c>int32</c> (default: None). The axis of the Tensor to
		///   find the unique elements.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UniqueWithCountsV2'.
		/// </param>
		/// <param name="out_idx">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns a tuple with multiple values, as follows:
		///   y: A <c>Tensor</c>. Unique elements along the <c>axis</c> of <c>Tensor</c> x.
		///   idx: A 1-D Tensor. Has the same type as x that contains the index of each
		///   value of x in the output y.
		///   count: A 1-D Tensor. The count of each value of x in the output y.
		///   The TF_Operation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
		/// </returns>
		/// <remarks>
		///   This operation either returns a tensor <c>y</c> containing unique elements
		///   along the <c>axis</c> of a tensor. The returned unique elements is sorted
		///   in the same order as they occur along <c>axis</c> in <c>x</c>.
		///   This operation also returns a tensor <c>idx</c> and a tensor <c>count</c>
		///   that are the same size as the number of the elements in <c>x</c> along the
		///   <c>axis</c> dimension. The <c>idx</c> contains the index in the unique output <c>y</c>
		///   and the <c>count</c> contains the count in the unique output <c>y</c>.
		///   In other words, for an <c>1-D</c> tensor <c>x</c> with <c>axis = None:
		///   
		///   </c>y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]<c>
		///   
		///   For example:
		///   
		///    <code>
		///   # tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]
		///   y, idx, count = unique_with_counts(x)
		///   y ==&amp;gt; [1, 2, 4, 7, 8]
		///   idx ==&amp;gt; [0, 0, 1, 2, 2, 2, 3, 4, 4]
		///   count ==&amp;gt; [2, 1, 3, 1, 2]
		///    </code>
		///   
		///   For an </c>2-D<c> tensor </c>x<c> with </c>axis = 0<c>:
		///   
		///    <code>
		///   # tensor 'x' is [[1, 0, 0],
		///   #                [1, 0, 0],
		///   #                [2, 0, 0]]
		///   y, idx, count = unique_with_counts(x, axis=0)
		///   y ==&amp;gt; [[1, 0, 0],
		///   [2, 0, 0]]
		///   idx ==&amp;gt; [0, 0, 1]
		///   count ==&amp;gt; [2, 1]
		///    </code>
		///   
		///   For an </c>2-D<c> tensor </c>x<c> with </c>axis = 1<c>:
		///   
		///    <code>
		///   # tensor 'x' is [[1, 0, 0],
		///   #                [1, 0, 0],
		///   #                [2, 0, 0]]
		///   y, idx, count = unique_with_counts(x, axis=1)
		///   y ==&amp;gt; [[1, 0],
		///   [1, 0],
		///   [2, 0]]
		///   idx ==&amp;gt; [0, 1, 1]
		///   count ==&amp;gt; [1, 2]
		///    </code>
		/// </remarks>
		public (TF_Output y, TF_Output idx, TF_Output count) UniqueWithCountsV2 (TF_Output x, TF_Output axis, TF_DataType? out_idx = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UniqueWithCountsV2", MakeName ("UniqueWithCountsV2", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, axis);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_idx.HasValue)
				c_api.TF_SetAttrType (desc, "out_idx", out_idx.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			var idx = new TF_Output (op, _idx++);
			var count = new TF_Output (op, _idx++);
			return (y, idx, count);
		}

		/// <summary>
		///   Unpacks a given dimension of a rank-<c>R</c> tensor into <c>num</c> rank-<c>(R-1)</c> tensors.
		/// </summary>
		/// <param name="value">
		///   1-D or higher, with <c>axis</c> dimension size equal to <c>num</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Unpack'.
		/// </param>
		/// <param name="axis">
		///   Optional argument
		///   Dimension along which to unpack.  Negative values wrap around, so the
		///   valid range is <c>[-R, R)</c>.
		/// </param>
		/// <param name="num">
		/// </param>
		/// <returns>
		///   The list of tensors unpacked from <c>value</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Unpacks <c>num</c> tensors from <c>value</c> by chipping it along the <c>axis</c> dimension.
		///   For example, given a tensor of shape <c>(A, B, C, D)</c>;
		///   
		///   If <c>axis == 0</c> then the i'th tensor in <c>output</c> is the slice <c>value[i, :, :, :]</c>
		///   and each tensor in <c>output</c> will have shape <c>(B, C, D)</c>. (Note that the
		///   dimension unpacked along is gone, unlike <c>split</c>).
		///   
		///   If <c>axis == 1</c> then the i'th tensor in <c>output</c> is the slice <c>value[:, i, :, :]</c>
		///   and each tensor in <c>output</c> will have shape <c>(A, C, D)</c>.
		///   Etc.
		///   
		///   This is the opposite of <c>pack</c>.
		/// </remarks>
		public TF_Output[] Unpack (TF_Output value, long num, long? axis = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Unpack", MakeName ("Unpack", operName));
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrInt (desc, "num", num);
			if (axis.HasValue)
				c_api.TF_SetAttrInt (desc, "axis", axis.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		///   Converts a flat index or array of flat indices into a tuple of
		/// </summary>
		/// <param name="indices">
		///   An 0-D or 1-D <c>int</c> Tensor whose elements are indices into the
		///   flattened version of an array of dimensions dims.
		/// </param>
		/// <param name="dims">
		///   An 1-D <c>int</c> Tensor. The shape of the array to use for unraveling
		///   indices.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnravelIndex'.
		/// </param>
		/// <returns>
		///   An 2-D (or 1-D if indices is 0-D) tensor where each row has the
		///   same shape as the indices array.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   coordinate arrays.
		///   
		///   @compatibility(numpy)
		///   Equivalent to np.unravel_index
		///   @end_compatibility
		/// </remarks>
		public TF_Output UnravelIndex (TF_Output indices, TF_Output dims, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnravelIndex", MakeName ("UnravelIndex", operName));
			c_api.TF_AddInput(desc, indices);
			c_api.TF_AddInput(desc, dims);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Joins the elements of <c>inputs</c> based on <c>segment_ids</c>.
		/// </summary>
		/// <param name="inputs">
		///   The input to be joined.
		/// </param>
		/// <param name="segment_ids">
		///   A tensor whose shape is a prefix of data.shape.  Negative segment ids are not
		///   supported.
		/// </param>
		/// <param name="num_segments">
		///   A scalar.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnsortedSegmentJoin'.
		/// </param>
		/// <param name="separator">
		///   Optional argument
		///   The separator to use when joining.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Computes the string join along segments of a tensor.
		///   Given <c>segment_ids</c> with rank <c>N</c> and <c>data</c> with rank <c>N+M</c>:
		///   
		///   <c>output[i, k1...kM] = strings.join([data[j1...jN, k1...kM])</c>
		///   
		///   where the join is over all [j1...jN] such that segment_ids[j1...jN] = i.
		///   Strings are joined in row-major order.
		///   
		///   For example:
		///   
		///    <code>
		///   inputs = [['Y', 'q', 'c'], ['Y', '6', '6'], ['p', 'G', 'a']]
		///   output_array = string_ops.unsorted_segment_join(inputs=inputs,
		///   segment_ids=[1, 0, 1],
		///   num_segments=2,
		///   separator=':'))
		///   # output_array ==&amp;gt; [['Y', '6', '6'], ['Y:p', 'q:G', 'c:a']]
		///   
		///   
		///   inputs = ['this', 'is', 'a', 'test']
		///   output_array = string_ops.unsorted_segment_join(inputs=inputs,
		///   segment_ids=[0, 0, 0, 0],
		///   num_segments=1,
		///   separator=':'))
		///   # output_array ==&amp;gt; ['this:is:a:test']
		///    </code>
		/// </remarks>
		public TF_Output UnsortedSegmentJoin (TF_Output inputs, TF_Output segment_ids, TF_Output num_segments, string separator = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnsortedSegmentJoin", MakeName ("UnsortedSegmentJoin", operName));
			c_api.TF_AddInput(desc, inputs);
			c_api.TF_AddInput(desc, segment_ids);
			c_api.TF_AddInput(desc, num_segments);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (separator != null)
				c_api.TF_SetAttrString (desc, "separator", separator);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the maximum along segments of a tensor.
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="segment_ids">
		///   A tensor whose shape is a prefix of <c>data.shape</c>.
		/// </param>
		/// <param name="num_segments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnsortedSegmentMax'.
		/// </param>
		/// <returns>
		///   Has same shape as data, except for the first <c>segment_ids.rank</c>
		///   dimensions, which are replaced with a single dimension which has size
		///   <c>num_segments</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Read
		///   [the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)
		///   for an explanation of segments.
		///   
		///   This operator is similar to the unsorted segment sum operator found
		///   [(here)](../../../api_docs/python/math_ops.md#UnsortedSegmentSum).
		///   Instead of computing the sum over segments, it computes the maximum such that:
		///   
		///   \\(output_i = \max_{j...} data[j...]\\) where max is over tuples <c>j...</c> such
		///   that <c>segment_ids[j...] == i</c>.
		///   
		///   If the maximum is empty for a given segment ID <c>i</c>, it outputs the smallest
		///   possible value for the specific numeric type,
		///   <c>output[i] = numeric_limits&amp;lt;T&amp;gt;::lowest()</c>.
		///   
		///   If the given segment ID <c>i</c> is negative, then the corresponding value is
		///   dropped, and will not be included in the result.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/UnsortedSegmentMax.png" alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		///   
		///   For example:
		///   
		///    <code>
		///    python
		///   c = tf.constant([[1,2,3,4], [5,6,7,8], [4,3,2,1]])
		///   tf.unsorted_segment_max(c, tf.constant([0, 1, 0]), num_segments=2)
		///   # ==&amp;gt; [[ 4,  3, 3, 4],
		///   #       [5,  6, 7, 8]]
		///    </code>
		///   
		/// </remarks>
		public TF_Output UnsortedSegmentMax (TF_Output data, TF_Output segment_ids, TF_Output num_segments, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnsortedSegmentMax", MakeName ("UnsortedSegmentMax", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, segment_ids);
			c_api.TF_AddInput(desc, num_segments);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the minimum along segments of a tensor.
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="segment_ids">
		///   A tensor whose shape is a prefix of <c>data.shape</c>.
		/// </param>
		/// <param name="num_segments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnsortedSegmentMin'.
		/// </param>
		/// <returns>
		///   Has same shape as data, except for the first <c>segment_ids.rank</c>
		///   dimensions, which are replaced with a single dimension which has size
		///   <c>num_segments</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Read
		///   [the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)
		///   for an explanation of segments.
		///   
		///   This operator is similar to the unsorted segment sum operator found
		///   [(here)](../../../api_docs/python/math_ops.md#UnsortedSegmentSum).
		///   Instead of computing the sum over segments, it computes the minimum such that:
		///   
		///   \\(output_i = \min_{j...} data_[j...]\\) where min is over tuples <c>j...</c> such
		///   that <c>segment_ids[j...] == i</c>.
		///   
		///   If the minimum is empty for a given segment ID <c>i</c>, it outputs the largest
		///   possible value for the specific numeric type,
		///   <c>output[i] = numeric_limits&amp;lt;T&amp;gt;::max()</c>.
		///   
		///   For example:
		///   
		///    <code>
		///    python
		///   c = tf.constant([[1,2,3,4], [5,6,7,8], [4,3,2,1]])
		///   tf.unsorted_segment_min(c, tf.constant([0, 1, 0]), num_segments=2)
		///   # ==&amp;gt; [[ 1,  2, 2, 1],
		///   #       [5,  6, 7, 8]]
		///    </code>
		///   
		///   If the given segment ID <c>i</c> is negative, then the corresponding value is
		///   dropped, and will not be included in the result.
		/// </remarks>
		public TF_Output UnsortedSegmentMin (TF_Output data, TF_Output segment_ids, TF_Output num_segments, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnsortedSegmentMin", MakeName ("UnsortedSegmentMin", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, segment_ids);
			c_api.TF_AddInput(desc, num_segments);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the product along segments of a tensor.
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="segment_ids">
		///   A tensor whose shape is a prefix of <c>data.shape</c>.
		/// </param>
		/// <param name="num_segments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnsortedSegmentProd'.
		/// </param>
		/// <returns>
		///   Has same shape as data, except for the first <c>segment_ids.rank</c>
		///   dimensions, which are replaced with a single dimension which has size
		///   <c>num_segments</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Read
		///   [the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)
		///   for an explanation of segments.
		///   
		///   This operator is similar to the unsorted segment sum operator found
		///   [(here)](../../../api_docs/python/math_ops.md#UnsortedSegmentSum).
		///   Instead of computing the sum over segments, it computes the product of all
		///   entries belonging to a segment such that:
		///   
		///   \\(output_i = \prod_{j...} data[j...]\\) where the product is over tuples
		///   <c>j...</c> such that <c>segment_ids[j...] == i</c>.
		///   
		///   For example:
		///   
		///    <code>
		///    python
		///   c = tf.constant([[1,2,3,4], [5,6,7,8], [4,3,2,1]])
		///   tf.unsorted_segment_prod(c, tf.constant([0, 1, 0]), num_segments=2)
		///   # ==&amp;gt; [[ 4,  6, 6, 4],
		///   #       [5,  6, 7, 8]]
		///    </code>
		///   
		///   If there is no entry for a given segment ID <c>i</c>, it outputs 1.
		///   
		///   If the given segment ID <c>i</c> is negative, then the corresponding value is
		///   dropped, and will not be included in the result.
		/// </remarks>
		public TF_Output UnsortedSegmentProd (TF_Output data, TF_Output segment_ids, TF_Output num_segments, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnsortedSegmentProd", MakeName ("UnsortedSegmentProd", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, segment_ids);
			c_api.TF_AddInput(desc, num_segments);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Computes the sum along segments of a tensor.
		/// </summary>
		/// <param name="data">
		/// </param>
		/// <param name="segment_ids">
		///   A tensor whose shape is a prefix of <c>data.shape</c>.
		/// </param>
		/// <param name="num_segments">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnsortedSegmentSum'.
		/// </param>
		/// <returns>
		///   Has same shape as data, except for the first <c>segment_ids.rank</c>
		///   dimensions, which are replaced with a single dimension which has size
		///   <c>num_segments</c>.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Read
		///   [the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)
		///   for an explanation of segments.
		///   
		///   Computes a tensor such that
		///   \\(output[i] = \sum_{j...} data[j...]\\) where the sum is over tuples <c>j...</c> such
		///   that <c>segment_ids[j...] == i</c>.  Unlike <c>SegmentSum</c>, <c>segment_ids</c>
		///   need not be sorted and need not cover all values in the full
		///   range of valid values.
		///   
		///   If the sum is empty for a given segment ID <c>i</c>, <c>output[i] = 0</c>.
		///   If the given segment ID <c>i</c> is negative, the value is dropped and will not be
		///   added to the sum of the segment.
		///   
		///   <c>num_segments</c> should equal the number of distinct segment IDs.
		///   
		///   &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
		///   &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/UnsortedSegmentSum.png" alt&amp;gt;
		///   &amp;lt;/div&amp;gt;
		///   
		///    <code>
		///    python
		///   c = tf.constant([[1,2,3,4], [5,6,7,8], [4,3,2,1]])
		///   tf.unsorted_segment_sum(c, tf.constant([0, 1, 0]), num_segments=2)
		///   # ==&amp;gt; [[ 5,  5, 5, 5],
		///   #       [5,  6, 7, 8]]
		///    </code>
		///   
		/// </remarks>
		public TF_Output UnsortedSegmentSum (TF_Output data, TF_Output segment_ids, TF_Output num_segments, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnsortedSegmentSum", MakeName ("UnsortedSegmentSum", operName));
			c_api.TF_AddInput(desc, data);
			c_api.TF_AddInput(desc, segment_ids);
			c_api.TF_AddInput(desc, num_segments);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Op is similar to a lightweight Dequeue.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Unstage'.
		/// </param>
		/// <param name="capacity">
		///   Optional argument
		/// </param>
		/// <param name="memory_limit">
		///   Optional argument
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="dtypes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The basic functionality is similar to dequeue with many fewer
		///   capabilities and options.  This Op is optimized for performance.
		/// </remarks>
		public TF_Output[] Unstage (TF_DataType[] dtypes, long? capacity = null, long? memory_limit = null, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Unstage", MakeName ("Unstage", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "dtypes", dtypes);
			if (capacity.HasValue)
				c_api.TF_SetAttrInt (desc, "capacity", capacity.Value);
			
			if (memory_limit.HasValue)
				c_api.TF_SetAttrInt (desc, "memory_limit", memory_limit.Value);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "values", status);
			var values = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				values [i] = new TF_Output (op, _idx++);
			
			return values;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UnwrapDatasetVariant'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output UnwrapDatasetVariant (TF_Output input_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UnwrapDatasetVariant", MakeName ("UnwrapDatasetVariant", operName));
			c_api.TF_AddInput(desc, input_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			return output_handle;
		}

		/// <summary>
		///   Applies upper_bound(sorted_search_values, values) along each row.
		/// </summary>
		/// <param name="sorted_inputs">
		///   2-D Tensor where each row is ordered.
		/// </param>
		/// <param name="values">
		///   2-D Tensor with the same numbers of rows as <c>sorted_search_values</c>. Contains
		///   the values that will be searched for in <c>sorted_search_values</c>.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'UpperBound'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   A <c>Tensor</c> with the same shape as <c>values</c>.  It contains the last scalar index
		///   into the last dimension where values can be inserted without changing the
		///   ordered property.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Each set of rows with the same index in (sorted_inputs, values) is treated
		///   independently.  The resulting row is the equivalent of calling
		///   <c>np.searchsorted(sorted_inputs, values, side='right')</c>.
		///   
		///   The result is not a global index to the entire
		///   <c>Tensor</c>, but rather just the index in the last dimension.
		///   
		///   A 2-D example:
		///   sorted_sequence = [[0, 3, 9, 9, 10],
		///   [1, 2, 3, 4, 5]]
		///   values = [[2, 4, 9],
		///   [0, 2, 6]]
		///   
		///   result = UpperBound(sorted_sequence, values)
		///   
		///   result == [[1, 2, 4],
		///   [0, 2, 5]]
		/// </remarks>
		public TF_Output UpperBound (TF_Output sorted_inputs, TF_Output values, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "UpperBound", MakeName ("UpperBound", operName));
			c_api.TF_AddInput(desc, sorted_inputs);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Creates a handle to a Variable resource.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'VarHandleOp'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   the container this variable is placed in.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   the name by which this variable is referred to.
		/// </param>
		/// <param name="dtype">
		///   the type of this variable. Must agree with the dtypes
		///   of all ops using this variable.
		/// </param>
		/// <param name="shape">
		///   The (possibly partially specified) shape of this variable.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output VarHandleOp (TF_DataType dtype, long[] shape, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "VarHandleOp", MakeName ("VarHandleOp", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var resource = new TF_Output (op, _idx++);
			return resource;
		}

		/// <summary>
		///   Use VariableV2 instead.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Variable'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		/// </param>
		/// <param name="shape">
		/// </param>
		/// <param name="dtype">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Variable (long[] shape, TF_DataType dtype, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Variable", MakeName ("Variable", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var reference = new TF_Output (op, _idx++);
			return reference;
		}

		/// <summary>
		///   Returns the shape of the variable pointed to by <c>resource</c>.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'VariableShape'.
		/// </param>
		/// <param name="out_type">
		///   Optional argument
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation returns a 1-D integer tensor representing the shape of <c>input</c>.
		///   
		///   For example:
		///   
		///    <code>
		///   # 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]
		///   shape(t) ==&amp;gt; [2, 2, 3]
		///    </code>
		/// </remarks>
		public TF_Output VariableShape (TF_Output input, TF_DataType? out_type = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "VariableShape", MakeName ("VariableShape", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (out_type.HasValue)
				c_api.TF_SetAttrType (desc, "out_type", out_type.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output = new TF_Output (op, _idx++);
			return output;
		}

		/// <summary>
		///   Holds state in the form of a tensor that persists across steps.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'VariableV2'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this variable is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this variable is named in the given bucket
		///   with this shared_name. Otherwise, the node name is used instead.
		/// </param>
		/// <param name="shape">
		///   The shape of the variable tensor.
		/// </param>
		/// <param name="dtype">
		///   The type of elements in the variable tensor.
		/// </param>
		/// <returns>
		///   A reference to the variable tensor.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Outputs a ref to the tensor state so it may be read or modified.
		///   TODO(zhifengc/mrry): Adds a pointer to a more detail document
		///   about sharing states in tensorflow.
		/// </remarks>
		public TF_Output VariableV2 (long[] shape, TF_DataType dtype, string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "VariableV2", MakeName ("VariableV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrShape (desc, "shape", ref shape[0], shape.Length);
			c_api.TF_SetAttrType (desc, "dtype", dtype);
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var reference = new TF_Output (op, _idx++);
			return reference;
		}

		/// <summary>
		///   Checks whether a resource handle-based variable has been initialized.
		/// </summary>
		/// <param name="resource">
		///   the input resource handle.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'VarIsInitializedOp'.
		/// </param>
		/// <returns>
		///   a scalar boolean which is true if the variable has been
		///   initialized.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output VarIsInitializedOp (TF_Output resource, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "VarIsInitializedOp", MakeName ("VarIsInitializedOp", operName));
			c_api.TF_AddInput(desc, resource);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var is_initialized = new TF_Output (op, _idx++);
			return is_initialized;
		}

		/// <summary>
		///   Returns locations of nonzero / true values in a tensor.
		/// </summary>
		/// <param name="input">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Where'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   This operation returns the coordinates of true elements in <c>condition</c>. The
		///   coordinates are returned in a 2-D tensor where the first dimension (rows)
		///   represents the number of true elements, and the second dimension (columns)
		///   represents the coordinates of the true elements. Keep in mind, the shape of
		///   the output tensor can vary depending on how many true values there are in
		///   <c>condition</c>. Indices are output in row-major order.
		///   
		///   For example:
		///   
		///    <code>
		///   # 'input' tensor is [[True, False]
		///   #                    [True, False]]
		///   # 'input' has two true values, so output has two coordinates.
		///   # 'input' has rank of 2, so coordinates have two indices.
		///   where(input) ==&amp;gt; [[0, 0],
		///   [1, 0]]
		///   
		///   # <c>condition</c> tensor is [[[True, False]
		///   #                     [True, False]]
		///   #                    [[False, True]
		///   #                     [False, True]]
		///   #                    [[False, False]
		///   #                     [False, True]]]
		///   # 'input' has 5 true values, so output has 5 coordinates.
		///   # 'input' has rank of 3, so coordinates have three indices.
		///   where(input) ==&amp;gt; [[0, 0, 0],
		///   [0, 1, 0],
		///   [1, 0, 1],
		///   [1, 1, 1],
		///   [2, 1, 1]]
		///   
		///   # <c>condition</c> tensor is [[[1.5,  0.0]
		///   #                     [-0.5, 0.0]]
		///   #                    [[0.0,  0.25]
		///   #                     [0.0,  0.75]]
		///   #                    [[0.0,  0.0]
		///   #                     [0.0,  0.01]]]
		///   # 'input' has 5 nonzero values, so output has 5 coordinates.
		///   # 'input' has rank of 3, so coordinates have three indices.
		///   where(input) ==&amp;gt; [[0, 0, 0],
		///   [0, 1, 0],
		///   [1, 0, 1],
		///   [1, 1, 1],
		///   [2, 1, 1]]
		///   
		///   # <c>condition</c> tensor is [[[1.5 + 0.0j, 0.0  + 0.0j]
		///   #                     [0.0 + 0.5j, 0.0  + 0.0j]]
		///   #                    [[0.0 + 0.0j, 0.25 + 1.5j]
		///   #                     [0.0 + 0.0j, 0.75 + 0.0j]]
		///   #                    [[0.0 + 0.0j, 0.0  + 0.0j]
		///   #                     [0.0 + 0.0j, 0.01 + 0.0j]]]
		///   # 'input' has 5 nonzero magnitude values, so output has 5 coordinates.
		///   # 'input' has rank of 3, so coordinates have three indices.
		///   where(input) ==&amp;gt; [[0, 0, 0],
		///   [0, 1, 0],
		///   [1, 0, 1],
		///   [1, 1, 1],
		///   [2, 1, 1]]
		///    </code>
		/// </remarks>
		public TF_Output Where (TF_Output input, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Where", MakeName ("Where", operName));
			c_api.TF_AddInput(desc, input);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var index = new TF_Output (op, _idx++);
			return index;
		}

		/// <summary>
		///   output = input; While (Cond(output)) { output = Body(output) }
		/// </summary>
		/// <param name="input">
		///   A list of input tensors whose types are T.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'While'.
		/// </param>
		/// <param name="output_shapes">
		///   Optional argument
		/// </param>
		/// <param name="parallel_iterations">
		///   Optional argument
		/// </param>
		/// <param name="cond">
		///   A function takes 'input' and returns a tensor.  If the tensor is
		///   a scalar of non-boolean, the scalar is converted to a boolean
		///   according to the following rule: if the scalar is a numerical
		///   value, non-zero means True and zero means False; if the scalar is
		///   a string, non-empty means True and empty means False. If the
		///   tensor is not a scalar, non-emptiness means True and False
		///   otherwise.
		/// </param>
		/// <param name="body">
		///   A function that takes a list of tensors and returns another
		///   list of tensors. Both lists have the same types as specified
		///   by T.
		/// </param>
		/// <returns>
		///   A list of output tensors whose types are T.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output[] While (TF_Output[] input, TF_Function cond, TF_Function body, long[][] output_shapes = null, long? parallel_iterations = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "While", MakeName ("While", operName));
			c_api.TF_AddInputList(desc, input[0], input.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrFuncName (desc, "cond", c_api.TF_FunctionName(cond));
			c_api.TF_SetAttrFuncName (desc, "body", c_api.TF_FunctionName(body));
			if (output_shapes != null)
				c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			
			if (parallel_iterations.HasValue)
				c_api.TF_SetAttrInt (desc, "parallel_iterations", parallel_iterations.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			int _n = 0;
			_n = c_api.TF_OperationOutputListLength(op, "output", status);
			var output = new TF_Output [_n];
			for (int i = 0; i < _n; i++)
				output [i] = new TF_Output (op, _idx++);
			
			return output;
		}

		/// <summary>
		///   A Reader that outputs the entire contents of a file as a value.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WholeFileReader'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this reader is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this reader is named in the given bucket
		///   with this shared_name. Otherwise, the node name is used instead.
		/// </param>
		/// <returns>
		///   The handle to reference the Reader.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   To use, enqueue filenames in a Queue.  The output of ReaderRead will
		///   be a filename (key) and the contents of that file (value).
		/// </remarks>
		public TF_Output WholeFileReader (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WholeFileReader", MakeName ("WholeFileReader", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		///   A Reader that outputs the entire contents of a file as a value.
		/// </summary>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WholeFileReaderV2'.
		/// </param>
		/// <param name="container">
		///   Optional argument
		///   If non-empty, this reader is placed in the given container.
		///   Otherwise, a default container is used.
		/// </param>
		/// <param name="shared_name">
		///   Optional argument
		///   If non-empty, this reader is named in the given bucket
		///   with this shared_name. Otherwise, the node name is used instead.
		/// </param>
		/// <returns>
		///   The handle to reference the Reader.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   To use, enqueue filenames in a Queue.  The output of ReaderRead will
		///   be a filename (key) and the contents of that file (value).
		/// </remarks>
		public TF_Output WholeFileReaderV2 (string container = null, string shared_name = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WholeFileReaderV2", MakeName ("WholeFileReaderV2", operName));
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (container != null)
				c_api.TF_SetAttrString (desc, "container", container);
			
			if (shared_name != null)
				c_api.TF_SetAttrString (desc, "shared_name", shared_name);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var reader_handle = new TF_Output (op, _idx++);
			return reader_handle;
		}

		/// <summary>
		///   A dataset that creates window datasets from the input dataset.
		/// </summary>
		/// <param name="input_dataset">
		/// </param>
		/// <param name="size">
		///   A scalar representing the number of elements to accumulate in a window.
		/// </param>
		/// <param name="shift">
		///   A scalar representing the steps moving the sliding window forward in one
		///   iteration. It must be positive.
		/// </param>
		/// <param name="stride">
		///   A scalar representing the stride of the input elements of the sliding window.
		///   It must be positive.
		/// </param>
		/// <param name="drop_remainder">
		///   A scalar representing whether a window should be dropped in case its size is
		///   smaller than desired.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WindowDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output WindowDataset (TF_Output input_dataset, TF_Output size, TF_Output shift, TF_Output stride, TF_Output drop_remainder, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WindowDataset", MakeName ("WindowDataset", operName));
			c_api.TF_AddInput(desc, input_dataset);
			c_api.TF_AddInput(desc, size);
			c_api.TF_AddInput(desc, shift);
			c_api.TF_AddInput(desc, stride);
			c_api.TF_AddInput(desc, drop_remainder);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

		/// <summary>
		///   Worker heartbeat op.
		/// </summary>
		/// <param name="request">
		///   A string tensor containing a serialized WorkerHeartbeatRequest
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WorkerHeartbeat'.
		/// </param>
		/// <returns>
		///   A string tensor containing a serialized WorkerHeartbeatResponse
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   Heartbeats may be sent periodically to indicate the coordinator is still active,
		///   to retrieve the current worker status and to expedite shutdown when necessary.
		/// </remarks>
		public TF_Output WorkerHeartbeat (TF_Output request, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WorkerHeartbeat", MakeName ("WorkerHeartbeat", operName));
			c_api.TF_AddInput(desc, request);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var response = new TF_Output (op, _idx++);
			return response;
		}

		/// <summary>
		/// </summary>
		/// <param name="input_handle">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WrapDatasetVariant'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output WrapDatasetVariant (TF_Output input_handle, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WrapDatasetVariant", MakeName ("WrapDatasetVariant", operName));
			c_api.TF_AddInput(desc, input_handle);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var output_handle = new TF_Output (op, _idx++);
			return output_handle;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="step">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="tensor">
		/// </param>
		/// <param name="sample_rate">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteAudioSummary'.
		/// </param>
		/// <param name="max_outputs">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation WriteAudioSummary (TF_Output writer, TF_Output step, TF_Output tag, TF_Output tensor, TF_Output sample_rate, long? max_outputs = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WriteAudioSummary", MakeName ("WriteAudioSummary", operName));
			c_api.TF_AddInput(desc, writer);
			c_api.TF_AddInput(desc, step);
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, sample_rate);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (max_outputs.HasValue)
				c_api.TF_SetAttrInt (desc, "max_outputs", max_outputs.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Writes contents to the file at input filename. Creates file and recursively
		/// </summary>
		/// <param name="filename">
		///   scalar. The name of the file to which we write the contents.
		/// </param>
		/// <param name="contents">
		///   scalar. The content to be written to the output file.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteFile'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		/// <remarks>
		///   creates directory if not existing.
		/// </remarks>
		public TF_Operation WriteFile (TF_Output filename, TF_Output contents, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WriteFile", MakeName ("WriteFile", operName));
			c_api.TF_AddInput(desc, filename);
			c_api.TF_AddInput(desc, contents);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="step">
		/// </param>
		/// <param name="tensor">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteGraphSummary'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation WriteGraphSummary (TF_Output writer, TF_Output step, TF_Output tensor, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WriteGraphSummary", MakeName ("WriteGraphSummary", operName));
			c_api.TF_AddInput(desc, writer);
			c_api.TF_AddInput(desc, step);
			c_api.TF_AddInput(desc, tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="step">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="values">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteHistogramSummary'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation WriteHistogramSummary (TF_Output writer, TF_Output step, TF_Output tag, TF_Output values, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WriteHistogramSummary", MakeName ("WriteHistogramSummary", operName));
			c_api.TF_AddInput(desc, writer);
			c_api.TF_AddInput(desc, step);
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, values);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="step">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="tensor">
		/// </param>
		/// <param name="bad_color">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteImageSummary'.
		/// </param>
		/// <param name="max_images">
		///   Optional argument
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation WriteImageSummary (TF_Output writer, TF_Output step, TF_Output tag, TF_Output tensor, TF_Output bad_color, long? max_images = null, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WriteImageSummary", MakeName ("WriteImageSummary", operName));
			c_api.TF_AddInput(desc, writer);
			c_api.TF_AddInput(desc, step);
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, bad_color);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			if (max_images.HasValue)
				c_api.TF_SetAttrInt (desc, "max_images", max_images.Value);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="step">
		/// </param>
		/// <param name="tensor">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteRawProtoSummary'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation WriteRawProtoSummary (TF_Output writer, TF_Output step, TF_Output tensor, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WriteRawProtoSummary", MakeName ("WriteRawProtoSummary", operName));
			c_api.TF_AddInput(desc, writer);
			c_api.TF_AddInput(desc, step);
			c_api.TF_AddInput(desc, tensor);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="step">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="value">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteScalarSummary'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation WriteScalarSummary (TF_Output writer, TF_Output step, TF_Output tag, TF_Output value, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WriteScalarSummary", MakeName ("WriteScalarSummary", operName));
			c_api.TF_AddInput(desc, writer);
			c_api.TF_AddInput(desc, step);
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, value);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		/// </summary>
		/// <param name="writer">
		/// </param>
		/// <param name="step">
		/// </param>
		/// <param name="tensor">
		/// </param>
		/// <param name="tag">
		/// </param>
		/// <param name="summary_metadata">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteSummary'.
		/// </param>
		/// <returns>
		///   Returns the description of the operation
		/// </returns>
		public TF_Operation WriteSummary (TF_Output writer, TF_Output step, TF_Output tensor, TF_Output tag, TF_Output summary_metadata, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "WriteSummary", MakeName ("WriteSummary", operName));
			c_api.TF_AddInput(desc, writer);
			c_api.TF_AddInput(desc, step);
			c_api.TF_AddInput(desc, tensor);
			c_api.TF_AddInput(desc, tag);
			c_api.TF_AddInput(desc, summary_metadata);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			return op;
		}

		/// <summary>
		///   Returns 0 if x == 0, and x / y otherwise, elementwise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Xdivy'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Xdivy (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Xdivy", MakeName ("Xdivy", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Returns 0 if x == 0, and x * log(y) otherwise, elementwise.
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="y">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Xlogy'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output Xlogy (TF_Output x, TF_Output y, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Xlogy", MakeName ("Xlogy", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, y);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Returns a tensor of zeros with the same shape and type as x.
		/// </summary>
		/// <param name="x">
		///   a tensor of type T.
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ZerosLike'.
		/// </param>
		/// <returns>
		///   a tensor of the same shape and type as x but filled with zeros.
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ZerosLike (TF_Output x, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ZerosLike", MakeName ("ZerosLike", operName));
			c_api.TF_AddInput(desc, x);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var y = new TF_Output (op, _idx++);
			return y;
		}

		/// <summary>
		///   Compute the Hurwitz zeta function \\(\zeta(x, q)\\).
		/// </summary>
		/// <param name="x">
		/// </param>
		/// <param name="q">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'Zeta'.
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		/// <remarks>
		///   The Hurwitz zeta function is defined as:
		///   
		///   
		///   \\(\zeta(x, q) = \sum_{n=0}^{\infty} (q + n)^{-x}\\)
		/// </remarks>
		public TF_Output Zeta (TF_Output x, TF_Output q, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "Zeta", MakeName ("Zeta", operName));
			c_api.TF_AddInput(desc, x);
			c_api.TF_AddInput(desc, q);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var z = new TF_Output (op, _idx++);
			return z;
		}

		/// <summary>
		///   Creates a dataset that zips together <c>input_datasets</c>.
		/// </summary>
		/// <param name="input_datasets">
		/// </param>
		/// <param name="operName">
		///   If specified, the created operation in the graph will be this one, otherwise it will be named 'ZipDataset'.
		/// </param>
		/// <param name="output_types">
		/// </param>
		/// <param name="output_shapes">
		/// </param>
		/// <returns>
		///   The TF_Operation can be fetched from the resulting TF_Output, by fethching the Operation property from the result.
		/// </returns>
		public TF_Output ZipDataset (TF_Output[] input_datasets, TF_DataType[] output_types, long[][] output_shapes, string operName = null)
		{
			var status = tf_status.TF_NewStatus();
			var desc = c_api.TF_NewOperation(this, "ZipDataset", MakeName ("ZipDataset", operName));
			c_api.TF_AddInputList(desc, input_datasets[0], input_datasets.Length);
			foreach ( TF_Operation control in Dependencies )
				c_api.TF_AddControlInput(desc, control);
			
			c_api.TF_SetAttrTypeList (desc, "output_types", output_types);
			c_api.TF_SetAttrShapeList (desc, "output_shapes", output_shapes);
			var op = c_api.TF_FinishOperation(desc, status);
			if (tf_status.TF_GetCode(status) != TF_Code.TF_OK)
			{
			    throw new OpException(op, status);
			}
			
			int _idx = 0;
			var handle = new TF_Output (op, _idx++);
			return handle;
		}

	}
}
