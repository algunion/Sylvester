// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace TensorFlow
{
    public enum TF_AttrType
    {
        TF_ATTR_STRING = 0,
        TF_ATTR_INT = 1,
        TF_ATTR_FLOAT = 2,
        TF_ATTR_BOOL = 3,
        TF_ATTR_TYPE = 4,
        TF_ATTR_SHAPE = 5,
        TF_ATTR_TENSOR = 6,
        TF_ATTR_PLACEHOLDER = 7,
        TF_ATTR_FUNC = 8
    }

    public enum TF_DataType
    {
        TF_FLOAT = 1,
        TF_DOUBLE = 2,
        TF_INT32 = 3,
        TF_UINT8 = 4,
        TF_INT16 = 5,
        TF_INT8 = 6,
        TF_STRING = 7,
        TF_COMPLEX64 = 8,
        TF_COMPLEX = 8,
        TF_INT64 = 9,
        TF_BOOL = 10,
        TF_QINT8 = 11,
        TF_QUINT8 = 12,
        TF_QINT32 = 13,
        TF_BFLOAT16 = 14,
        TF_QINT16 = 15,
        TF_QUINT16 = 16,
        TF_UINT16 = 17,
        TF_COMPLEX128 = 18,
        TF_HALF = 19,
        TF_RESOURCE = 20,
        TF_VARIANT = 21,
        TF_UINT32 = 22,
        TF_UINT64 = 23
    }

    public unsafe partial class tf_datatype
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DataTypeSize")]
            internal static extern ulong TF_DataTypeSize(global::TensorFlow.TF_DataType dt);
        }

        public static ulong TF_DataTypeSize(global::TensorFlow.TF_DataType dt)
        {
            var __ret = __Internal.TF_DataTypeSize(dt);
            return __ret;
        }
    }

    public enum TF_Code
    {
        TF_OK = 0,
        TF_CANCELLED = 1,
        TF_UNKNOWN = 2,
        TF_INVALID_ARGUMENT = 3,
        TF_DEADLINE_EXCEEDED = 4,
        TF_NOT_FOUND = 5,
        TF_ALREADY_EXISTS = 6,
        TF_PERMISSION_DENIED = 7,
        TF_UNAUTHENTICATED = 16,
        TF_RESOURCE_EXHAUSTED = 8,
        TF_FAILED_PRECONDITION = 9,
        TF_ABORTED = 10,
        TF_OUT_OF_RANGE = 11,
        TF_UNIMPLEMENTED = 12,
        TF_INTERNAL = 13,
        TF_UNAVAILABLE = 14,
        TF_DATA_LOSS = 15
    }

    public unsafe partial class TF_Status
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Status> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Status>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_Status __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Status(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_Status __CreateInstance(global::TensorFlow.TF_Status.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Status(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_Status.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_Status.__Internal));
            *(global::TensorFlow.TF_Status.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_Status(global::TensorFlow.TF_Status.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_Status(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class tf_status
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_NewStatus")]
            internal static extern global::System.IntPtr TF_NewStatus();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeleteStatus")]
            internal static extern void TF_DeleteStatus(global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetStatus")]
            internal static extern void TF_SetStatus(global::System.IntPtr s, global::TensorFlow.TF_Code code, [MarshalAs(UnmanagedType.LPStr)] string msg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GetCode")]
            internal static extern global::TensorFlow.TF_Code TF_GetCode(global::System.IntPtr s);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_Message")]
            internal static extern global::System.IntPtr TF_Message(global::System.IntPtr s);
        }

        public static global::TensorFlow.TF_Status TF_NewStatus()
        {
            var __ret = __Internal.TF_NewStatus();
            global::TensorFlow.TF_Status __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_Status.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_Status) global::TensorFlow.TF_Status.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_Status.__CreateInstance(__ret);
            return __result0;
        }

        public static void TF_DeleteStatus(global::TensorFlow.TF_Status _0)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            __Internal.TF_DeleteStatus(__arg0);
        }

        public static void TF_SetStatus(global::TensorFlow.TF_Status s, global::TensorFlow.TF_Code code, string msg)
        {
            var __arg0 = ReferenceEquals(s, null) ? global::System.IntPtr.Zero : s.__Instance;
            __Internal.TF_SetStatus(__arg0, code, msg);
        }

        public static global::TensorFlow.TF_Code TF_GetCode(global::TensorFlow.TF_Status s)
        {
            var __arg0 = ReferenceEquals(s, null) ? global::System.IntPtr.Zero : s.__Instance;
            var __ret = __Internal.TF_GetCode(__arg0);
            return __ret;
        }

        public static string TF_Message(global::TensorFlow.TF_Status s)
        {
            var __arg0 = ReferenceEquals(s, null) ? global::System.IntPtr.Zero : s.__Instance;
            var __ret = __Internal.TF_Message(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }
    }

    public unsafe partial class TF_Tensor
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Tensor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Tensor>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_Tensor __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Tensor(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_Tensor __CreateInstance(global::TensorFlow.TF_Tensor.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Tensor(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_Tensor.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_Tensor.__Internal));
            *(global::TensorFlow.TF_Tensor.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_Tensor(global::TensorFlow.TF_Tensor.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_Tensor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class tf_tensor
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_NewTensor")]
            internal static extern global::System.IntPtr TF_NewTensor(global::TensorFlow.TF_DataType _0, long* dims, int num_dims, global::System.IntPtr data, ulong len, global::System.IntPtr deallocator, global::System.IntPtr deallocator_arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_AllocateTensor")]
            internal static extern global::System.IntPtr TF_AllocateTensor(global::TensorFlow.TF_DataType _0, long* dims, int num_dims, ulong len);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_TensorMaybeMove")]
            internal static extern global::System.IntPtr TF_TensorMaybeMove(global::System.IntPtr tensor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeleteTensor")]
            internal static extern void TF_DeleteTensor(global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_TensorType")]
            internal static extern global::TensorFlow.TF_DataType TF_TensorType(global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_NumDims")]
            internal static extern int TF_NumDims(global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_Dim")]
            internal static extern long TF_Dim(global::System.IntPtr tensor, int dim_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_TensorByteSize")]
            internal static extern ulong TF_TensorByteSize(global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_TensorData")]
            internal static extern global::System.IntPtr TF_TensorData(global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_TensorElementCount")]
            internal static extern long TF_TensorElementCount(global::System.IntPtr tensor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_TensorBitcastFrom")]
            internal static extern void TF_TensorBitcastFrom(global::System.IntPtr from, global::TensorFlow.TF_DataType type, global::System.IntPtr to, long* new_dims, int num_new_dims, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_StringEncode")]
            internal static extern ulong TF_StringEncode([MarshalAs(UnmanagedType.LPStr)] string src, ulong src_len, sbyte* dst, ulong dst_len, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_StringDecode")]
            internal static extern ulong TF_StringDecode([MarshalAs(UnmanagedType.LPStr)] string src, ulong src_len, sbyte** dst, ulong* dst_len, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_StringEncodedSize")]
            internal static extern ulong TF_StringEncodedSize(ulong len);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_TensorIsAligned")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TF_TensorIsAligned(global::System.IntPtr _0);
        }

        public static global::TensorFlow.TF_Tensor TF_NewTensor(global::TensorFlow.TF_DataType _0, ref long dims, int num_dims, global::System.IntPtr data, ulong len, global::TensorFlow.Delegates.Action_IntPtr_ulong_IntPtr deallocator, global::System.IntPtr deallocator_arg)
        {
            fixed (long* __dims1 = &dims)
            {
                var __arg1 = __dims1;
                var __arg5 = deallocator == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(deallocator);
                var __ret = __Internal.TF_NewTensor(_0, __arg1, num_dims, data, len, __arg5, deallocator_arg);
                global::TensorFlow.TF_Tensor __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::TensorFlow.TF_Tensor.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::TensorFlow.TF_Tensor) global::TensorFlow.TF_Tensor.NativeToManagedMap[__ret];
                else __result0 = global::TensorFlow.TF_Tensor.__CreateInstance(__ret);
                return __result0;
            }
        }

        public static global::TensorFlow.TF_Tensor TF_AllocateTensor(global::TensorFlow.TF_DataType _0, ref long dims, int num_dims, ulong len)
        {
            fixed (long* __dims1 = &dims)
            {
                var __arg1 = __dims1;
                var __ret = __Internal.TF_AllocateTensor(_0, __arg1, num_dims, len);
                global::TensorFlow.TF_Tensor __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::TensorFlow.TF_Tensor.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::TensorFlow.TF_Tensor) global::TensorFlow.TF_Tensor.NativeToManagedMap[__ret];
                else __result0 = global::TensorFlow.TF_Tensor.__CreateInstance(__ret);
                return __result0;
            }
        }

        public static global::TensorFlow.TF_Tensor TF_TensorMaybeMove(global::TensorFlow.TF_Tensor tensor)
        {
            var __arg0 = ReferenceEquals(tensor, null) ? global::System.IntPtr.Zero : tensor.__Instance;
            var __ret = __Internal.TF_TensorMaybeMove(__arg0);
            global::TensorFlow.TF_Tensor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_Tensor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_Tensor) global::TensorFlow.TF_Tensor.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_Tensor.__CreateInstance(__ret);
            return __result0;
        }

        public static void TF_DeleteTensor(global::TensorFlow.TF_Tensor _0)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            __Internal.TF_DeleteTensor(__arg0);
        }

        public static global::TensorFlow.TF_DataType TF_TensorType(global::TensorFlow.TF_Tensor _0)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.TF_TensorType(__arg0);
            return __ret;
        }

        public static int TF_NumDims(global::TensorFlow.TF_Tensor _0)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.TF_NumDims(__arg0);
            return __ret;
        }

        public static long TF_Dim(global::TensorFlow.TF_Tensor tensor, int dim_index)
        {
            var __arg0 = ReferenceEquals(tensor, null) ? global::System.IntPtr.Zero : tensor.__Instance;
            var __ret = __Internal.TF_Dim(__arg0, dim_index);
            return __ret;
        }

        public static ulong TF_TensorByteSize(global::TensorFlow.TF_Tensor _0)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.TF_TensorByteSize(__arg0);
            return __ret;
        }

        public static global::System.IntPtr TF_TensorData(global::TensorFlow.TF_Tensor _0)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.TF_TensorData(__arg0);
            return __ret;
        }

        public static long TF_TensorElementCount(global::TensorFlow.TF_Tensor tensor)
        {
            var __arg0 = ReferenceEquals(tensor, null) ? global::System.IntPtr.Zero : tensor.__Instance;
            var __ret = __Internal.TF_TensorElementCount(__arg0);
            return __ret;
        }

        public static void TF_TensorBitcastFrom(global::TensorFlow.TF_Tensor from, global::TensorFlow.TF_DataType type, global::TensorFlow.TF_Tensor to, ref long new_dims, int num_new_dims, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(from, null) ? global::System.IntPtr.Zero : from.__Instance;
            var __arg2 = ReferenceEquals(to, null) ? global::System.IntPtr.Zero : to.__Instance;
            fixed (long* __new_dims3 = &new_dims)
            {
                var __arg3 = __new_dims3;
                var __arg5 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
                __Internal.TF_TensorBitcastFrom(__arg0, type, __arg2, __arg3, num_new_dims, __arg5);
            }
        }

        public static ulong TF_StringEncode(string src, ulong src_len, sbyte* dst, ulong dst_len, global::TensorFlow.TF_Status status)
        {
            var __arg4 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_StringEncode(src, src_len, dst, dst_len, __arg4);
            return __ret;
        }

        public static ulong TF_StringDecode(string src, ulong src_len, sbyte** dst, ref ulong dst_len, global::TensorFlow.TF_Status status)
        {
            fixed (ulong* __dst_len3 = &dst_len)
            {
                var __arg3 = __dst_len3;
                var __arg4 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
                var __ret = __Internal.TF_StringDecode(src, src_len, dst, __arg3, __arg4);
                return __ret;
            }
        }

        public static ulong TF_StringEncodedSize(ulong len)
        {
            var __ret = __Internal.TF_StringEncodedSize(len);
            return __ret;
        }

        public static bool TF_TensorIsAligned(global::TensorFlow.TF_Tensor _0)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.TF_TensorIsAligned(__arg0);
            return __ret;
        }
    }

    public unsafe partial class TF_Buffer : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr data;

            [FieldOffset(8)]
            internal ulong length;

            [FieldOffset(16)]
            internal global::System.IntPtr data_deallocator;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0TF_Buffer@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Buffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Buffer>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_Buffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Buffer(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_Buffer __CreateInstance(global::TensorFlow.TF_Buffer.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Buffer(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_Buffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_Buffer.__Internal));
            *(global::TensorFlow.TF_Buffer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_Buffer(global::TensorFlow.TF_Buffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_Buffer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TF_Buffer()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_Buffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TF_Buffer(global::TensorFlow.TF_Buffer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_Buffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::TensorFlow.TF_Buffer.__Internal*) __Instance) = *((global::TensorFlow.TF_Buffer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::TensorFlow.TF_Buffer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::System.IntPtr Data
        {
            get
            {
                return ((global::TensorFlow.TF_Buffer.__Internal*) __Instance)->data;
            }

            set
            {
                ((global::TensorFlow.TF_Buffer.__Internal*)__Instance)->data = (global::System.IntPtr) value;
            }
        }

        public ulong Length
        {
            get
            {
                return ((global::TensorFlow.TF_Buffer.__Internal*) __Instance)->length;
            }

            set
            {
                ((global::TensorFlow.TF_Buffer.__Internal*)__Instance)->length = value;
            }
        }

        public global::TensorFlow.Delegates.Action_IntPtr_ulong DataDeallocator
        {
            get
            {
                var __ptr0 = ((global::TensorFlow.TF_Buffer.__Internal*) __Instance)->data_deallocator;
                return __ptr0 == IntPtr.Zero? null : (global::TensorFlow.Delegates.Action_IntPtr_ulong) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::TensorFlow.Delegates.Action_IntPtr_ulong));
            }

            set
            {
                ((global::TensorFlow.TF_Buffer.__Internal*)__Instance)->data_deallocator = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class TF_SessionOptions
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_SessionOptions> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_SessionOptions>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_SessionOptions __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_SessionOptions(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_SessionOptions __CreateInstance(global::TensorFlow.TF_SessionOptions.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_SessionOptions(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_SessionOptions.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_SessionOptions.__Internal));
            *(global::TensorFlow.TF_SessionOptions.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_SessionOptions(global::TensorFlow.TF_SessionOptions.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_SessionOptions(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class TF_Graph
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Graph> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Graph>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_Graph __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Graph(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_Graph __CreateInstance(global::TensorFlow.TF_Graph.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Graph(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_Graph.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_Graph.__Internal));
            *(global::TensorFlow.TF_Graph.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_Graph(global::TensorFlow.TF_Graph.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_Graph(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class TF_OperationDescription
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_OperationDescription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_OperationDescription>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_OperationDescription __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_OperationDescription(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_OperationDescription __CreateInstance(global::TensorFlow.TF_OperationDescription.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_OperationDescription(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_OperationDescription.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_OperationDescription.__Internal));
            *(global::TensorFlow.TF_OperationDescription.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_OperationDescription(global::TensorFlow.TF_OperationDescription.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_OperationDescription(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class TF_Operation
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Operation> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Operation>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_Operation __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Operation(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_Operation __CreateInstance(global::TensorFlow.TF_Operation.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Operation(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_Operation.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_Operation.__Internal));
            *(global::TensorFlow.TF_Operation.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_Operation(global::TensorFlow.TF_Operation.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_Operation(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class TF_Function
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Function> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Function>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_Function __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Function(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_Function __CreateInstance(global::TensorFlow.TF_Function.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Function(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_Function.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_Function.__Internal));
            *(global::TensorFlow.TF_Function.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_Function(global::TensorFlow.TF_Function.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_Function(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class TF_FunctionOptions
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_FunctionOptions> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_FunctionOptions>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_FunctionOptions __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_FunctionOptions(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_FunctionOptions __CreateInstance(global::TensorFlow.TF_FunctionOptions.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_FunctionOptions(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_FunctionOptions.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_FunctionOptions.__Internal));
            *(global::TensorFlow.TF_FunctionOptions.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_FunctionOptions(global::TensorFlow.TF_FunctionOptions.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_FunctionOptions(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class TF_ImportGraphDefOptions
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_ImportGraphDefOptions> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_ImportGraphDefOptions>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_ImportGraphDefOptions __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_ImportGraphDefOptions(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_ImportGraphDefOptions __CreateInstance(global::TensorFlow.TF_ImportGraphDefOptions.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_ImportGraphDefOptions(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_ImportGraphDefOptions.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_ImportGraphDefOptions.__Internal));
            *(global::TensorFlow.TF_ImportGraphDefOptions.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_ImportGraphDefOptions(global::TensorFlow.TF_ImportGraphDefOptions.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_ImportGraphDefOptions(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class TF_ImportGraphDefResults
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_ImportGraphDefResults> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_ImportGraphDefResults>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_ImportGraphDefResults __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_ImportGraphDefResults(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_ImportGraphDefResults __CreateInstance(global::TensorFlow.TF_ImportGraphDefResults.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_ImportGraphDefResults(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_ImportGraphDefResults.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_ImportGraphDefResults.__Internal));
            *(global::TensorFlow.TF_ImportGraphDefResults.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_ImportGraphDefResults(global::TensorFlow.TF_ImportGraphDefResults.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_ImportGraphDefResults(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class TF_Session
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Session> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Session>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_Session __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Session(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_Session __CreateInstance(global::TensorFlow.TF_Session.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Session(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_Session.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_Session.__Internal));
            *(global::TensorFlow.TF_Session.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_Session(global::TensorFlow.TF_Session.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_Session(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class TF_DeprecatedSession
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_DeprecatedSession> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_DeprecatedSession>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_DeprecatedSession __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_DeprecatedSession(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_DeprecatedSession __CreateInstance(global::TensorFlow.TF_DeprecatedSession.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_DeprecatedSession(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_DeprecatedSession.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_DeprecatedSession.__Internal));
            *(global::TensorFlow.TF_DeprecatedSession.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_DeprecatedSession(global::TensorFlow.TF_DeprecatedSession.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_DeprecatedSession(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class TF_DeviceList
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_DeviceList> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_DeviceList>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_DeviceList __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_DeviceList(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_DeviceList __CreateInstance(global::TensorFlow.TF_DeviceList.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_DeviceList(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_DeviceList.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_DeviceList.__Internal));
            *(global::TensorFlow.TF_DeviceList.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_DeviceList(global::TensorFlow.TF_DeviceList.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_DeviceList(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class TF_Library
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Library> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Library>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_Library __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Library(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_Library __CreateInstance(global::TensorFlow.TF_Library.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Library(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_Library.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_Library.__Internal));
            *(global::TensorFlow.TF_Library.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_Library(global::TensorFlow.TF_Library.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_Library(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class TF_ApiDefMap
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_ApiDefMap> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_ApiDefMap>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_ApiDefMap __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_ApiDefMap(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_ApiDefMap __CreateInstance(global::TensorFlow.TF_ApiDefMap.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_ApiDefMap(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_ApiDefMap.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_ApiDefMap.__Internal));
            *(global::TensorFlow.TF_ApiDefMap.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_ApiDefMap(global::TensorFlow.TF_ApiDefMap.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_ApiDefMap(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class TF_Server
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Server> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Server>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_Server __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Server(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_Server __CreateInstance(global::TensorFlow.TF_Server.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Server(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_Server.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_Server.__Internal));
            *(global::TensorFlow.TF_Server.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_Server(global::TensorFlow.TF_Server.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_Server(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class TF_Input : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr oper;

            [FieldOffset(8)]
            internal int index;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0TF_Input@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Input> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Input>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_Input __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Input(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_Input __CreateInstance(global::TensorFlow.TF_Input.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Input(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_Input.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_Input.__Internal));
            *(global::TensorFlow.TF_Input.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_Input(global::TensorFlow.TF_Input.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_Input(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TF_Input()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_Input.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TF_Input(global::TensorFlow.TF_Input _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_Input.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::TensorFlow.TF_Input.__Internal*) __Instance) = *((global::TensorFlow.TF_Input.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::TensorFlow.TF_Input __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::TensorFlow.TF_Operation Oper
        {
            get
            {
                global::TensorFlow.TF_Operation __result0;
                if (((global::TensorFlow.TF_Input.__Internal*) __Instance)->oper == IntPtr.Zero) __result0 = null;
                else if (global::TensorFlow.TF_Operation.NativeToManagedMap.ContainsKey(((global::TensorFlow.TF_Input.__Internal*) __Instance)->oper))
                    __result0 = (global::TensorFlow.TF_Operation) global::TensorFlow.TF_Operation.NativeToManagedMap[((global::TensorFlow.TF_Input.__Internal*) __Instance)->oper];
                else __result0 = global::TensorFlow.TF_Operation.__CreateInstance(((global::TensorFlow.TF_Input.__Internal*) __Instance)->oper);
                return __result0;
            }

            set
            {
                ((global::TensorFlow.TF_Input.__Internal*)__Instance)->oper = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public int Index
        {
            get
            {
                return ((global::TensorFlow.TF_Input.__Internal*) __Instance)->index;
            }

            set
            {
                ((global::TensorFlow.TF_Input.__Internal*)__Instance)->index = value;
            }
        }
    }

    public unsafe partial class TF_Output : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr oper;

            [FieldOffset(8)]
            internal int index;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0TF_Output@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Output> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_Output>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_Output __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Output(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_Output __CreateInstance(global::TensorFlow.TF_Output.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_Output(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_Output.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_Output.__Internal));
            *(global::TensorFlow.TF_Output.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_Output(global::TensorFlow.TF_Output.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_Output(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TF_Output()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_Output.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TF_Output(global::TensorFlow.TF_Output _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_Output.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::TensorFlow.TF_Output.__Internal*) __Instance) = *((global::TensorFlow.TF_Output.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::TensorFlow.TF_Output __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::TensorFlow.TF_Operation Oper
        {
            get
            {
                global::TensorFlow.TF_Operation __result0;
                if (((global::TensorFlow.TF_Output.__Internal*) __Instance)->oper == IntPtr.Zero) __result0 = null;
                else if (global::TensorFlow.TF_Operation.NativeToManagedMap.ContainsKey(((global::TensorFlow.TF_Output.__Internal*) __Instance)->oper))
                    __result0 = (global::TensorFlow.TF_Operation) global::TensorFlow.TF_Operation.NativeToManagedMap[((global::TensorFlow.TF_Output.__Internal*) __Instance)->oper];
                else __result0 = global::TensorFlow.TF_Operation.__CreateInstance(((global::TensorFlow.TF_Output.__Internal*) __Instance)->oper);
                return __result0;
            }

            set
            {
                ((global::TensorFlow.TF_Output.__Internal*)__Instance)->oper = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public int Index
        {
            get
            {
                return ((global::TensorFlow.TF_Output.__Internal*) __Instance)->index;
            }

            set
            {
                ((global::TensorFlow.TF_Output.__Internal*)__Instance)->index = value;
            }
        }
    }

    public unsafe partial class TF_AttrMetadata : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte is_list;

            [FieldOffset(8)]
            internal long list_size;

            [FieldOffset(16)]
            internal global::TensorFlow.TF_AttrType type;

            [FieldOffset(24)]
            internal long total_size;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0TF_AttrMetadata@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_AttrMetadata> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_AttrMetadata>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_AttrMetadata __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_AttrMetadata(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_AttrMetadata __CreateInstance(global::TensorFlow.TF_AttrMetadata.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_AttrMetadata(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_AttrMetadata.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_AttrMetadata.__Internal));
            *(global::TensorFlow.TF_AttrMetadata.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_AttrMetadata(global::TensorFlow.TF_AttrMetadata.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_AttrMetadata(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TF_AttrMetadata()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_AttrMetadata.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TF_AttrMetadata(global::TensorFlow.TF_AttrMetadata _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_AttrMetadata.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::TensorFlow.TF_AttrMetadata.__Internal*) __Instance) = *((global::TensorFlow.TF_AttrMetadata.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::TensorFlow.TF_AttrMetadata __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte IsList
        {
            get
            {
                return ((global::TensorFlow.TF_AttrMetadata.__Internal*) __Instance)->is_list;
            }

            set
            {
                ((global::TensorFlow.TF_AttrMetadata.__Internal*)__Instance)->is_list = value;
            }
        }

        public long ListSize
        {
            get
            {
                return ((global::TensorFlow.TF_AttrMetadata.__Internal*) __Instance)->list_size;
            }

            set
            {
                ((global::TensorFlow.TF_AttrMetadata.__Internal*)__Instance)->list_size = value;
            }
        }

        public global::TensorFlow.TF_AttrType Type
        {
            get
            {
                return ((global::TensorFlow.TF_AttrMetadata.__Internal*) __Instance)->type;
            }

            set
            {
                ((global::TensorFlow.TF_AttrMetadata.__Internal*)__Instance)->type = value;
            }
        }

        public long TotalSize
        {
            get
            {
                return ((global::TensorFlow.TF_AttrMetadata.__Internal*) __Instance)->total_size;
            }

            set
            {
                ((global::TensorFlow.TF_AttrMetadata.__Internal*)__Instance)->total_size = value;
            }
        }
    }

    public unsafe partial class TF_WhileParams : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int ninputs;

            [FieldOffset(8)]
            internal global::System.IntPtr cond_graph;

            [FieldOffset(16)]
            internal global::System.IntPtr cond_inputs;

            [FieldOffset(24)]
            internal global::TensorFlow.TF_Output.__Internal cond_output;

            [FieldOffset(40)]
            internal global::System.IntPtr body_graph;

            [FieldOffset(48)]
            internal global::System.IntPtr body_inputs;

            [FieldOffset(56)]
            internal global::System.IntPtr body_outputs;

            [FieldOffset(64)]
            internal global::System.IntPtr name;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0TF_WhileParams@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_WhileParams> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::TensorFlow.TF_WhileParams>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::TensorFlow.TF_WhileParams __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_WhileParams(native.ToPointer(), skipVTables);
        }

        internal static global::TensorFlow.TF_WhileParams __CreateInstance(global::TensorFlow.TF_WhileParams.__Internal native, bool skipVTables = false)
        {
            return new global::TensorFlow.TF_WhileParams(native, skipVTables);
        }

        private static void* __CopyValue(global::TensorFlow.TF_WhileParams.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_WhileParams.__Internal));
            *(global::TensorFlow.TF_WhileParams.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TF_WhileParams(global::TensorFlow.TF_WhileParams.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TF_WhileParams(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TF_WhileParams()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_WhileParams.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TF_WhileParams(global::TensorFlow.TF_WhileParams _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::TensorFlow.TF_WhileParams.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::TensorFlow.TF_WhileParams.__Internal*) __Instance) = *((global::TensorFlow.TF_WhileParams.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::TensorFlow.TF_WhileParams __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Ninputs
        {
            get
            {
                return ((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->ninputs;
            }
        }

        public global::TensorFlow.TF_Graph CondGraph
        {
            get
            {
                global::TensorFlow.TF_Graph __result0;
                if (((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->cond_graph == IntPtr.Zero) __result0 = null;
                else if (global::TensorFlow.TF_Graph.NativeToManagedMap.ContainsKey(((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->cond_graph))
                    __result0 = (global::TensorFlow.TF_Graph) global::TensorFlow.TF_Graph.NativeToManagedMap[((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->cond_graph];
                else __result0 = global::TensorFlow.TF_Graph.__CreateInstance(((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->cond_graph);
                return __result0;
            }
        }

        public global::TensorFlow.TF_Output CondInputs
        {
            get
            {
                global::TensorFlow.TF_Output __result0;
                if (((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->cond_inputs == IntPtr.Zero) __result0 = null;
                else if (global::TensorFlow.TF_Output.NativeToManagedMap.ContainsKey(((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->cond_inputs))
                    __result0 = (global::TensorFlow.TF_Output) global::TensorFlow.TF_Output.NativeToManagedMap[((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->cond_inputs];
                else __result0 = global::TensorFlow.TF_Output.__CreateInstance(((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->cond_inputs);
                return __result0;
            }
        }

        public global::TensorFlow.TF_Output CondOutput
        {
            get
            {
                return global::TensorFlow.TF_Output.__CreateInstance(new global::System.IntPtr(&((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->cond_output));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::TensorFlow.TF_WhileParams.__Internal*)__Instance)->cond_output = *(global::TensorFlow.TF_Output.__Internal*) value.__Instance;
            }
        }

        public global::TensorFlow.TF_Graph BodyGraph
        {
            get
            {
                global::TensorFlow.TF_Graph __result0;
                if (((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->body_graph == IntPtr.Zero) __result0 = null;
                else if (global::TensorFlow.TF_Graph.NativeToManagedMap.ContainsKey(((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->body_graph))
                    __result0 = (global::TensorFlow.TF_Graph) global::TensorFlow.TF_Graph.NativeToManagedMap[((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->body_graph];
                else __result0 = global::TensorFlow.TF_Graph.__CreateInstance(((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->body_graph);
                return __result0;
            }
        }

        public global::TensorFlow.TF_Output BodyInputs
        {
            get
            {
                global::TensorFlow.TF_Output __result0;
                if (((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->body_inputs == IntPtr.Zero) __result0 = null;
                else if (global::TensorFlow.TF_Output.NativeToManagedMap.ContainsKey(((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->body_inputs))
                    __result0 = (global::TensorFlow.TF_Output) global::TensorFlow.TF_Output.NativeToManagedMap[((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->body_inputs];
                else __result0 = global::TensorFlow.TF_Output.__CreateInstance(((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->body_inputs);
                return __result0;
            }
        }

        public global::TensorFlow.TF_Output BodyOutputs
        {
            get
            {
                global::TensorFlow.TF_Output __result0;
                if (((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->body_outputs == IntPtr.Zero) __result0 = null;
                else if (global::TensorFlow.TF_Output.NativeToManagedMap.ContainsKey(((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->body_outputs))
                    __result0 = (global::TensorFlow.TF_Output) global::TensorFlow.TF_Output.NativeToManagedMap[((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->body_outputs];
                else __result0 = global::TensorFlow.TF_Output.__CreateInstance(((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->body_outputs);
                return __result0;
            }
        }

        public string Name
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::TensorFlow.TF_WhileParams.__Internal*) __Instance)->name);
            }

            set
            {
                ((global::TensorFlow.TF_WhileParams.__Internal*)__Instance)->name = (global::System.IntPtr) Marshal.StringToHGlobalAnsi(value);
            }
        }
    }

    public unsafe partial class c_api
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_Version")]
            internal static extern global::System.IntPtr TF_Version();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_NewBufferFromString")]
            internal static extern global::System.IntPtr TF_NewBufferFromString(global::System.IntPtr proto, ulong proto_len);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_NewBuffer")]
            internal static extern global::System.IntPtr TF_NewBuffer();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeleteBuffer")]
            internal static extern void TF_DeleteBuffer(global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GetBuffer")]
            internal static extern void TF_GetBuffer(global::System.IntPtr @return, global::System.IntPtr buffer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_NewSessionOptions")]
            internal static extern global::System.IntPtr TF_NewSessionOptions();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetTarget")]
            internal static extern void TF_SetTarget(global::System.IntPtr options, [MarshalAs(UnmanagedType.LPStr)] string target);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetConfig")]
            internal static extern void TF_SetConfig(global::System.IntPtr options, global::System.IntPtr proto, ulong proto_len, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeleteSessionOptions")]
            internal static extern void TF_DeleteSessionOptions(global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_NewGraph")]
            internal static extern global::System.IntPtr TF_NewGraph();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeleteGraph")]
            internal static extern void TF_DeleteGraph(global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GraphSetTensorShape")]
            internal static extern void TF_GraphSetTensorShape(global::System.IntPtr graph, global::TensorFlow.TF_Output.__Internal output, long* dims, int num_dims, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GraphGetTensorNumDims")]
            internal static extern int TF_GraphGetTensorNumDims(global::System.IntPtr graph, global::TensorFlow.TF_Output.__Internal output, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GraphGetTensorShape")]
            internal static extern void TF_GraphGetTensorShape(global::System.IntPtr graph, global::TensorFlow.TF_Output.__Internal output, long* dims, int num_dims, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_NewOperation")]
            internal static extern global::System.IntPtr TF_NewOperation(global::System.IntPtr graph, [MarshalAs(UnmanagedType.LPStr)] string op_type, [MarshalAs(UnmanagedType.LPStr)] string oper_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetDevice")]
            internal static extern void TF_SetDevice(global::System.IntPtr desc, [MarshalAs(UnmanagedType.LPStr)] string device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_AddInput")]
            internal static extern void TF_AddInput(global::System.IntPtr desc, global::TensorFlow.TF_Output.__Internal input);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_AddInputList")]
            internal static extern void TF_AddInputList(global::System.IntPtr desc, global::System.IntPtr inputs, int num_inputs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_AddControlInput")]
            internal static extern void TF_AddControlInput(global::System.IntPtr desc, global::System.IntPtr input);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ColocateWith")]
            internal static extern void TF_ColocateWith(global::System.IntPtr desc, global::System.IntPtr op);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetAttrString")]
            internal static extern void TF_SetAttrString(global::System.IntPtr desc, [MarshalAs(UnmanagedType.LPStr)] string attr_name, global::System.IntPtr value, ulong length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetAttrStringList")]
            internal static extern void TF_SetAttrStringList(global::System.IntPtr desc, [MarshalAs(UnmanagedType.LPStr)] string attr_name, void** values, ulong* lengths, int num_values);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetAttrInt")]
            internal static extern void TF_SetAttrInt(global::System.IntPtr desc, [MarshalAs(UnmanagedType.LPStr)] string attr_name, long value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetAttrIntList")]
            internal static extern void TF_SetAttrIntList(global::System.IntPtr desc, [MarshalAs(UnmanagedType.LPStr)] string attr_name, long* values, int num_values);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetAttrFloat")]
            internal static extern void TF_SetAttrFloat(global::System.IntPtr desc, [MarshalAs(UnmanagedType.LPStr)] string attr_name, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetAttrFloatList")]
            internal static extern void TF_SetAttrFloatList(global::System.IntPtr desc, [MarshalAs(UnmanagedType.LPStr)] string attr_name, float* values, int num_values);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetAttrBool")]
            internal static extern void TF_SetAttrBool(global::System.IntPtr desc, [MarshalAs(UnmanagedType.LPStr)] string attr_name, byte value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetAttrBoolList")]
            internal static extern void TF_SetAttrBoolList(global::System.IntPtr desc, [MarshalAs(UnmanagedType.LPStr)] string attr_name, byte* values, int num_values);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetAttrType")]
            internal static extern void TF_SetAttrType(global::System.IntPtr desc, [MarshalAs(UnmanagedType.LPStr)] string attr_name, global::TensorFlow.TF_DataType value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetAttrTypeList")]
            internal static extern void TF_SetAttrTypeList(global::System.IntPtr desc, [MarshalAs(UnmanagedType.LPStr)] string attr_name, global::TensorFlow.TF_DataType* values, int num_values);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetAttrPlaceholder")]
            internal static extern void TF_SetAttrPlaceholder(global::System.IntPtr desc, [MarshalAs(UnmanagedType.LPStr)] string attr_name, [MarshalAs(UnmanagedType.LPStr)] string placeholder);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetAttrFuncName")]
            internal static extern void TF_SetAttrFuncName(global::System.IntPtr desc, [MarshalAs(UnmanagedType.LPStr)] string attr_name, [MarshalAs(UnmanagedType.LPStr)] string value, ulong length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetAttrShape")]
            internal static extern void TF_SetAttrShape(global::System.IntPtr desc, [MarshalAs(UnmanagedType.LPStr)] string attr_name, long* dims, int num_dims);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetAttrShapeList")]
            internal static extern void TF_SetAttrShapeList(global::System.IntPtr desc, [MarshalAs(UnmanagedType.LPStr)] string attr_name, long** dims, int* num_dims, int num_shapes);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetAttrTensorShapeProto")]
            internal static extern void TF_SetAttrTensorShapeProto(global::System.IntPtr desc, [MarshalAs(UnmanagedType.LPStr)] string attr_name, global::System.IntPtr proto, ulong proto_len, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetAttrTensorShapeProtoList")]
            internal static extern void TF_SetAttrTensorShapeProtoList(global::System.IntPtr desc, [MarshalAs(UnmanagedType.LPStr)] string attr_name, void** protos, ulong* proto_lens, int num_shapes, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetAttrTensor")]
            internal static extern void TF_SetAttrTensor(global::System.IntPtr desc, [MarshalAs(UnmanagedType.LPStr)] string attr_name, global::System.IntPtr value, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetAttrTensorList")]
            internal static extern void TF_SetAttrTensorList(global::System.IntPtr desc, [MarshalAs(UnmanagedType.LPStr)] string attr_name, global::System.IntPtr values, int num_values, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SetAttrValueProto")]
            internal static extern void TF_SetAttrValueProto(global::System.IntPtr desc, [MarshalAs(UnmanagedType.LPStr)] string attr_name, global::System.IntPtr proto, ulong proto_len, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_FinishOperation")]
            internal static extern global::System.IntPtr TF_FinishOperation(global::System.IntPtr desc, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationName")]
            internal static extern global::System.IntPtr TF_OperationName(global::System.IntPtr oper);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationOpType")]
            internal static extern global::System.IntPtr TF_OperationOpType(global::System.IntPtr oper);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationDevice")]
            internal static extern global::System.IntPtr TF_OperationDevice(global::System.IntPtr oper);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationNumOutputs")]
            internal static extern int TF_OperationNumOutputs(global::System.IntPtr oper);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationOutputType")]
            internal static extern global::TensorFlow.TF_DataType TF_OperationOutputType(global::System.IntPtr oper_out);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationOutputListLength")]
            internal static extern int TF_OperationOutputListLength(global::System.IntPtr oper, [MarshalAs(UnmanagedType.LPStr)] string arg_name, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationNumInputs")]
            internal static extern int TF_OperationNumInputs(global::System.IntPtr oper);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationInputType")]
            internal static extern global::TensorFlow.TF_DataType TF_OperationInputType(global::System.IntPtr oper_in);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationInputListLength")]
            internal static extern int TF_OperationInputListLength(global::System.IntPtr oper, [MarshalAs(UnmanagedType.LPStr)] string arg_name, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationInput")]
            internal static extern void TF_OperationInput(global::System.IntPtr @return, global::System.IntPtr oper_in);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationOutputNumConsumers")]
            internal static extern int TF_OperationOutputNumConsumers(global::System.IntPtr oper_out);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationOutputConsumers")]
            internal static extern int TF_OperationOutputConsumers(global::System.IntPtr oper_out, global::System.IntPtr consumers, int max_consumers);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationNumControlInputs")]
            internal static extern int TF_OperationNumControlInputs(global::System.IntPtr oper);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationGetControlInputs")]
            internal static extern int TF_OperationGetControlInputs(global::System.IntPtr oper, global::System.IntPtr control_inputs, int max_control_inputs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationNumControlOutputs")]
            internal static extern int TF_OperationNumControlOutputs(global::System.IntPtr oper);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationGetControlOutputs")]
            internal static extern int TF_OperationGetControlOutputs(global::System.IntPtr oper, global::System.IntPtr control_outputs, int max_control_outputs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationGetAttrMetadata")]
            internal static extern global::TensorFlow.TF_AttrMetadata.__Internal TF_OperationGetAttrMetadata(global::System.IntPtr oper, [MarshalAs(UnmanagedType.LPStr)] string attr_name, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationGetAttrString")]
            internal static extern void TF_OperationGetAttrString(global::System.IntPtr oper, [MarshalAs(UnmanagedType.LPStr)] string attr_name, global::System.IntPtr value, ulong max_length, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationGetAttrStringList")]
            internal static extern void TF_OperationGetAttrStringList(global::System.IntPtr oper, [MarshalAs(UnmanagedType.LPStr)] string attr_name, void** values, ulong* lengths, int max_values, global::System.IntPtr storage, ulong storage_size, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationGetAttrInt")]
            internal static extern void TF_OperationGetAttrInt(global::System.IntPtr oper, [MarshalAs(UnmanagedType.LPStr)] string attr_name, long* value, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationGetAttrIntList")]
            internal static extern void TF_OperationGetAttrIntList(global::System.IntPtr oper, [MarshalAs(UnmanagedType.LPStr)] string attr_name, long* values, int max_values, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationGetAttrFloat")]
            internal static extern void TF_OperationGetAttrFloat(global::System.IntPtr oper, [MarshalAs(UnmanagedType.LPStr)] string attr_name, float* value, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationGetAttrFloatList")]
            internal static extern void TF_OperationGetAttrFloatList(global::System.IntPtr oper, [MarshalAs(UnmanagedType.LPStr)] string attr_name, float* values, int max_values, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationGetAttrBool")]
            internal static extern void TF_OperationGetAttrBool(global::System.IntPtr oper, [MarshalAs(UnmanagedType.LPStr)] string attr_name, byte* value, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationGetAttrBoolList")]
            internal static extern void TF_OperationGetAttrBoolList(global::System.IntPtr oper, [MarshalAs(UnmanagedType.LPStr)] string attr_name, byte* values, int max_values, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationGetAttrType")]
            internal static extern void TF_OperationGetAttrType(global::System.IntPtr oper, [MarshalAs(UnmanagedType.LPStr)] string attr_name, global::TensorFlow.TF_DataType* value, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationGetAttrTypeList")]
            internal static extern void TF_OperationGetAttrTypeList(global::System.IntPtr oper, [MarshalAs(UnmanagedType.LPStr)] string attr_name, global::TensorFlow.TF_DataType* values, int max_values, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationGetAttrShape")]
            internal static extern void TF_OperationGetAttrShape(global::System.IntPtr oper, [MarshalAs(UnmanagedType.LPStr)] string attr_name, long* value, int num_dims, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationGetAttrShapeList")]
            internal static extern void TF_OperationGetAttrShapeList(global::System.IntPtr oper, [MarshalAs(UnmanagedType.LPStr)] string attr_name, long** dims, int* num_dims, int num_shapes, long* storage, int storage_size, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationGetAttrTensorShapeProto")]
            internal static extern void TF_OperationGetAttrTensorShapeProto(global::System.IntPtr oper, [MarshalAs(UnmanagedType.LPStr)] string attr_name, global::System.IntPtr value, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationGetAttrTensorShapeProtoList")]
            internal static extern void TF_OperationGetAttrTensorShapeProtoList(global::System.IntPtr oper, [MarshalAs(UnmanagedType.LPStr)] string attr_name, global::System.IntPtr values, int max_values, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationGetAttrTensor")]
            internal static extern void TF_OperationGetAttrTensor(global::System.IntPtr oper, [MarshalAs(UnmanagedType.LPStr)] string attr_name, global::System.IntPtr value, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationGetAttrTensorList")]
            internal static extern void TF_OperationGetAttrTensorList(global::System.IntPtr oper, [MarshalAs(UnmanagedType.LPStr)] string attr_name, global::System.IntPtr values, int max_values, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationGetAttrValueProto")]
            internal static extern void TF_OperationGetAttrValueProto(global::System.IntPtr oper, [MarshalAs(UnmanagedType.LPStr)] string attr_name, global::System.IntPtr output_attr_value, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GraphOperationByName")]
            internal static extern global::System.IntPtr TF_GraphOperationByName(global::System.IntPtr graph, [MarshalAs(UnmanagedType.LPStr)] string oper_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GraphNextOperation")]
            internal static extern global::System.IntPtr TF_GraphNextOperation(global::System.IntPtr graph, ulong* pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GraphToGraphDef")]
            internal static extern void TF_GraphToGraphDef(global::System.IntPtr graph, global::System.IntPtr output_graph_def, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GraphGetOpDef")]
            internal static extern void TF_GraphGetOpDef(global::System.IntPtr graph, [MarshalAs(UnmanagedType.LPStr)] string op_name, global::System.IntPtr output_op_def, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GraphVersions")]
            internal static extern void TF_GraphVersions(global::System.IntPtr graph, global::System.IntPtr output_version_def, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_NewImportGraphDefOptions")]
            internal static extern global::System.IntPtr TF_NewImportGraphDefOptions();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeleteImportGraphDefOptions")]
            internal static extern void TF_DeleteImportGraphDefOptions(global::System.IntPtr opts);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ImportGraphDefOptionsSetPrefix")]
            internal static extern void TF_ImportGraphDefOptionsSetPrefix(global::System.IntPtr opts, [MarshalAs(UnmanagedType.LPStr)] string prefix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ImportGraphDefOptionsSetDefaultDevice")]
            internal static extern void TF_ImportGraphDefOptionsSetDefaultDevice(global::System.IntPtr opts, [MarshalAs(UnmanagedType.LPStr)] string device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ImportGraphDefOptionsSetUniquifyNames")]
            internal static extern void TF_ImportGraphDefOptionsSetUniquifyNames(global::System.IntPtr opts, byte uniquify_names);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ImportGraphDefOptionsSetUniquifyPrefix")]
            internal static extern void TF_ImportGraphDefOptionsSetUniquifyPrefix(global::System.IntPtr opts, byte uniquify_prefix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ImportGraphDefOptionsAddInputMapping")]
            internal static extern void TF_ImportGraphDefOptionsAddInputMapping(global::System.IntPtr opts, [MarshalAs(UnmanagedType.LPStr)] string src_name, int src_index, global::TensorFlow.TF_Output.__Internal dst);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ImportGraphDefOptionsRemapControlDependency")]
            internal static extern void TF_ImportGraphDefOptionsRemapControlDependency(global::System.IntPtr opts, [MarshalAs(UnmanagedType.LPStr)] string src_name, global::System.IntPtr dst);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ImportGraphDefOptionsAddControlDependency")]
            internal static extern void TF_ImportGraphDefOptionsAddControlDependency(global::System.IntPtr opts, global::System.IntPtr oper);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ImportGraphDefOptionsAddReturnOutput")]
            internal static extern void TF_ImportGraphDefOptionsAddReturnOutput(global::System.IntPtr opts, [MarshalAs(UnmanagedType.LPStr)] string oper_name, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ImportGraphDefOptionsNumReturnOutputs")]
            internal static extern int TF_ImportGraphDefOptionsNumReturnOutputs(global::System.IntPtr opts);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ImportGraphDefOptionsAddReturnOperation")]
            internal static extern void TF_ImportGraphDefOptionsAddReturnOperation(global::System.IntPtr opts, [MarshalAs(UnmanagedType.LPStr)] string oper_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ImportGraphDefOptionsNumReturnOperations")]
            internal static extern int TF_ImportGraphDefOptionsNumReturnOperations(global::System.IntPtr opts);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ImportGraphDefResultsReturnOutputs")]
            internal static extern void TF_ImportGraphDefResultsReturnOutputs(global::System.IntPtr results, int* num_outputs, global::System.IntPtr outputs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ImportGraphDefResultsReturnOperations")]
            internal static extern void TF_ImportGraphDefResultsReturnOperations(global::System.IntPtr results, int* num_opers, global::System.IntPtr opers);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ImportGraphDefResultsMissingUnusedInputMappings")]
            internal static extern void TF_ImportGraphDefResultsMissingUnusedInputMappings(global::System.IntPtr results, int* num_missing_unused_input_mappings, sbyte*** src_names, int** src_indexes);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeleteImportGraphDefResults")]
            internal static extern void TF_DeleteImportGraphDefResults(global::System.IntPtr results);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GraphImportGraphDefWithResults")]
            internal static extern global::System.IntPtr TF_GraphImportGraphDefWithResults(global::System.IntPtr graph, global::System.IntPtr graph_def, global::System.IntPtr options, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GraphImportGraphDefWithReturnOutputs")]
            internal static extern void TF_GraphImportGraphDefWithReturnOutputs(global::System.IntPtr graph, global::System.IntPtr graph_def, global::System.IntPtr options, global::System.IntPtr return_outputs, int num_return_outputs, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GraphImportGraphDef")]
            internal static extern void TF_GraphImportGraphDef(global::System.IntPtr graph, global::System.IntPtr graph_def, global::System.IntPtr options, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GraphCopyFunction")]
            internal static extern void TF_GraphCopyFunction(global::System.IntPtr g, global::System.IntPtr func, global::System.IntPtr grad, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GraphNumFunctions")]
            internal static extern int TF_GraphNumFunctions(global::System.IntPtr g);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GraphGetFunctions")]
            internal static extern int TF_GraphGetFunctions(global::System.IntPtr g, global::System.IntPtr funcs, int max_func, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_OperationToNodeDef")]
            internal static extern void TF_OperationToNodeDef(global::System.IntPtr oper, global::System.IntPtr output_node_def, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_NewWhile")]
            internal static extern global::TensorFlow.TF_WhileParams.__Internal TF_NewWhile(global::System.IntPtr g, global::System.IntPtr inputs, int ninputs, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_FinishWhile")]
            internal static extern void TF_FinishWhile(global::System.IntPtr @params, global::System.IntPtr status, global::System.IntPtr outputs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_AbortWhile")]
            internal static extern void TF_AbortWhile(global::System.IntPtr @params);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_AddGradients")]
            internal static extern void TF_AddGradients(global::System.IntPtr g, global::System.IntPtr y, int ny, global::System.IntPtr x, int nx, global::System.IntPtr dx, global::System.IntPtr status, global::System.IntPtr dy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_AddGradientsWithPrefix")]
            internal static extern void TF_AddGradientsWithPrefix(global::System.IntPtr g, [MarshalAs(UnmanagedType.LPStr)] string prefix, global::System.IntPtr y, int ny, global::System.IntPtr x, int nx, global::System.IntPtr dx, global::System.IntPtr status, global::System.IntPtr dy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GraphToFunction")]
            internal static extern global::System.IntPtr TF_GraphToFunction(global::System.IntPtr fn_body, [MarshalAs(UnmanagedType.LPStr)] string fn_name, byte append_hash_to_fn_name, int num_opers, global::System.IntPtr opers, int ninputs, global::System.IntPtr inputs, int noutputs, global::System.IntPtr outputs, sbyte** output_names, global::System.IntPtr opts, [MarshalAs(UnmanagedType.LPStr)] string description, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GraphToFunctionWithControlOutputs")]
            internal static extern global::System.IntPtr TF_GraphToFunctionWithControlOutputs(global::System.IntPtr fn_body, [MarshalAs(UnmanagedType.LPStr)] string fn_name, byte append_hash_to_fn_name, int num_opers, global::System.IntPtr opers, int ninputs, global::System.IntPtr inputs, int noutputs, global::System.IntPtr outputs, sbyte** output_names, int ncontrol_outputs, global::System.IntPtr control_outputs, sbyte** control_output_names, global::System.IntPtr opts, [MarshalAs(UnmanagedType.LPStr)] string description, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_FunctionName")]
            internal static extern global::System.IntPtr TF_FunctionName(global::System.IntPtr func);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_FunctionToFunctionDef")]
            internal static extern void TF_FunctionToFunctionDef(global::System.IntPtr func, global::System.IntPtr output_func_def, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_FunctionImportFunctionDef")]
            internal static extern global::System.IntPtr TF_FunctionImportFunctionDef(global::System.IntPtr proto, ulong proto_len, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_FunctionSetAttrValueProto")]
            internal static extern void TF_FunctionSetAttrValueProto(global::System.IntPtr func, [MarshalAs(UnmanagedType.LPStr)] string attr_name, global::System.IntPtr proto, ulong proto_len, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_FunctionGetAttrValueProto")]
            internal static extern void TF_FunctionGetAttrValueProto(global::System.IntPtr func, [MarshalAs(UnmanagedType.LPStr)] string attr_name, global::System.IntPtr output_attr_value, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeleteFunction")]
            internal static extern void TF_DeleteFunction(global::System.IntPtr func);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_TryEvaluateConstant")]
            internal static extern byte TF_TryEvaluateConstant(global::System.IntPtr graph, global::TensorFlow.TF_Output.__Internal output, global::System.IntPtr result, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_NewSession")]
            internal static extern global::System.IntPtr TF_NewSession(global::System.IntPtr graph, global::System.IntPtr opts, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_LoadSessionFromSavedModel")]
            internal static extern global::System.IntPtr TF_LoadSessionFromSavedModel(global::System.IntPtr session_options, global::System.IntPtr run_options, [MarshalAs(UnmanagedType.LPStr)] string export_dir, sbyte** tags, int tags_len, global::System.IntPtr graph, global::System.IntPtr meta_graph_def, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_CloseSession")]
            internal static extern void TF_CloseSession(global::System.IntPtr _0, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeleteSession")]
            internal static extern void TF_DeleteSession(global::System.IntPtr _0, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SessionRun")]
            internal static extern void TF_SessionRun(global::System.IntPtr session, global::System.IntPtr run_options, global::System.IntPtr inputs, global::System.IntPtr input_values, int ninputs, global::System.IntPtr outputs, global::System.IntPtr output_values, int noutputs, global::System.IntPtr target_opers, int ntargets, global::System.IntPtr run_metadata, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SessionPRunSetup")]
            internal static extern void TF_SessionPRunSetup(global::System.IntPtr _0, global::System.IntPtr inputs, int ninputs, global::System.IntPtr outputs, int noutputs, global::System.IntPtr target_opers, int ntargets, sbyte** handle, global::System.IntPtr _1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SessionPRun")]
            internal static extern void TF_SessionPRun(global::System.IntPtr _0, [MarshalAs(UnmanagedType.LPStr)] string handle, global::System.IntPtr inputs, global::System.IntPtr input_values, int ninputs, global::System.IntPtr outputs, global::System.IntPtr output_values, int noutputs, global::System.IntPtr target_opers, int ntargets, global::System.IntPtr _1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeletePRunHandle")]
            internal static extern void TF_DeletePRunHandle([MarshalAs(UnmanagedType.LPStr)] string handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_NewDeprecatedSession")]
            internal static extern global::System.IntPtr TF_NewDeprecatedSession(global::System.IntPtr _0, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_CloseDeprecatedSession")]
            internal static extern void TF_CloseDeprecatedSession(global::System.IntPtr _0, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeleteDeprecatedSession")]
            internal static extern void TF_DeleteDeprecatedSession(global::System.IntPtr _0, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_Reset")]
            internal static extern void TF_Reset(global::System.IntPtr opt, sbyte** containers, int ncontainers, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ExtendGraph")]
            internal static extern void TF_ExtendGraph(global::System.IntPtr _0, global::System.IntPtr proto, ulong proto_len, global::System.IntPtr _1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_Run")]
            internal static extern void TF_Run(global::System.IntPtr _0, global::System.IntPtr run_options, sbyte** input_names, global::System.IntPtr inputs, int ninputs, sbyte** output_names, global::System.IntPtr outputs, int noutputs, sbyte** target_oper_names, int ntargets, global::System.IntPtr run_metadata, global::System.IntPtr _1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_PRunSetup")]
            internal static extern void TF_PRunSetup(global::System.IntPtr _0, sbyte** input_names, int ninputs, sbyte** output_names, int noutputs, sbyte** target_oper_names, int ntargets, sbyte** handle, global::System.IntPtr _1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_PRun")]
            internal static extern void TF_PRun(global::System.IntPtr _0, [MarshalAs(UnmanagedType.LPStr)] string handle, sbyte** input_names, global::System.IntPtr inputs, int ninputs, sbyte** output_names, global::System.IntPtr outputs, int noutputs, sbyte** target_oper_names, int ntargets, global::System.IntPtr _1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_SessionListDevices")]
            internal static extern global::System.IntPtr TF_SessionListDevices(global::System.IntPtr session, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeprecatedSessionListDevices")]
            internal static extern global::System.IntPtr TF_DeprecatedSessionListDevices(global::System.IntPtr session, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeleteDeviceList")]
            internal static extern void TF_DeleteDeviceList(global::System.IntPtr list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeviceListCount")]
            internal static extern int TF_DeviceListCount(global::System.IntPtr list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeviceListName")]
            internal static extern global::System.IntPtr TF_DeviceListName(global::System.IntPtr list, int index, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeviceListType")]
            internal static extern global::System.IntPtr TF_DeviceListType(global::System.IntPtr list, int index, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeviceListMemoryBytes")]
            internal static extern long TF_DeviceListMemoryBytes(global::System.IntPtr list, int index, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeviceListIncarnation")]
            internal static extern ulong TF_DeviceListIncarnation(global::System.IntPtr list, int index, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_LoadLibrary")]
            internal static extern global::System.IntPtr TF_LoadLibrary([MarshalAs(UnmanagedType.LPStr)] string library_filename, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GetOpList")]
            internal static extern global::TensorFlow.TF_Buffer.__Internal TF_GetOpList(global::System.IntPtr lib_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeleteLibraryHandle")]
            internal static extern void TF_DeleteLibraryHandle(global::System.IntPtr lib_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GetAllOpList")]
            internal static extern global::System.IntPtr TF_GetAllOpList();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_NewApiDefMap")]
            internal static extern global::System.IntPtr TF_NewApiDefMap(global::System.IntPtr op_list_buffer, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeleteApiDefMap")]
            internal static extern void TF_DeleteApiDefMap(global::System.IntPtr apimap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ApiDefMapPut")]
            internal static extern void TF_ApiDefMapPut(global::System.IntPtr api_def_map, [MarshalAs(UnmanagedType.LPStr)] string text, ulong text_len, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ApiDefMapGet")]
            internal static extern global::System.IntPtr TF_ApiDefMapGet(global::System.IntPtr api_def_map, [MarshalAs(UnmanagedType.LPStr)] string name, ulong name_len, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GetAllRegisteredKernels")]
            internal static extern global::System.IntPtr TF_GetAllRegisteredKernels(global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_GetRegisteredKernelsForOp")]
            internal static extern global::System.IntPtr TF_GetRegisteredKernelsForOp([MarshalAs(UnmanagedType.LPStr)] string name, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_NewServer")]
            internal static extern global::System.IntPtr TF_NewServer(global::System.IntPtr proto, ulong proto_len, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ServerStart")]
            internal static extern void TF_ServerStart(global::System.IntPtr server, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ServerStop")]
            internal static extern void TF_ServerStop(global::System.IntPtr server, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ServerJoin")]
            internal static extern void TF_ServerJoin(global::System.IntPtr server, global::System.IntPtr status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_ServerTarget")]
            internal static extern global::System.IntPtr TF_ServerTarget(global::System.IntPtr server);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_DeleteServer")]
            internal static extern void TF_DeleteServer(global::System.IntPtr server);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("tensorflow", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TF_RegisterLogListener")]
            internal static extern void TF_RegisterLogListener(global::System.IntPtr listener);
        }

        public static string TF_Version()
        {
            var __ret = __Internal.TF_Version();
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static global::TensorFlow.TF_Buffer TF_NewBufferFromString(global::System.IntPtr proto, ulong proto_len)
        {
            var __ret = __Internal.TF_NewBufferFromString(proto, proto_len);
            global::TensorFlow.TF_Buffer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_Buffer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_Buffer) global::TensorFlow.TF_Buffer.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_Buffer.__CreateInstance(__ret);
            return __result0;
        }

        public static global::TensorFlow.TF_Buffer TF_NewBuffer()
        {
            var __ret = __Internal.TF_NewBuffer();
            global::TensorFlow.TF_Buffer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_Buffer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_Buffer) global::TensorFlow.TF_Buffer.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_Buffer.__CreateInstance(__ret);
            return __result0;
        }

        public static void TF_DeleteBuffer(global::TensorFlow.TF_Buffer _0)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            __Internal.TF_DeleteBuffer(__arg0);
        }

        public static global::TensorFlow.TF_Buffer TF_GetBuffer(global::TensorFlow.TF_Buffer buffer)
        {
            var __arg0 = ReferenceEquals(buffer, null) ? global::System.IntPtr.Zero : buffer.__Instance;
            var __ret = new global::TensorFlow.TF_Buffer.__Internal();
            __Internal.TF_GetBuffer(new IntPtr(&__ret), __arg0);
            return global::TensorFlow.TF_Buffer.__CreateInstance(__ret);
        }

        public static global::TensorFlow.TF_SessionOptions TF_NewSessionOptions()
        {
            var __ret = __Internal.TF_NewSessionOptions();
            global::TensorFlow.TF_SessionOptions __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_SessionOptions.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_SessionOptions) global::TensorFlow.TF_SessionOptions.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_SessionOptions.__CreateInstance(__ret);
            return __result0;
        }

        public static void TF_SetTarget(global::TensorFlow.TF_SessionOptions options, string target)
        {
            var __arg0 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            __Internal.TF_SetTarget(__arg0, target);
        }

        public static void TF_SetConfig(global::TensorFlow.TF_SessionOptions options, global::System.IntPtr proto, ulong proto_len, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            var __arg3 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_SetConfig(__arg0, proto, proto_len, __arg3);
        }

        public static void TF_DeleteSessionOptions(global::TensorFlow.TF_SessionOptions _0)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            __Internal.TF_DeleteSessionOptions(__arg0);
        }

        public static global::TensorFlow.TF_Graph TF_NewGraph()
        {
            var __ret = __Internal.TF_NewGraph();
            global::TensorFlow.TF_Graph __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_Graph.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_Graph) global::TensorFlow.TF_Graph.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_Graph.__CreateInstance(__ret);
            return __result0;
        }

        public static void TF_DeleteGraph(global::TensorFlow.TF_Graph _0)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            __Internal.TF_DeleteGraph(__arg0);
        }

        public static void TF_GraphSetTensorShape(global::TensorFlow.TF_Graph graph, global::TensorFlow.TF_Output output, ref long dims, int num_dims, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(graph, null) ? global::System.IntPtr.Zero : graph.__Instance;
            if (ReferenceEquals(output, null))
                throw new global::System.ArgumentNullException("output", "Cannot be null because it is passed by value.");
            var __arg1 = output.__Instance;
            fixed (long* __dims2 = &dims)
            {
                var __arg2 = __dims2;
                var __arg4 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
                __Internal.TF_GraphSetTensorShape(__arg0, *(global::TensorFlow.TF_Output.__Internal*) __arg1, __arg2, num_dims, __arg4);
            }
        }

        public static int TF_GraphGetTensorNumDims(global::TensorFlow.TF_Graph graph, global::TensorFlow.TF_Output output, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(graph, null) ? global::System.IntPtr.Zero : graph.__Instance;
            if (ReferenceEquals(output, null))
                throw new global::System.ArgumentNullException("output", "Cannot be null because it is passed by value.");
            var __arg1 = output.__Instance;
            var __arg2 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_GraphGetTensorNumDims(__arg0, *(global::TensorFlow.TF_Output.__Internal*) __arg1, __arg2);
            return __ret;
        }

        public static void TF_GraphGetTensorShape(global::TensorFlow.TF_Graph graph, global::TensorFlow.TF_Output output, ref long dims, int num_dims, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(graph, null) ? global::System.IntPtr.Zero : graph.__Instance;
            if (ReferenceEquals(output, null))
                throw new global::System.ArgumentNullException("output", "Cannot be null because it is passed by value.");
            var __arg1 = output.__Instance;
            fixed (long* __dims2 = &dims)
            {
                var __arg2 = __dims2;
                var __arg4 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
                __Internal.TF_GraphGetTensorShape(__arg0, *(global::TensorFlow.TF_Output.__Internal*) __arg1, __arg2, num_dims, __arg4);
            }
        }

        public static global::TensorFlow.TF_OperationDescription TF_NewOperation(global::TensorFlow.TF_Graph graph, string op_type, string oper_name)
        {
            var __arg0 = ReferenceEquals(graph, null) ? global::System.IntPtr.Zero : graph.__Instance;
            var __ret = __Internal.TF_NewOperation(__arg0, op_type, oper_name);
            global::TensorFlow.TF_OperationDescription __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_OperationDescription.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_OperationDescription) global::TensorFlow.TF_OperationDescription.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_OperationDescription.__CreateInstance(__ret);
            return __result0;
        }

        public static void TF_SetDevice(global::TensorFlow.TF_OperationDescription desc, string device)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            __Internal.TF_SetDevice(__arg0, device);
        }

        public static void TF_AddInput(global::TensorFlow.TF_OperationDescription desc, global::TensorFlow.TF_Output input)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            if (ReferenceEquals(input, null))
                throw new global::System.ArgumentNullException("input", "Cannot be null because it is passed by value.");
            var __arg1 = input.__Instance;
            __Internal.TF_AddInput(__arg0, *(global::TensorFlow.TF_Output.__Internal*) __arg1);
        }

        public static void TF_AddInputList(global::TensorFlow.TF_OperationDescription desc, global::TensorFlow.TF_Output inputs, int num_inputs)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            var __arg1 = ReferenceEquals(inputs, null) ? global::System.IntPtr.Zero : inputs.__Instance;
            __Internal.TF_AddInputList(__arg0, __arg1, num_inputs);
        }

        public static void TF_AddControlInput(global::TensorFlow.TF_OperationDescription desc, global::TensorFlow.TF_Operation input)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            var __arg1 = ReferenceEquals(input, null) ? global::System.IntPtr.Zero : input.__Instance;
            __Internal.TF_AddControlInput(__arg0, __arg1);
        }

        public static void TF_ColocateWith(global::TensorFlow.TF_OperationDescription desc, global::TensorFlow.TF_Operation op)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            var __arg1 = ReferenceEquals(op, null) ? global::System.IntPtr.Zero : op.__Instance;
            __Internal.TF_ColocateWith(__arg0, __arg1);
        }

        public static void TF_SetAttrString(global::TensorFlow.TF_OperationDescription desc, string attr_name, global::System.IntPtr value, ulong length)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            __Internal.TF_SetAttrString(__arg0, attr_name, value, length);
        }

        public static void TF_SetAttrStringList(global::TensorFlow.TF_OperationDescription desc, string attr_name, void** values, ref ulong lengths, int num_values)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            fixed (ulong* __lengths3 = &lengths)
            {
                var __arg3 = __lengths3;
                __Internal.TF_SetAttrStringList(__arg0, attr_name, values, __arg3, num_values);
            }
        }

        public static void TF_SetAttrInt(global::TensorFlow.TF_OperationDescription desc, string attr_name, long value)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            __Internal.TF_SetAttrInt(__arg0, attr_name, value);
        }

        public static void TF_SetAttrIntList(global::TensorFlow.TF_OperationDescription desc, string attr_name, ref long values, int num_values)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            fixed (long* __values2 = &values)
            {
                var __arg2 = __values2;
                __Internal.TF_SetAttrIntList(__arg0, attr_name, __arg2, num_values);
            }
        }

        public static void TF_SetAttrFloat(global::TensorFlow.TF_OperationDescription desc, string attr_name, float value)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            __Internal.TF_SetAttrFloat(__arg0, attr_name, value);
        }

        public static void TF_SetAttrFloatList(global::TensorFlow.TF_OperationDescription desc, string attr_name, ref float values, int num_values)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            fixed (float* __values2 = &values)
            {
                var __arg2 = __values2;
                __Internal.TF_SetAttrFloatList(__arg0, attr_name, __arg2, num_values);
            }
        }

        public static void TF_SetAttrBool(global::TensorFlow.TF_OperationDescription desc, string attr_name, byte value)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            __Internal.TF_SetAttrBool(__arg0, attr_name, value);
        }

        public static void TF_SetAttrBoolList(global::TensorFlow.TF_OperationDescription desc, string attr_name, byte* values, int num_values)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            __Internal.TF_SetAttrBoolList(__arg0, attr_name, values, num_values);
        }

        public static void TF_SetAttrType(global::TensorFlow.TF_OperationDescription desc, string attr_name, global::TensorFlow.TF_DataType value)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            __Internal.TF_SetAttrType(__arg0, attr_name, value);
        }

        public static void TF_SetAttrTypeList(global::TensorFlow.TF_OperationDescription desc, string attr_name, global::TensorFlow.TF_DataType* values, int num_values)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            __Internal.TF_SetAttrTypeList(__arg0, attr_name, values, num_values);
        }

        public static void TF_SetAttrPlaceholder(global::TensorFlow.TF_OperationDescription desc, string attr_name, string placeholder)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            __Internal.TF_SetAttrPlaceholder(__arg0, attr_name, placeholder);
        }

        public static void TF_SetAttrFuncName(global::TensorFlow.TF_OperationDescription desc, string attr_name, string value, ulong length)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            __Internal.TF_SetAttrFuncName(__arg0, attr_name, value, length);
        }

        public static void TF_SetAttrShape(global::TensorFlow.TF_OperationDescription desc, string attr_name, ref long dims, int num_dims)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            fixed (long* __dims2 = &dims)
            {
                var __arg2 = __dims2;
                __Internal.TF_SetAttrShape(__arg0, attr_name, __arg2, num_dims);
            }
        }

        public static void TF_SetAttrShapeList(global::TensorFlow.TF_OperationDescription desc, string attr_name, long** dims, ref int num_dims, int num_shapes)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            fixed (int* __num_dims3 = &num_dims)
            {
                var __arg3 = __num_dims3;
                __Internal.TF_SetAttrShapeList(__arg0, attr_name, dims, __arg3, num_shapes);
            }
        }

        public static void TF_SetAttrTensorShapeProto(global::TensorFlow.TF_OperationDescription desc, string attr_name, global::System.IntPtr proto, ulong proto_len, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            var __arg4 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_SetAttrTensorShapeProto(__arg0, attr_name, proto, proto_len, __arg4);
        }

        public static void TF_SetAttrTensorShapeProtoList(global::TensorFlow.TF_OperationDescription desc, string attr_name, void** protos, ref ulong proto_lens, int num_shapes, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            fixed (ulong* __proto_lens3 = &proto_lens)
            {
                var __arg3 = __proto_lens3;
                var __arg5 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
                __Internal.TF_SetAttrTensorShapeProtoList(__arg0, attr_name, protos, __arg3, num_shapes, __arg5);
            }
        }

        public static void TF_SetAttrTensor(global::TensorFlow.TF_OperationDescription desc, string attr_name, global::TensorFlow.TF_Tensor value, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            var __arg2 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            var __arg3 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_SetAttrTensor(__arg0, attr_name, __arg2, __arg3);
        }

        public static void TF_SetAttrTensorList(global::TensorFlow.TF_OperationDescription desc, string attr_name, global::TensorFlow.TF_Tensor values, int num_values, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            var ____arg2 = ReferenceEquals(values, null) ? global::System.IntPtr.Zero : values.__Instance;
            var __arg2 = new global::System.IntPtr(&____arg2);
            var __arg4 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_SetAttrTensorList(__arg0, attr_name, __arg2, num_values, __arg4);
        }

        public static void TF_SetAttrValueProto(global::TensorFlow.TF_OperationDescription desc, string attr_name, global::System.IntPtr proto, ulong proto_len, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            var __arg4 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_SetAttrValueProto(__arg0, attr_name, proto, proto_len, __arg4);
        }

        public static global::TensorFlow.TF_Operation TF_FinishOperation(global::TensorFlow.TF_OperationDescription desc, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(desc, null) ? global::System.IntPtr.Zero : desc.__Instance;
            var __arg1 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_FinishOperation(__arg0, __arg1);
            global::TensorFlow.TF_Operation __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_Operation.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_Operation) global::TensorFlow.TF_Operation.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_Operation.__CreateInstance(__ret);
            return __result0;
        }

        public static string TF_OperationName(global::TensorFlow.TF_Operation oper)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var __ret = __Internal.TF_OperationName(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static string TF_OperationOpType(global::TensorFlow.TF_Operation oper)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var __ret = __Internal.TF_OperationOpType(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static string TF_OperationDevice(global::TensorFlow.TF_Operation oper)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var __ret = __Internal.TF_OperationDevice(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static int TF_OperationNumOutputs(global::TensorFlow.TF_Operation oper)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var __ret = __Internal.TF_OperationNumOutputs(__arg0);
            return __ret;
        }

        public static global::TensorFlow.TF_DataType TF_OperationOutputType(global::TensorFlow.TF_Output oper_out)
        {
            if (ReferenceEquals(oper_out, null))
                throw new global::System.ArgumentNullException("oper_out", "Cannot be null because it is passed by value.");
            var __arg0 = oper_out.__Instance;
            var __ret = __Internal.TF_OperationOutputType(__arg0);
            return __ret;
        }

        public static int TF_OperationOutputListLength(global::TensorFlow.TF_Operation oper, string arg_name, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var __arg2 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_OperationOutputListLength(__arg0, arg_name, __arg2);
            return __ret;
        }

        public static int TF_OperationNumInputs(global::TensorFlow.TF_Operation oper)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var __ret = __Internal.TF_OperationNumInputs(__arg0);
            return __ret;
        }

        public static global::TensorFlow.TF_DataType TF_OperationInputType(global::TensorFlow.TF_Input oper_in)
        {
            if (ReferenceEquals(oper_in, null))
                throw new global::System.ArgumentNullException("oper_in", "Cannot be null because it is passed by value.");
            var __arg0 = oper_in.__Instance;
            var __ret = __Internal.TF_OperationInputType(__arg0);
            return __ret;
        }

        public static int TF_OperationInputListLength(global::TensorFlow.TF_Operation oper, string arg_name, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var __arg2 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_OperationInputListLength(__arg0, arg_name, __arg2);
            return __ret;
        }

        public static global::TensorFlow.TF_Output TF_OperationInput(global::TensorFlow.TF_Input oper_in)
        {
            if (ReferenceEquals(oper_in, null))
                throw new global::System.ArgumentNullException("oper_in", "Cannot be null because it is passed by value.");
            var __arg0 = oper_in.__Instance;
            var __ret = new global::TensorFlow.TF_Output.__Internal();
            __Internal.TF_OperationInput(new IntPtr(&__ret), __arg0);
            return global::TensorFlow.TF_Output.__CreateInstance(__ret);
        }

        public static int TF_OperationOutputNumConsumers(global::TensorFlow.TF_Output oper_out)
        {
            if (ReferenceEquals(oper_out, null))
                throw new global::System.ArgumentNullException("oper_out", "Cannot be null because it is passed by value.");
            var __arg0 = oper_out.__Instance;
            var __ret = __Internal.TF_OperationOutputNumConsumers(__arg0);
            return __ret;
        }

        public static int TF_OperationOutputConsumers(global::TensorFlow.TF_Output oper_out, global::TensorFlow.TF_Input consumers, int max_consumers)
        {
            if (ReferenceEquals(oper_out, null))
                throw new global::System.ArgumentNullException("oper_out", "Cannot be null because it is passed by value.");
            var __arg0 = oper_out.__Instance;
            var __arg1 = ReferenceEquals(consumers, null) ? global::System.IntPtr.Zero : consumers.__Instance;
            var __ret = __Internal.TF_OperationOutputConsumers(__arg0, __arg1, max_consumers);
            return __ret;
        }

        public static int TF_OperationNumControlInputs(global::TensorFlow.TF_Operation oper)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var __ret = __Internal.TF_OperationNumControlInputs(__arg0);
            return __ret;
        }

        public static int TF_OperationGetControlInputs(global::TensorFlow.TF_Operation oper, global::TensorFlow.TF_Operation control_inputs, int max_control_inputs)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var ____arg1 = ReferenceEquals(control_inputs, null) ? global::System.IntPtr.Zero : control_inputs.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.TF_OperationGetControlInputs(__arg0, __arg1, max_control_inputs);
            return __ret;
        }

        public static int TF_OperationNumControlOutputs(global::TensorFlow.TF_Operation oper)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var __ret = __Internal.TF_OperationNumControlOutputs(__arg0);
            return __ret;
        }

        public static int TF_OperationGetControlOutputs(global::TensorFlow.TF_Operation oper, global::TensorFlow.TF_Operation control_outputs, int max_control_outputs)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var ____arg1 = ReferenceEquals(control_outputs, null) ? global::System.IntPtr.Zero : control_outputs.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.TF_OperationGetControlOutputs(__arg0, __arg1, max_control_outputs);
            return __ret;
        }

        public static global::TensorFlow.TF_AttrMetadata TF_OperationGetAttrMetadata(global::TensorFlow.TF_Operation oper, string attr_name, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var __arg2 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_OperationGetAttrMetadata(__arg0, attr_name, __arg2);
            return global::TensorFlow.TF_AttrMetadata.__CreateInstance(__ret);
        }

        public static void TF_OperationGetAttrString(global::TensorFlow.TF_Operation oper, string attr_name, global::System.IntPtr value, ulong max_length, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var __arg4 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_OperationGetAttrString(__arg0, attr_name, value, max_length, __arg4);
        }

        public static void TF_OperationGetAttrStringList(global::TensorFlow.TF_Operation oper, string attr_name, void** values, ref ulong lengths, int max_values, global::System.IntPtr storage, ulong storage_size, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            fixed (ulong* __lengths3 = &lengths)
            {
                var __arg3 = __lengths3;
                var __arg7 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
                __Internal.TF_OperationGetAttrStringList(__arg0, attr_name, values, __arg3, max_values, storage, storage_size, __arg7);
            }
        }

        public static void TF_OperationGetAttrInt(global::TensorFlow.TF_Operation oper, string attr_name, ref long value, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            fixed (long* __value2 = &value)
            {
                var __arg2 = __value2;
                var __arg3 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
                __Internal.TF_OperationGetAttrInt(__arg0, attr_name, __arg2, __arg3);
            }
        }

        public static void TF_OperationGetAttrIntList(global::TensorFlow.TF_Operation oper, string attr_name, ref long values, int max_values, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            fixed (long* __values2 = &values)
            {
                var __arg2 = __values2;
                var __arg4 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
                __Internal.TF_OperationGetAttrIntList(__arg0, attr_name, __arg2, max_values, __arg4);
            }
        }

        public static void TF_OperationGetAttrFloat(global::TensorFlow.TF_Operation oper, string attr_name, ref float value, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            fixed (float* __value2 = &value)
            {
                var __arg2 = __value2;
                var __arg3 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
                __Internal.TF_OperationGetAttrFloat(__arg0, attr_name, __arg2, __arg3);
            }
        }

        public static void TF_OperationGetAttrFloatList(global::TensorFlow.TF_Operation oper, string attr_name, ref float values, int max_values, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            fixed (float* __values2 = &values)
            {
                var __arg2 = __values2;
                var __arg4 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
                __Internal.TF_OperationGetAttrFloatList(__arg0, attr_name, __arg2, max_values, __arg4);
            }
        }

        public static void TF_OperationGetAttrBool(global::TensorFlow.TF_Operation oper, string attr_name, byte* value, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var __arg3 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_OperationGetAttrBool(__arg0, attr_name, value, __arg3);
        }

        public static void TF_OperationGetAttrBoolList(global::TensorFlow.TF_Operation oper, string attr_name, byte* values, int max_values, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var __arg4 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_OperationGetAttrBoolList(__arg0, attr_name, values, max_values, __arg4);
        }

        public static void TF_OperationGetAttrType(global::TensorFlow.TF_Operation oper, string attr_name, global::TensorFlow.TF_DataType* value, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var __arg3 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_OperationGetAttrType(__arg0, attr_name, value, __arg3);
        }

        public static void TF_OperationGetAttrTypeList(global::TensorFlow.TF_Operation oper, string attr_name, global::TensorFlow.TF_DataType* values, int max_values, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var __arg4 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_OperationGetAttrTypeList(__arg0, attr_name, values, max_values, __arg4);
        }

        public static void TF_OperationGetAttrShape(global::TensorFlow.TF_Operation oper, string attr_name, ref long value, int num_dims, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            fixed (long* __value2 = &value)
            {
                var __arg2 = __value2;
                var __arg4 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
                __Internal.TF_OperationGetAttrShape(__arg0, attr_name, __arg2, num_dims, __arg4);
            }
        }

        public static void TF_OperationGetAttrShapeList(global::TensorFlow.TF_Operation oper, string attr_name, long** dims, ref int num_dims, int num_shapes, ref long storage, int storage_size, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            fixed (int* __num_dims3 = &num_dims)
            {
                var __arg3 = __num_dims3;
                fixed (long* __storage5 = &storage)
                {
                    var __arg5 = __storage5;
                    var __arg7 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
                    __Internal.TF_OperationGetAttrShapeList(__arg0, attr_name, dims, __arg3, num_shapes, __arg5, storage_size, __arg7);
                }
            }
        }

        public static void TF_OperationGetAttrTensorShapeProto(global::TensorFlow.TF_Operation oper, string attr_name, global::TensorFlow.TF_Buffer value, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var __arg2 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            var __arg3 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_OperationGetAttrTensorShapeProto(__arg0, attr_name, __arg2, __arg3);
        }

        public static void TF_OperationGetAttrTensorShapeProtoList(global::TensorFlow.TF_Operation oper, string attr_name, global::TensorFlow.TF_Buffer values, int max_values, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var ____arg2 = ReferenceEquals(values, null) ? global::System.IntPtr.Zero : values.__Instance;
            var __arg2 = new global::System.IntPtr(&____arg2);
            var __arg4 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_OperationGetAttrTensorShapeProtoList(__arg0, attr_name, __arg2, max_values, __arg4);
        }

        public static void TF_OperationGetAttrTensor(global::TensorFlow.TF_Operation oper, string attr_name, global::TensorFlow.TF_Tensor value, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var ____arg2 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            var __arg2 = new global::System.IntPtr(&____arg2);
            var __arg3 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_OperationGetAttrTensor(__arg0, attr_name, __arg2, __arg3);
        }

        public static void TF_OperationGetAttrTensorList(global::TensorFlow.TF_Operation oper, string attr_name, global::TensorFlow.TF_Tensor values, int max_values, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var ____arg2 = ReferenceEquals(values, null) ? global::System.IntPtr.Zero : values.__Instance;
            var __arg2 = new global::System.IntPtr(&____arg2);
            var __arg4 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_OperationGetAttrTensorList(__arg0, attr_name, __arg2, max_values, __arg4);
        }

        public static void TF_OperationGetAttrValueProto(global::TensorFlow.TF_Operation oper, string attr_name, global::TensorFlow.TF_Buffer output_attr_value, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var __arg2 = ReferenceEquals(output_attr_value, null) ? global::System.IntPtr.Zero : output_attr_value.__Instance;
            var __arg3 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_OperationGetAttrValueProto(__arg0, attr_name, __arg2, __arg3);
        }

        public static global::TensorFlow.TF_Operation TF_GraphOperationByName(global::TensorFlow.TF_Graph graph, string oper_name)
        {
            var __arg0 = ReferenceEquals(graph, null) ? global::System.IntPtr.Zero : graph.__Instance;
            var __ret = __Internal.TF_GraphOperationByName(__arg0, oper_name);
            global::TensorFlow.TF_Operation __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_Operation.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_Operation) global::TensorFlow.TF_Operation.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_Operation.__CreateInstance(__ret);
            return __result0;
        }

        public static global::TensorFlow.TF_Operation TF_GraphNextOperation(global::TensorFlow.TF_Graph graph, ref ulong pos)
        {
            var __arg0 = ReferenceEquals(graph, null) ? global::System.IntPtr.Zero : graph.__Instance;
            fixed (ulong* __pos1 = &pos)
            {
                var __arg1 = __pos1;
                var __ret = __Internal.TF_GraphNextOperation(__arg0, __arg1);
                global::TensorFlow.TF_Operation __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::TensorFlow.TF_Operation.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::TensorFlow.TF_Operation) global::TensorFlow.TF_Operation.NativeToManagedMap[__ret];
                else __result0 = global::TensorFlow.TF_Operation.__CreateInstance(__ret);
                return __result0;
            }
        }

        public static void TF_GraphToGraphDef(global::TensorFlow.TF_Graph graph, global::TensorFlow.TF_Buffer output_graph_def, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(graph, null) ? global::System.IntPtr.Zero : graph.__Instance;
            var __arg1 = ReferenceEquals(output_graph_def, null) ? global::System.IntPtr.Zero : output_graph_def.__Instance;
            var __arg2 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_GraphToGraphDef(__arg0, __arg1, __arg2);
        }

        public static void TF_GraphGetOpDef(global::TensorFlow.TF_Graph graph, string op_name, global::TensorFlow.TF_Buffer output_op_def, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(graph, null) ? global::System.IntPtr.Zero : graph.__Instance;
            var __arg2 = ReferenceEquals(output_op_def, null) ? global::System.IntPtr.Zero : output_op_def.__Instance;
            var __arg3 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_GraphGetOpDef(__arg0, op_name, __arg2, __arg3);
        }

        public static void TF_GraphVersions(global::TensorFlow.TF_Graph graph, global::TensorFlow.TF_Buffer output_version_def, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(graph, null) ? global::System.IntPtr.Zero : graph.__Instance;
            var __arg1 = ReferenceEquals(output_version_def, null) ? global::System.IntPtr.Zero : output_version_def.__Instance;
            var __arg2 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_GraphVersions(__arg0, __arg1, __arg2);
        }

        public static global::TensorFlow.TF_ImportGraphDefOptions TF_NewImportGraphDefOptions()
        {
            var __ret = __Internal.TF_NewImportGraphDefOptions();
            global::TensorFlow.TF_ImportGraphDefOptions __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_ImportGraphDefOptions.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_ImportGraphDefOptions) global::TensorFlow.TF_ImportGraphDefOptions.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_ImportGraphDefOptions.__CreateInstance(__ret);
            return __result0;
        }

        public static void TF_DeleteImportGraphDefOptions(global::TensorFlow.TF_ImportGraphDefOptions opts)
        {
            var __arg0 = ReferenceEquals(opts, null) ? global::System.IntPtr.Zero : opts.__Instance;
            __Internal.TF_DeleteImportGraphDefOptions(__arg0);
        }

        public static void TF_ImportGraphDefOptionsSetPrefix(global::TensorFlow.TF_ImportGraphDefOptions opts, string prefix)
        {
            var __arg0 = ReferenceEquals(opts, null) ? global::System.IntPtr.Zero : opts.__Instance;
            __Internal.TF_ImportGraphDefOptionsSetPrefix(__arg0, prefix);
        }

        public static void TF_ImportGraphDefOptionsSetDefaultDevice(global::TensorFlow.TF_ImportGraphDefOptions opts, string device)
        {
            var __arg0 = ReferenceEquals(opts, null) ? global::System.IntPtr.Zero : opts.__Instance;
            __Internal.TF_ImportGraphDefOptionsSetDefaultDevice(__arg0, device);
        }

        public static void TF_ImportGraphDefOptionsSetUniquifyNames(global::TensorFlow.TF_ImportGraphDefOptions opts, byte uniquify_names)
        {
            var __arg0 = ReferenceEquals(opts, null) ? global::System.IntPtr.Zero : opts.__Instance;
            __Internal.TF_ImportGraphDefOptionsSetUniquifyNames(__arg0, uniquify_names);
        }

        public static void TF_ImportGraphDefOptionsSetUniquifyPrefix(global::TensorFlow.TF_ImportGraphDefOptions opts, byte uniquify_prefix)
        {
            var __arg0 = ReferenceEquals(opts, null) ? global::System.IntPtr.Zero : opts.__Instance;
            __Internal.TF_ImportGraphDefOptionsSetUniquifyPrefix(__arg0, uniquify_prefix);
        }

        public static void TF_ImportGraphDefOptionsAddInputMapping(global::TensorFlow.TF_ImportGraphDefOptions opts, string src_name, int src_index, global::TensorFlow.TF_Output dst)
        {
            var __arg0 = ReferenceEquals(opts, null) ? global::System.IntPtr.Zero : opts.__Instance;
            if (ReferenceEquals(dst, null))
                throw new global::System.ArgumentNullException("dst", "Cannot be null because it is passed by value.");
            var __arg3 = dst.__Instance;
            __Internal.TF_ImportGraphDefOptionsAddInputMapping(__arg0, src_name, src_index, *(global::TensorFlow.TF_Output.__Internal*) __arg3);
        }

        public static void TF_ImportGraphDefOptionsRemapControlDependency(global::TensorFlow.TF_ImportGraphDefOptions opts, string src_name, global::TensorFlow.TF_Operation dst)
        {
            var __arg0 = ReferenceEquals(opts, null) ? global::System.IntPtr.Zero : opts.__Instance;
            var __arg2 = ReferenceEquals(dst, null) ? global::System.IntPtr.Zero : dst.__Instance;
            __Internal.TF_ImportGraphDefOptionsRemapControlDependency(__arg0, src_name, __arg2);
        }

        public static void TF_ImportGraphDefOptionsAddControlDependency(global::TensorFlow.TF_ImportGraphDefOptions opts, global::TensorFlow.TF_Operation oper)
        {
            var __arg0 = ReferenceEquals(opts, null) ? global::System.IntPtr.Zero : opts.__Instance;
            var __arg1 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            __Internal.TF_ImportGraphDefOptionsAddControlDependency(__arg0, __arg1);
        }

        public static void TF_ImportGraphDefOptionsAddReturnOutput(global::TensorFlow.TF_ImportGraphDefOptions opts, string oper_name, int index)
        {
            var __arg0 = ReferenceEquals(opts, null) ? global::System.IntPtr.Zero : opts.__Instance;
            __Internal.TF_ImportGraphDefOptionsAddReturnOutput(__arg0, oper_name, index);
        }

        public static int TF_ImportGraphDefOptionsNumReturnOutputs(global::TensorFlow.TF_ImportGraphDefOptions opts)
        {
            var __arg0 = ReferenceEquals(opts, null) ? global::System.IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.TF_ImportGraphDefOptionsNumReturnOutputs(__arg0);
            return __ret;
        }

        public static void TF_ImportGraphDefOptionsAddReturnOperation(global::TensorFlow.TF_ImportGraphDefOptions opts, string oper_name)
        {
            var __arg0 = ReferenceEquals(opts, null) ? global::System.IntPtr.Zero : opts.__Instance;
            __Internal.TF_ImportGraphDefOptionsAddReturnOperation(__arg0, oper_name);
        }

        public static int TF_ImportGraphDefOptionsNumReturnOperations(global::TensorFlow.TF_ImportGraphDefOptions opts)
        {
            var __arg0 = ReferenceEquals(opts, null) ? global::System.IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.TF_ImportGraphDefOptionsNumReturnOperations(__arg0);
            return __ret;
        }

        public static void TF_ImportGraphDefResultsReturnOutputs(global::TensorFlow.TF_ImportGraphDefResults results, ref int num_outputs, global::TensorFlow.TF_Output outputs)
        {
            var __arg0 = ReferenceEquals(results, null) ? global::System.IntPtr.Zero : results.__Instance;
            fixed (int* __num_outputs1 = &num_outputs)
            {
                var __arg1 = __num_outputs1;
                var ____arg2 = ReferenceEquals(outputs, null) ? global::System.IntPtr.Zero : outputs.__Instance;
                var __arg2 = new global::System.IntPtr(&____arg2);
                __Internal.TF_ImportGraphDefResultsReturnOutputs(__arg0, __arg1, __arg2);
            }
        }

        public static void TF_ImportGraphDefResultsReturnOperations(global::TensorFlow.TF_ImportGraphDefResults results, ref int num_opers, global::TensorFlow.TF_Operation opers)
        {
            var __arg0 = ReferenceEquals(results, null) ? global::System.IntPtr.Zero : results.__Instance;
            fixed (int* __num_opers1 = &num_opers)
            {
                var __arg1 = __num_opers1;
                var ____arg2 = ReferenceEquals(opers, null) ? global::System.IntPtr.Zero : opers.__Instance;
                var __arg2 = new global::System.IntPtr(&____arg2);
                __Internal.TF_ImportGraphDefResultsReturnOperations(__arg0, __arg1, __arg2);
            }
        }

        public static void TF_ImportGraphDefResultsMissingUnusedInputMappings(global::TensorFlow.TF_ImportGraphDefResults results, ref int num_missing_unused_input_mappings, sbyte*** src_names, int** src_indexes)
        {
            var __arg0 = ReferenceEquals(results, null) ? global::System.IntPtr.Zero : results.__Instance;
            fixed (int* __num_missing_unused_input_mappings1 = &num_missing_unused_input_mappings)
            {
                var __arg1 = __num_missing_unused_input_mappings1;
                __Internal.TF_ImportGraphDefResultsMissingUnusedInputMappings(__arg0, __arg1, src_names, src_indexes);
            }
        }

        public static void TF_DeleteImportGraphDefResults(global::TensorFlow.TF_ImportGraphDefResults results)
        {
            var __arg0 = ReferenceEquals(results, null) ? global::System.IntPtr.Zero : results.__Instance;
            __Internal.TF_DeleteImportGraphDefResults(__arg0);
        }

        public static global::TensorFlow.TF_ImportGraphDefResults TF_GraphImportGraphDefWithResults(global::TensorFlow.TF_Graph graph, global::TensorFlow.TF_Buffer graph_def, global::TensorFlow.TF_ImportGraphDefOptions options, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(graph, null) ? global::System.IntPtr.Zero : graph.__Instance;
            var __arg1 = ReferenceEquals(graph_def, null) ? global::System.IntPtr.Zero : graph_def.__Instance;
            var __arg2 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            var __arg3 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_GraphImportGraphDefWithResults(__arg0, __arg1, __arg2, __arg3);
            global::TensorFlow.TF_ImportGraphDefResults __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_ImportGraphDefResults.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_ImportGraphDefResults) global::TensorFlow.TF_ImportGraphDefResults.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_ImportGraphDefResults.__CreateInstance(__ret);
            return __result0;
        }

        public static void TF_GraphImportGraphDefWithReturnOutputs(global::TensorFlow.TF_Graph graph, global::TensorFlow.TF_Buffer graph_def, global::TensorFlow.TF_ImportGraphDefOptions options, global::TensorFlow.TF_Output return_outputs, int num_return_outputs, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(graph, null) ? global::System.IntPtr.Zero : graph.__Instance;
            var __arg1 = ReferenceEquals(graph_def, null) ? global::System.IntPtr.Zero : graph_def.__Instance;
            var __arg2 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            var __arg3 = ReferenceEquals(return_outputs, null) ? global::System.IntPtr.Zero : return_outputs.__Instance;
            var __arg5 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_GraphImportGraphDefWithReturnOutputs(__arg0, __arg1, __arg2, __arg3, num_return_outputs, __arg5);
        }

        public static void TF_GraphImportGraphDef(global::TensorFlow.TF_Graph graph, global::TensorFlow.TF_Buffer graph_def, global::TensorFlow.TF_ImportGraphDefOptions options, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(graph, null) ? global::System.IntPtr.Zero : graph.__Instance;
            var __arg1 = ReferenceEquals(graph_def, null) ? global::System.IntPtr.Zero : graph_def.__Instance;
            var __arg2 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            var __arg3 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_GraphImportGraphDef(__arg0, __arg1, __arg2, __arg3);
        }

        public static void TF_GraphCopyFunction(global::TensorFlow.TF_Graph g, global::TensorFlow.TF_Function func, global::TensorFlow.TF_Function grad, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(g, null) ? global::System.IntPtr.Zero : g.__Instance;
            var __arg1 = ReferenceEquals(func, null) ? global::System.IntPtr.Zero : func.__Instance;
            var __arg2 = ReferenceEquals(grad, null) ? global::System.IntPtr.Zero : grad.__Instance;
            var __arg3 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_GraphCopyFunction(__arg0, __arg1, __arg2, __arg3);
        }

        public static int TF_GraphNumFunctions(global::TensorFlow.TF_Graph g)
        {
            var __arg0 = ReferenceEquals(g, null) ? global::System.IntPtr.Zero : g.__Instance;
            var __ret = __Internal.TF_GraphNumFunctions(__arg0);
            return __ret;
        }

        public static int TF_GraphGetFunctions(global::TensorFlow.TF_Graph g, global::TensorFlow.TF_Function funcs, int max_func, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(g, null) ? global::System.IntPtr.Zero : g.__Instance;
            var ____arg1 = ReferenceEquals(funcs, null) ? global::System.IntPtr.Zero : funcs.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __arg3 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_GraphGetFunctions(__arg0, __arg1, max_func, __arg3);
            return __ret;
        }

        public static void TF_OperationToNodeDef(global::TensorFlow.TF_Operation oper, global::TensorFlow.TF_Buffer output_node_def, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(oper, null) ? global::System.IntPtr.Zero : oper.__Instance;
            var __arg1 = ReferenceEquals(output_node_def, null) ? global::System.IntPtr.Zero : output_node_def.__Instance;
            var __arg2 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_OperationToNodeDef(__arg0, __arg1, __arg2);
        }

        public static global::TensorFlow.TF_WhileParams TF_NewWhile(global::TensorFlow.TF_Graph g, global::TensorFlow.TF_Output inputs, int ninputs, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(g, null) ? global::System.IntPtr.Zero : g.__Instance;
            var __arg1 = ReferenceEquals(inputs, null) ? global::System.IntPtr.Zero : inputs.__Instance;
            var __arg3 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_NewWhile(__arg0, __arg1, ninputs, __arg3);
            return global::TensorFlow.TF_WhileParams.__CreateInstance(__ret);
        }

        public static void TF_FinishWhile(global::TensorFlow.TF_WhileParams @params, global::TensorFlow.TF_Status status, global::TensorFlow.TF_Output outputs)
        {
            var __arg0 = ReferenceEquals(@params, null) ? global::System.IntPtr.Zero : @params.__Instance;
            var __arg1 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __arg2 = ReferenceEquals(outputs, null) ? global::System.IntPtr.Zero : outputs.__Instance;
            __Internal.TF_FinishWhile(__arg0, __arg1, __arg2);
        }

        public static void TF_AbortWhile(global::TensorFlow.TF_WhileParams @params)
        {
            var __arg0 = ReferenceEquals(@params, null) ? global::System.IntPtr.Zero : @params.__Instance;
            __Internal.TF_AbortWhile(__arg0);
        }

        public static void TF_AddGradients(global::TensorFlow.TF_Graph g, global::TensorFlow.TF_Output y, int ny, global::TensorFlow.TF_Output x, int nx, global::TensorFlow.TF_Output dx, global::TensorFlow.TF_Status status, global::TensorFlow.TF_Output dy)
        {
            var __arg0 = ReferenceEquals(g, null) ? global::System.IntPtr.Zero : g.__Instance;
            var __arg1 = ReferenceEquals(y, null) ? global::System.IntPtr.Zero : y.__Instance;
            var __arg3 = ReferenceEquals(x, null) ? global::System.IntPtr.Zero : x.__Instance;
            var __arg5 = ReferenceEquals(dx, null) ? global::System.IntPtr.Zero : dx.__Instance;
            var __arg6 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __arg7 = ReferenceEquals(dy, null) ? global::System.IntPtr.Zero : dy.__Instance;
            __Internal.TF_AddGradients(__arg0, __arg1, ny, __arg3, nx, __arg5, __arg6, __arg7);
        }

        public static void TF_AddGradientsWithPrefix(global::TensorFlow.TF_Graph g, string prefix, global::TensorFlow.TF_Output y, int ny, global::TensorFlow.TF_Output x, int nx, global::TensorFlow.TF_Output dx, global::TensorFlow.TF_Status status, global::TensorFlow.TF_Output dy)
        {
            var __arg0 = ReferenceEquals(g, null) ? global::System.IntPtr.Zero : g.__Instance;
            var __arg2 = ReferenceEquals(y, null) ? global::System.IntPtr.Zero : y.__Instance;
            var __arg4 = ReferenceEquals(x, null) ? global::System.IntPtr.Zero : x.__Instance;
            var __arg6 = ReferenceEquals(dx, null) ? global::System.IntPtr.Zero : dx.__Instance;
            var __arg7 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __arg8 = ReferenceEquals(dy, null) ? global::System.IntPtr.Zero : dy.__Instance;
            __Internal.TF_AddGradientsWithPrefix(__arg0, prefix, __arg2, ny, __arg4, nx, __arg6, __arg7, __arg8);
        }

        public static global::TensorFlow.TF_Function TF_GraphToFunction(global::TensorFlow.TF_Graph fn_body, string fn_name, byte append_hash_to_fn_name, int num_opers, global::TensorFlow.TF_Operation opers, int ninputs, global::TensorFlow.TF_Output inputs, int noutputs, global::TensorFlow.TF_Output outputs, sbyte** output_names, global::TensorFlow.TF_FunctionOptions opts, string description, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(fn_body, null) ? global::System.IntPtr.Zero : fn_body.__Instance;
            var ____arg4 = ReferenceEquals(opers, null) ? global::System.IntPtr.Zero : opers.__Instance;
            var __arg4 = new global::System.IntPtr(&____arg4);
            var __arg6 = ReferenceEquals(inputs, null) ? global::System.IntPtr.Zero : inputs.__Instance;
            var __arg8 = ReferenceEquals(outputs, null) ? global::System.IntPtr.Zero : outputs.__Instance;
            var __arg10 = ReferenceEquals(opts, null) ? global::System.IntPtr.Zero : opts.__Instance;
            var __arg12 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_GraphToFunction(__arg0, fn_name, append_hash_to_fn_name, num_opers, __arg4, ninputs, __arg6, noutputs, __arg8, output_names, __arg10, description, __arg12);
            global::TensorFlow.TF_Function __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_Function.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_Function) global::TensorFlow.TF_Function.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_Function.__CreateInstance(__ret);
            return __result0;
        }

        public static global::TensorFlow.TF_Function TF_GraphToFunctionWithControlOutputs(global::TensorFlow.TF_Graph fn_body, string fn_name, byte append_hash_to_fn_name, int num_opers, global::TensorFlow.TF_Operation opers, int ninputs, global::TensorFlow.TF_Output inputs, int noutputs, global::TensorFlow.TF_Output outputs, sbyte** output_names, int ncontrol_outputs, global::TensorFlow.TF_Operation control_outputs, sbyte** control_output_names, global::TensorFlow.TF_FunctionOptions opts, string description, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(fn_body, null) ? global::System.IntPtr.Zero : fn_body.__Instance;
            var ____arg4 = ReferenceEquals(opers, null) ? global::System.IntPtr.Zero : opers.__Instance;
            var __arg4 = new global::System.IntPtr(&____arg4);
            var __arg6 = ReferenceEquals(inputs, null) ? global::System.IntPtr.Zero : inputs.__Instance;
            var __arg8 = ReferenceEquals(outputs, null) ? global::System.IntPtr.Zero : outputs.__Instance;
            var ____arg11 = ReferenceEquals(control_outputs, null) ? global::System.IntPtr.Zero : control_outputs.__Instance;
            var __arg11 = new global::System.IntPtr(&____arg11);
            var __arg13 = ReferenceEquals(opts, null) ? global::System.IntPtr.Zero : opts.__Instance;
            var __arg15 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_GraphToFunctionWithControlOutputs(__arg0, fn_name, append_hash_to_fn_name, num_opers, __arg4, ninputs, __arg6, noutputs, __arg8, output_names, ncontrol_outputs, __arg11, control_output_names, __arg13, description, __arg15);
            global::TensorFlow.TF_Function __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_Function.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_Function) global::TensorFlow.TF_Function.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_Function.__CreateInstance(__ret);
            return __result0;
        }

        public static string TF_FunctionName(global::TensorFlow.TF_Function func)
        {
            var __arg0 = ReferenceEquals(func, null) ? global::System.IntPtr.Zero : func.__Instance;
            var __ret = __Internal.TF_FunctionName(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static void TF_FunctionToFunctionDef(global::TensorFlow.TF_Function func, global::TensorFlow.TF_Buffer output_func_def, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(func, null) ? global::System.IntPtr.Zero : func.__Instance;
            var __arg1 = ReferenceEquals(output_func_def, null) ? global::System.IntPtr.Zero : output_func_def.__Instance;
            var __arg2 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_FunctionToFunctionDef(__arg0, __arg1, __arg2);
        }

        public static global::TensorFlow.TF_Function TF_FunctionImportFunctionDef(global::System.IntPtr proto, ulong proto_len, global::TensorFlow.TF_Status status)
        {
            var __arg2 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_FunctionImportFunctionDef(proto, proto_len, __arg2);
            global::TensorFlow.TF_Function __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_Function.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_Function) global::TensorFlow.TF_Function.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_Function.__CreateInstance(__ret);
            return __result0;
        }

        public static void TF_FunctionSetAttrValueProto(global::TensorFlow.TF_Function func, string attr_name, global::System.IntPtr proto, ulong proto_len, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(func, null) ? global::System.IntPtr.Zero : func.__Instance;
            var __arg4 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_FunctionSetAttrValueProto(__arg0, attr_name, proto, proto_len, __arg4);
        }

        public static void TF_FunctionGetAttrValueProto(global::TensorFlow.TF_Function func, string attr_name, global::TensorFlow.TF_Buffer output_attr_value, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(func, null) ? global::System.IntPtr.Zero : func.__Instance;
            var __arg2 = ReferenceEquals(output_attr_value, null) ? global::System.IntPtr.Zero : output_attr_value.__Instance;
            var __arg3 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_FunctionGetAttrValueProto(__arg0, attr_name, __arg2, __arg3);
        }

        public static void TF_DeleteFunction(global::TensorFlow.TF_Function func)
        {
            var __arg0 = ReferenceEquals(func, null) ? global::System.IntPtr.Zero : func.__Instance;
            __Internal.TF_DeleteFunction(__arg0);
        }

        public static byte TF_TryEvaluateConstant(global::TensorFlow.TF_Graph graph, global::TensorFlow.TF_Output output, global::TensorFlow.TF_Tensor result, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(graph, null) ? global::System.IntPtr.Zero : graph.__Instance;
            if (ReferenceEquals(output, null))
                throw new global::System.ArgumentNullException("output", "Cannot be null because it is passed by value.");
            var __arg1 = output.__Instance;
            var ____arg2 = ReferenceEquals(result, null) ? global::System.IntPtr.Zero : result.__Instance;
            var __arg2 = new global::System.IntPtr(&____arg2);
            var __arg3 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_TryEvaluateConstant(__arg0, *(global::TensorFlow.TF_Output.__Internal*) __arg1, __arg2, __arg3);
            return __ret;
        }

        public static global::TensorFlow.TF_Session TF_NewSession(global::TensorFlow.TF_Graph graph, global::TensorFlow.TF_SessionOptions opts, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(graph, null) ? global::System.IntPtr.Zero : graph.__Instance;
            var __arg1 = ReferenceEquals(opts, null) ? global::System.IntPtr.Zero : opts.__Instance;
            var __arg2 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_NewSession(__arg0, __arg1, __arg2);
            global::TensorFlow.TF_Session __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_Session.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_Session) global::TensorFlow.TF_Session.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_Session.__CreateInstance(__ret);
            return __result0;
        }

        public static global::TensorFlow.TF_Session TF_LoadSessionFromSavedModel(global::TensorFlow.TF_SessionOptions session_options, global::TensorFlow.TF_Buffer run_options, string export_dir, sbyte** tags, int tags_len, global::TensorFlow.TF_Graph graph, global::TensorFlow.TF_Buffer meta_graph_def, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(session_options, null) ? global::System.IntPtr.Zero : session_options.__Instance;
            var __arg1 = ReferenceEquals(run_options, null) ? global::System.IntPtr.Zero : run_options.__Instance;
            var __arg5 = ReferenceEquals(graph, null) ? global::System.IntPtr.Zero : graph.__Instance;
            var __arg6 = ReferenceEquals(meta_graph_def, null) ? global::System.IntPtr.Zero : meta_graph_def.__Instance;
            var __arg7 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_LoadSessionFromSavedModel(__arg0, __arg1, export_dir, tags, tags_len, __arg5, __arg6, __arg7);
            global::TensorFlow.TF_Session __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_Session.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_Session) global::TensorFlow.TF_Session.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_Session.__CreateInstance(__ret);
            return __result0;
        }

        public static void TF_CloseSession(global::TensorFlow.TF_Session _0, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg1 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_CloseSession(__arg0, __arg1);
        }

        public static void TF_DeleteSession(global::TensorFlow.TF_Session _0, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg1 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_DeleteSession(__arg0, __arg1);
        }

        public static void TF_SessionRun(global::TensorFlow.TF_Session session, global::TensorFlow.TF_Buffer run_options, global::TensorFlow.TF_Output inputs, global::TensorFlow.TF_Tensor input_values, int ninputs, global::TensorFlow.TF_Output outputs, global::TensorFlow.TF_Tensor output_values, int noutputs, global::TensorFlow.TF_Operation target_opers, int ntargets, global::TensorFlow.TF_Buffer run_metadata, global::TensorFlow.TF_Status _0)
        {
            var __arg0 = ReferenceEquals(session, null) ? global::System.IntPtr.Zero : session.__Instance;
            var __arg1 = ReferenceEquals(run_options, null) ? global::System.IntPtr.Zero : run_options.__Instance;
            var __arg2 = ReferenceEquals(inputs, null) ? global::System.IntPtr.Zero : inputs.__Instance;
            var ____arg3 = ReferenceEquals(input_values, null) ? global::System.IntPtr.Zero : input_values.__Instance;
            var __arg3 = new global::System.IntPtr(&____arg3);
            var __arg5 = ReferenceEquals(outputs, null) ? global::System.IntPtr.Zero : outputs.__Instance;
            var ____arg6 = ReferenceEquals(output_values, null) ? global::System.IntPtr.Zero : output_values.__Instance;
            var __arg6 = new global::System.IntPtr(&____arg6);
            var ____arg8 = ReferenceEquals(target_opers, null) ? global::System.IntPtr.Zero : target_opers.__Instance;
            var __arg8 = new global::System.IntPtr(&____arg8);
            var __arg10 = ReferenceEquals(run_metadata, null) ? global::System.IntPtr.Zero : run_metadata.__Instance;
            var __arg11 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            __Internal.TF_SessionRun(__arg0, __arg1, __arg2, __arg3, ninputs, __arg5, __arg6, noutputs, __arg8, ntargets, __arg10, __arg11);
        }

        public static void TF_SessionPRunSetup(global::TensorFlow.TF_Session _0, global::TensorFlow.TF_Output inputs, int ninputs, global::TensorFlow.TF_Output outputs, int noutputs, global::TensorFlow.TF_Operation target_opers, int ntargets, sbyte** handle, global::TensorFlow.TF_Status _1)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg1 = ReferenceEquals(inputs, null) ? global::System.IntPtr.Zero : inputs.__Instance;
            var __arg3 = ReferenceEquals(outputs, null) ? global::System.IntPtr.Zero : outputs.__Instance;
            var ____arg5 = ReferenceEquals(target_opers, null) ? global::System.IntPtr.Zero : target_opers.__Instance;
            var __arg5 = new global::System.IntPtr(&____arg5);
            var __arg8 = ReferenceEquals(_1, null) ? global::System.IntPtr.Zero : _1.__Instance;
            __Internal.TF_SessionPRunSetup(__arg0, __arg1, ninputs, __arg3, noutputs, __arg5, ntargets, handle, __arg8);
        }

        public static void TF_SessionPRun(global::TensorFlow.TF_Session _0, string handle, global::TensorFlow.TF_Output inputs, global::TensorFlow.TF_Tensor input_values, int ninputs, global::TensorFlow.TF_Output outputs, global::TensorFlow.TF_Tensor output_values, int noutputs, global::TensorFlow.TF_Operation target_opers, int ntargets, global::TensorFlow.TF_Status _1)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg2 = ReferenceEquals(inputs, null) ? global::System.IntPtr.Zero : inputs.__Instance;
            var ____arg3 = ReferenceEquals(input_values, null) ? global::System.IntPtr.Zero : input_values.__Instance;
            var __arg3 = new global::System.IntPtr(&____arg3);
            var __arg5 = ReferenceEquals(outputs, null) ? global::System.IntPtr.Zero : outputs.__Instance;
            var ____arg6 = ReferenceEquals(output_values, null) ? global::System.IntPtr.Zero : output_values.__Instance;
            var __arg6 = new global::System.IntPtr(&____arg6);
            var ____arg8 = ReferenceEquals(target_opers, null) ? global::System.IntPtr.Zero : target_opers.__Instance;
            var __arg8 = new global::System.IntPtr(&____arg8);
            var __arg10 = ReferenceEquals(_1, null) ? global::System.IntPtr.Zero : _1.__Instance;
            __Internal.TF_SessionPRun(__arg0, handle, __arg2, __arg3, ninputs, __arg5, __arg6, noutputs, __arg8, ntargets, __arg10);
        }

        public static void TF_DeletePRunHandle(string handle)
        {
            __Internal.TF_DeletePRunHandle(handle);
        }

        public static global::TensorFlow.TF_DeprecatedSession TF_NewDeprecatedSession(global::TensorFlow.TF_SessionOptions _0, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg1 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_NewDeprecatedSession(__arg0, __arg1);
            global::TensorFlow.TF_DeprecatedSession __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_DeprecatedSession.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_DeprecatedSession) global::TensorFlow.TF_DeprecatedSession.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_DeprecatedSession.__CreateInstance(__ret);
            return __result0;
        }

        public static void TF_CloseDeprecatedSession(global::TensorFlow.TF_DeprecatedSession _0, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg1 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_CloseDeprecatedSession(__arg0, __arg1);
        }

        public static void TF_DeleteDeprecatedSession(global::TensorFlow.TF_DeprecatedSession _0, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg1 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_DeleteDeprecatedSession(__arg0, __arg1);
        }

        public static void TF_Reset(global::TensorFlow.TF_SessionOptions opt, sbyte** containers, int ncontainers, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(opt, null) ? global::System.IntPtr.Zero : opt.__Instance;
            var __arg3 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_Reset(__arg0, containers, ncontainers, __arg3);
        }

        public static void TF_ExtendGraph(global::TensorFlow.TF_DeprecatedSession _0, global::System.IntPtr proto, ulong proto_len, global::TensorFlow.TF_Status _1)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg3 = ReferenceEquals(_1, null) ? global::System.IntPtr.Zero : _1.__Instance;
            __Internal.TF_ExtendGraph(__arg0, proto, proto_len, __arg3);
        }

        public static void TF_Run(global::TensorFlow.TF_DeprecatedSession _0, global::TensorFlow.TF_Buffer run_options, sbyte** input_names, global::TensorFlow.TF_Tensor inputs, int ninputs, sbyte** output_names, global::TensorFlow.TF_Tensor outputs, int noutputs, sbyte** target_oper_names, int ntargets, global::TensorFlow.TF_Buffer run_metadata, global::TensorFlow.TF_Status _1)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg1 = ReferenceEquals(run_options, null) ? global::System.IntPtr.Zero : run_options.__Instance;
            var ____arg3 = ReferenceEquals(inputs, null) ? global::System.IntPtr.Zero : inputs.__Instance;
            var __arg3 = new global::System.IntPtr(&____arg3);
            var ____arg6 = ReferenceEquals(outputs, null) ? global::System.IntPtr.Zero : outputs.__Instance;
            var __arg6 = new global::System.IntPtr(&____arg6);
            var __arg10 = ReferenceEquals(run_metadata, null) ? global::System.IntPtr.Zero : run_metadata.__Instance;
            var __arg11 = ReferenceEquals(_1, null) ? global::System.IntPtr.Zero : _1.__Instance;
            __Internal.TF_Run(__arg0, __arg1, input_names, __arg3, ninputs, output_names, __arg6, noutputs, target_oper_names, ntargets, __arg10, __arg11);
        }

        public static void TF_PRunSetup(global::TensorFlow.TF_DeprecatedSession _0, sbyte** input_names, int ninputs, sbyte** output_names, int noutputs, sbyte** target_oper_names, int ntargets, sbyte** handle, global::TensorFlow.TF_Status _1)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg8 = ReferenceEquals(_1, null) ? global::System.IntPtr.Zero : _1.__Instance;
            __Internal.TF_PRunSetup(__arg0, input_names, ninputs, output_names, noutputs, target_oper_names, ntargets, handle, __arg8);
        }

        public static void TF_PRun(global::TensorFlow.TF_DeprecatedSession _0, string handle, sbyte** input_names, global::TensorFlow.TF_Tensor inputs, int ninputs, sbyte** output_names, global::TensorFlow.TF_Tensor outputs, int noutputs, sbyte** target_oper_names, int ntargets, global::TensorFlow.TF_Status _1)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var ____arg3 = ReferenceEquals(inputs, null) ? global::System.IntPtr.Zero : inputs.__Instance;
            var __arg3 = new global::System.IntPtr(&____arg3);
            var ____arg6 = ReferenceEquals(outputs, null) ? global::System.IntPtr.Zero : outputs.__Instance;
            var __arg6 = new global::System.IntPtr(&____arg6);
            var __arg10 = ReferenceEquals(_1, null) ? global::System.IntPtr.Zero : _1.__Instance;
            __Internal.TF_PRun(__arg0, handle, input_names, __arg3, ninputs, output_names, __arg6, noutputs, target_oper_names, ntargets, __arg10);
        }

        public static global::TensorFlow.TF_DeviceList TF_SessionListDevices(global::TensorFlow.TF_Session session, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(session, null) ? global::System.IntPtr.Zero : session.__Instance;
            var __arg1 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_SessionListDevices(__arg0, __arg1);
            global::TensorFlow.TF_DeviceList __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_DeviceList.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_DeviceList) global::TensorFlow.TF_DeviceList.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_DeviceList.__CreateInstance(__ret);
            return __result0;
        }

        public static global::TensorFlow.TF_DeviceList TF_DeprecatedSessionListDevices(global::TensorFlow.TF_DeprecatedSession session, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(session, null) ? global::System.IntPtr.Zero : session.__Instance;
            var __arg1 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_DeprecatedSessionListDevices(__arg0, __arg1);
            global::TensorFlow.TF_DeviceList __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_DeviceList.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_DeviceList) global::TensorFlow.TF_DeviceList.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_DeviceList.__CreateInstance(__ret);
            return __result0;
        }

        public static void TF_DeleteDeviceList(global::TensorFlow.TF_DeviceList list)
        {
            var __arg0 = ReferenceEquals(list, null) ? global::System.IntPtr.Zero : list.__Instance;
            __Internal.TF_DeleteDeviceList(__arg0);
        }

        public static int TF_DeviceListCount(global::TensorFlow.TF_DeviceList list)
        {
            var __arg0 = ReferenceEquals(list, null) ? global::System.IntPtr.Zero : list.__Instance;
            var __ret = __Internal.TF_DeviceListCount(__arg0);
            return __ret;
        }

        public static string TF_DeviceListName(global::TensorFlow.TF_DeviceList list, int index, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(list, null) ? global::System.IntPtr.Zero : list.__Instance;
            var __arg2 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_DeviceListName(__arg0, index, __arg2);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static string TF_DeviceListType(global::TensorFlow.TF_DeviceList list, int index, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(list, null) ? global::System.IntPtr.Zero : list.__Instance;
            var __arg2 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_DeviceListType(__arg0, index, __arg2);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static long TF_DeviceListMemoryBytes(global::TensorFlow.TF_DeviceList list, int index, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(list, null) ? global::System.IntPtr.Zero : list.__Instance;
            var __arg2 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_DeviceListMemoryBytes(__arg0, index, __arg2);
            return __ret;
        }

        public static ulong TF_DeviceListIncarnation(global::TensorFlow.TF_DeviceList list, int index, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(list, null) ? global::System.IntPtr.Zero : list.__Instance;
            var __arg2 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_DeviceListIncarnation(__arg0, index, __arg2);
            return __ret;
        }

        public static global::TensorFlow.TF_Library TF_LoadLibrary(string library_filename, global::TensorFlow.TF_Status status)
        {
            var __arg1 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_LoadLibrary(library_filename, __arg1);
            global::TensorFlow.TF_Library __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_Library.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_Library) global::TensorFlow.TF_Library.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_Library.__CreateInstance(__ret);
            return __result0;
        }

        public static global::TensorFlow.TF_Buffer TF_GetOpList(global::TensorFlow.TF_Library lib_handle)
        {
            var __arg0 = ReferenceEquals(lib_handle, null) ? global::System.IntPtr.Zero : lib_handle.__Instance;
            var __ret = __Internal.TF_GetOpList(__arg0);
            return global::TensorFlow.TF_Buffer.__CreateInstance(__ret);
        }

        public static void TF_DeleteLibraryHandle(global::TensorFlow.TF_Library lib_handle)
        {
            var __arg0 = ReferenceEquals(lib_handle, null) ? global::System.IntPtr.Zero : lib_handle.__Instance;
            __Internal.TF_DeleteLibraryHandle(__arg0);
        }

        public static global::TensorFlow.TF_Buffer TF_GetAllOpList()
        {
            var __ret = __Internal.TF_GetAllOpList();
            global::TensorFlow.TF_Buffer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_Buffer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_Buffer) global::TensorFlow.TF_Buffer.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_Buffer.__CreateInstance(__ret);
            return __result0;
        }

        public static global::TensorFlow.TF_ApiDefMap TF_NewApiDefMap(global::TensorFlow.TF_Buffer op_list_buffer, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(op_list_buffer, null) ? global::System.IntPtr.Zero : op_list_buffer.__Instance;
            var __arg1 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_NewApiDefMap(__arg0, __arg1);
            global::TensorFlow.TF_ApiDefMap __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_ApiDefMap.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_ApiDefMap) global::TensorFlow.TF_ApiDefMap.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_ApiDefMap.__CreateInstance(__ret);
            return __result0;
        }

        public static void TF_DeleteApiDefMap(global::TensorFlow.TF_ApiDefMap apimap)
        {
            var __arg0 = ReferenceEquals(apimap, null) ? global::System.IntPtr.Zero : apimap.__Instance;
            __Internal.TF_DeleteApiDefMap(__arg0);
        }

        public static void TF_ApiDefMapPut(global::TensorFlow.TF_ApiDefMap api_def_map, string text, ulong text_len, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(api_def_map, null) ? global::System.IntPtr.Zero : api_def_map.__Instance;
            var __arg3 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_ApiDefMapPut(__arg0, text, text_len, __arg3);
        }

        public static global::TensorFlow.TF_Buffer TF_ApiDefMapGet(global::TensorFlow.TF_ApiDefMap api_def_map, string name, ulong name_len, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(api_def_map, null) ? global::System.IntPtr.Zero : api_def_map.__Instance;
            var __arg3 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_ApiDefMapGet(__arg0, name, name_len, __arg3);
            global::TensorFlow.TF_Buffer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_Buffer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_Buffer) global::TensorFlow.TF_Buffer.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_Buffer.__CreateInstance(__ret);
            return __result0;
        }

        public static global::TensorFlow.TF_Buffer TF_GetAllRegisteredKernels(global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_GetAllRegisteredKernels(__arg0);
            global::TensorFlow.TF_Buffer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_Buffer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_Buffer) global::TensorFlow.TF_Buffer.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_Buffer.__CreateInstance(__ret);
            return __result0;
        }

        public static global::TensorFlow.TF_Buffer TF_GetRegisteredKernelsForOp(string name, global::TensorFlow.TF_Status status)
        {
            var __arg1 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_GetRegisteredKernelsForOp(name, __arg1);
            global::TensorFlow.TF_Buffer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_Buffer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_Buffer) global::TensorFlow.TF_Buffer.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_Buffer.__CreateInstance(__ret);
            return __result0;
        }

        public static global::TensorFlow.TF_Server TF_NewServer(global::System.IntPtr proto, ulong proto_len, global::TensorFlow.TF_Status status)
        {
            var __arg2 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            var __ret = __Internal.TF_NewServer(proto, proto_len, __arg2);
            global::TensorFlow.TF_Server __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::TensorFlow.TF_Server.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::TensorFlow.TF_Server) global::TensorFlow.TF_Server.NativeToManagedMap[__ret];
            else __result0 = global::TensorFlow.TF_Server.__CreateInstance(__ret);
            return __result0;
        }

        public static void TF_ServerStart(global::TensorFlow.TF_Server server, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(server, null) ? global::System.IntPtr.Zero : server.__Instance;
            var __arg1 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_ServerStart(__arg0, __arg1);
        }

        public static void TF_ServerStop(global::TensorFlow.TF_Server server, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(server, null) ? global::System.IntPtr.Zero : server.__Instance;
            var __arg1 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_ServerStop(__arg0, __arg1);
        }

        public static void TF_ServerJoin(global::TensorFlow.TF_Server server, global::TensorFlow.TF_Status status)
        {
            var __arg0 = ReferenceEquals(server, null) ? global::System.IntPtr.Zero : server.__Instance;
            var __arg1 = ReferenceEquals(status, null) ? global::System.IntPtr.Zero : status.__Instance;
            __Internal.TF_ServerJoin(__arg0, __arg1);
        }

        public static string TF_ServerTarget(global::TensorFlow.TF_Server server)
        {
            var __arg0 = ReferenceEquals(server, null) ? global::System.IntPtr.Zero : server.__Instance;
            var __ret = __Internal.TF_ServerTarget(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static void TF_DeleteServer(global::TensorFlow.TF_Server server)
        {
            var __arg0 = ReferenceEquals(server, null) ? global::System.IntPtr.Zero : server.__Instance;
            __Internal.TF_DeleteServer(__arg0);
        }

        public static void TF_RegisterLogListener(global::TensorFlow.Delegates.Action_string listener)
        {
            var __arg0 = listener == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(listener);
            __Internal.TF_RegisterLogListener(__arg0);
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_ulong_IntPtr(global::System.IntPtr data, ulong len, global::System.IntPtr arg);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_ulong(global::System.IntPtr data, ulong length);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_string([MarshalAs(UnmanagedType.LPStr)] string _0);
    }
}
